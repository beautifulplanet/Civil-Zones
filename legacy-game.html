<!DOCTYPE html>
<!-- saved from url=(0087)file:///C:/Users/Elite/Documents/My%20Made%20Games/CitGame%20Early%20version/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Civil Zones - Stone Age Civilization</title>
    <style>
        :root {
            --bg: #0A0806; --text: #F5E6C8; --panel: #2E251B; --border: #5C4A3D;
            --c-res: #4fc3f7; --c-com: #ffd54f; --c-ind: #ff7043; --c-wat: #00e5ff; --c-road: #8d6e63; --c-bull: #e57373;
            --accent: #8B6914; --accent-hover: #A68328; --text-primary: #F5E6C8; --text-secondary: #C4A878; --text-muted: #8B7355;
            --tribal-gold: #8B6914; --tribal-brown: #5C4A3D; --tribal-dark: #2E251B; --tribal-leather: #6B4423;
        }
        /* Google Font loaded locally to avoid internet dependency */
        /* @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap'); */
        html, body { margin: 0; width: 100%; height: 100%; background: #0a0a0f; color: var(--text); font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; overflow: hidden; display: flex; flex-direction: column; user-select: none; }
        
        /* ‚ïê‚ïê‚ïê TRIBAL TOP MENU BAR - Weathered wood beam ‚ïê‚ïê‚ïê */
        #menubar { 
            height: 56px; 
            background: 
                linear-gradient(180deg, 
                    rgba(60, 45, 30, 0.98) 0%, 
                    rgba(46, 37, 27, 0.98) 50%,
                    rgba(35, 28, 20, 0.98) 100%);
            display: flex; 
            align-items: center; 
            padding: 0 12px; 
            gap: 6px; 
            border-bottom: 3px solid #8B6914; 
            z-index: 100; 
            box-shadow: 
                0 4px 20px rgba(0,0,0,0.7), 
                0 2px 8px rgba(139, 105, 20, 0.2),
                inset 0 -2px 4px rgba(0,0,0,0.3),
                inset 0 2px 0 rgba(255,255,255,0.03);
            flex-wrap: nowrap;
            overflow-x: auto;
        }
        #menubar .btn {
            padding: 6px 10px;
            font-size: 14px;
            min-width: 36px;
            flex-shrink: 0;
        }
        #menubar .separator {
            width: 1px;
            height: 28px;
            background: rgba(139, 105, 20, 0.5);
            flex-shrink: 0;
        }
        .menubar-right {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
            flex-shrink: 0;
        }
        .menubar-right .btn {
            padding: 4px 8px !important;
            font-size: 12px !important;
        }
        .debug-btn {
            padding: 2px 5px !important;
            font-size: 9px !important;
            opacity: 0.7;
        }
        .debug-btn:hover {
            opacity: 1;
        }
        
        #viewport { flex-grow: 1; background: transparent; position: relative; overflow: hidden; display: flex; }
        #sidebar { width: 280px; background: #2E251B; border-right: 2px solid #5C4A3D; overflow-y: auto; padding: 15px; display: none; z-index: 50; }
        #canvas-container { flex-grow: 1; position: relative; background: transparent; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* ‚ïê‚ïê‚ïê TRIBAL DASHBOARD - Stone foundation bar ‚ïê‚ïê‚ïê */
        #dashboard { 
            height: auto; 
            min-height: 60px;
            background: 
                linear-gradient(180deg, 
                    rgba(46, 37, 27, 0.98) 0%, 
                    rgba(35, 28, 20, 0.98) 50%,
                    rgba(25, 20, 15, 0.98) 100%);
            border-top: 3px solid #8B6914; 
            display: flex; 
            align-items: center; 
            padding: 8px 15px; 
            justify-content: space-between; 
            gap: 10px;
            box-shadow: 
                0 -4px 20px rgba(0,0,0,0.5),
                inset 0 2px 0 rgba(139, 105, 20, 0.1);
            flex-wrap: nowrap;
            overflow-x: auto;
        }
        #dashboard .btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        #dashboard .separator {
            width: 1px;
            height: 40px;
            background: rgba(139, 105, 20, 0.4);
            flex-shrink: 0;
        }
        .stats-group {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .rci-container {
            background: rgba(0,0,0,0.4);
            border: 2px solid #5C4A3D;
            border-radius: 6px;
            padding: 6px 10px;
            flex-shrink: 0;
        }
        .dashboard-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        /* ‚ïê‚ïê‚ïê TRIBAL STATS DISPLAY - Carved wood tablets ‚ïê‚ïê‚ïê */
        .stat { 
            display: flex; 
            flex-direction: column; 
            margin-right: 4px;
            padding: 4px 8px;
            background: 
                linear-gradient(145deg, rgba(74, 58, 40, 0.9) 0%, rgba(50, 40, 28, 0.9) 100%);
            border-radius: 4px;
            border: 1px solid rgba(92, 74, 61, 0.6);
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.05),
                0 2px 4px rgba(0,0,0,0.3);
        }
        .stat:hover {
            background: linear-gradient(145deg, rgba(92, 74, 50, 0.95) 0%, rgba(60, 48, 35, 0.95) 100%);
            border-color: #8B6914;
        }
        .lbl { 
            font-size: 9px; 
            color: #A89070; 
            text-transform: uppercase; 
            letter-spacing: 0.3px;
            font-weight: 600;
            margin-bottom: 1px;
        }
        .val { 
            font-size: 14px; 
            font-weight: 700;
            letter-spacing: -0.3px;
            color: #F5E6C8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* ‚ïê‚ïê‚ïê GLOBAL TRIBAL SCROLLBARS ‚ïê‚ïê‚ïê */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(46, 37, 27, 0.5);
            border-radius: 6px;
        }
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6B4423 0%, #4A3018 100%);
            border-radius: 6px;
            border: 2px solid rgba(0,0,0,0.3);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #8B5A2B 0%, #6B4423 100%);
        }
        ::-webkit-scrollbar-corner {
            background: rgba(46, 37, 27, 0.5);
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           TRIBAL STONE BUTTONS - Carved stone tablet aesthetic
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        .btn { 
            padding: 10px 14px; 
            border: 2px solid #5C4A3D; 
            background: 
                linear-gradient(145deg, #4A3D30 0%, #3D3025 50%, #2E251B 100%);
            color: #D4C4A8; 
            cursor: pointer; 
            font-weight: 600; 
            border-radius: 6px; 
            font-family: 'Segoe UI', sans-serif;
            font-size: 18px; 
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 3px 8px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.08),
                inset 0 -2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            min-width: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        /* Stone texture overlay */
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(255,255,255,0.05) 0%, transparent 40%),
                radial-gradient(ellipse at 80% 80%, rgba(0,0,0,0.1) 0%, transparent 40%);
            pointer-events: none;
        }
        /* Shine animation on hover */
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.4s ease;
        }
        .btn:hover::after {
            left: 150%;
        }
        .btn:hover { 
            background: linear-gradient(145deg, #5C4A3D 0%, #4A3D30 50%, #3D3025 100%);
            border-color: #8B6914; 
            color: #F5E6C8;
            transform: translateY(-2px);
            box-shadow: 
                0 6px 15px rgba(139, 105, 20, 0.4),
                0 0 20px rgba(139, 105, 20, 0.2),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        .btn.active { 
            background: linear-gradient(145deg, #4A7A2A 0%, #3D6B22 50%, #2E5E1A 100%) !important; 
            border-color: #6B9B4A; 
            color: #E8F5E9; 
            box-shadow: 
                0 0 25px rgba(76, 175, 80, 0.5),
                0 4px 15px rgba(76, 175, 80, 0.4),
                inset 0 2px 0 rgba(255,255,255,0.15),
                inset 0 -2px 6px rgba(0,0,0,0.3);
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .btn:disabled { 
            opacity: 0.35; 
            cursor: not-allowed; 
            background: linear-gradient(145deg, #2E2E28 0%, #252520 100%); 
            color: #5A5A52;
            border-color: #3A3A35;
        }
        .btn:disabled:hover { 
            background: linear-gradient(145deg, #2E2E28 0%, #252520 100%); 
            color: #5A5A52;
            transform: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           PREHISTORIC TRIBAL UI THEME - Unique Stone Age Aesthetic
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        
        /* Base Menu Panel - Stone tablet with leather binding */
        .menu-panel-base {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: 
                linear-gradient(135deg, rgba(60, 45, 30, 0.98) 0%, rgba(40, 30, 20, 0.98) 100%);
            border: 4px solid #8B6914;
            border-radius: 8px;
            padding: 20px;
            z-index: 1001;
            min-width: 420px;
            max-width: 90vw;
            max-height: 85vh;
            box-shadow: 
                0 0 0 2px #5C4A0F,
                0 0 40px rgba(139, 105, 20, 0.4),
                inset 0 0 60px rgba(0,0,0,0.5),
                0 15px 50px rgba(0,0,0,0.8);
        }
        .menu-panel-base::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 16px;
            background: linear-gradient(180deg, #6B4423 0%, #4A3018 100%);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Building Level Selector Panel - Vibrant Green/Nature theme */
        #building-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: 
                linear-gradient(145deg, rgba(25, 60, 35, 0.98) 0%, rgba(15, 45, 25, 0.98) 50%, rgba(20, 55, 30, 0.98) 100%);
            border: 4px solid #4CAF50;
            border-radius: 16px; 
            padding: 25px; 
            display: none; 
            z-index: 1001;
            box-shadow: 
                0 0 0 2px #2E7D32,
                0 0 60px rgba(76, 175, 80, 0.5),
                0 0 100px rgba(129, 199, 132, 0.2),
                inset 0 0 80px rgba(0,0,0,0.3),
                0 20px 60px rgba(0,0,0,0.8);
            width: 75vw;
            max-width: 1200px;
            max-height: 85vh;
        }
        #building-menu-panel::before {
            content: 'üè† HOMES';
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            background: linear-gradient(180deg, #66BB6A 0%, #43A047 100%);
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            padding: 6px 24px;
            border-radius: 25px;
            border: 3px solid #81C784;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Industrial Menu Panel - Vibrant Red/Orange theme */
        #industrial-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: 
                linear-gradient(145deg, rgba(60, 25, 20, 0.98) 0%, rgba(45, 18, 15, 0.98) 50%, rgba(55, 22, 18, 0.98) 100%);
            border: 4px solid #FF5722;
            border-radius: 16px; 
            padding: 25px; 
            display: none; 
            z-index: 1001;
            box-shadow: 
                0 0 0 2px #E64A19,
                0 0 60px rgba(255, 87, 34, 0.5),
                0 0 100px rgba(255, 138, 101, 0.2),
                inset 0 0 80px rgba(0,0,0,0.3),
                0 20px 60px rgba(0,0,0,0.8);
            min-width: 480px;
            max-width: 90vw;
            max-height: 85vh;
        }
        #industrial-menu-panel::before {
            content: '‚öíÔ∏è WORKSHOPS';
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            background: linear-gradient(180deg, #FF7043 0%, #E64A19 100%);
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            padding: 6px 24px;
            border-radius: 25px;
            border: 3px solid #FF8A65;
            box-shadow: 0 4px 15px rgba(255, 87, 34, 0.5);
        }
        #industrial-menu-panel .menu-title {
            font-size: 22px;
            font-weight: bold;
            color: #FFCCBC;
            margin-bottom: 20px;
            margin-top: 10px;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6), 0 0 20px rgba(255, 138, 101, 0.4);
            letter-spacing: 2px;
            padding-bottom: 15px;
            border-bottom: 3px solid rgba(255, 138, 101, 0.4);
            background: linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.1), transparent);
        }
        #industrial-menu-panel .level-card.selected {
            background: linear-gradient(145deg, rgba(255, 87, 34, 0.35) 0%, rgba(230, 74, 25, 0.3) 100%);
            border-color: #FFAB91;
            box-shadow: 0 0 35px rgba(255, 138, 101, 0.6), 0 0 60px rgba(255, 87, 34, 0.3), inset 0 0 25px rgba(255, 138, 101, 0.15);
        }
        #industrial-menu-panel .level-card {
            background: linear-gradient(145deg, rgba(80, 40, 30, 0.95) 0%, rgba(55, 30, 22, 0.95) 100%);
            border: 3px solid #FF5722;
        }
        #industrial-menu-panel .level-card:hover {
            background: linear-gradient(145deg, rgba(100, 50, 38, 0.98) 0%, rgba(70, 38, 28, 0.98) 100%);
            border-color: #FF8A65;
        }
        #industrial-menu-panel .level-card .level-number {
            background: linear-gradient(135deg, #FF5722, #E64A19);
        }
        #industrial-menu-panel .level-card .level-stats {
            color: #FFAB91;
        }
        
        /* Roads Menu Panel - Brown/Path theme */
        #road-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: 
                linear-gradient(145deg, rgba(60, 45, 35, 0.98) 0%, rgba(40, 30, 22, 0.98) 100%);
            border: 4px solid #8D6E63;
            border-radius: 8px; 
            padding: 20px; 
            display: none; 
            z-index: 1001;
            box-shadow: 
                0 0 0 2px #5D4037,
                0 0 50px rgba(141, 110, 99, 0.3),
                inset 0 0 80px rgba(0,0,0,0.4),
                0 15px 50px rgba(0,0,0,0.8);
            min-width: 420px;
            max-width: 90vw;
            max-height: 85vh;
        }
        #road-menu-panel::before {
            content: 'ü¶∂';
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            background: linear-gradient(180deg, #8D6E63 0%, #5D4037 100%);
            padding: 4px 16px;
            border-radius: 20px;
            border: 2px solid #A1887F;
        }
        #road-menu-panel .menu-title {
            font-size: 18px;
            font-weight: bold;
            color: #BCAAA4;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }
        #road-menu-panel .level-card.selected {
            background: linear-gradient(145deg, rgba(141, 110, 99, 0.4) 0%, rgba(93, 64, 55, 0.3) 100%);
            border-color: #A1887F;
            box-shadow: 0 0 20px rgba(161, 136, 127, 0.5), inset 0 0 15px rgba(200, 170, 150, 0.1);
        }
        
        /* Commercial selected state */
        #commercial-menu-panel .level-card.selected {
            background: linear-gradient(145deg, rgba(74, 158, 255, 0.3) 0%, rgba(33, 100, 180, 0.2) 100%);
            border-color: #64B5F6;
            box-shadow: 0 0 20px rgba(100, 181, 246, 0.5), inset 0 0 15px rgba(100, 200, 255, 0.1);
        }
        
        /* Special/Milestone selected state */
        #special-menu-panel .level-card.selected,
        #milestone-menu-panel .level-card.selected {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.3) 0%, rgba(200, 150, 0, 0.2) 100%);
            border-color: #FFD54F;
            box-shadow: 0 0 20px rgba(255, 213, 79, 0.5), inset 0 0 15px rgba(255, 230, 100, 0.1);
        }
        
        /* Menu Title - Modern vibrant look */
        #building-menu-panel .menu-title {
            font-size: 22px;
            font-weight: bold;
            color: #C8E6C9;
            margin-bottom: 20px;
            margin-top: 10px;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6), 0 0 20px rgba(129, 199, 132, 0.4);
            letter-spacing: 2px;
            padding-bottom: 15px;
            border-bottom: 3px solid rgba(129, 199, 132, 0.4);
            background: linear-gradient(90deg, transparent, rgba(76, 175, 80, 0.1), transparent);
        }
        
        /* Level Grid - Scroll area */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            max-height: 65vh;
            overflow-y: auto;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .level-grid::-webkit-scrollbar {
            width: 10px;
        }
        .level-grid::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .level-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6B4423 0%, #4A3018 100%);
            border-radius: 5px;
            border: 2px solid rgba(0,0,0,0.3);
        }
        .level-grid::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #8B5A2B 0%, #6B4423 100%);
        }
        
        /* Level Card - Modern colorful style */
        .level-card {
            background: 
                linear-gradient(145deg, rgba(45, 80, 55, 0.95) 0%, rgba(30, 60, 40, 0.95) 100%);
            border: 3px solid #4CAF50;
            border-radius: 12px;
            padding: 16px 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 280px;
            min-width: 220px;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 4px 12px rgba(0,0,0,0.4);
        }
        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #4CAF50, #81C784, #4CAF50);
            opacity: 0.8;
        }
        .level-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(129, 199, 132, 0.5), transparent);
        }
        .level-card:hover {
            background: linear-gradient(145deg, rgba(60, 100, 70, 0.98) 0%, rgba(40, 80, 55, 0.98) 100%);
            border-color: #81C784;
            transform: translateY(-5px) scale(1.03);
            box-shadow: 
                0 12px 30px rgba(0,0,0,0.5),
                0 0 25px rgba(76, 175, 80, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .level-card.selected {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.4) 0%, rgba(56, 142, 60, 0.35) 100%);
            border-color: #A5D6A7;
            box-shadow: 
                0 0 35px rgba(129, 199, 132, 0.6),
                0 0 60px rgba(76, 175, 80, 0.3),
                inset 0 0 25px rgba(129, 199, 132, 0.15),
                0 8px 20px rgba(0,0,0,0.4);
            transform: scale(1.05);
        }
        .level-card.level-locked {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(60%) brightness(0.8);
        }
        .level-card.level-locked:hover {
            transform: none;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 3px 8px rgba(0,0,0,0.4);
            border-color: #5A4A3A;
        }
        .level-card.level-locked .level-cost {
            color: #E57373;
            font-size: 10px;
        }
        
        /* Level Card Icon - Canvas container */
        .level-card .level-icon {
            text-align: center;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .level-card .level-icon canvas {
            border: 3px solid rgba(107, 83, 68, 0.8);
            border-radius: 6px;
            box-shadow: 
                0 3px 10px rgba(0,0,0,0.5),
                inset 0 0 10px rgba(0,0,0,0.3);
        }
        
        /* Card text elements - Modern colorful style */
        .level-card .level-number {
            position: absolute;
            top: 6px;
            left: 8px;
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
            background: linear-gradient(135deg, #4CAF50, #388E3C);
            padding: 3px 8px;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .level-card .level-name {
            font-size: 12px;
            font-weight: 700;
            color: #fff;
            text-align: center;
            margin-bottom: 6px;
            line-height: 1.3;
            min-height: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.6);
            letter-spacing: 0.5px;
        }
        .level-card .level-stats {
            font-size: 10px;
            color: #A5D6A7;
            text-align: center;
            margin-bottom: 6px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.2);
            padding: 3px 6px;
            border-radius: 6px;
        }
        .level-card .level-cost {
            font-size: 10px;
            color: #FFE082;
            text-align: center;
            font-weight: 600;
            padding: 6px 4px;
            margin-top: 6px;
            border-top: 2px solid rgba(255, 224, 130, 0.3);
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
            background: rgba(255, 193, 7, 0.1);
            border-radius: 0 0 8px 8px;
        }
        
        /* Menu Close Button - Bone/stone style */
        .menu-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(145deg, #8B4513 0%, #5C2E0A 100%);
            border: 2px solid #A0522D;
            color: #FFE4C4;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .menu-close-btn:hover {
            background: linear-gradient(145deg, #CD853F 0%, #8B4513 100%);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 15px rgba(205, 133, 63, 0.3);
        }
        
        /* Panel footer info */
        .menu-panel-footer {
            text-align: center;
            margin-top: 12px;
            font-size: 10px;
            color: #A89070;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            border: 1px solid rgba(139, 105, 20, 0.2);
        }
        
        /* Build confirm button - Tribal style */
        .menu-confirm-btn {
            background: linear-gradient(145deg, #4A7A2A 0%, #2E5E1A 100%) !important;
            border: 2px solid #6B9B4A !important;
            color: #E8F5E9 !important;
            padding: 10px 25px !important;
            font-size: 13px !important;
            font-weight: bold !important;
            border-radius: 6px !important;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }
        .menu-confirm-btn:hover {
            background: linear-gradient(145deg, #5C9B3A 0%, #4A7A2A 100%) !important;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), 0 0 20px rgba(76, 175, 80, 0.3);
        }
        
        .build-category { margin-bottom: 20px; }
        .category-title { color: #4CAF50; font-weight: bold; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #333; }
        .build-btn { width: 100%; padding: 12px; margin-bottom: 8px; border: 1px solid #555; background: #2a2a2a; color: #ccc; cursor: pointer; font-weight: bold; border-radius: 4px; font-family: sans-serif; text-align: left; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
        .build-btn:hover { background: #3a3a3a; border-color: #777; }
        .build-btn.active { background: #4CAF50; border-color: #66BB6A; color: #fff; }
        .build-btn .cost { font-size: 11px; color: #999; }
        .build-btn.active .cost { color: #E8F5E9; }

        .b-res { border-bottom: 3px solid var(--c-res); } .b-com { border-bottom: 3px solid var(--c-com); }
        .b-ind { border-bottom: 3px solid var(--c-ind); } .b-wat { border-bottom: 3px solid var(--c-wat); } .b-road { border-bottom: 3px solid var(--c-road); }

        /* ‚ïê‚ïê‚ïê TRIBAL STATS DISPLAY - Carved wood tablets ‚ïê‚ïê‚ïê */
        .stat { 
            display: flex; 
            flex-direction: column; 
            margin-right: 4px;
            padding: 4px 8px;
            background: 
                linear-gradient(145deg, rgba(74, 58, 40, 0.9) 0%, rgba(50, 40, 28, 0.9) 100%);
            border-radius: 4px;
            border: 1px solid rgba(92, 74, 61, 0.6);
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.05),
                0 2px 4px rgba(0,0,0,0.3);
        }
        .stat:hover {
            background: linear-gradient(145deg, rgba(92, 74, 50, 0.95) 0%, rgba(60, 48, 35, 0.95) 100%);
            border-color: #8B6914;
        }
        .lbl { 
            font-size: 9px; 
            color: #A89070; 
            text-transform: uppercase; 
            letter-spacing: 0.3px;
            font-weight: 600;
            margin-bottom: 1px;
        }
        .val { 
            font-size: 14px; 
            font-weight: 700;
            letter-spacing: -0.3px;
            color: #F5E6C8;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* ‚ïê‚ïê‚ïê TRIBAL TOAST NOTIFICATIONS - Ancient scroll style ‚ïê‚ïê‚ïê */
        #toast { 
            position: absolute; 
            top: 85px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: 
                linear-gradient(145deg, rgba(60, 45, 30, 0.98) 0%, rgba(40, 30, 20, 0.98) 100%);
            border: 3px solid #8B6914; 
            color: #F5E6C8; 
            padding: 20px 50px; 
            border-radius: 8px; 
            opacity: 0; 
            transition: opacity 0.3s ease, transform 0.3s ease; 
            pointer-events: none; 
            z-index: 300; 
            font-family: 'Segoe UI', sans-serif;
            font-weight: 700; 
            font-size: 16px;
            box-shadow: 
                0 0 0 2px #5C4A0F,
                0 6px 30px rgba(0,0,0,0.9), 
                0 0 40px rgba(139, 105, 20, 0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        /* Small decorative binding holes */
        #toast::before,
        #toast::after {
            content: '‚óè';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: #5C4A0F;
        }
        #toast::before { left: 12px; }
        #toast::after { right: 12px; }
        
        #debug { 
            position: absolute; 
            bottom: 10px; 
            right: 10px; 
            font-size: 11px; 
            color: #8B8B7A; 
            pointer-events: none; 
            z-index: 101;
            background: rgba(40, 35, 25, 0.85);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(92, 74, 61, 0.4);
            font-family: 'Courier New', monospace;
        }
        #file-input { display: none; }
        
        /* ‚ïê‚ïê‚ïê TRIBAL TOOLTIPS - Stone tablet popups ‚ïê‚ïê‚ïê */
        .btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, rgba(60, 45, 30, 0.98) 0%, rgba(40, 30, 20, 0.98) 100%);
            color: #F5E6C8;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            margin-bottom: 8px;
            pointer-events: none;
            z-index: 1000;
            border: 2px solid #8B6914;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8), 0 0 15px rgba(139, 105, 20, 0.3);
            font-weight: 600;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .btn[title]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #8B6914;
            margin-bottom: 2px;
            pointer-events: none;
            z-index: 1001;
        }
        
        /* ‚ïê‚ïê‚ïê TRIBAL CAMERA CONTROLS - Stone arrow buttons ‚ïê‚ïê‚ïê */
        .camera-arrow { 
            position: absolute; 
            background: linear-gradient(145deg, rgba(74, 58, 40, 0.9) 0%, rgba(50, 40, 28, 0.9) 100%);
            border: 2px solid #5C4A3D; 
            color: #D4C4A8; 
            font-size: 24px; 
            width: 50px; 
            height: 50px; 
            display: none; 
            cursor: pointer; 
            z-index: 150; 
            border-radius: 6px; 
            transition: all 0.2s;
            box-shadow: 0 3px 10px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .camera-arrow:hover { 
            background: linear-gradient(145deg, rgba(92, 74, 50, 0.95) 0%, rgba(60, 48, 35, 0.95) 100%);
            border-color: #8B6914; 
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.6), 0 0 15px rgba(139, 105, 20, 0.2);
        }
        .camera-arrow:active { 
            background: linear-gradient(145deg, #4A7A2A 0%, #3D6B22 100%);
            border-color: #6B9B4A;
        }
        #cam-up { top: 60px; left: 50%; transform: translateX(-50%); }
        #cam-down { bottom: 90px; left: 50%; transform: translateX(-50%); }
        #cam-left { top: 50%; left: 10px; transform: translateY(-50%); }
        #cam-right { top: 50%; right: 10px; transform: translateY(-50%); }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           LORE POPUP SYSTEM - Pokemon/Cartoon Style Event Illustrations
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        #lore-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5000;
            background: linear-gradient(145deg, #2a1a0a 0%, #1a1205 50%, #0f0a03 100%);
            border: 6px solid #d4a85a;
            border-radius: 20px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            box-shadow: 
                0 0 60px rgba(212, 168, 90, 0.4),
                0 15px 40px rgba(0,0,0,0.8),
                inset 0 2px 0 rgba(255,255,255,0.1);
            animation: lorePopIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
        }
        @keyframes lorePopIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #lore-popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            z-index: 4999;
            backdrop-filter: blur(4px);
        }
        .lore-illustration {
            width: 100%;
            height: 200px;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 50%, #7DB87D 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border-bottom: 4px solid #d4a85a;
        }
        .lore-illustration canvas {
            width: 100%;
            height: 100%;
        }
        .lore-content {
            padding: 25px;
            text-align: center;
        }
        .lore-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }
        .lore-text {
            font-size: 16px;
            color: #e8dcc8;
            line-height: 1.7;
            font-style: italic;
            margin-bottom: 20px;
        }
        .lore-close-btn {
            padding: 12px 35px;
            background: linear-gradient(180deg, #4CAF50 0%, #388E3C 100%);
            border: 3px solid #66BB6A;
            border-radius: 30px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        .lore-close-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        .lore-toggle-btn {
            background: linear-gradient(180deg, #9C27B0 0%, #7B1FA2 100%);
            border-color: #BA68C8;
        }
        .lore-toggle-btn.active {
            background: linear-gradient(180deg, #E040FB 0%, #AA00FF 100%) !important;
            border-color: #EA80FC !important;
            box-shadow: 0 0 20px rgba(234, 128, 252, 0.6);
        }
        
        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           MOBILE RESPONSIVE STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
        @media screen and (max-width: 768px) {
            /* Smaller toolbar buttons for mobile */
            .btn {
                padding: 8px 10px;
                font-size: 14px;
                min-width: 36px;
                border-radius: 6px;
            }
            
            /* Toolbar adjustments */
            #toolbar {
                padding: 8px 10px;
                gap: 6px;
                flex-wrap: wrap;
            }
            
            /* Dashboard stat boxes */
            .stat {
                padding: 4px 8px;
                margin-right: 4px;
            }
            .stat .lbl {
                font-size: 8px;
            }
            .stat .val {
                font-size: 14px;
            }
            
            /* Menu panels - smaller and fit screen */
            #building-menu-panel,
            #industrial-menu-panel,
            #road-menu-panel,
            #special-menu-panel,
            #commercial-menu-panel,
            #milestone-menu-panel {
                min-width: auto !important;
                width: 95vw !important;
                max-width: 95vw !important;
                padding: 12px !important;
                max-height: 80vh !important;
            }
            
            /* Menu titles smaller */
            .menu-title {
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }
            
            /* Grid - 2 columns on mobile */
            .level-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 8px !important;
                padding: 6px !important;
            }
            
            /* Smaller cards */
            .level-card {
                min-height: 100px !important;
                padding: 10px 8px !important;
            }
            .level-card .level-icon {
                font-size: 28px !important;
                margin-bottom: 4px !important;
            }
            .level-card .level-name {
                font-size: 11px !important;
                min-height: 24px !important;
            }
            .level-card .level-stats {
                font-size: 9px !important;
            }
            .level-card .level-cost {
                font-size: 9px !important;
            }
            
            /* RCI meters */
            #rci-meters {
                padding: 4px 8px !important;
            }
            #rci-meters > div:first-child {
                height: 40px !important;
            }
            #rci-meters > div:first-child > div > div:first-child {
                width: 12px !important;
            }
            
            /* Dashboard */
            #dashboard {
                padding: 6px 10px !important;
                gap: 10px !important;
            }
            
            /* Hide some stats on very small screens */
            #stat-geology,
            #stat-wander-wells {
                display: none !important;
            }
        }
        
        /* Even smaller screens (phones) */
        @media screen and (max-width: 480px) {
            .btn {
                padding: 6px 8px;
                font-size: 12px;
                min-width: 32px;
            }
            
            .stat {
                padding: 3px 6px;
            }
            .stat .val {
                font-size: 12px;
            }
            
            /* Single column on very small screens */
            .level-grid {
                grid-template-columns: 1fr 1fr !important;
            }
            
            .level-card {
                min-height: 90px !important;
            }
            .level-card .level-icon {
                font-size: 24px !important;
            }
            
            /* Hide more stats */
            #stat-inventory,
            #stat-workforce {
                display: none !important;
            }
        }
    </style>
</head>
<body oncontextmenu="return false;" style="cursor: default;">

    <!-- LORE POPUP MODAL -->
    <div id="lore-popup-overlay" onclick="Controller.closeLorePopup()"></div>
    <div id="lore-popup">
        <div class="lore-illustration">
            <canvas id="lore-canvas" width="500" height="200"></canvas>
        </div>
        <div class="lore-content">
            <div class="lore-title" id="lore-title">The Journey Begins</div>
            <div class="lore-text" id="lore-text">Early man had a dream...</div>
            <button class="lore-close-btn" onclick="Controller.closeLorePopup()">Continue Journey</button>
        </div>
    </div>

    <!-- FLOATING HARD STOP BUTTON - Always visible when AI is running -->
    <button id="ai-hard-stop" onclick="QLearningAI.hardStop()" style="display:none;position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:9999;padding:15px 20px;background:#f44336;color:#fff;border:3px solid #fff;border-radius:12px;cursor:pointer;font-weight:bold;font-size:16px;box-shadow:0 4px 20px rgba(244,67,54,0.6);animation:pulse-stop 1.5s infinite;" title="Emergency Stop - Stops all AI activity">‚èπÔ∏è STOP AI</button>
    <style>
        @keyframes pulse-stop {
            0%, 100% { box-shadow: 0 4px 20px rgba(244,67,54,0.6); }
            50% { box-shadow: 0 4px 30px rgba(244,67,54,0.9); transform: translateY(-50%) scale(1.05); }
        }
    </style>
    <!-- Game Log Modal -->
    <div id="log-modal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:10000;align-items:center;justify-content:center;">
        <div onclick="event.stopPropagation();" style="background:#222;color:#fff;padding:24px 32px;max-width:800px;width:90vw;max-height:85vh;overflow:hidden;border-radius:8px;box-shadow:0 4px 32px #000;position:relative;display:flex;flex-direction:column;">
            <button onclick="Controller.hideLog()" style="position:absolute;top:8px;right:8px;font-size:1.5em;background:none;border:none;color:#fff;cursor:pointer;z-index:1;">‚úñ</button>
            <h2 style="margin:0 0 12px 0;">Game Logs</h2>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
                <button onclick="Controller.switchLog(&#39;player&#39;)" id="btn-player-log" style="padding:8px 16px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">Player Log</button>
                <button onclick="Controller.switchLog(&#39;technical&#39;)" id="btn-technical-log" style="padding:8px 16px;background:#333;color:#fff;border:none;border-radius:4px;cursor:pointer;">Technical Log</button>
                <button onclick="Controller.copyLog()" style="padding:8px 16px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;margin-left:auto;">üìã Copy</button>
            </div>
            <pre id="log-content" style="white-space:pre-wrap;word-wrap:break-word;font-family:monospace;font-size:0.85em;background:#181818;padding:12px;border-radius:6px;overflow-y:auto;flex:1;margin:0;"></pre>
        </div>
    </div>

    <!-- AI Training Panel -->
    <div id="ai-training-panel" style="position: fixed; bottom: 10px; right: 10px; background: rgba(20, 20, 30, 0.95); color: rgb(255, 255, 255); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 9000; border: 2px solid rgb(74, 158, 255); min-width: 280px; display: block;">
        <!-- AI MODE SELECTOR -->
        <div style="display:flex;gap:5px;margin-bottom:10px;">
            <button id="btn-ai-qlearn" onclick="switchAIMode('qlearn')" style="flex:1;padding:8px;background:#4a9eff;color:#fff;border:2px solid #4a9eff;border-radius:4px;cursor:pointer;font-weight:bold;">üß† Q-Learn</button>
            <button id="btn-ai-blueprint" onclick="switchAIMode('blueprint')" style="flex:1;padding:8px;background:#333;color:#888;border:2px solid #555;border-radius:4px;cursor:pointer;font-weight:bold;">üèóÔ∏è Blueprint</button>
        </div>
        
        <!-- Q-LEARNING PANEL -->
        <div id="qlearn-panel">
        <div style="font-weight:bold;font-size:14px;margin-bottom:5px;color:#4a9eff;">ü§ñ Q-Learning AI</div>
        <div id="ai-version-label" style="color:#FFD700;font-size:11px;margin-bottom:8px;padding:4px 8px;background:#2a2a3a;border-radius:4px;border:1px solid #FFD700;">Loading AI version...</div>
        <!-- Curriculum Phase Banner -->
        <div id="ai-phase-banner" style="background: rgb(21, 101, 192); padding: 6px; border-radius: 4px; text-align: center; margin-bottom: 8px; font-weight: bold;">üèóÔ∏è Phase 2: Building Cities (0/5 balanced)</div>
        <div style="display:grid;grid-template-columns:auto 1fr;gap:5px 10px;margin-bottom:10px;">
            <span style="color:#888;">Episode:</span><span id="ai-episode">11989</span>
            <span style="color:#888;">Best Score:</span><span id="ai-best-score" style="color:#4CAF50;">130762.8</span>
            <span style="color:#888;">Avg Reward:</span><span id="ai-avg-reward">32527.5</span>
            <span style="color:#888;">Exploration:</span><span id="ai-exploration">10.0%</span>
            <span style="color:#888;">States:</span><span id="ai-states">154</span>
            <span style="color:#888;">Demos:</span><span id="ai-demo-count" style="color:#9b59b6;">0</span>
        </div>
        <!-- Playbook Status -->
        <div id="ai-playbook-status" style="padding:5px;margin:5px 0;background:#1a1a2a;border-radius:4px;font-size:10px;">
            <span style="color:#9b59b6;">üìö Playbook:</span>
            <span id="ai-playbook-count" style="color:#fff;">No playbooks saved</span>
            <button onclick="localStorage.removeItem('ai_playbooks');QLearningAI.savedPlaybooks=[];QLearningAI.log('üóëÔ∏è Playbooks cleared');Controller.toast('Playbooks cleared!')" style="padding:2px 6px;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:9px;margin-left:5px;">Clear</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;">
            <button id="ai-train-btn" onclick="QLearningAI.isTraining ? QLearningAI.stopTraining() : QLearningAI.startTraining()" style="padding:6px 12px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">‚èπÔ∏è Stop</button>
            <button id="ai-watch-btn" onclick="QLearningAI.isWatching ? QLearningAI.stopWatching() : QLearningAI.startWatching()" style="padding:6px 10px;background:#9b59b6;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">üëÅÔ∏è Watch Me</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.replayBestRun()" style="padding:6px 10px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="Replay the best recorded run">üîÑ Replay Best</button>
            <button onclick="QLearningAI.showWisdom()" style="padding:6px 10px;background:#FF9800;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="View learned rules and patterns">üß† Wisdom</button>
            <button onclick="QLearningAI.softReset()" style="padding:6px 10px;background:#f44336;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="Reset but keep best patterns">‚ôªÔ∏è Soft Reset</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.showPlaytestReport()" style="padding:6px 10px;background:#00BCD4;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="View bugs, exploits, balance">üêõ Report</button>
            <button onclick="QLearningAI.exportStats()" style="padding:6px 10px;background:#9C27B0;color:#fff;border:none;border-radius:4px;cursor:pointer;">üìä Export</button>
        </div>
        <!-- FILE-BASED Q-TABLE SAVE/LOAD -->
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.saveBrainToFile()" style="padding:6px 10px;background:#6366F1;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Download Q-table as JSON file">üì• Save AI</button>
            <button onclick="document.getElementById('qtable-file-input').click()" style="padding:6px 10px;background:#8B5CF6;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Load Q-table from JSON file">üì§ Load AI</button>
            <input type="file" id="qtable-file-input" accept=".json" style="display:none" onchange="QLearningAI.loadBrainFromFile(this.files[0])">
            <button onclick="QLearningAI.clearMemory(true)" style="padding:6px 10px;background:#FF5722;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Clear memory to reduce RAM usage">üßπ Clear RAM</button>
        </div>
        <!-- MEMORY STATS -->
        <div id="ai-memory-stats" style="margin-top:5px;padding:5px;background:#1a1a2a;border-radius:4px;font-size:10px;border:1px solid #555;">
            <span style="color:#888;">üíæ Memory:</span>
            <span id="ai-mem-states" style="color:#fff;">0 states</span>
            <span style="color:#888;"> | </span>
            <span id="ai-mem-mb" style="color:#4CAF50;">0MB</span>
        </div>
        <!-- EXPLORATION TEST MODE -->
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;align-items:center;">
            <button id="ai-explore-btn" onclick="QLearningAI.toggleExplorationTest()" style="padding:6px 10px;background:#E91E63;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Test map collection - tracks death chance per tile">üó∫Ô∏è Explore Test</button>
            <button onclick="QLearningAI.showExplorationReport()" style="padding:6px 10px;background:#607D8B;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="View exploration statistics">üìà Explore Stats</button>
        </div>
        <!-- Exploration Test Status -->
        <div id="ai-explore-status" style="display:none;margin-top:5px;padding:6px;background:#311B2B;border-radius:4px;font-size:10px;border:1px solid #E91E63;">
            <div style="color:#E91E63;font-weight:bold;">üó∫Ô∏è EXPLORATION TEST ACTIVE</div>
            <div id="ai-explore-tiles">Tiles: 0/0 (0%)</div>
            <div id="ai-explore-resources">Resources: 0 collected</div>
            <div id="ai-explore-deaths">Deaths: 0 | Avg Steps/Death: --</div>
            <div id="ai-explore-danger">Danger/Tile: --</div>
        </div>
        <div style="margin-top:8px;font-size:10px;color:#666;">
            Speed: <select id="ai-speed" onchange="QLearningAI.trainingSpeed=parseFloat(this.value);QLearningAI.frameSkipCounter=0;" style="background:#333;color:#fff;border:1px solid #555;padding:2px;">
                <option value="0.05">0.05x (Debug)</option>
                <option value="0.1">0.1x (Crawl)</option>
                <option value="0.25">0.25x (Watch)</option>
                <option value="1">1x (Slow)</option>
                <option value="5">5x</option>
                <option value="10" selected="">10x (Normal)</option>
                <option value="50">50x (Fast)</option>
                <option value="100">100x (Ultra)</option>
            </select>
        </div>
        <!-- Live Stats -->
        <div id="ai-live-stats" style="margin-top:8px;padding:8px;background:#1a1a2a;border-radius:4px;font-size:10px;">
            <div style="color:#4a9eff;margin-bottom:4px;">üìä Live Stats:</div>
            <div id="ai-current-state" style="color:#aaa;">State: WANDER_P0_F1_W1</div>
            <div id="ai-current-action" style="color:#aaa;">Action: WANDER</div>
            <div id="ai-step-count" style="color:#aaa;">Steps: 1850</div>
            <div id="ai-current-pop" style="color:#aaa;">Pop: 4 | Food: 0 | Yr: 0</div>
        </div>
        <!-- Learning Progress -->
        <div id="ai-learning-progress" style="margin-top:8px;padding:8px;background:#1a2a1a;border-radius:4px;font-size:10px;">
            <div style="color:#4CAF50;margin-bottom:4px;">üìà Learning Progress:</div>
            <div id="ai-cities-built" style="color:#aaa;">Cities Built: 863</div>
            <div id="ai-best-pop" style="color:#aaa;">Best Population: 15</div>
            <div id="ai-best-year" style="color:#aaa;">Best Survival: 1 years</div>
            <div id="ai-rci-balance" style="color:#aaa;">Balanced Cities: 0</div>
            <div id="ai-settled-near-res" style="color:#aaa;">Smart Settlements: 2211778</div>
        </div>
        <!-- Learning Curve (Mini Graph) -->
        <div style="margin-top:8px;">
            <div style="color:#4a9eff;font-size:10px;margin-bottom:2px;">üìâ Reward Trend (last 20):</div>
            <canvas id="ai-reward-graph" width="200" height="40" style="background:#111;border-radius:4px;width:100%;"></canvas>
        </div>
        <!-- Log Window -->
        <div style="margin-top:8px;">
            <div style="color:#4a9eff;font-size:10px;margin-bottom:2px;">üìú Training Log:</div>
            <div id="ai-log" style="background:#111;padding:6px;border-radius:4px;height:80px;overflow-y:auto;font-size:9px;color:#0f0;"></div>
        </div>
        </div><!-- END Q-LEARNING PANEL -->
        
        <!-- BLUEPRINT AI PANEL -->
        <div id="blueprint-panel" style="display:none;">
            <div style="font-weight:bold;font-size:14px;margin-bottom:5px;color:#4CAF50;">üèóÔ∏è Blueprint AI v4.0 - Custom Presets</div>
            <div style="color:#aaa;font-size:10px;margin-bottom:10px;">‚ö†Ô∏è CITY MODE ONLY - Teach me your building strategy!</div>
            
            <!-- RECORD MODE Section -->
            <div style="margin-bottom:10px;padding:10px;background:linear-gradient(135deg, #2a1a1a 0%, #1a2a1a 100%);border-radius:6px;border:2px solid #FFD700;">
                <div style="color:#FFD700;font-size:12px;margin-bottom:8px;font-weight:bold;">üìπ RECORD YOUR STRATEGY</div>
                
                <!-- Recording Controls -->
                <div style="display:flex;gap:5px;margin-bottom:8px;">
                    <button id="bp-record-btn" onclick="toggleRecordMode()" style="flex:1;padding:8px 12px;background:linear-gradient(135deg, #FF4444, #CC0000);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;font-size:12px;box-shadow:0 2px 8px rgba(255,0,0,0.3);">‚è∫ Start Recording</button>
                    <button id="bp-stop-btn" onclick="stopRecording()" disabled style="flex:1;padding:8px 12px;background:#555;color:#888;border:none;border-radius:6px;cursor:not-allowed;font-size:12px;">‚èπ Stop & Save</button>
                </div>
                
                <!-- Preset Name Input (shown when recording stops) -->
                <div id="bp-save-preset-ui" style="display:none;margin-top:8px;padding:8px;background:#1a1a1a;border-radius:4px;">
                    <input id="bp-preset-name" type="text" placeholder="Name your strategy (e.g., 'Fast Start', 'Balanced Growth')" style="width:100%;padding:8px;background:#222;color:#fff;border:1px solid #555;border-radius:4px;margin-bottom:5px;font-size:11px;">
                    <button onclick="savePreset()" style="width:100%;padding:8px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;font-size:12px;">üíæ Save Preset</button>
                </div>
                
                <div id="bp-record-status" style="font-size:10px;color:#888;margin-top:5px;padding:6px;background:#0a0a0a;border-radius:4px;">
                    <span style="color:#FFD700;">üí° Tip:</span> Click Record, build your city strategy, then Stop to save!
                </div>
            </div>
            
            <!-- MY PRESETS Section -->
            <div style="margin-bottom:10px;padding:10px;background:#1a2a1a;border-radius:6px;border:1px solid #4CAF50;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                    <div style="color:#4CAF50;font-size:12px;font-weight:bold;">üìö MY PRESETS</div>
                    <div style="font-size:10px;color:#888;" id="bp-preset-count">0 saved</div>
                </div>
                
                <!-- Preset List -->
                <div id="bp-preset-list" style="max-height:180px;overflow-y:auto;margin-bottom:8px;">
                    <div style="text-align:center;padding:20px;color:#666;font-size:11px;">
                        No presets yet!<br>Record your first strategy above.
                    </div>
                </div>
                
                <!-- Active Preset Display -->
                <div id="bp-active-preset" style="padding:8px;background:#0a2a0a;border-radius:4px;border:1px solid #2E7D32;">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <div>
                            <div style="font-size:10px;color:#81C784;margin-bottom:3px;">Active Strategy:</div>
                            <div id="bp-active-preset-name" style="font-size:11px;color:#A5D6A7;font-weight:bold;">None (using default)</div>
                        </div>
                        <button id="bp-clear-preset-btn" onclick="clearActivePreset()" style="padding:4px 8px;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:10px;display:none;">Clear</button>
                    </div>
                    <div id="bp-current-step" style="font-size:9px;color:#888;margin-top:3px;">-</div>
                </div>
            </div>
            
            <!-- AI Controls -->
            <div style="display:flex;gap:5px;margin-bottom:10px;">
                <button id="bp-start-btn" onclick="toggleBlueprintAI()" style="flex:1;padding:10px;background:linear-gradient(135deg, #4CAF50, #2E7D32);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;font-size:13px;box-shadow:0 2px 8px rgba(76,175,80,0.4);">‚ñ∂Ô∏è Start AI</button>
                <button onclick="stopBlueprintAI()" style="padding:10px 15px;background:#f44336;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:13px;">‚èπ</button>
            </div>
            
            <!-- Stats -->
            <div style="display:grid;grid-template-columns:auto 1fr;gap:5px 10px;font-size:10px;padding:8px;background:#0a0a0a;border-radius:4px;">
                <span style="color:#888;">Status:</span><span id="bp-status" style="color:#4CAF50;">Ready</span>
                <span style="color:#888;">Built:</span><span id="bp-built">0 total</span>
                <span style="color:#888;">Step:</span><span id="bp-current-step">-</span>
            </div>
        </div><!-- END BLUEPRINT PANEL -->
        
    </div>

    <div id="toast" style="opacity: 0; background: rgba(0, 0, 0, 0.85);">‚õ∞Ô∏è Stone deposit blocking path.</div>

    <div id="gameover-screen" style="display: none; position: fixed; top: 0px; left: 0px; width: 100vw; height: 100vh; background: rgba(30, 25, 20, 0.97); z-index: 9999; justify-content: center; align-items: center; flex-direction: column; font-family: serif; overflow-y: auto; padding: 20px 0px;">
        <div id="newspaper-article" style="max-width:700px; background:#F5F0E1; color:#222; padding:40px 50px; margin:20px; border-radius:4px; box-shadow:0 10px 40px rgba(0,0,0,0.5); border:1px solid #D4C9B0; position:relative;">
            <!-- Newspaper Header -->
            <div style="text-align:center; border-bottom:3px double #333; padding-bottom:15px; margin-bottom:20px;">
                <div style="font-size:0.75em; color:#666; letter-spacing:4px; text-transform:uppercase;">The Prehistoric Times</div>
                <div id="newspaper-date" style="font-size:0.85em; color:#888; margin-top:5px;">December 28, 2025</div>
            </div>
            <!-- Fossil Illustration -->
            <div style="display:flex; justify-content:center; align-items:center; margin-bottom:10px;">
                <canvas id="fossil-illustration" width="280" height="140" style="background:#E8DCC8; border:2px solid #998; border-radius:8px; margin-bottom:10px;"></canvas>
            </div>
            <!-- Headline -->
            <h1 id="newspaper-headline" style="font-family:&#39;Times New Roman&#39;,serif; font-size:2.2em; font-weight:900; text-align:center; line-height:1.2; margin:0 0 15px 0; color:#111;">Settlement Died of Thirst: "Water Was Everything," Say Archaeologists</h1>
            <!-- Subheadline -->
            <div id="newspaper-subheadline" style="font-family:&#39;Times New Roman&#39;,serif; font-size:1.1em; font-style:italic; text-align:center; color:#444; margin-bottom:20px; padding-bottom:15px; border-bottom:1px solid #ccc;">Excavation of a tiny hamlet (5 inhabitants) shows why early humans needed foresight to survive</div>
            <!-- Article Body -->
            <div id="newspaper-body" style="font-family:Georgia,serif; font-size:1em; line-height:1.7; color:#333; text-align:justify; column-count:1;"><p><strong>FERTILE CRESCENT REGION</strong> ‚Äî Researchers have completed their analysis of a tiny hamlet that housed approximately 5 people before its sudden collapse in Year 1 of the settlement's existence.</p><p>The excavation revealed no residential structures. No evidence of organized trade or social gathering spots was found. Remarkably, no organized food production was ever established‚Äîthe settlement relied entirely on opportunistic foraging.</p><p>Notably, no permanent water infrastructure was ever constructed‚Äîa critical oversight that may have contributed to the settlement's demise.</p><p>Skeletal analysis reveals catastrophic dehydration as the primary cause of death. The settlement existed for over two years without any permanent water infrastructure‚Äîa fatal oversight. Bone analysis shows progressive signs of water stress, malnutrition, and ultimately mass mortality during what appears to have been a severe drought season.</p><p>"The difference between the groups that survived and those that perished often came down to planning," explained Dr. Catherine Dubois. "Those who thought seasons ahead, who built reserves, who prepared for hardship‚Äîthey became our ancestors. The others... became archaeology."</p><p>This settlement joins thousands of similar failed attempts across the prehistoric world, each a testament to the razor-thin margin between survival and extinction that defined early human existence.</p></div>
            <!-- Stats Box -->
            <div id="newspaper-stats" style="margin-top:25px; padding:15px; background:#EDE8D9; border:1px solid #ccc; border-radius:3px; font-family:&#39;Courier New&#39;,monospace; font-size:0.9em;"><strong>üìã SETTLEMENT SURVEY:</strong><br>‚Ä¢ Peak population: 5<br>‚Ä¢ Years survived: 1<br>‚Ä¢ Dwellings: None<br>‚Ä¢ Trade spots: None<br>‚Ä¢ Food production: None<br>‚Ä¢ Water wells: 0 built / 1 needed<br>‚Ä¢ Food at collapse: 22 units<br>‚Ä¢ Years without water: 312<br>‚Ä¢ Verdict: <span style="color:#8B0000;">Death by dehydration</span></div>
            <!-- New Game Button -->
            <div style="text-align:center; margin-top:30px;">
                <button id="btn-newgame-gameover" onclick="Controller.reset(); document.getElementById('gameover-screen').style.display='none';" style="font-size:1.2em; padding:15px 40px; background:#8B4513; color:#F5F0E1; border:none; border-radius:6px; font-family:serif; font-weight:bold; cursor:pointer; box-shadow:0 3px 10px rgba(0,0,0,0.3); transition:background 0.2s;">Try Again</button>
            </div>
        </div>
    </div>

    <div id="menubar" style="display: flex !important; visibility: visible !important;">
        <div style="font-weight:700; font-size:14px; margin-right:10px; font-family:sans-serif; color:#D4A040; white-space:nowrap;">CIVIL ZONES</div>
        <div class="separator"></div>
            <script>
            // Show/hide both Pass Year buttons based on level
            function updatePassYearButton() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                // Show if in CITY mode (settled)
                var show = (typeof Game !== 'undefined' && Game.gameState === 'CITY');
                if (btn2) btn2.style.display = show ? 'inline-block' : 'none';
            }

            // Unified Pass Year click handler
            function handlePassYearClick() {
                if (typeof Game !== 'undefined' && typeof Game.endTurn === 'function') {
                    Game.endTurn();
                    if (typeof Controller !== 'undefined' && typeof Controller.updateUI === 'function') {
                        Controller.updateUI();
                    }
                    updatePassYearButton();
                }
            }

            // Hook up both Pass Year buttons when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                if (btn2) btn2.addEventListener('click', handlePassYearClick);
                
                // Initial update after short delay to ensure Game is initialized
                setTimeout(function() {
                    updatePassYearButton();
                    // Update AI version label
                    if(typeof AI !== 'undefined' && AI.updateVersionLabel) {
                        AI.updateVersionLabel();
                    }
                }, 100);
            });
            </script>
        <button class="btn" id="t-pan" onclick="Controller.setTool(&#39;PAN&#39;)" title="Pan Camera">‚úã</button>
        <button class="btn b-road" id="t-road" onclick="Controller.openRoadMenu()" style="display: inline-block;" title="Build Roads">üõ£Ô∏è</button>
        <button class="btn b-wat" id="t-well" onclick="Controller.openWellMenu()" style="display: inline-block;" title="Build Well">üíß</button>
        <div id="sep1" class="separator"></div>
        <button class="btn" id="t-demolish" onclick="Controller.setTool('DEMOLISH')" style="display: inline-block;" title="Demolish (drag for area)">üî®</button>
        <button class="btn b-res" id="t-res" onclick="Controller.openBuildingMenu()" style="display: inline-block;" title="Build Residential">üèóÔ∏è</button>
        <button class="btn b-com" id="t-com" onclick="Controller.openCommercialMenu()" style="display: inline-block;" title="Build Pebble Traders Post">üè¢</button>
        <button class="btn b-ind" id="t-ind" onclick="Controller.openIndustrialMenu()" style="display: inline-block;" title="Build hunting ground">üè≠</button>
        <!-- Storage Pits REMOVED - use Monolithic Resource Pit instead -->
        <button class="btn b-special" id="t-special" onclick="Controller.openSpecialMenu()" style="display: inline-block;" title="Special Buildings">‚≠ê</button>
        <button class="btn b-milestone" id="t-milestone" onclick="Controller.openMilestoneMenu()" style="display: inline-block;" title="Milestone Buildings (unlock new tiers)">üèõÔ∏è</button>
        <button class="btn b-exchange" id="t-exchange" onclick="Controller.exchangeGold()" style="display: inline-block; background: #FFD700; color: #000;" title="Exchange 5,000 Metal for 1 Gold">üí∞</button>
        <div id="sep2" class="separator"></div>
        <button class="btn" id="btn-settle" onclick="console.log(&#39;Settlement button clicked!&#39;); Game.settleHere();" style="background: rgb(76, 175, 80); border-color: rgb(129, 199, 132); display: none;" title="Start Settlement">üèõÔ∏è</button>
        <button class="btn" id="btn-turn" onclick="Game.endTurn()" style="display: inline-block;" title="Pass Turn">‚è≠Ô∏è</button>
        <div style="flex-grow:1;"></div>
        <button class="btn" id="btn-view" onclick="Controller.toggleView()" style="display: inline-block;" title="Toggle View Mode">üëÅÔ∏è</button>
        <button class="btn" onclick="Controller.saveMap()" title="Save Game">üíæ</button>
        <button class="btn" onclick="Controller.loadMap()" title="Load Game">üìÇ</button>
        <button class="btn" onclick="Controller.zoomIn()" title="Zoom In">üîç+</button>
        <button class="btn" onclick="Controller.zoomOut()" title="Zoom Out">üîç-</button>
        <button class="btn" onclick="Controller.reset()" title="New Game">üîÑ</button>
        <div class="separator"></div>
        <!-- Right side utility buttons -->
        <div class="menubar-right">
            <button class="btn debug-btn" style="background:#2196F3;border-color:#64B5F6;" onclick="Controller.toggleElevation()" title="Toggle Elevation View">üóª</button>
            <button class="btn debug-btn" style="background:#9C27B0;border-color:#BA68C8;" onclick="Game.debugAddPopulation(1000)" title="+1000 Pop">üë•+1k</button>
            <button class="btn debug-btn" style="background:#FF5722;border-color:#FF8A65;" onclick="Game.debugAddResources(1000)" title="+1000 Resources">üì¶+1k</button>
            <button class="btn" id="btn-lore" onclick="Controller.toggleLore()" title="Toggle Lore">üìñ</button>
            <button class="btn" onclick="var p=document.getElementById('ai-training-panel');p.style.display=p.style.display==='none'?'block':'none';QLearningAI.updateTrainingUI();" title="Q-Learning AI">ü§ñ</button>
            <button class="btn" id="btn-log" onclick="Controller.showLog()" title="Game Log">üìú</button>
        </div>
    </div>

    <!-- Building Menu Panel -->
    <div id="building-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeBuildingMenu()">√ó</button>
        <div class="menu-title">ÔøΩ Select Your Home</div>
        <div class="level-grid" id="building-level-grid">
            <!-- Dynamically populated by Controller.openBuildingMenu() -->
        </div>
        <div style="text-align: center; margin-top: 15px; font-size: 12px; color: #A5D6A7; background: rgba(76,175,80,0.1); padding: 10px 15px; border-radius: 10px; border: 1px solid rgba(129,199,132,0.3);">
            üåü <strong>Tip:</strong> Homes near roads and water grow faster!
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="Controller.confirmBuildingSelection()" style="background: linear-gradient(135deg, #66BB6A, #43A047); padding: 12px 40px; font-size: 15px; font-weight: bold; border-radius: 25px; border: 2px solid #81C784; box-shadow: 0 4px 15px rgba(76,175,80,0.4); transition: all 0.3s;">üè† Build Home</button>
        </div>
    </div>

    <!-- Industrial Menu Panel -->
    <div id="industrial-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeIndustrialMenu()">√ó</button>
        <div class="menu-title">‚öíÔ∏è Select Workshop</div>
        <div class="level-grid" id="industrial-level-grid">
            <!-- Dynamically populated by Controller.openIndustrialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 15px; font-size: 12px; color: #FFAB91; background: rgba(229,57,53,0.1); padding: 10px 15px; border-radius: 10px; border: 1px solid rgba(255,138,128,0.3);">
            üî• <strong>Tip:</strong> Build on ore deposits for bonus resources!
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="Controller.confirmIndustrialSelection()" style="background: linear-gradient(135deg, #FF7043, #E53935); padding: 12px 40px; font-size: 15px; font-weight: bold; border-radius: 25px; border: 2px solid #FF8A65; box-shadow: 0 4px 15px rgba(229,57,53,0.4); transition: all 0.3s;">‚öíÔ∏è Build Workshop</button>
        </div>
    </div>

    <!-- Storage Menu Panel - REMOVED (storage pits no longer available) -->
    <!-- Storage is now 1 million base. Build Monolithic Resource Pit for 50 million storage + 10% rot! -->

    <!-- Special Buildings Menu Panel -->
    <div id="special-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(145deg, #1a1a2e 0%, #151528 100%); border:2px solid #FFD700; border-radius:12px; padding:20px; z-index:1001; min-width:400px; box-shadow:0 0 30px rgba(255,215,0,0.3), 0 8px 32px rgba(0,0,0,0.8);">
        <button class="menu-close-btn" onclick="Controller.closeSpecialMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">√ó</button>
        <div class="menu-title" style="color:#FFD700; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">‚≠ê Special Buildings</div>
        <div class="level-grid" id="special-level-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
            <!-- Dynamically populated by Controller.openSpecialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            üí° Special buildings provide unique bonuses to your settlement!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmSpecialSelection()" style="background: #FFD700; color: #000; padding: 10px 30px; font-size: 14px;">‚úì Build Selected</button>
        </div>
    </div>

    <!-- Commercial Menu Panel -->
    <div id="commercial-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(145deg, #1a1a2e 0%, #151528 100%); border:2px solid #4a9eff; border-radius:12px; padding:20px; z-index:1001; min-width:400px; box-shadow:0 0 30px rgba(74,158,255,0.3), 0 8px 32px rgba(0,0,0,0.8);">
        <button class="menu-close-btn" onclick="Controller.closeCommercialMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">√ó</button>
        <div class="menu-title" style="color:#4a9eff; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">üè™ Choose Commercial Type</div>
        <div class="level-grid" id="commercial-level-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
            <!-- Dynamically populated by Controller.openCommercialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            üí° Commercial buildings generate income and improve desirability!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmCommercialSelection()" style="background: #4a9eff; padding: 10px 30px; font-size: 14px;">‚úì Build Selected</button>
        </div>
    </div>

    <!-- Milestone Menu Panel -->
    <div id="milestone-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(145deg, #1a1a2e 0%, #151528 100%); border:2px solid #FFD700; border-radius:12px; padding:20px; z-index:1001; min-width:400px; box-shadow:0 0 30px rgba(255,215,0,0.3), 0 8px 32px rgba(0,0,0,0.8);">
        <button class="menu-close-btn" onclick="Controller.closeMilestoneMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">√ó</button>
        <div class="menu-title" style="color:#FFD700; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">üèõÔ∏è Milestone Buildings</div>
        <div style="text-align: center; margin-bottom: 15px; font-size: 12px; color: #aaa;">
            Milestone buildings unlock new building tiers! They require Gold, which can be exchanged for Metal.
        </div>
        <div class="level-grid" id="milestone-level-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:15px;">
            <!-- Dynamically populated by Controller.openMilestoneMenu() -->
        </div>
        <div style="text-align: center; margin-top: 15px; padding: 10px; background: #2a2a4a; border-radius: 8px;">
            <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px;">üí∞ Gold Exchange</div>
            <div style="font-size: 11px; color: #aaa;">5,000 Metal = 1 Gold</div>
            <div style="font-size: 13px; color: #fff; margin-top: 5px;">
                Current Metal: <span id="milestone-metal-display" style="color:#78909C;">0</span> | 
                Current Gold: <span id="milestone-gold-display" style="color:#FFD700;">0</span>
            </div>
            <button class="btn" onclick="Controller.exchangeGold()" style="background: #FFD700; color: #000; padding: 8px 20px; font-size: 12px; margin-top: 10px;">üí∞ Exchange Metal for Gold</button>
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="Controller.confirmMilestoneSelection()" style="background: #FFD700; color: #000; padding: 10px 30px; font-size: 14px;">‚úì Build Selected</button>
        </div>
    </div>

    <!-- Roads Menu Panel -->
    <div id="road-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeRoadMenu()">√ó</button>
        <div class="menu-title">üõ£Ô∏è Choose Road Type</div>
        <div class="level-grid" id="road-level-grid">
            <!-- Level 1: Path -->
            <div class="level-card selected" id="card-road-1" onclick="Controller.selectRoadLevel(1)">
                <div class="level-icon">üö∂</div>
                <div class="level-name">Path</div>
                <div class="level-stats">Level 1 ‚Ä¢ Basic footpath</div>
                <div class="level-cost">Cost: $5</div>
            </div>
            <!-- Level 2: Road (Locked) -->
            <div class="level-card level-locked" id="card-road-2" onclick="Controller.selectRoadLevel(2)">
                <div class="level-icon">üõ§Ô∏è</div>
                <div class="level-name">Road</div>
                <div class="level-stats">Level 2 ‚Ä¢ Coming Soon</div>
                <div class="level-cost">üîí Locked</div>
            </div>
            <!-- Level 3: (Locked) -->
            <div class="level-card level-locked" id="card-road-3" onclick="Controller.selectRoadLevel(3)">
                <div class="level-icon">üöó</div>
                <div class="level-name">Paved Road</div>
                <div class="level-stats">Level 3 ‚Ä¢ Coming Soon</div>
                <div class="level-cost">üîí Locked</div>
            </div>
            <!-- Level 4: (Locked) -->
            <div class="level-card level-locked" id="card-road-4" onclick="Controller.selectRoadLevel(4)">
                <div class="level-icon">üèéÔ∏è</div>
                <div class="level-name">Highway</div>
                <div class="level-stats">Level 4 ‚Ä¢ Coming Soon</div>
                <div class="level-cost">üîí Locked</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            üí° Roads improve desirability and connect your buildings!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmRoadSelection()" style="background: var(--c-road); padding: 10px 30px; font-size: 14px;">‚úì Build Selected</button>
        </div>
    </div>

    <div id="viewport"><canvas id="cvs" width="1014" height="749"></canvas><div id="debug">Pos: 103, 116</div></div>

    <div id="dashboard">
        <!-- RCI Demand Indicator -->
        <div id="rci-meters" class="rci-container">
            <div style="display:flex; gap:4px; align-items:flex-end; height:45px;">
                <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                    <div style="flex:1; width:14px; background:#1A1510; border:1px solid #5C4A3D; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                        <div id="r-bar-fill" style="width:100%; background:linear-gradient(to top, #2E7D32, #4CAF50); transition:height 0.3s; height:40%;"></div>
                    </div>
                    <span style="color:#4CAF50; font-weight:bold; font-size:9px; margin-top:1px;">R</span>
                </div>
                <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                    <div style="flex:1; width:14px; background:#1A1510; border:1px solid #5C4A3D; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                        <div id="c-bar-fill" style="width:100%; background:linear-gradient(to top, #1565C0, #42A5F5); transition:height 0.3s; height:90%;"></div>
                    </div>
                    <span style="color:#42A5F5; font-weight:bold; font-size:9px; margin-top:1px;">C</span>
                </div>
                <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                    <div style="flex:1; width:14px; background:#1A1510; border:1px solid #5C4A3D; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                        <div id="i-bar-fill" style="width:100%; background:linear-gradient(to top, #E65100, #FF9800); transition:height 0.3s; height:80%;"></div>
                    </div>
                    <span style="color:#FF9800; font-weight:bold; font-size:9px; margin-top:1px;">I</span>
                </div>
            </div>
            <div id="rci-tooltip" style="font-size:8px; color:#8B7355; text-align:center; margin-top:2px;">R:1 C:0 I:0</div>
        </div>
        <div class="separator"></div>
        <button class="btn" id="btn-pass-year-dash" style="display:none; background:#388E3C; color:#fff;" title="Pass Year">‚è©</button>
        <!-- Stats Group -->
        <div class="stats-group">
            <div class="stat"><span class="lbl">Pop</span><span class="val" id="v-pop" style="color:var(--c-res)">4</span></div>
            <div class="stat"><span class="lbl">Food</span><span class="val" id="v-food" style="color:#4CAF50">280/450</span></div>
            <div class="stat" id="stat-wood"><span class="lbl">Wood</span><span class="val" id="v-wood" style="color:#A86838">158</span></div>
            <div class="stat" id="stat-metal"><span class="lbl">Metal</span><span class="val" id="v-metal" style="color:#78909C">0</span></div>
            <div class="stat" id="stat-stone"><span class="lbl">Stone</span><span class="val" id="v-stone" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-inventory"><span class="lbl">Inv</span><span class="val" id="v-inventory" style="color:#64B5F6">438/450</span></div>
            <div class="stat" id="stat-year"><span class="lbl">Year</span><span class="val" id="v-year" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-geology" style="display:none;"><span class="lbl">Climate</span><span class="val" id="v-geology" style="color:#4FC3F7">üåç</span></div>
            <div class="stat" id="stat-nomad" style="display:none;"><span class="lbl">Nomads</span><span class="val" id="v-nomad" style="color:#FFA726">0</span></div>
            <div class="stat" id="stat-thirst"><span class="lbl">üíß Thirst</span><span class="val" id="v-thirst" style="color:#29B6F6">87</span></div>
            <div class="stat" id="stat-wander-wells" style="display:none;"><span class="lbl">üï≥Ô∏è Pits</span><span class="val" id="v-wander-wells" style="color:#29B6F6">0</span></div>
            <div class="stat" id="stat-water"><span class="lbl">üíß Water</span><span class="val" id="v-wat" style="color:var(--c-wat)">‚ö†Ô∏è 0/1</span></div>
            <div class="stat" id="stat-wells" style="display:none;" title="Wells provide water for 100 people each."><span class="lbl">üï≥Ô∏è Wells</span><span class="val" id="v-wells" style="color:#29B6F6">0</span></div>
            <div class="stat" id="stat-workforce" style="display:none;"><span class="lbl">Workers</span><span class="val" id="v-workforce" style="color:#AB47BC">üë∑ 5</span></div>
            <div class="stat" id="stat-funds"><span class="lbl">Gold</span><span class="val" id="v-res" style="color:var(--c-com)">0</span></div>
        </div>
        <div class="separator"></div>
        <!-- Right side -->
        <div class="dashboard-right">
            <div class="val" id="v-epoch" style="font-size:11px; font-weight:600; color:#D4A040;">üåç EXPLORING</div>
            <button class="btn" id="btn-newgame" onclick="window.startNewGame()" style="background:#1976D2; color:#fff;">üÜï</button>
            <button class="btn" onclick="Controller.showStatsMenu()" title="Stats">üìä</button>
        </div>
    </div>

    <!-- Stats Menu Popup - Tribal Stone Tablet -->
    <div id="stats-menu" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background: linear-gradient(145deg, rgba(60, 45, 30, 0.98) 0%, rgba(40, 30, 20, 0.98) 100%); border:3px solid #8B6914; border-radius:8px; padding:25px; max-width:500px; min-width:400px; z-index:1000; color:#F5E6C8; box-shadow: 0 0 0 2px #5C4A0F, 0 15px 50px rgba(0,0,0,0.8), 0 0 40px rgba(139, 105, 20, 0.3);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#D4A040; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">üìä Tribe Statistics</h3>
            <button onclick="Controller.hideStatsMenu()" style="background:linear-gradient(145deg, #6B4423 0%, #4A3018 100%); border:2px solid #8B6914; color:#F5E6C8; font-size:16px; width:32px; height:32px; border-radius:4px; cursor:pointer; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">√ó</button>
        </div>
        <div id="stats-content" style="line-height:1.8; font-size:14px; color:#C4A878;">
            <!-- Stats will be populated by JavaScript -->
        </div>
    </div>
    <div id="stats-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:999; backdrop-filter: blur(2px);" onclick="Controller.hideStatsMenu()"></div>

    <!-- New Game Confirmation Modal - Tribal Warning -->
    <div id="newgame-confirm-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.85); z-index:10000; align-items:center; justify-content:center; backdrop-filter: blur(3px);">
        <div onclick="event.stopPropagation();" style="background:linear-gradient(145deg, rgba(60, 35, 25, 0.98) 0%, rgba(40, 25, 18, 0.98) 100%); border:4px solid #B44B4B; border-radius:10px; padding:30px; max-width:450px; width:85vw; box-shadow: 0 0 0 2px rgba(139, 40, 40, 0.4), 0 10px 40px rgba(0,0,0,0.9), 0 0 50px rgba(180, 75, 75, 0.2); color:#F5E6C8; text-align:center;">
            <div style="font-size:48px; margin-bottom:15px;">‚ö†Ô∏è</div>
            <h2 style="margin:0 0 15px 0; color:#FF8B8B; font-size:24px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">Abandon Tribe?</h2>
            <p style="margin:0 0 25px 0; color:#C4A878; font-size:16px; line-height:1.5;">All tribe progress will be lost to time!<br>This cannot be undone.</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button onclick="window.confirmNewGame()" style="padding:12px 30px; background:linear-gradient(145deg, #B44B4B 0%, #8B3030 100%); color:#F5E6C8; border:2px solid #D06060; border-radius:6px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s; text-shadow: 0 1px 2px rgba(0,0,0,0.5);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚úì Yes, Restart
                </button>
                <button onclick="window.cancelNewGame()" style="padding:12px 30px; background:linear-gradient(145deg, #4A7A2A 0%, #3D6B22 100%); color:#E8F5E9; border:2px solid #6B9B4A; border-radius:6px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s; text-shadow: 0 1px 2px rgba(0,0,0,0.5);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    ‚úó Keep Playing
                </button>
            </div>
        </div>
    </div>

    <!-- NEEDS WARNING PANEL - Tribal Warning Scroll -->
    <div id="needs-warning-panel" style="position: fixed; bottom: 20px; right: 20px; background: linear-gradient(145deg, rgba(60, 35, 25, 0.98) 0%, rgba(40, 25, 18, 0.98) 100%); border: 3px solid #B44B4B; border-radius: 8px; padding: 15px; width: 300px; font-size: 13px; display: none; z-index: 100; box-shadow: 0 0 0 2px rgba(139, 40, 40, 0.4), 0 8px 25px rgba(180, 75, 75, 0.3);">
        <div style="color: #FF8B8B; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">
            ‚ö†Ô∏è TRIBE NEEDS:
        </div>
        <div id="needs-list" style="color: #F5E6C8; line-height: 1.6;">
            <!-- Populated by updateNeedsWarning() -->
        </div>
        <div id="satisfaction-meter" style="margin-top: 10px; background: rgba(40, 30, 22, 0.9); height: 20px; border-radius: 4px; overflow: hidden; border: 2px solid #5C4A3D;">
            <div id="satisfaction-bar" style="background: linear-gradient(90deg, #B44B4B 0%, #D4A040 50%, #5A9A5A 100%); height: 100%; width: 100%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: #F5E6C8; font-size: 10px; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">
                50%
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".json">

    <!-- External AI Module -->
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/ai.js"></script>
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/assign_population.js"></script>
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/ai_blueprint.js"></script>

        <script>
        window.startNewGame = function() {
            // Show custom confirmation modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) {
                modal.style.display = 'flex';
            } else {
                // Fallback if modal not found - just confirm directly
                if(confirm('Start a new game? All progress will be lost!')) {
                    window.confirmNewGame();
                }
            }
        };
        
        window.confirmNewGame = function() {
            // Hide modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
            
            // Reset progression and all game state
            if (typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) PROGRESSION.reset();
            // Re-initialize the game with a new seed
            if (typeof Game.init === 'function') {
                Game.init(Math.floor(Math.random()*100000));
            }
            // Reset camera and UI
            Controller.cam.x = CFG.CAMERA.START_X;
            Controller.cam.y = CFG.CAMERA.START_Y;
            Controller.cam.z = CFG.CAMERA.START_ZOOM;
            Controller.updateUI();
            Controller.toast('üÜï New game started!');
            
            // Reset lore tracking for new game
            Game.loreSeen = {};
            
            // Show game start lore after a brief delay
            setTimeout(() => {
                if(Game.loreEnabled) {
                    Controller.showLoreEvent('GAME_START');
                }
            }, 500);
        };
        
        window.cancelNewGame = function() {
            // Just hide the modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
        };
        </script>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AI MODE SWITCHING - Toggle between Q-Learning and Blueprint AI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        var currentAIMode = 'qlearn'; // 'qlearn' or 'blueprint'
        var blueprintRunning = false;
        var blueprintInterval = null;
        
        function switchAIMode(mode) {
            currentAIMode = mode;
            
            // Update UI buttons
            var qlearnBtn = document.getElementById('btn-ai-qlearn');
            var blueprintBtn = document.getElementById('btn-ai-blueprint');
            var qlearnPanel = document.getElementById('qlearn-panel');
            var blueprintPanel = document.getElementById('blueprint-panel');
            
            if (mode === 'qlearn') {
                // Activate Q-Learning mode
                if (qlearnBtn) {
                    qlearnBtn.style.background = '#4a9eff';
                    qlearnBtn.style.borderColor = '#4a9eff';
                    qlearnBtn.style.color = '#fff';
                }
                if (blueprintBtn) {
                    blueprintBtn.style.background = '#333';
                    blueprintBtn.style.borderColor = '#555';
                    blueprintBtn.style.color = '#888';
                }
                if (qlearnPanel) qlearnPanel.style.display = 'block';
                if (blueprintPanel) blueprintPanel.style.display = 'none';
                
                // Stop Blueprint AI if running
                if (blueprintRunning) {
                    toggleBlueprintAI();
                }
                
                console.log('üß† Switched to Q-Learning AI mode');
            } else {
                // Activate Blueprint mode
                if (blueprintBtn) {
                    blueprintBtn.style.background = '#4CAF50';
                    blueprintBtn.style.borderColor = '#4CAF50';
                    blueprintBtn.style.color = '#fff';
                }
                if (qlearnBtn) {
                    qlearnBtn.style.background = '#333';
                    qlearnBtn.style.borderColor = '#555';
                    qlearnBtn.style.color = '#888';
                }
                if (qlearnPanel) qlearnPanel.style.display = 'none';
                if (blueprintPanel) blueprintPanel.style.display = 'block';
                
                // Stop Q-Learning if running
                if (typeof AI !== 'undefined' && AI.enabled) {
                    AI.toggle();
                }
                
                console.log('üèóÔ∏è Switched to Blueprint AI mode');
            }
        }
        
        // Toggle Watch Mode for Blueprint AI
        function toggleWatchMode() {
            var btn = document.getElementById('bp-watch-btn');
            var statusEl = document.getElementById('bp-watch-status');
            
            if (typeof BlueprintAI === 'undefined') {
                Controller.toast('Blueprint AI not loaded!');
                return;
            }
            
            if (BlueprintAI.watchMode) {
                // Stop watching
                BlueprintAI.stopWatching();
                if (btn) {
                    btn.innerHTML = 'üëÅÔ∏è Start Watching';
                    btn.style.background = '#FFD700';
                    btn.style.color = '#000';
                }
                if (statusEl) statusEl.textContent = 'Lesson saved! Click Apply to use it.';
                
                // Update lessons count
                var lessonsEl = document.getElementById('bp-lessons');
                if (lessonsEl && BlueprintAI.memory.watchedActions) {
                    lessonsEl.textContent = BlueprintAI.memory.watchedActions.length + ' learned';
                }
                
                // Update ratio display
                var ratioEl = document.getElementById('bp-ratio');
                if (ratioEl) {
                    ratioEl.textContent = BlueprintAI.RULES.TARGET_RATIO.R + ' : ' + 
                                         BlueprintAI.RULES.TARGET_RATIO.C + ' : ' + 
                                         BlueprintAI.RULES.TARGET_RATIO.I;
                }
            } else {
                // Start watching
                BlueprintAI.startWatching();
                if (btn) {
                    btn.innerHTML = '‚èπÔ∏è Stop & Learn';
                    btn.style.background = '#f44336';
                    btn.style.color = '#fff';
                }
                if (statusEl) statusEl.textContent = 'üëÄ Watching... Build wells, housing, etc!';
            }
        }
        
        function toggleBlueprintAI() {
            var btn = document.getElementById('bp-start-btn');
            var statusEl = document.getElementById('bp-status');
            
            if (blueprintRunning) {
                // Stop Blueprint AI
                blueprintRunning = false;
                if (blueprintInterval) {
                    clearInterval(blueprintInterval);
                    blueprintInterval = null;
                }
                if (btn) {
                    btn.innerHTML = '‚ñ∂Ô∏è Start';
                    btn.style.background = '#4CAF50';
                }
                if (statusEl) statusEl.textContent = 'Stopped';
                console.log('üèóÔ∏è Blueprint AI stopped');
            } else {
                // Start Blueprint AI
                blueprintRunning = true;
                if (btn) {
                    btn.innerHTML = '‚èπÔ∏è Stop';
                    btn.style.background = '#f44336';
                }
                if (statusEl) statusEl.textContent = 'Running...';
                
                // Initialize Blueprint AI if available
                if (typeof BlueprintAI !== 'undefined') {
                    BlueprintAI.enable();
                    // initializeBlueprint is optional - AI auto-initializes on first update
                    
                    // Update ratio display from memory
                    var ratioEl = document.getElementById('bp-ratio');
                    if (ratioEl) {
                        ratioEl.textContent = BlueprintAI.RULES.TARGET_RATIO.R + ' : ' + 
                                             BlueprintAI.RULES.TARGET_RATIO.C + ' : ' + 
                                             BlueprintAI.RULES.TARGET_RATIO.I;
                    }
                    
                    // Update lessons count
                    var lessonsEl = document.getElementById('bp-lessons');
                    if (lessonsEl && BlueprintAI.memory.watchedActions) {
                        lessonsEl.textContent = BlueprintAI.memory.watchedActions.length + ' learned';
                    }
                    
                    // Run Blueprint AI step every 500ms (PERFORMANCE: reduced from 100ms)
                    blueprintInterval = setInterval(function() {
                        if (!blueprintRunning) return;
                        
                        try {
                            if (typeof Game !== 'undefined') {
                                BlueprintAI.update(Game);
                            }
                            
                            // Update UI stats
                            var queueEl = document.getElementById('bp-queue');
                            var builtEl = document.getElementById('bp-built');
                            if (queueEl) queueEl.textContent = (BlueprintAI.buildQueue ? BlueprintAI.buildQueue.length : 0) + ' buildings';
                            if (builtEl) builtEl.textContent = (BlueprintAI.stats ? BlueprintAI.stats.totalBuilt : 0) + ' total';
                            
                        } catch (err) {
                            console.error('Blueprint AI error:', err);
                        }
                    }, 500);
                    
                    console.log('üèóÔ∏è Blueprint AI started');
                } else {
                    console.error('BlueprintAI not loaded! Include ai_blueprint.js');
                    if (statusEl) statusEl.textContent = 'Error: Not loaded';
                    blueprintRunning = false;
                    if (btn) {
                        btn.innerHTML = '‚ñ∂Ô∏è Start';
                        btn.style.background = '#4CAF50';
                    }
                }
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PRESET SYSTEM - Record and replay custom building strategies
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        var presetRecording = false;
        var recordedActions = [];
        var savedPresets = [];
        var activePresetIndex = -1;
        
        // Load presets from localStorage on startup
        function loadPresets() {
            try {
                var saved = localStorage.getItem('civilzones_presets');
                if (saved) {
                    savedPresets = JSON.parse(saved);
                } else {
                    // Create smart default presets if none exist
                    createDefaultPresets();
                }
                updatePresetUI();
            } catch(e) {
                console.error('Failed to load presets:', e);
                createDefaultPresets();
                updatePresetUI();
            }
        }
        
        // Create smart default presets with optimal zoning patterns
        function createDefaultPresets() {
            // Get player starting position (assume center of map)
            var cx = Game && Game.player ? Game.player.x : 80;
            var cy = Game && Game.player ? Game.player.y : 80;
            
            // PRESET 1: "Smart Zoning Pattern" - Optimal growth strategy
            // Pattern: Start with well ‚Üí RES cluster with roads ‚Üí Add COM/IND with proper spacing
            var smartZoning = {
                name: "üèÜ Smart Zoning Pattern",
                actions: [
                    // Phase 1: Foundation (Well + First RES + Roads)
                    {type: 'WELL', x: cx, y: cy - 2, timestamp: 0, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx - 2, y: cy, timestamp: 100, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx, y: cy, timestamp: 200, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 1, y: cy, timestamp: 300, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 2: More housing
                    {type: 'RES', x: cx + 3, y: cy, timestamp: 400, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx, y: cy + 1, timestamp: 500, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 1, y: cy + 1, timestamp: 600, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 3: Add commercial zone
                    {type: 'COM', x: cx - 2, y: cy + 3, timestamp: 700, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx - 2, y: cy + 2, timestamp: 800, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 4: Add more housing (4:1:2 ratio)
                    {type: 'RES', x: cx, y: cy - 4, timestamp: 900, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx, y: cy - 3, timestamp: 1000, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 5: Add industrial (downwind/separated)
                    {type: 'IND', x: cx + 5, y: cy + 3, timestamp: 1100, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 4, y: cy + 3, timestamp: 1200, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'IND', x: cx + 5, y: cy + 5, timestamp: 1300, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 5, y: cy + 4, timestamp: 1400, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 6: Second well for expansion
                    {type: 'WELL', x: cx + 4, y: cy - 2, timestamp: 1500, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 7: More residential (maintaining 4:1:2 ratio)
                    {type: 'RES', x: cx + 3, y: cy - 4, timestamp: 1600, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 3, y: cy - 3, timestamp: 1700, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx - 5, y: cy, timestamp: 1800, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx - 3, y: cy, timestamp: 1900, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    
                    // Phase 8: Expand road network
                    {type: 'ROAD', x: cx + 2, y: cy, timestamp: 2000, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx, y: cy + 2, timestamp: 2100, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                ],
                created: Date.now(),
                stats: {
                    totalActions: 22,
                    wellCount: 2,
                    resCount: 5,
                    comCount: 1,
                    indCount: 2,
                    roadCount: 12
                }
            };
            
            // PRESET 2: "Housing Focus" - Maximize population quickly
            var housingFocus = {
                name: "üèòÔ∏è Housing Focus",
                actions: [
                    {type: 'WELL', x: cx, y: cy, timestamp: 0, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx - 2, y: cy + 2, timestamp: 100, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx - 1, y: cy + 2, timestamp: 200, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx + 1, y: cy + 2, timestamp: 300, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx, y: cy + 1, timestamp: 400, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'WELL', x: cx + 3, y: cy, timestamp: 500, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx - 2, y: cy - 2, timestamp: 600, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx - 2, y: cy, timestamp: 700, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'RES', x: cx + 1, y: cy - 2, timestamp: 800, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx + 1, y: cy, timestamp: 900, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'COM', x: cx - 4, y: cy, timestamp: 1000, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                    {type: 'ROAD', x: cx - 3, y: cy, timestamp: 1100, gameState: {year: 0, pop: 0, food: 0, wood: 0}},
                ],
                created: Date.now(),
                stats: {
                    totalActions: 12,
                    wellCount: 2,
                    resCount: 4,
                    comCount: 1,
                    indCount: 0,
                    roadCount: 5
                }
            };
            
            savedPresets.push(smartZoning);
            savedPresets.push(housingFocus);
            savePresetsToStorage();
        }
        
        function savePresetsToStorage() {
            try {
                localStorage.setItem('civilzones_presets', JSON.stringify(savedPresets));
            } catch(e) {
                console.error('Failed to save presets:', e);
            }
        }
        
        function toggleRecordMode() {
            var btn = document.getElementById('bp-record-btn');
            var stopBtn = document.getElementById('bp-stop-btn');
            var statusEl = document.getElementById('bp-record-status');
            
            if (!presetRecording) {
                // Start recording
                presetRecording = true;
                recordedActions = [];
                btn.innerHTML = '‚è∫ Recording...';
                btn.style.background = 'linear-gradient(135deg, #FF0000, #AA0000)';
                btn.style.animation = 'pulse 1s infinite';
                stopBtn.disabled = false;
                stopBtn.style.background = '#FFD700';
                stopBtn.style.color = '#000';
                stopBtn.style.cursor = 'pointer';
                statusEl.innerHTML = '<span style="color:#FF4444;">‚è∫ RECORDING</span> - Build your strategy, then click Stop!';
                Controller.toast('üìπ Recording started! Build your strategy now.');
            }
        }
        
        function stopRecording() {
            if (!presetRecording) return;
            
            presetRecording = false;
            var btn = document.getElementById('bp-record-btn');
            var stopBtn = document.getElementById('bp-stop-btn');
            var statusEl = document.getElementById('bp-record-status');
            var saveUI = document.getElementById('bp-save-preset-ui');
            
            btn.innerHTML = '‚è∫ Start Recording';
            btn.style.background = 'linear-gradient(135deg, #FF4444, #CC0000)';
            btn.style.animation = 'none';
            stopBtn.disabled = true;
            stopBtn.style.background = '#555';
            stopBtn.style.color = '#888';
            stopBtn.style.cursor = 'not-allowed';
            
            if (recordedActions.length === 0) {
                statusEl.innerHTML = '<span style="color:#FF4444;">No actions recorded!</span> Build something first.';
                Controller.toast('‚ö†Ô∏è No actions recorded! Build something while recording.');
                return;
            }
            
            // Show save UI
            saveUI.style.display = 'block';
            statusEl.innerHTML = '<span style="color:#4CAF50;">‚úì Recorded ' + recordedActions.length + ' actions!</span> Name and save below:';
            Controller.toast('‚úì Recorded ' + recordedActions.length + ' actions! Name your preset.');
        }
        
        function savePreset() {
            var nameInput = document.getElementById('bp-preset-name');
            var name = nameInput.value.trim();
            
            if (!name) {
                Controller.toast('‚ö†Ô∏è Please enter a preset name!');
                return;
            }
            
            if (recordedActions.length === 0) {
                Controller.toast('‚ö†Ô∏è No actions to save!');
                return;
            }
            
            // Create preset object
            var preset = {
                name: name,
                actions: recordedActions.slice(),
                created: Date.now(),
                stats: {
                    totalActions: recordedActions.length,
                    wellCount: recordedActions.filter(a => a.type === 'WELL').length,
                    resCount: recordedActions.filter(a => a.type === 'RES').length,
                    comCount: recordedActions.filter(a => a.type === 'COM').length,
                    indCount: recordedActions.filter(a => a.type === 'IND').length,
                    roadCount: recordedActions.filter(a => a.type === 'ROAD').length
                }
            };
            
            savedPresets.push(preset);
            savePresetsToStorage();
            updatePresetUI();
            
            // Reset UI
            document.getElementById('bp-save-preset-ui').style.display = 'none';
            document.getElementById('bp-record-status').innerHTML = '<span style="color:#FFD700;">üí° Tip:</span> Click Record to create another strategy!';
            nameInput.value = '';
            recordedActions = [];
            
            Controller.toast('üíæ Saved preset: ' + name);
        }
        
        function updatePresetUI() {
            var listEl = document.getElementById('bp-preset-list');
            var countEl = document.getElementById('bp-preset-count');
            
            countEl.textContent = savedPresets.length + ' saved';
            
            if (savedPresets.length === 0) {
                listEl.innerHTML = '<div style="text-align:center;padding:20px;color:#666;font-size:11px;">No presets yet!<br>Record your first strategy above.</div>';
                return;
            }
            
            var html = '';
            for (var i = 0; i < savedPresets.length; i++) {
                var preset = savedPresets[i];
                var isActive = i === activePresetIndex;
                var bgColor = isActive ? '#0a3a0a' : '#0a0a0a';
                var borderColor = isActive ? '#4CAF50' : '#333';
                
                html += '<div style="margin-bottom:6px;padding:8px;background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:4px;">';
                html += '  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">';
                html += '    <div style="font-size:11px;color:' + (isActive ? '#81C784' : '#ccc') + ';font-weight:bold;">' + preset.name + (isActive ? ' ‚úì' : '') + '</div>';
                html += '    <div style="display:flex;gap:3px;">';
                html += '      <button onclick="activatePreset(' + i + ')" style="padding:4px 8px;background:#4CAF50;color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:10px;">Use</button>';
                html += '      <button onclick="deletePreset(' + i + ')" style="padding:4px 8px;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:10px;">√ó</button>';
                html += '    </div>';
                html += '  </div>';
                html += '  <div style="font-size:9px;color:#888;">';
                html += '    üè†' + preset.stats.resCount + ' üè™' + preset.stats.comCount + ' üè≠' + preset.stats.indCount + ' üíß' + preset.stats.wellCount + ' üõ£Ô∏è' + preset.stats.roadCount;
                html += '  </div>';
                html += '</div>';
            }
            
            listEl.innerHTML = html;
        }
        
        function activatePreset(index) {
            if (index < 0 || index >= savedPresets.length) return;
            
            activePresetIndex = index;
            var preset = savedPresets[index];
            
            // Update BlueprintAI to use this preset
            if (typeof BlueprintAI !== 'undefined') {
                BlueprintAI.currentPreset = preset;
                BlueprintAI.presetStep = 0;
            }
            
            // Update active preset display
            document.getElementById('bp-active-preset-name').innerHTML = preset.name;
            document.getElementById('bp-current-step').textContent = 'Ready: ' + preset.stats.totalActions + ' steps';
            document.getElementById('bp-clear-preset-btn').style.display = 'block';
            
            updatePresetUI();
            Controller.toast('‚úì Activated: ' + preset.name);
        }
        
        function clearActivePreset() {
            activePresetIndex = -1;
            
            // Clear BlueprintAI preset
            if (typeof BlueprintAI !== 'undefined') {
                BlueprintAI.currentPreset = null;
                BlueprintAI.presetStep = 0;
            }
            
            // Update UI
            document.getElementById('bp-active-preset-name').innerHTML = 'None (using default)';
            document.getElementById('bp-current-step').textContent = '-';
            document.getElementById('bp-clear-preset-btn').style.display = 'none';
            
            updatePresetUI();
            Controller.toast('Cleared active preset - using default AI');
        }
        
        function deletePreset(index) {
            if (index < 0 || index >= savedPresets.length) return;
            
            var preset = savedPresets[index];
            if (!confirm('Delete preset "' + preset.name + '"?')) return;
            
            savedPresets.splice(index, 1);
            if (activePresetIndex === index) {
                activePresetIndex = -1;
                if (typeof BlueprintAI !== 'undefined') {
                    BlueprintAI.currentPreset = null;
                }
            } else if (activePresetIndex > index) {
                activePresetIndex--;
            }
            
            savePresetsToStorage();
            updatePresetUI();
            Controller.toast('üóëÔ∏è Deleted preset');
        }
        
        function stopBlueprintAI() {
            var btn = document.getElementById('bp-start-btn');
            var statusEl = document.getElementById('bp-status');
            
            if (blueprintRunning) {
                blueprintRunning = false;
                if (blueprintInterval) {
                    clearInterval(blueprintInterval);
                    blueprintInterval = null;
                }
                if (btn) {
                    btn.innerHTML = '‚ñ∂Ô∏è Start AI';
                    btn.style.background = 'linear-gradient(135deg, #4CAF50, #2E7D32)';
                }
                if (statusEl) statusEl.textContent = 'Stopped';
                
                if (typeof BlueprintAI !== 'undefined') {
                    BlueprintAI.disable();
                }
            }
        }
        
        // Load presets on startup
        setTimeout(loadPresets, 100);
        
        // Hook into game building to record actions
        function recordBuildAction(type, x, y) {
            if (!presetRecording) return;
            
            // Store RELATIVE coordinates to settlement center for portability
            var settlementX = Game && Game.player ? Game.player.x : x;
            var settlementY = Game && Game.player ? Game.player.y : y;
            var relX = x - settlementX;
            var relY = y - settlementY;
            
            var action = {
                type: type,
                x: relX,  // Relative X offset from settlement
                y: relY,  // Relative Y offset from settlement
                absX: x,  // Original absolute (for debug)
                absY: y,
                timestamp: Date.now(),
                gameState: {
                    year: Game ? Game.year : 0,
                    pop: Game ? Game.pop : 0,
                    food: Game ? Game.food : 0,
                    wood: Game ? Game.wood : 0
                }
            };
            
            recordedActions.push(action);
            
            // Update recording status
            var statusEl = document.getElementById('bp-record-status');
            if (statusEl) {
                var counts = {};
                for (var i = 0; i < recordedActions.length; i++) {
                    var t = recordedActions[i].type;
                    counts[t] = (counts[t] || 0) + 1;
                }
                var summary = [];
                if (counts.WELL) summary.push('üíß' + counts.WELL);
                if (counts.RES) summary.push('üè†' + counts.RES);
                if (counts.COM) summary.push('üè™' + counts.COM);
                if (counts.IND) summary.push('üè≠' + counts.IND);
                if (counts.ROAD) summary.push('üõ£Ô∏è' + counts.ROAD);
                
                statusEl.innerHTML = '<span style="color:#FF4444;">‚è∫ RECORDING</span> - ' + recordedActions.length + ' actions: ' + summary.join(' ');
            }
        }
        
        /* ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
           ‚ïë                      CITGAME v48.0 - EVOLUTION SYSTEM              ‚ïë
           ‚ïë                   Historical City Building Simulator               ‚ïë
           ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
           
           CODE STRUCTURE:
           ===============
           1. CONFIG MODULE       - Game constants and configuration
           2. PROGRESSION MODULE  - Unlock system and advancement
           3. TERRAIN MODULE      - Perlin noise map generation
           4. ENTITIES MODULE     - Berries, nomads, animals, player
           5. GAME MODULE         - Core game logic, building, turns
           6. RENDERER MODULE     - Canvas drawing and visual effects
           7. CONTROLLER MODULE   - UI updates and input handling
           8. INITIALIZATION      - Game startup and event listeners
           
           NAVIGATION GUIDE:
           =================
           - Press Ctrl+F and search for "MODULE" to jump between sections
           - Each major function has a comment header explaining its purpose
           - Key systems: Building (line ~3200), AI (line ~2658), Rendering (line ~3600)
           
           BALANCE REFERENCE (see GAME_BALANCE.txt for full details):
           ============================================================
           Level 1 Cost: 100 Food + 100 Wood
           Level 1 Upkeep: 1 wood/year (occupied), 2 wood/year (empty)
           Level 1 Abandoned Timer: 5 years empty
           Animals: 1064 total (50% Deer, 35% Bison, 15% Mammoth)
           Nomads: 1200 total (83% friendly, 17% hostile)
           Inventory: 150 base + 100/nomad | Pocket: 1000 max
           Herd Danger: Adjacent animals cost 1-3 pop to kill
           
           WORKFORCE SYSTEM:
           =================
           Workers auto-assigned: Roads(1/5tiles) > Commercial(3) > Gathering
           Well: Serves 100 people water (no workers needed)
           Road: 1 worker per 5 tiles ‚Üí maintains desirability bonus
           Commercial: 3 workers ‚Üí operates the building
           Gatherers: 0.5 food/year per unassigned worker
        */

        // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        // ‚ïë MODULE 1: CONFIG - Game Configuration & Constants                 ‚ïë
        // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        // All game settings, costs, and balance values are defined here.
        // Modify these values to change game difficulty and behavior.
        // !! IMPORTANT: When changing values here, also update GAME_BALANCE.txt !!
        
        // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        // ‚ïë                    CITGAME v40.0 - MASTER CONFIGURATION                       ‚ïë
        // ‚ïë                                                                               ‚ïë
        // ‚ïë  This CFG object contains ALL game balance variables. When modifying game     ‚ïë
        // ‚ïë  mechanics, update values here and in GAME_BALANCE.txt for documentation.     ‚ïë
        // ‚ïë                                                                               ‚ïë
        // ‚ïë  EPOCH SYSTEM:                                                                ‚ïë
        // ‚ïë  - Epoch 0 (WANDER): Survival phase - explore, gather, recruit nomads         ‚ïë
        // ‚ïë  - Epoch 1 (PIT AGE): Subsistence phase - build settlements, manage labor     ‚ïë
        // ‚ïë  - Epoch 2 (TENTS): Advanced phase - commercial, granaries (LOCKED)           ‚ïë
        // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        
        const CFG = {
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // I. GLOBAL RULES (The Physics Engine)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // === MAP & RENDERING ===
            TILE: 48,           // Tile size in pixels - larger for detailed view
            W: 250,             // Map width in tiles (250x250 = 62,500 tiles)
            H: 250,             // Map height in tiles
            
            // === INVENTORY SYSTEM ===
            // Backpack: Holds Food & Wood, scales with population
            // Sack (Rare): Holds Stone & Metal, fixed capacity
            INVENTORY: {
                BACKPACK_BASE: 150,         // Starting backpack capacity
                BACKPACK_PER_POP: 100,      // Additional capacity per population
                SACK_CAPACITY: 1000,        // Fixed rare item storage (Stone & Metal)
                OVERFLOW_DELETE: true       // Overflow items are deleted instantly
            },
            
            // === VISUAL STATES ===
            // Buildings change appearance based on occupancy percentage
            // 0=Abandoned (0%, 10yrs), 1=Light (1-30%), 2=Medium (31-80%), 3=Extreme (81-100%)
            VISUAL_STATES: {
                ABANDONED_YEARS: 10,        // Years at 0 occupancy before abandoned
                LIGHT_MAX: 0.30,            // 1-30% occupancy
                MEDIUM_MAX: 0.80,           // 31-80% occupancy
                EXTREME_MIN: 0.81           // 81-100% occupancy
            },
            
            // === BULLDOZE MECHANIC ===
            BULLDOZE_REFUND: 0.10,          // 10% of construction cost returned
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // PRE-FIRE AGE BUILDING SYSTEM
            // Theme: First people who discovered fire, no boats yet
            // Structure: 3 Levels √ó 3 Density States for each zone type
            // Density affects: Income, Production, Appearance, Name
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            PRE_FIRE_AGE: {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RESIDENTIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Level 1: Low Density (Tree Houses)
                // Level 2: Medium Density (Ground Shelters)  
                // Level 3: High Density (Communal Structures)
                RESIDENTIAL: {
                    1: {
                        name: 'Tree Shelter',
                        description: 'Primitive shelter in the trees, safe from predators',
                        baseCost: { food: 100, wood: 100, stone: 0 },
                        baseCapacity: 5,
                        baseIncome: 1,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Attempted Treehouse', 
                                icon: 'üå≥',
                                popRange: [1, 2],
                                incomeMultiplier: 0.5,
                                description: 'A few branches tied together, barely shelter'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Treebranch House', 
                                icon: 'üèïÔ∏è',
                                popRange: [3, 4],
                                incomeMultiplier: 1.0,
                                description: 'Woven branches form a proper platform'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Sturdy Tree Nest', 
                                icon: 'üõñ',
                                popRange: [5, 5],
                                incomeMultiplier: 1.5,
                                description: 'A well-built elevated dwelling'
                            }
                        ]
                    },
                    2: {
                        name: 'Ground Pit',
                        description: 'Dug-out shelter with branch covering',
                        baseCost: { food: 300, wood: 300, stone: 50 },
                        baseCapacity: 15,
                        baseIncome: 3,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Shallow Scrape', 
                                icon: 'üï≥Ô∏è',
                                popRange: [1, 5],
                                incomeMultiplier: 0.5,
                                description: 'Just a depression in the ground'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Covered Pit', 
                                icon: 'üèöÔ∏è',
                                popRange: [6, 10],
                                incomeMultiplier: 1.0,
                                description: 'A proper pit with branch roof'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Pit Dwelling', 
                                icon: 'üè†',
                                popRange: [11, 15],
                                incomeMultiplier: 1.5,
                                description: 'Stone-lined pit with sturdy roof'
                            }
                        ]
                    },
                    3: {
                        name: 'Communal Lodge',
                        description: 'Large shared shelter for extended family groups',
                        baseCost: { food: 900, wood: 900, stone: 200 },
                        baseCapacity: 40,
                        baseIncome: 8,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Gathering Lean-To', 
                                icon: 'üèïÔ∏è',
                                popRange: [1, 15],
                                incomeMultiplier: 0.5,
                                description: 'Simple shared shelter'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Family Longhouse', 
                                icon: 'üõñ',
                                popRange: [16, 30],
                                incomeMultiplier: 1.0,
                                description: 'Multiple families under one roof'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Clan Lodge', 
                                icon: 'üèòÔ∏è',
                                popRange: [31, 40],
                                incomeMultiplier: 1.5,
                                description: 'Prosperous communal dwelling'
                            }
                        ]
                    }
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COMMERCIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Level 1: Low Density (Simple Trading)
                // Level 2: Medium Density (Established Trading)
                // Level 3: High Density (Trading Hub)
                COMMERCIAL: {
                    1: {
                        name: 'Pebble Trade Fire',
                        description: 'Simple fire pit for exchanging goods',
                        baseCost: { food: 200, wood: 200, stone: 0 },
                        baseProduction: 5,
                        baseWorkers: 2,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Cold Embers', 
                                icon: 'ü™®',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Cold stones mark an abandoned trade spot'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Pebble Trade Fire', 
                                icon: 'üî•',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Warm fire attracts traders'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Busy Trade Fire', 
                                icon: 'üéâ',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Bustling trade hub around the fire'
                            }
                        ]
                    },
                    2: {
                        name: 'Squirrel Trade Camp',
                        description: 'Camp where hunters trade squirrel pelts and goods',
                        baseCost: { food: 500, wood: 500, stone: 100 },
                        baseProduction: 15,
                        baseWorkers: 5,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Empty Camp', 
                                icon: 'üèïÔ∏è',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Abandoned trading camp'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Squirrel Trade Camp', 
                                icon: 'üêøÔ∏è',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Active camp with hunters and traders'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Busy Fur Camp', 
                                icon: 'ü¶∫',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Thriving fur trading hub'
                            }
                        ]
                    },
                    3: {
                        name: 'Fire Meet Camp',
                        description: 'Grand meeting camp where tribes gather to trade',
                        baseCost: { food: 1500, wood: 1500, stone: 500 },
                        baseProduction: 40,
                        baseWorkers: 12,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Cold Meeting Ground', 
                                icon: '‚ö´',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Empty fire circle'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Fire Meet Camp', 
                                icon: 'üî•',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Regular tribal gatherings'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Great Fire Gathering', 
                                icon: 'üèõÔ∏è',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Major tribal council and trade center'
                            }
                        ]
                    }
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INDUSTRIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Level 1: Low Density (Hunting)
                // Level 2: Medium Density (Gathering/Processing)
                // Level 3: High Density (Production)
                INDUSTRIAL: {
                    1: {
                        name: 'Bird Hunting Range',
                        description: 'Area for hunting small birds with rocks',
                        baseCost: { food: 200, wood: 200, stone: 0 },
                        baseProduction: 10,
                        baseWorkers: 3,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Sparse Hunting Path', 
                                icon: 'ü™∂',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Few birds, poor pickings'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Bird Hunting Range', 
                                icon: 'ü¶Ö',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Good hunting grounds'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Prime Fowling Grounds', 
                                icon: 'üéØ',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Rich bird population'
                            }
                        ]
                    },
                    2: {
                        name: 'Grub Digging Pit',
                        description: 'Digging area for insects, roots, and small prey',
                        baseCost: { food: 500, wood: 500, stone: 100 },
                        baseProduction: 25,
                        baseWorkers: 6,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Scratched Earth', 
                                icon: 'üï≥Ô∏è',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Barely productive soil'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Grub Digging Pit', 
                                icon: 'ü™±',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Reliable source of protein'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Bountiful Foraging Pit', 
                                icon: 'üçñ',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Rich in edible finds'
                            }
                        ]
                    },
                    3: {
                        name: 'Stone Knapping Site',
                        description: 'Area for making primitive tools from stone',
                        baseCost: { food: 1500, wood: 1500, stone: 500 },
                        baseProduction: 60,
                        baseWorkers: 15,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Scattered Flakes', 
                                icon: 'ü™®',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Abandoned tool-making spot'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Stone Knapping Site', 
                                icon: '‚öíÔ∏è',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Active tool production'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Master Flint Workshop', 
                                icon: 'üî®',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Expert tool crafting center'
                            }
                        ]
                    }
                }
            },
            
            // Helper function to get density state based on population/activity
            getDensityState(zoneType, level, fillPercent) {
                const config = this.PRE_FIRE_AGE[zoneType]?.[level];
                if (!config) return null;
                
                for (let i = config.densityStates.length - 1; i >= 0; i--) {
                    const state = config.densityStates[i];
                    const range = state.popRange || state.activityRange;
                    if (fillPercent >= range[0]) {
                        return { ...state, index: i };
                    }
                }
                return { ...config.densityStates[0], index: 0 };
            },
            
            // === PERFORMANCE OPTIMIZATION ===
            PERF: {
                SPATIAL_GRID_SIZE: 10,
                PARTICLE_POOL_SIZE: 100,
                ENABLE_OFFSCREEN_CACHE: true,
                DIRTY_RECT_RENDERING: true
            },
            
            // === TERRAIN & BUILDING COLORS - VICTORIAN MAP THEME ===
            COLORS: {
                // Terrain - Aged parchment & ink tones
                DEEP: "#4A6B8A", WATER: "#6B8FAD", RIVER: "#7FA0B8", SAND: "#D4C4A8", 
                GRASS: "#C9D4A0", FOREST: "#8B9A6B", EARTH: "#C4A882", ROCK: "#9A9A8A", SNOW: "#E8E8E0", 
                STONE: "#8A8A7A",
                // Building colors - Ink & wash tones
                ROAD: "#A89070", RES: "#C4946A", COM: "#B8A060", IND: "#8A7A6A", WELL: "#6A8A9A",
                BASKET: "#B89A70", POTTERY: "#A8906A", GRANARY: "#9A8A70", PALACE: "#D4B480", CHIEF: "#C4A070",
                CLAN_CHIEF: "#D4B060", DOCK: "#5A7A8A",
                // Map overlay colors
                PARCHMENT: "#E8DCC8", INK: "#3A3020", SEPIA: "#704020",
                // UI colors
                OK: "rgba(180,160,120,0.5)", NO: "rgba(160,80,60,0.85)"
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // II. EPOCH 0: THE WANDERER (Survival Phase)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // === MOVEMENT & EXPLORATION ===
            PLAYER: { 
                START_HEALTH: 3,            // Initial health (population = health in Epoch 0)
                VISION_RADIUS: 3            // Fog of war reveal radius
            },
            
            // === MOVEMENT FOOD COST ===
            // Walking costs food - 1 food per 15 tiles per population
            MOVEMENT: {
                STEPS_PER_FOOD: 15,         // Every 15 steps costs food
                FOOD_PER_PERSON: 1          // 1 food consumed per person per 15 steps
            },
            
            // === FOREST TILE ===
            // Passive step: +1 Wood (Scavenging)
            FOREST: {
                WOOD_PER_STEP: 1            // Wood gained when stepping on forest
            },
            
            // === OPEN GROUND ===
            // Passive step: 0.01% chance for rare find
            OPEN_GROUND: {
                RARE_FIND_CHANCE: 0.01,     // 1% chance per step
                METAL_CHANCE: 0.5,          // 50% metal, 50% stone if rare find
                FIND_AMOUNT: 1              // +1 Metal or +1 Stone
            },
            
            // === LORE EVENTS - Story mode messages for first-time events ===
            LORE_EVENTS: {
                GAME_START: {
                    title: 'The Dream',
                    text: 'Early man had a dream one night... a vision of something greater than mere survival. He saw his descendants building, thriving, creating. And so, with nothing but hope and hunger, he left his people and began to wander...',
                    illustration: 'wanderer'
                },
                FIRST_WELL: {
                    title: 'Fresh Water!',
                    text: 'Digging far enough revealed what the wise ones spoke of - underground rivers! Fresh water bubbled up from the earth. No longer would the tribe be slaves to rivers and lakes. Now they could make water appear wherever they chose!',
                    illustration: 'well'
                },
                FIRST_RESIDENTIAL: {
                    title: 'A Proper Shelter',
                    text: 'Now THIS is proper living! No more sleeping under stars with wolves howling. Four walls and a roof - what luxury! The tribe looked upon their creation with pride. "We are no longer wanderers," they declared. "We are SETTLERS."',
                    illustration: 'hut'
                },
                FIRST_HUNTING_GROUND: {
                    title: 'The Hunting Grounds',
                    text: 'The wise hunter knows: chase the deer, catch one meal. Let the deer come to you, catch a hundred! And so the first hunting ground was established - a place where prey would wander in, never to wander out.',
                    illustration: 'hunting'
                },
                FIRST_ROAD: {
                    title: 'The Beaten Path',
                    text: 'Why walk through thorns when you can walk on dirt? The tribe\'s smartest member (whose name has been lost to time, but was probably "Ook" or "Ug") packed down the earth to make travel easier. Revolutionary!',
                    illustration: 'road'
                },
                FIRST_KILL: {
                    title: 'The First Hunt',
                    text: 'Blood! Meat! VICTORY! The beast fell before the tribe\'s mighty hunter. Tonight they would feast, and tomorrow... they would hunt again. The way of the predator had begun.',
                    illustration: 'hunt_success'
                },
                FIRST_SETTLEMENT: {
                    title: 'A Settlement is Born',
                    text: 'No more wandering. No more running. This patch of earth... THIS belongs to us! The tribe drove stakes into the ground and declared themselves FOUNDERS. History was about to begin.',
                    illustration: 'settlement'
                },
                FIRST_STORAGE: {
                    title: 'The Storage Pit',
                    text: 'The brilliant idea came from watching squirrels hide nuts. "What if WE buried our food?" And lo, the storage pit was invented. Now surplus wouldn\'t rot in the sun - it would rot underground! Progress!',
                    illustration: 'storage'
                },
                FIRST_COMMERCIAL: {
                    title: 'Trading Post',
                    text: 'One day, Ook had three fish. Ug had three berries. Both wanted variety. After much grunting and gesturing, they discovered TRADE! The economy was born, and Ook\'s descendants would one day invent taxes.',
                    illustration: 'trading'
                },
                FIRST_NOMAD: {
                    title: 'A Stranger Approaches',
                    text: 'From the mist emerged another... a fellow wanderer! Heart pounding, spear raised, our ancestor faced a choice. Friend or foe? The stranger raised a hand in peace. Today, the tribe grows stronger.',
                    illustration: 'nomad'
                },
                FIRST_TURTLE: {
                    title: 'Beach Bounty',
                    text: 'Upon the sandy shores, a strange shelled creature waddled slowly. "What manner of rock moves on its own?" wondered the hunter. Turns out, it was delicious. The beach would never go hungry again.',
                    illustration: 'turtle'
                },
                FLOOD_WARNING: {
                    title: 'The Waters Rise',
                    text: 'The elders spoke of this - the great waters that swallow the land. "Build high," they warned. "The sea remembers, and the sea returns." Perhaps it was time to seek higher ground...',
                    illustration: 'flood'
                },
                FIRST_BERRY: {
                    title: 'The Berry Bush',
                    text: 'Red and plump, the berries glistened in the sun. The hungry wanderer reached out... Would they bring life or death? 90% of the time, it\'s fine! The other 10%... well, that\'s how we learned which ones NOT to eat.',
                    illustration: 'berry'
                }
            },
            
            // === BERRY BUSH ===
            BERRIES: { 
                SPAWN_COUNT: 400,           // Number of berry bushes on map
                FOOD_VALUE: 10,             // Food gained (90% chance)
                POISON_CHANCE: 0.10,        // 10% chance of poison
                POISON_DAMAGE: 1            // -1 Pop if poisoned
            },
            
            // === ANIMALS (Deer/Bison/Mammoth/Turtle) ===
            // Pack Logic: If touching another animal, -1 Pop
            // Wolves are separate entity type (always cost pop, fixed reward)
            ANIMALS: { 
                SPAWN_COUNT: 1064,          // Total animals on map (excluding wolves)
                PACK_DAMAGE: 1,             // -1 Pop if in pack (adjacent to another)
                TYPES: [
                    { name: 'DEER', hitToKill: 2, foodReward: [1, 30], popCost: 0, color: '#C89858', speed: 1, spawnRate: 0.45, terrain: ['GRASS', 'FOREST'] },
                    { name: 'BISON', hitToKill: 3, foodReward: [5, 30], popCost: 0, color: '#A06830', speed: 0.5, spawnRate: 0.30, terrain: ['GRASS', 'FOREST'] },
                    { name: 'MAMMOTH', hitToKill: 5, foodReward: [15, 30], popCost: 0, color: '#806040', speed: 0.3, spawnRate: 0.10, terrain: ['GRASS', 'FOREST'] },
                    { name: 'TURTLE', hitToKill: 1, foodReward: [3, 15], popCost: 0, color: '#4A7A4A', speed: 0.1, spawnRate: 0.15, terrain: ['SAND'] }
                ],
                BEACH_SPAWN_COUNT: 150      // Extra turtles spawned only on beaches
            },
            
            // === NOMADS ===
            // 84% Friendly: +1 Pop, +Map Reveal, Loot
            // 16% Hostile: Ambush (-1 to -3 Pop)
            NOMAD: { 
                SPAWN_COUNT: 1500,          // Total nomads on map (increased)
                HOSTILE_CHANCE: 0.33,       // 33% hostile (increased)
                FRIENDLY_POP_BONUS: 1,      // +1 Pop from friendly
                HOSTILE_DAMAGE: [1, 3],     // -1 to -3 Pop from hostile
                LOOT_RANGES: {              // Loot from friendly nomads
                    FOOD: [5, 30],
                    WOOD: [5, 30],
                    METAL: [0, 10],
                    STONE: [0, 5]           // No stone loot per spec (0-10 metal only)
                }
            },
            
            // === SETTLEMENT TRANSITION REQUIREMENTS ===
            // To unlock "Found Settlement" button (Epoch 0 ‚Üí Epoch 1)
            SETTLEMENT_REQUIREMENTS: {
                MIN_POP: 2,                 // Population >= 2 (player + 1 nomad)
                MIN_FOOD: 100,              // Food >= 100
                MIN_WOOD: 25,               // Wood >= 25 (lowered to allow quick start)
                WATER_DISTANCE: 5           // Must be <= 5 tiles from fresh water
            },
            
            // === SETTLEMENT BONUSES (for recruiting before settling) ===
            SETTLEMENT_BONUS: {
                THRESHOLD_50: 0.10,         // 50 people = +10% inventory bonus
                THRESHOLD_100: 0.20,        // 100 people = +20%
                THRESHOLD_150: 0.30,        // 150 people = +30%
                THRESHOLD_200: 0.40         // 200 people = +40% (max)
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // III. EPOCH 1: THE PIT AGE (Subsistence Phase)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // === BUILDING COSTS (Construction) ===
            BUILDING_COSTS: {
                MUD_PIT: { food: 100, wood: 100, stone: 0 },
                DIRT_ROAD: { food: 5, wood: 5, stone: 0 },
                WATER_WELL: { food: 50, wood: 200, stone: 5 },
                HUNTING_GROUND: { food: 500, wood: 100, stone: 0 }
            },
            
            // === BUILDING UPKEEP (Per Year) ===
            BUILDING_UPKEEP: {
                MUD_PIT: { wood: 1 },
                DIRT_ROAD: { wood: 0 },
                WATER_WELL: { wood: 0 },
                HUNTING_GROUND: { wood: 5 }
            },
            
            // === BUILDING LABOR COSTS (Workers) ===
            BUILDING_LABOR: {
                MUD_PIT: 0,                 // No workers needed
                DIRT_ROAD: 1,               // 1 worker per road tile
                WATER_WELL: 0,              // No workers needed - wells work automatically
                HUNTING_GROUND_MIN: 20,     // Minimum 20 workers
                HUNTING_GROUND_MAX: 100     // Maximum 100 workers
            },
            
            // === BUILDING CAPACITIES & STATS ===
            BUILDING_STATS: {
                MUD_PIT: {
                    capacity: 20,           // Max 20 people per Mud Pit
                    efficiency: 0.50,       // 50% efficiency (high consumption)
                    growth_light: 0.01,     // +1% growth at light occupancy
                    growth_extreme: 0.05    // +5% growth at extreme occupancy
                },
                WATER_WELL: {
                    capacity: 500           // Each well serves 500 people
                },
                HUNTING_GROUND: {
                    range_walk: 7,          // Range without roads
                    range_road: 17,         // Range with roads (doubles + 3)
                    unlock_residences: 20,  // OR 20 residences built
                    unlock_pop: 100         // OR 100 population
                }
            },
            
            // === DIRT ROAD EFFECT ===
            ROAD: {
                MOVEMENT_MULTIPLIER: 2      // Doubles movement range for services
            },
            
            // === LOCKED BUILDINGS (Epoch 2+) ===
            LOCKED_EPOCH1: ['COMMERCIAL', 'GRANARY'],
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // IV. EPOCH 1: THREATS & CRISES (The Math of Death)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            CRISES: {
                // STARVATION: Food < 0
                STARVATION: {
                    trigger: 'FOOD_NEGATIVE',
                    death_rate: 0.20        // Instant loss of 20% Population
                },
                
                // THIRST: Pop > (Wells * 100)
                THIRST: {
                    trigger: 'INSUFFICIENT_WATER',
                    death_rate: 0.10        // Instant loss of 10% Population
                },
                
                // LABOR COLLAPSE: Workers Needed > Pop
                LABOR_COLLAPSE: {
                    trigger: 'INSUFFICIENT_LABOR',
                    effect: 'SHUTDOWN'      // Roads lose bonus, Wells stop
                },
                
                // ABANDONMENT: Occupancy == 0 for 10 years
                ABANDONMENT: {
                    trigger: 'EMPTY_10_YEARS',
                    upkeep_multiplier: 2    // Double upkeep or repair cost
                },
                
                // ROT: Food > Storage Cap
                ROT: {
                    trigger: 'OVER_STORAGE',
                    spoilage_rate: 0.30     // Lose 30% of surplus food per year
                },
                
                // OVERPOPULATION: Pop > Housing Cap
                OVERPOPULATION: {
                    trigger: 'OVER_HOUSING',
                    theft_rate: 0.05,       // Homeless steal 5% of food
                    plague_kill: 0.30       // Plague kills 30% of total Pop
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // V. EPOCH 2 TRANSITION REQUIREMENTS (The Boss Fight)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            EPOCH2_REQUIREMENTS: {
                POPULATION: 500,            // 500+ people
                INDUSTRY: 10,               // 10 Hunting Grounds built
                FOOD: 20000,                // 20,000 food stockpile
                WOOD: 10000,                // 10,000 wood stockpile
                STONE: 100,                 // 100 stone (scavenged)
                METAL: 100                  // 100 metal (scavenged)
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // LEGACY CONFIGURATION (For backward compatibility)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            COST: { RES:100, COM:250, IND:500, WELL:50, BULL:1, ROAD:5 },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // BUILDING DATABASE - Unified data-driven building system
            // All buildings defined in one place for easy expansion
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // === LEVEL 1 RESIDENTIAL GATHERING RATES (per your docs) ===
            LEVEL_1_GATHER: {
                HOMELESS: { food: 3, wood: 3, stone: 0, metal: 0 },
                MUD_PIT: { food: 6, wood: 6, stone: 0, metal: 0 },      // 3 base + 3 bonus
                STRAW_PIT: { food: 7, wood: 7, stone: 0, metal: 0 },    // Mud + 1
                LARGE_STRAW_PIT: { food: 8, wood: 8, stonePerPerson: 1, metalPerPerson: 1 }  // Mud + 2 + per person bonus
            },
            
            // === LEVEL 1 ZONE COSTS ===
            LEVEL_1_COSTS: {
                PATH: 5,                                                // $5 per path
                COMMERCIAL: { wood: 200, food: 200 },                   // Pebble Trade Fire
                INDUSTRIAL: { wood: 200, food: 200 }                    // Hunting Grounds
            },
            
            // === LEVEL 2 ZONE COSTS ===
            LEVEL_2_COSTS: {
                RESIDENTIAL: { wood: 10000, food: 10000 },              // Grub Class
                COMMERCIAL: { wood: 10000, food: 10000 },               // Fire Pit
                INDUSTRIAL: { wood: 10000, food: 10000 },               // Water Industry
                DOCK: { wood: 100000, food: 10000 }                     // One-time special structure
            },
            
            // === LEVEL 2 PROGRESSION ===
            LEVEL_2_REQ: {
                POP: 2000,
                DOCK_BONUS: 0.05                                        // +5% output when connected
            },
            
            // === LEVEL 3 PROGRESSION ===
            LEVEL_3_REQ: {
                POP: 10000,
                MINE_COST: { wood: 1000000, food: 1000000 }
            },
            
            // === OVERPOPULATION PENALTY ===
            OVERPOP: {
                YEARS_BEFORE_PENALTY: 10,
                FIRST_PENALTY: 0.50,                                    // -50% after 10 years
                MAX_PENALTY: 0.80,                                      // Up to -80%
                MIN_POPULATION: 3                                       // Never below 3
            },
            
            // === ABANDONMENT ===
            ABANDON: {
                ZONE_YEARS: 20,                                         // Zone disappears after 20 years empty
                HOMELESS_DEATH_YEARS: 5                                 // Homeless die after 5 years
            },
            
            BUILDING_DB: {
                /*
                ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                UNIVERSAL UNLOCK SYSTEM - Reference Guide
                ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                Each building can have an `unlockReq` object with ANY combination of:
                
                ‚Ä¢ pop: number              ‚Üí Minimum population (e.g., pop: 5000)
                ‚Ä¢ resources: { res: n }    ‚Üí Must have X resource in stock
                                             (e.g., resources: { wood: 500, stone: 200 })
                ‚Ä¢ buildings: { ... }       ‚Üí Must have built specific buildings:
                    - type + level + count ‚Üí { type: 'IND', level: 2, count: 5 }
                    - type + count         ‚Üí { type: 'COM', count: 3 }
                    - category + count     ‚Üí { category: 'RESIDENTIAL', count: 10 }
                    - id + count           ‚Üí { id: 'WELL', count: 1 }
                    - Array for multiple   ‚Üí [{ type: 'IND', count: 2 }, { type: 'COM', count: 1 }]
                ‚Ä¢ year: number             ‚Üí Must reach Year X
                ‚Ä¢ level: number            ‚Üí Must be at Civilization Level X
                ‚Ä¢ tech: string[]           ‚Üí Must have researched technologies (future)
                ‚Ä¢ achievements: string[]   ‚Üí Must have earned achievements (future)
                
                EXAMPLES:
                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                // Simple: just population
                unlockReq: { pop: 2000 }
                
                // Medium: population + resources
                unlockReq: { pop: 5000, resources: { wood: 1000, stone: 500 } }
                
                // Complex: pop + resources + buildings
                unlockReq: { 
                    pop: 10000, 
                    resources: { food: 5000 },
                    buildings: { type: 'IND', level: 2, count: 3 }
                }
                
                // Multi-building gate
                unlockReq: {
                    pop: 50000,
                    buildings: [
                        { type: 'IND', level: 3, count: 2 },
                        { type: 'COM', level: 2, count: 5 }
                    ]
                }
                ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                */
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RESIDENTIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Pre-Fire Age Theme: First people who just discovered fire
                // 3 Levels √ó 3 Density States (Low/Medium/High income based on population)
                // Lifespan: Low=20yr, Medium=+5% (21yr), High=+10% (22yr)
                // Overcrowding: +5 extra pop allowed, but if full >1 year, lose population
                'RES_1': {
                    id: 'RES_1', category: 'RESIDENTIAL', level: 1, name: 'Tree Shelter',
                    cost: { food: 100, wood: 100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 15, overflowCapacity: 20,
                    upkeep: { wood: 1, food: 1 },
                    baseIncome: 1,
                    baseLifespan: 20, // years
                    // Density states: population determines income class and lifespan bonus
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Nest', icon: 'ü™π', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 5, name: 'Small Nest', icon: 'ü™∫', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 6, max: 10, name: 'Tree Platform', icon: 'üå≥', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 11, max: 15, name: 'Sturdy Treehouse', icon: 'üèïÔ∏è', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 2 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 2 }
                    ],
                    variants: [
                        { name: 'Abandoned Nest', icon: 'ü™π', bonusMult: 0 },
                        { name: 'Small Nest', icon: 'ü™∫', bonusMult: 0.5 },
                        { name: 'Tree Platform', icon: 'üå≥', bonusMult: 1.0 },
                        { name: 'Sturdy Treehouse', icon: 'üèïÔ∏è', bonusMult: 1.5 }
                    ],
                    unlockReq: { pop: 0 } // Always available with resources
                },
                'RES_2': {
                    id: 'RES_2', category: 'RESIDENTIAL', level: 2, name: 'Ground Pit',
                    cost: { food: 300, wood: 300, stone: 50, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 25, overflowCapacity: 30,
                    upkeep: { wood: 2, food: 2 },
                    baseIncome: 3,
                    baseLifespan: 20,
                    // Density states: population determines income class
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Collapsed Pit', icon: 'üï≥Ô∏è', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 8, name: 'Shallow Scrape', icon: '‚¨õ', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 9, max: 17, name: 'Dug Pit', icon: 'üü´', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 18, max: 25, name: 'Covered Pit Dwelling', icon: 'üè†', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 1 }
                    ],
                    variants: [
                        { name: 'Collapsed Pit', icon: 'üï≥Ô∏è', bonusMult: 0 },
                        { name: 'Shallow Scrape', icon: '‚¨õ', bonusMult: 0.5 },
                        { name: 'Dug Pit', icon: 'üü´', bonusMult: 1.0 },
                        { name: 'Covered Pit Dwelling', icon: 'üè†', bonusMult: 1.5 }
                    ],
                    unlockReq: { pop: 50 }
                },
                'RES_3': {
                    id: 'RES_3', category: 'RESIDENTIAL', level: 3, name: 'Ground Cave',
                    cost: { food: 900, wood: 900, stone: 200, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 60, overflowCapacity: 65,
                    upkeep: { wood: 3, food: 3 },
                    baseIncome: 8,
                    baseLifespan: 20,
                    // Density states: population determines income class
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Collapsed Cave', icon: 'ü™®', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 20, name: 'Small Cave', icon: 'üï≥Ô∏è', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 21, max: 40, name: 'Deep Cave', icon: '‚õ∞Ô∏è', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 41, max: 60, name: 'Cave Complex', icon: 'üèîÔ∏è', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 12 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 12 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 1 }
                    ],
                    variants: [
                        { name: 'Collapsed Cave', icon: 'ü™®', bonusMult: 0 },
                        { name: 'Small Cave', icon: 'üï≥Ô∏è', bonusMult: 0.5 },
                        { name: 'Deep Cave', icon: '‚õ∞Ô∏è', bonusMult: 1.0 },
                        { name: 'Cave Complex', icon: 'üèîÔ∏è', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        pop: 200, 
                        buildings: { type: 'COM', level: 1, count: 2 } 
                    }
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RESIDENTIAL LEVEL 4-6 (Clan Chief Unlocked) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Post-Clan Chief Era: Native American themed buildings
                // Requires Clan Chief's Hut to unlock
                'RES_4': {
                    id: 'RES_4', category: 'RESIDENTIAL', level: 4, name: 'Tipi Village',
                    cost: { food: 2000, wood: 2000, stone: 40, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50, overflowCapacity: 55,
                    upkeep: { wood: 4, food: 4 },
                    baseIncome: 16,
                    baseLifespan: 25,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Tipis', icon: '‚õ∫', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 16, name: 'Small Camp', icon: '‚õ∫', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 17, max: 33, name: 'Tipi Circle', icon: 'üèïÔ∏è', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 2 },
                        { min: 34, max: 50, name: 'Tipi Village', icon: 'üé™', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 4 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 50 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 5 }
                    ],
                    variants: [
                        { name: 'Abandoned Tipis', icon: '‚õ∫', bonusMult: 0 },
                        { name: 'Small Camp', icon: '‚õ∫', bonusMult: 0.5 },
                        { name: 'Tipi Circle', icon: 'üèïÔ∏è', bonusMult: 1.0 },
                        { name: 'Tipi Village', icon: 'üé™', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'RES_5': {
                    id: 'RES_5', category: 'RESIDENTIAL', level: 5, name: 'Log Longhouse',
                    cost: { food: 8000, wood: 8000, stone: 80, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 120, overflowCapacity: 130,
                    upkeep: { wood: 6, food: 6 },
                    baseIncome: 32,
                    baseLifespan: 30,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Ruined Longhouse', icon: 'üèöÔ∏è', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 40, name: 'Small Longhouse', icon: 'üè†', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 41, max: 80, name: 'Family Longhouse', icon: 'üè°', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 3 },
                        { min: 81, max: 120, name: 'Clan Longhouse', icon: 'üèòÔ∏è', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 5 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 }
                    ],
                    variants: [
                        { name: 'Ruined Longhouse', icon: 'üèöÔ∏è', bonusMult: 0 },
                        { name: 'Small Longhouse', icon: 'üè†', bonusMult: 0.5 },
                        { name: 'Family Longhouse', icon: 'üè°', bonusMult: 1.0 },
                        { name: 'Clan Longhouse', icon: 'üèòÔ∏è', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'RES_6': {
                    id: 'RES_6', category: 'RESIDENTIAL', level: 6, name: 'Old Growth Log Compound',
                    cost: { food: 20000, wood: 20000, stone: 100, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 240, overflowCapacity: 260,
                    upkeep: { wood: 10, food: 10 },
                    baseIncome: 64,
                    baseLifespan: 35,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Compound', icon: 'üèöÔ∏è', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 80, name: 'Small Compound', icon: 'üèòÔ∏è', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 81, max: 160, name: 'Growing Compound', icon: 'üè∞', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 4 },
                        { min: 161, max: 240, name: 'Grand Log Compound', icon: 'üèØ', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 7 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 240 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 80 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 80 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 6 }
                    ],
                    variants: [
                        { name: 'Abandoned Compound', icon: 'üèöÔ∏è', bonusMult: 0 },
                        { name: 'Small Compound', icon: 'üèòÔ∏è', bonusMult: 0.5 },
                        { name: 'Growing Compound', icon: 'üè∞', bonusMult: 1.0 },
                        { name: 'Grand Log Compound', icon: 'üèØ', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INDUSTRIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Pre-Fire Age Theme: First people who discovered fire
                // 3 Levels √ó 3 Density States (activity level affects production)
                'IND_1': {
                    id: 'IND_1', category: 'INDUSTRIAL', level: 1, name: 'Bird Hunting Range',
                    cost: { food: 200, wood: 200, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 10,
                    baseProduction: 10,
                    upkeep: { wood: 1, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 5 },
                        { type: 'DESIRABILITY', radius: 3, value: 0.1 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Range', icon: 'ü™∂', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Hunting Path', icon: 'ü™∂', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bird Hunting Range', icon: 'ü¶Ö', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Prime Fowling Grounds', icon: 'üéØ', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Range', icon: 'ü™∂', bonusMult: 0 },
                        { name: 'Sparse Hunting Path', icon: 'ü™∂', bonusMult: 0.5 },
                        { name: 'Bird Hunting Range', icon: 'ü¶Ö', bonusMult: 1.0 },
                        { name: 'Prime Fowling Grounds', icon: 'üéØ', bonusMult: 1.5 }
                    ],
                    popUnlock: 2
                },
                'IND_2': {
                    id: 'IND_2', category: 'INDUSTRIAL', level: 2, name: 'Grub Digging Pit',
                    cost: { food: 500, wood: 500, stone: 100, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 25,
                    baseProduction: 25,
                    upkeep: { wood: 2, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 2 },
                        { type: 'DESIRABILITY', radius: 3, value: 0.1 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Filled Hole', icon: 'üï≥Ô∏è', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Scratched Earth', icon: 'üï≥Ô∏è', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Grub Digging Pit', icon: 'ü™±', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Bountiful Foraging Pit', icon: 'üçñ', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Filled Hole', icon: 'üï≥Ô∏è', bonusMult: 0 },
                        { name: 'Scratched Earth', icon: 'üï≥Ô∏è', bonusMult: 0.5 },
                        { name: 'Grub Digging Pit', icon: 'ü™±', bonusMult: 1.0 },
                        { name: 'Bountiful Foraging Pit', icon: 'üçñ', bonusMult: 1.5 }
                    ],
                    popUnlock: 50
                },
                'IND_3': {
                    id: 'IND_3', category: 'INDUSTRIAL', level: 3, name: 'Stone Knapping Site',
                    cost: { food: 1500, wood: 1500, stone: 500, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 60,
                    baseProduction: 60,
                    upkeep: { wood: 3, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.15 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Site', icon: 'ü™®', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Scattered Flakes', icon: 'ü™®', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Stone Knapping Site', icon: '‚öíÔ∏è', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Master Flint Workshop', icon: 'üî®', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Site', icon: 'ü™®', bonusMult: 0 },
                        { name: 'Scattered Flakes', icon: 'ü™®', bonusMult: 0.5 },
                        { name: 'Stone Knapping Site', icon: '‚öíÔ∏è', bonusMult: 1.0 },
                        { name: 'Master Flint Workshop', icon: 'üî®', bonusMult: 1.5 }
                    ],
                    popUnlock: 200
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INDUSTRIAL LEVEL 4-6 (Clan Chief Unlocked) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Post-Clan Chief Era: Advanced hunting and resource extraction
                'IND_4': {
                    id: 'IND_4', category: 'INDUSTRIAL', level: 4, name: 'Turtle Hunting Ground',
                    cost: { food: 2400, wood: 2400, stone: 48, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20,
                    baseProduction: 50,
                    upkeep: { wood: 4, food: 2 },
                    benefits: [
                        { type: 'JOBS', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 30 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 15 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.2 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Grounds', icon: 'üê¢', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Hunting', icon: 'üê¢', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Turtle Hunting Ground', icon: 'üéØ', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Prime Turtle Territory', icon: 'üèÜ', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Grounds', icon: 'üê¢', bonusMult: 0 },
                        { name: 'Sparse Hunting', icon: 'üê¢', bonusMult: 0.5 },
                        { name: 'Turtle Hunting Ground', icon: 'üéØ', bonusMult: 1.0 },
                        { name: 'Prime Turtle Territory', icon: 'üèÜ', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'IND_5': {
                    id: 'IND_5', category: 'INDUSTRIAL', level: 5, name: 'Bear Pit',
                    cost: { food: 9600, wood: 9600, stone: 96, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50,
                    baseProduction: 120,
                    upkeep: { wood: 6, food: 3 },
                    benefits: [
                        { type: 'JOBS', value: 50 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 8 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.25 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Pit', icon: 'üêª', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Small Bear Trap', icon: 'üêª', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bear Pit', icon: '‚öîÔ∏è', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Bear Hunting Ground', icon: 'üèπ', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Pit', icon: 'üêª', bonusMult: 0 },
                        { name: 'Small Bear Trap', icon: 'üêª', bonusMult: 0.5 },
                        { name: 'Bear Pit', icon: '‚öîÔ∏è', bonusMult: 1.0 },
                        { name: 'Great Bear Hunting Ground', icon: 'üèπ', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'IND_6': {
                    id: 'IND_6', category: 'INDUSTRIAL', level: 6, name: 'Buffalo Grounds',
                    cost: { food: 24000, wood: 24000, stone: 120, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 120,
                    baseProduction: 240,
                    upkeep: { wood: 10, food: 5 },
                    benefits: [
                        { type: 'JOBS', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 15 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.3 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Plains', icon: 'ü¶¨', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Herd Grounds', icon: 'ü¶¨', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Buffalo Grounds', icon: 'üèπ', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Buffalo Hunt', icon: '‚ö°', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Plains', icon: 'ü¶¨', bonusMult: 0 },
                        { name: 'Sparse Herd Grounds', icon: 'ü¶¨', bonusMult: 0.5 },
                        { name: 'Buffalo Grounds', icon: 'üèπ', bonusMult: 1.0 },
                        { name: 'Great Buffalo Hunt', icon: '‚ö°', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COMMERCIAL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Pre-Fire Age Theme: First people who discovered fire
                // 3 Levels √ó 3 Density States (activity level affects income)
                'COM_1': {
                    id: 'COM_1', category: 'COMMERCIAL', level: 1, name: 'Pebble Trade Fire',
                    cost: { food: 150, wood: 150, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 8,
                    baseIncome: 5,
                    upkeep: { wood: 1, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 8 },
                        { type: 'INCOME', value: 5 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.2 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Cold Embers', icon: '‚¨õ', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Pebble Trade Fire', icon: 'üî•', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Pebble Trade Fire', icon: 'üî•', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Busy Trade Fire', icon: 'üî•', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Cold Embers', icon: '‚¨õ', bonusMult: 0 },
                        { name: 'Pebble Trade Fire', icon: 'üî•', bonusMult: 0.5 },
                        { name: 'Pebble Trade Fire', icon: 'üî•', bonusMult: 1.0 },
                        { name: 'Busy Trade Fire', icon: 'üî•', bonusMult: 1.5 }
                    ],
                    popUnlock: 10
                },
                'COM_2': {
                    id: 'COM_2', category: 'COMMERCIAL', level: 2, name: 'Squirrel Trade Camp',
                    cost: { food: 400, wood: 400, stone: 50, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20,
                    baseIncome: 15,
                    upkeep: { wood: 2, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 20 },
                        { type: 'INCOME', value: 15 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.3 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Camp', icon: 'üèïÔ∏è', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Squirrel Trade Camp', icon: 'üêøÔ∏è', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Squirrel Trade Camp', icon: 'üêøÔ∏è', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Busy Fur Camp', icon: 'üêøÔ∏è', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Camp', icon: 'üèïÔ∏è', bonusMult: 0 },
                        { name: 'Squirrel Trade Camp', icon: 'üêøÔ∏è', bonusMult: 0.5 },
                        { name: 'Squirrel Trade Camp', icon: 'üêøÔ∏è', bonusMult: 1.0 },
                        { name: 'Busy Fur Camp', icon: 'üêøÔ∏è', bonusMult: 1.5 }
                    ],
                    popUnlock: 40
                },
                'COM_3': {
                    id: 'COM_3', category: 'COMMERCIAL', level: 3, name: 'Fire Meet Camp',
                    cost: { food: 1200, wood: 1200, stone: 200, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50,
                    baseIncome: 40,
                    upkeep: { wood: 3, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 50 },
                        { type: 'INCOME', value: 40 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.4 },
                        { type: 'CULTURE', value: 5 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Cold Meeting Ground', icon: '‚≠ï', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Fire Meet Camp', icon: 'üèïÔ∏è', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Fire Meet Camp', icon: 'üî•', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Fire Gathering', icon: 'üéÜ', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Cold Meeting Ground', icon: '‚≠ï', bonusMult: 0 },
                        { name: 'Fire Meet Camp', icon: 'üèïÔ∏è', bonusMult: 0.5 },
                        { name: 'Fire Meet Camp', icon: 'üî•', bonusMult: 1.0 },
                        { name: 'Great Fire Gathering', icon: 'üéÜ', bonusMult: 1.5 }
                    ],
                    popUnlock: 150
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COMMERCIAL LEVEL 4-6 (Clan Chief Unlocked) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Post-Clan Chief Era: Advanced trading and marketplaces
                'COM_4': {
                    id: 'COM_4', category: 'COMMERCIAL', level: 4, name: 'Barter Barrel',
                    cost: { food: 1600, wood: 1600, stone: 32, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 16,
                    baseIncome: 80,
                    upkeep: { wood: 4, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 16 },
                        { type: 'INCOME', value: 80 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.35 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Barrel', icon: 'ü™£', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Goods', icon: 'ü™£', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Barter Barrel', icon: 'üõ¢Ô∏è', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Bustling Trade Post', icon: 'üí∞', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Barrel', icon: 'ü™£', bonusMult: 0 },
                        { name: 'Sparse Goods', icon: 'ü™£', bonusMult: 0.5 },
                        { name: 'Barter Barrel', icon: 'üõ¢Ô∏è', bonusMult: 1.0 },
                        { name: 'Bustling Trade Post', icon: 'üí∞', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'COM_5': {
                    id: 'COM_5', category: 'COMMERCIAL', level: 5, name: 'Blanket Market',
                    cost: { food: 6400, wood: 6400, stone: 64, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 40,
                    baseIncome: 160,
                    upkeep: { wood: 6, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 40 },
                        { type: 'INCOME', value: 160 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.45 },
                        { type: 'CULTURE', value: 8 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Market', icon: 'üß∫', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Few Blankets', icon: 'üß∫', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Blanket Market', icon: 'üõçÔ∏è', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Grand Market Fair', icon: 'üé™', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Market', icon: 'üß∫', bonusMult: 0 },
                        { name: 'Few Blankets', icon: 'üß∫', bonusMult: 0.5 },
                        { name: 'Blanket Market', icon: 'üõçÔ∏è', bonusMult: 1.0 },
                        { name: 'Grand Market Fair', icon: 'üé™', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'COM_6': {
                    id: 'COM_6', category: 'COMMERCIAL', level: 6, name: 'Bear Market',
                    cost: { food: 16000, wood: 16000, stone: 80, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 100,
                    baseIncome: 320,
                    upkeep: { wood: 10, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 100 },
                        { type: 'INCOME', value: 320 },
                        { type: 'DESIRABILITY', radius: 7, value: 0.55 },
                        { type: 'CULTURE', value: 15 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Market', icon: 'üêª', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Quiet Trading', icon: 'üêª', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bear Market', icon: 'üè™', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Bear Exchange', icon: 'üèõÔ∏è', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Market', icon: 'üêª', bonusMult: 0 },
                        { name: 'Quiet Trading', icon: 'üêª', bonusMult: 0.5 },
                        { name: 'Bear Market', icon: 'üè™', bonusMult: 1.0 },
                        { name: 'Great Bear Exchange', icon: 'üèõÔ∏è', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INFRASTRUCTURE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                'WELL': {
                    id: 'WELL', category: 'INFRASTRUCTURE', level: 1, name: 'Water Well',
                    cost: { food: 50, wood: 200, stone: 5, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'WATER', value: 100 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Dry Well', icon: 'üï≥Ô∏è', bonusMult: 0 },
                        { name: 'Water Well', icon: 'üíß', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                },
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê MILESTONE BUILDINGS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // These are major progression gates that unlock new building tiers
                'CLAN_CHIEF': {
                    id: 'CLAN_CHIEF', category: 'MILESTONE', level: 1, name: "Clan Chief's Hut",
                    description: "The seat of power for your clan. Building this unlocks Level 4-6 buildings.",
                    cost: { food: 100000, wood: 100000, stone: 0, metal: 0, gold: 1 },
                    size: { w: 2, h: 2 }, capacity: 0,
                    upkeep: { wood: 5, food: 5 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 50, value: 2.0 },
                        { type: 'CULTURE', value: 25 },
                        { type: 'UNLOCK_TIER', value: 4 }
                    ],
                    variants: [
                        { name: "Clan Chief's Hut", icon: 'üèõÔ∏è', bonusMult: 1.0 }
                    ],
                    popUnlock: 0,
                    unlockReq: {
                        pop: 500,
                        resources: { food: 100000, wood: 100000, gold: 1 }
                    }
                },
                'DOCK': {
                    id: 'DOCK', category: 'MILESTONE', level: 2, name: "First Dock",
                    description: "The first dock for river trade. Building this unlocks Level 7+ buildings.",
                    cost: { food: 500000, wood: 500000, stone: 0, metal: 0, gold: 5 },
                    size: { w: 3, h: 2 }, capacity: 0,
                    upkeep: { wood: 15, food: 10 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 60, value: 3.0 },
                        { type: 'CULTURE', value: 50 },
                        { type: 'INCOME', value: 500 },
                        { type: 'UNLOCK_TIER', value: 7 }
                    ],
                    variants: [
                        { name: "First Dock", icon: '‚öì', bonusMult: 1.0 }
                    ],
                    popUnlock: 0,
                    unlockReq: {
                        pop: 2000,
                        buildings: { id: 'CLAN_CHIEF', count: 1 },
                        resources: { food: 500000, wood: 500000, gold: 5 }
                    }
                },
                // Legacy CHIEF for backward compatibility
                'CHIEF': {
                    id: 'CHIEF', category: 'SPECIAL', level: 1, name: "First Chief's Hut",
                    cost: { food: 10000, wood: 0, stone: 0, metal: 0 },
                    size: { w: 2, h: 2 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 50, value: 2.0 },
                        { type: 'CULTURE', value: 10 }
                    ],
                    variants: [
                        { name: "First Chief's Hut", icon: 'üèõÔ∏è', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                }
            },
            
            // Gold exchange rate: 5000 metal = 1 gold
            GOLD_EXCHANGE_RATE: 5000,
            
            // Category groupings for menus
            BUILDING_CATEGORIES: {
                RESIDENTIAL: ['RES_1', 'RES_2', 'RES_3', 'RES_4', 'RES_5', 'RES_6'],
                INDUSTRIAL: ['IND_1', 'IND_2', 'IND_3', 'IND_4', 'IND_5', 'IND_6'],
                COMMERCIAL: ['COM_1', 'COM_2', 'COM_3', 'COM_4', 'COM_5', 'COM_6'],
                INFRASTRUCTURE: ['WELL'],
                MILESTONE: ['CLAN_CHIEF', 'DOCK'],
                SPECIAL: ['CHIEF']
            },
            
            // Helper to get building by ID
            getBuilding(id) {
                return this.BUILDING_DB[id] || null;
            },
            
            // Helper to get buildings by category
            getBuildingsByCategory(category) {
                let ids = this.BUILDING_CATEGORIES[category] || [];
                return ids.map(id => this.BUILDING_DB[id]).filter(b => b);
            },
            
            // BACKWARD COMPATIBILITY: Map level number to BUILDING_DB entry
            // Returns building in OLD format for compatibility with existing code
            getResidentialByLevel(level) {
                let building = this.BUILDING_DB['RES_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            getIndustrialByLevel(level) {
                let building = this.BUILDING_DB['IND_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            // Helper to extract gatherBonus from benefits array
            _extractGatherBonus(building) {
                let bonus = { wood: 0, food: 0, stone: 0, metal: 0 };
                if(!building.benefits) return bonus;
                for(let b of building.benefits) {
                    if(b.type === 'GATHER_BONUS' && b.resource) {
                        bonus[b.resource] = b.value;
                    }
                }
                return bonus;
            },
            
            // ERAS control maximum building level based on population
            // Follows exponential scaling: each level requires ~3x previous population
            ERAS: [
                { name: 'Wanderer', level: 0, popUnlock: 0 },
                { name: 'Settlement', level: 1, popUnlock: 2 },
                { name: 'Village', level: 2, popUnlock: 20 },
                { name: 'Town', level: 3, popUnlock: 100 },
                { name: 'City', level: 4, popUnlock: 500 },
                { name: 'Metro', level: 5, popUnlock: 2000 },
                { name: 'Province', level: 6, popUnlock: 7000 },
                { name: 'Region', level: 7, popUnlock: 20000 },
                { name: 'State', level: 8, popUnlock: 60000 },
                { name: 'Nation', level: 9, popUnlock: 180000 },
                { name: 'Empire', level: 10, popUnlock: 500000 },
                { name: 'Dominion', level: 11, popUnlock: 1400000 },
                { name: 'Realm', level: 12, popUnlock: 4200000 },
                { name: 'Dynasty', level: 13, popUnlock: 13000000 },
                { name: 'Hegemony', level: 14, popUnlock: 38000000 },
                { name: 'Superpower', level: 15, popUnlock: 115000000 },
                { name: 'World Power', level: 16, popUnlock: 345000000 },
                { name: 'Hyperpower', level: 17, popUnlock: 1000000000 },
                { name: 'Civilization', level: 18, popUnlock: 3100000000 },
                { name: 'Eternal', level: 19, popUnlock: 10000000000 }
            ],
            
            // === BUILDING LEVELS (Multi-tier system) - Pre-Fire Age ===
            BUILDING_LEVELS: [
                // Level 0: WANDER epoch - no building
                { level: 0, name: 'Wanderer', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0, overflowCapacity: 0 },
                
                // Level 1: Tree Shelter (capacity 15, overflow 20)
                { level: 1, name: 'Tree Shelter', food: 100, wood: 100, stone: 0, metal: 0, capacity: 15, overflowCapacity: 20,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 2, food: 2, stone: 0, metal: 0 },
                  variants: [
                    { name: 'Abandoned Nest', icon: 'ü™π' },
                    { name: 'Small Nest', icon: 'ü™∫', bonus: { wood: 0, food: 0 } },
                    { name: 'Tree Platform', icon: 'üå≥', bonus: { wood: 1, food: 1 } },
                    { name: 'Sturdy Treehouse', icon: 'üèïÔ∏è', bonus: { wood: 1.5, food: 1.5 } }
                  ]
                },
                // Level 2: Ground Pit (capacity 25, overflow 30)
                { level: 2, name: 'Ground Pit', food: 300, wood: 300, stone: 50, metal: 0, capacity: 25, overflowCapacity: 30,
                  upkeep: { wood: 2, food: 2 },
                  gatherBonus: { wood: 5, food: 5, stone: 1, metal: 0 },
                  variants: [
                    { name: 'Collapsed Pit', icon: 'üï≥Ô∏è' },
                    { name: 'Shallow Scrape', icon: '‚¨õ', bonus: { wood: 0, food: 0 } },
                    { name: 'Dug Pit', icon: 'üü´', bonus: { wood: 2, food: 2 } },
                    { name: 'Covered Pit Dwelling', icon: 'üè†', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                // Level 3: Ground Cave (capacity 60, overflow 65)
                { level: 3, name: 'Ground Cave', food: 900, wood: 900, stone: 200, metal: 0, capacity: 60, overflowCapacity: 65,
                  upkeep: { wood: 3, food: 3 },
                  gatherBonus: { wood: 12, food: 12, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Collapsed Cave', icon: 'ü™®' },
                    { name: 'Small Cave', icon: 'üï≥Ô∏è', bonus: { wood: 0, food: 0 } },
                    { name: 'Deep Cave', icon: '‚õ∞Ô∏è', bonus: { wood: 3, food: 3 } },
                    { name: 'Cave Complex', icon: 'üèîÔ∏è', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                // Level 4: Log House (overflow +5)
                { level: 4, name: 'Log House', food: 2700, wood: 2700, stone: 0, metal: 0, capacity: 170, overflowCapacity: 175,
                  upkeep: { wood: 4, food: 4 },
                  gatherBonus: { wood: 57, food: 57, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Ruins', icon: 'üèöÔ∏è' },
                    { name: 'Wood Shack', icon: 'üõñ', bonus: { wood: 0, food: 0 } },
                    { name: 'Log House', icon: 'üè†', bonus: { wood: 4, food: 4 } },
                    { name: 'Grand Log Hall', icon: 'üè°', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                // Level 5: Stone Cottage (overflow +5)
                { level: 5, name: 'Stone Cottage', food: 8100, wood: 8100, stone: 0, metal: 0, capacity: 260, overflowCapacity: 265,
                  upkeep: { wood: 5, food: 5 },
                  gatherBonus: { wood: 93, food: 93, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Rubble', icon: 'ü™®' },
                    { name: 'Stone Hut', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Stone Cottage', icon: 'üè°', bonus: { wood: 5, food: 5 } },
                    { name: 'Stone Manor', icon: 'üèòÔ∏è', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                },
                // Level 6: Timber Frame (overflow +5)
                { level: 6, name: 'Timber Frame', food: 24300, wood: 24300, stone: 0, metal: 0, capacity: 370, overflowCapacity: 375,
                  upkeep: { wood: 6, food: 6 },
                  gatherBonus: { wood: 138, food: 138, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Collapsed Frame', icon: 'üèöÔ∏è' },
                    { name: 'Basic Frame', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Timber House', icon: 'üè°', bonus: { wood: 6, food: 6 } },
                    { name: 'Timber Hall', icon: 'üèõÔ∏è', bonus: { wood: 6.5, food: 6.5 } }
                  ]
                },
                // Level 7: Brick House (overflow +5)
                { level: 7, name: 'Brick House', food: 72900, wood: 72900, stone: 0, metal: 0, capacity: 500, overflowCapacity: 505,
                  upkeep: { wood: 7, food: 7 },
                  gatherBonus: { wood: 192, food: 192, stone: 7, metal: 5 },
                  variants: [
                    { name: 'Crumbling Brick', icon: 'üß±' },
                    { name: 'Brick Shack', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Brick House', icon: 'üè°', bonus: { wood: 7, food: 7 } },
                    { name: 'Brick Mansion', icon: 'üèòÔ∏è', bonus: { wood: 7.5, food: 7.5 } }
                  ]
                },
                // Level 8: Town House (overflow +5)
                { level: 8, name: 'Town House', food: 218700, wood: 218700, stone: 0, metal: 0, capacity: 650, overflowCapacity: 655,
                  upkeep: { wood: 8, food: 8 },
                  gatherBonus: { wood: 255, food: 255, stone: 8, metal: 6 },
                  variants: [
                    { name: 'Abandoned Town', icon: 'üèöÔ∏è' },
                    { name: 'Small Townhouse', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Town House', icon: 'üè°', bonus: { wood: 8, food: 8 } },
                    { name: 'Grand Townhouse', icon: 'üèõÔ∏è', bonus: { wood: 8.5, food: 8.5 } }
                  ]
                },
                // Level 9: Villa (overflow +5)
                { level: 9, name: 'Villa', food: 656100, wood: 656100, stone: 0, metal: 0, capacity: 820, overflowCapacity: 825,
                  upkeep: { wood: 9, food: 9 },
                  gatherBonus: { wood: 327, food: 327, stone: 9, metal: 7 },
                  variants: [
                    { name: 'Ruined Villa', icon: 'üèöÔ∏è' },
                    { name: 'Simple Villa', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Villa', icon: 'üè°', bonus: { wood: 9, food: 9 } },
                    { name: 'Grand Villa', icon: 'üè∞', bonus: { wood: 9.5, food: 9.5 } }
                  ]
                },
                // Level 10: Estate (overflow +5)
                { level: 10, name: 'Estate', food: 1968300, wood: 1968300, stone: 0, metal: 0, capacity: 1010, overflowCapacity: 1015,
                  upkeep: { wood: 10, food: 10 },
                  gatherBonus: { wood: 408, food: 408, stone: 10, metal: 8 },
                  variants: [
                    { name: 'Ruined Estate', icon: 'üèöÔ∏è' },
                    { name: 'Small Estate', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Estate', icon: 'üè°', bonus: { wood: 10, food: 10 } },
                    { name: 'Grand Estate', icon: 'üè∞', bonus: { wood: 10.5, food: 10.5 } }
                  ]
                },
                // Level 11: Manor
                { level: 11, name: 'Manor', food: 5904900, wood: 5904900, stone: 0, metal: 0, capacity: 1220,
                  upkeep: { wood: 11, food: 11 },
                  gatherBonus: { wood: 498, food: 498, stone: 11, metal: 9 },
                  variants: [
                    { name: 'Ruined Manor', icon: 'üèöÔ∏è' },
                    { name: 'Small Manor', icon: 'üè†', bonus: { wood: 0, food: 0 } },
                    { name: 'Manor', icon: 'üèõÔ∏è', bonus: { wood: 11, food: 11 } },
                    { name: 'Grand Manor', icon: 'üè∞', bonus: { wood: 11.5, food: 11.5 } }
                  ]
                },
                // Level 12: Palace
                { level: 12, name: 'Palace', food: 17714700, wood: 17714700, stone: 0, metal: 0, capacity: 1450,
                  upkeep: { wood: 12, food: 12 },
                  gatherBonus: { wood: 597, food: 597, stone: 12, metal: 10 },
                  variants: [
                    { name: 'Ruined Palace', icon: 'üèöÔ∏è' },
                    { name: 'Small Palace', icon: 'üèõÔ∏è', bonus: { wood: 0, food: 0 } },
                    { name: 'Palace', icon: 'üè∞', bonus: { wood: 12, food: 12 } },
                    { name: 'Grand Palace', icon: 'üëë', bonus: { wood: 12.5, food: 12.5 } }
                  ]
                },
                // Level 13: Citadel
                { level: 13, name: 'Citadel', food: 53144100, wood: 53144100, stone: 0, metal: 0, capacity: 1700,
                  upkeep: { wood: 13, food: 13 },
                  gatherBonus: { wood: 705, food: 705, stone: 13, metal: 11 },
                  variants: [
                    { name: 'Ruined Citadel', icon: 'üèöÔ∏è' },
                    { name: 'Small Citadel', icon: 'üè∞', bonus: { wood: 0, food: 0 } },
                    { name: 'Citadel', icon: 'üèØ', bonus: { wood: 13, food: 13 } },
                    { name: 'Grand Citadel', icon: '‚öîÔ∏è', bonus: { wood: 13.5, food: 13.5 } }
                  ]
                },
                // Level 14: Fortress
                { level: 14, name: 'Fortress', food: 159432300, wood: 159432300, stone: 0, metal: 0, capacity: 1970,
                  upkeep: { wood: 14, food: 14 },
                  gatherBonus: { wood: 822, food: 822, stone: 14, metal: 12 },
                  variants: [
                    { name: 'Ruined Fortress', icon: 'üèöÔ∏è' },
                    { name: 'Small Fortress', icon: 'üè∞', bonus: { wood: 0, food: 0 } },
                    { name: 'Fortress', icon: 'üèØ', bonus: { wood: 14, food: 14 } },
                    { name: 'Grand Fortress', icon: 'üõ°Ô∏è', bonus: { wood: 14.5, food: 14.5 } }
                  ]
                },
                // Level 15: Castle
                { level: 15, name: 'Castle', food: 478296900, wood: 478296900, stone: 0, metal: 0, capacity: 2260,
                  upkeep: { wood: 15, food: 15 },
                  gatherBonus: { wood: 948, food: 948, stone: 15, metal: 13 },
                  variants: [
                    { name: 'Ruined Castle', icon: 'üèöÔ∏è' },
                    { name: 'Small Castle', icon: 'üè∞', bonus: { wood: 0, food: 0 } },
                    { name: 'Castle', icon: 'üèØ', bonus: { wood: 15, food: 15 } },
                    { name: 'Grand Castle', icon: 'üëë', bonus: { wood: 15.5, food: 15.5 } }
                  ]
                },
                // Level 16: Kingdom
                { level: 16, name: 'Kingdom', food: 1434890700, wood: 1434890700, stone: 0, metal: 0, capacity: 2570,
                  upkeep: { wood: 16, food: 16 },
                  gatherBonus: { wood: 1083, food: 1083, stone: 16, metal: 14 },
                  variants: [
                    { name: 'Fallen Kingdom', icon: 'üèöÔ∏è' },
                    { name: 'Small Kingdom', icon: 'üè∞', bonus: { wood: 0, food: 0 } },
                    { name: 'Kingdom', icon: 'üëë', bonus: { wood: 16, food: 16 } },
                    { name: 'Grand Kingdom', icon: 'üåü', bonus: { wood: 16.5, food: 16.5 } }
                  ]
                },
                // Level 17: Empire
                { level: 17, name: 'Empire', food: 4304672100, wood: 4304672100, stone: 0, metal: 0, capacity: 2900,
                  upkeep: { wood: 17, food: 17 },
                  gatherBonus: { wood: 1227, food: 1227, stone: 17, metal: 15 },
                  variants: [
                    { name: 'Fallen Empire', icon: 'üèöÔ∏è' },
                    { name: 'Small Empire', icon: 'üëë', bonus: { wood: 0, food: 0 } },
                    { name: 'Empire', icon: 'üåü', bonus: { wood: 17, food: 17 } },
                    { name: 'Grand Empire', icon: '‚ú®', bonus: { wood: 17.5, food: 17.5 } }
                  ]
                },
                // Level 18: Dynasty
                { level: 18, name: 'Dynasty', food: 12914016300, wood: 12914016300, stone: 0, metal: 0, capacity: 3250,
                  upkeep: { wood: 18, food: 18 },
                  gatherBonus: { wood: 1380, food: 1380, stone: 18, metal: 16 },
                  variants: [
                    { name: 'Fallen Dynasty', icon: 'üèöÔ∏è' },
                    { name: 'Rising Dynasty', icon: 'üëë', bonus: { wood: 0, food: 0 } },
                    { name: 'Dynasty', icon: 'üåü', bonus: { wood: 18, food: 18 } },
                    { name: 'Eternal Dynasty', icon: 'üí´', bonus: { wood: 18.5, food: 18.5 } }
                  ]
                },
                // Level 19: Civilization
                { level: 19, name: 'Civilization', food: 38742048900, wood: 38742048900, stone: 0, metal: 0, capacity: 3620,
                  upkeep: { wood: 19, food: 19 },
                  gatherBonus: { wood: 1542, food: 1542, stone: 19, metal: 17 },
                  variants: [
                    { name: 'Lost Civilization', icon: 'üèöÔ∏è' },
                    { name: 'Young Civilization', icon: 'üåü', bonus: { wood: 0, food: 0 } },
                    { name: 'Civilization', icon: '‚ú®', bonus: { wood: 19, food: 19 } },
                    { name: 'Eternal Civilization', icon: 'üåå', bonus: { wood: 19.5, food: 19.5 } }
                  ]
                }
            ],
            
            // === INDUSTRIAL BUILDING LEVELS (4 tiers) ===
            INDUSTRIAL_LEVELS: [
                // Level 0: Placeholder (not buildable)
                { level: 0, name: 'None', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0 },
                
                // Level 1: Hunting Ground
                { level: 1, name: 'Hunting Ground', food: 1000, wood: 1000, stone: 0, metal: 0, capacity: 100,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 3, food: 3, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Abandoned Hunting Ground', icon: 'üèöÔ∏è' },
                    { name: 'Hunting Ground', icon: 'üèπ', bonus: { wood: 0, food: 0 } },
                    { name: 'Active Hunting Ground', icon: 'ü¶å', bonus: { wood: 2, food: 2 } },
                    { name: 'Thriving Hunting Ground', icon: 'üèïÔ∏è', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                
                // Level 2: Hunting Pit
                { level: 2, name: 'Hunting Pit', food: 2000, wood: 2000, stone: 0, metal: 0, capacity: 200,
                  upkeep: { wood: 2, food: 1 },
                  gatherBonus: { wood: 4, food: 4, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Collapsed Hunting Pit', icon: 'üï≥Ô∏è' },
                    { name: 'Hunting Pit', icon: '‚öîÔ∏è', bonus: { wood: 0, food: 0 } },
                    { name: 'Deep Hunting Pit', icon: 'üó°Ô∏è', bonus: { wood: 3, food: 3 } },
                    { name: 'Grand Hunting Pit', icon: '‚öîÔ∏è', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                
                // Level 3: Advanced Hunting Ground
                { level: 3, name: 'Advanced Hunting Ground', food: 3000, wood: 3000, stone: 100, metal: 100, capacity: 300,
                  upkeep: { wood: 3, food: 1 },
                  gatherBonus: { wood: 5, food: 5, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Ruined Advanced Ground', icon: 'üèöÔ∏è' },
                    { name: 'Advanced Hunting Ground', icon: 'üéØ', bonus: { wood: 0, food: 0 } },
                    { name: 'Superior Hunting Ground', icon: 'ü¶¨', bonus: { wood: 4, food: 4 } },
                    { name: 'Elite Hunting Ground', icon: 'üèÜ', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                
                // Level 4: Basic Tannery
                { level: 4, name: 'Basic Tannery', food: 4000, wood: 4000, stone: 500, metal: 500, capacity: 400,
                  upkeep: { wood: 4, food: 1 },
                  gatherBonus: { wood: 6, food: 6, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Abandoned Tannery', icon: 'üèöÔ∏è' },
                    { name: 'Basic Tannery', icon: 'ü•æ', bonus: { wood: 0, food: 0 } },
                    { name: 'Working Tannery', icon: 'üëú', bonus: { wood: 5, food: 5 } },
                    { name: 'Master Tannery', icon: 'üéí', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                }
            ],
            
            ZONE_COST: 50,
            CHIEF_COST: 10000,
            CHIEF_RADIUS: 50,
            CHIEF_BONUS: 2.0,
            GROWTH_THRESHOLD: 1.0,
            DECAY_THRESHOLD: 0.7,
            EFFICIENCY: {
                NO_ROAD_PENALTY: 0.05,
                WATER_BONUS_MAX: 0.5,
                FOREST_BONUS: 0.2,
                DECAY_RATE: 0.02,
                MIN_EFFICIENCY: 0.1
            },
            DESIRABILITY: {
                NEIGHBOR_BONUS: 0.10,
                TREE_BONUS: 0.25,
                WATER_BONUS: 0.50,
                WATER_RANGE: 5,             // Updated to match settlement requirement
                ISOLATION_PENALTY: 0.50,
                ISOLATION_RANGE: 2,
                WEALTH_FOOD_MULTIPLIER: 1.2,
                PATH_BONUS: 0.10, // Path (formerly road)
                WELL_BONUS: 0.15,
                INDUSTRIAL_BONUS: 0.15,
            },
            // === SIMCITY SNES STYLE ZONING BONUSES ===
            // Build anywhere, but smart placement gets bonuses!
            ZONE_BONUSES: {
                // Road Access (critical for all zones)
                ROAD_ACCESS_BONUS: 0.50,        // +50% if adjacent to road
                NO_ROAD_PENALTY: 0.30,          // -70% if no road nearby (within 3 tiles)
                
                // Residential bonuses
                RES_WATER_BONUS: 0.30,          // +30% near water (within 3 tiles)
                RES_TREE_BONUS: 0.20,           // +20% near trees/forest
                RES_CLUSTER_BONUS: 0.10,        // +10% per adjacent residential
                RES_INDUSTRIAL_PENALTY: 0.25,   // -25% if industrial within 2 tiles
                RES_WELL_BONUS: 0.15,           // +15% if well within 3 tiles
                
                // Commercial bonuses (needs customers - residential)
                COM_RES_NEARBY_BONUS: 0.40,     // +40% if 3+ residential within 5 tiles
                COM_ROAD_JUNCTION_BONUS: 0.20,  // +20% if 3+ road tiles adjacent
                COM_INDUSTRIAL_NEARBY: 0.15,    // +15% if industrial within 5 tiles (workers)
                COM_ISOLATION_PENALTY: 0.50,    // -50% if no residential nearby
                
                // Industrial bonuses (needs resources and workers)
                IND_FOREST_BONUS: 0.30,         // +30% near forest (wood source)
                IND_STONE_BONUS: 0.25,          // +25% near stone deposits
                IND_WATER_BONUS: 0.20,          // +20% near water (processing)
                IND_RES_NEARBY_PENALTY: 0.20,   // -20% too close to residential (pollution)
                IND_CLUSTER_BONUS: 0.15,        // +15% per adjacent industrial (efficiency)
                
                // Special building bonuses
                CHIEF_CULTURE_RADIUS: 10,       // Chief's Hut boosts everything in radius
                CHIEF_BONUS: 0.50,              // +50% to nearby buildings
            },
            ZOOM: { MIN: 0.1, MAX: 3, STEP: 1.1 },
            CAMERA: { START_X: 3200, START_Y: 3200, START_ZOOM: 1.0 },
            
            HOUSING: { MUD_HUT_CAPACITY: 20, WARNING_CAPACITY: 55, MAX_CAPACITY: 60, OVERPOPULATION_YEARS: 10, DECAY_TARGET: 30 },
            PRODUCTION: { 
                PERSON_HUNTS: 2, 
                PERSON_EATS: 1, 
                FOOD_TO_GROW: 10, 
                FOOD_FOR_HUT: 50,
                INDUSTRIAL_FOOD_PER_TURN: 100, 
                INDUSTRIAL_SUPPORTS_POPULATION: 200, 
                YEARS_TO_UNLOCK_INDUSTRIAL: 10, 
                INDUSTRIAL_UNLOCK_COST: 100, 
                FOOD_CONSUMPTION_PER_10_POP: 1, 
                INDUSTRIAL_POPULATION_REQUIREMENT: 100, 
                WOLVES_REQUIRED_FOR_INDUSTRIAL: 0, // Removed - wolves no longer in game
                SIMCITY_MODE_UNLOCK_COST: 10000,
                SIMCITY_POPULATION_GROWTH_RATE: 0.15,
                SIMCITY_FOOD_PER_PERSON: 0.1,
                STARVATION_RATE: 0.20,      // Updated: 20% death on starvation
                BASE_GROWTH_RATE: 3
            },
            UPGRADE: {
                BASE_COST: 100,
                COST_MULTIPLIER: 1.5,
                RES_CAPACITY_PER_LEVEL: 20,
                COM_PRODUCTION_PER_LEVEL: 10,
                IND_PRODUCTION_PER_LEVEL: 8
            },
            
            // === WORKFORCE SYSTEM ===
            WORKFORCE: {
                WELL_WORKERS: 0,            // Wells operate automatically (no workers needed)
                ROAD_WORKERS: 0,            // 0 workers per road tile (no upkeep needed)
                COMMERCIAL_WORKERS: 3,      // 3 workers per commercial building
                HUNTING_WORKERS_MIN: 20,    // Min workers for Hunting Ground
                HUNTING_WORKERS_MAX: 100,   // Max workers for Hunting Ground
                GATHERER_FOOD_RATE: 1.5,    // Food per gatherer per year
                GATHERER_WOOD_RATE: 3.0,    // Wood per gatherer per year
                HUNTER_FOOD_RATE: 1.0       // Food per hunter per year
            },
            
            WATER: {
                WELL_CAPACITY: 100,         // Each well serves 100 people
                PER_BUILDING: 0,            // No extra water for buildings under 100 pop
                PER_500_PEOPLE: 500         // 1 well per 500 people (won't trigger under 100)
            },
            
            RESOURCES: {
                WOOD_PER_STEP: 1,           // Wood from forest tiles
                RARE_FIND_CHANCE: 0.0001,   // 0.01% per step on open ground
                LUCKY_FIND_AMOUNT: 1
            },
            
            STONE_DEPOSITS: {
                SPAWN_COUNT: 80,
                MIN_METAL: 50,
                MAX_METAL: 500
            },
            
            CONSTANTS: {
                BASE_SPOILAGE: 0.30,        // 30% rot per year over capacity
                FOOD_PER_PERSON: 0.2,       // People eat 0.2 food/year (minimal survival)
                BASE_PROD: 1.5,
                STARVATION_DEATH: 0.20,     // 20% instant death when food < 0
                THIRST_DEATH: 0.10,         // 10% instant death when water shortage
                BASE_STORAGE: 1000000          // 1 million base storage (no pit needed until Monolithic Resource Pit)
            },
            
            BUILDINGS: {
                BASKET: { cost: 500, reqPop: 20, cap: 2000, desc: 'üß∫ Basket Storage', icon: 'üß∫' },
                POTTERY: { cost: 5000, reqPop: 150, cap: 10000, desc: 'üè∫ Pottery Storage', icon: 'üè∫' },
                GRANARY: { food: 1000000, wood: 1000000, reqPop: 1000, cap: 50000000, rotReduction: 0.10, desc: 'üå∞ Nuts Storage Reed House', icon: 'üå∞', locked: true },
                PALACE: { cost: 250000, reqPop: 5000, cap: 1000000, desc: 'üè∞ Palace Storage', icon: 'üè∞', locked: true }
            },
            
            // Storage Pits - REMOVED (use Monolithic Resource Pit instead)
            STORAGE_PITS: {
                FOOD_PIT: { food: 2000, wood: 10000, stone: 10, cap: 10000, resource: 'food', desc: 'üï≥Ô∏è Food Pit', icon: 'üçñ' },
                WOOD_PIT: { food: 4000, wood: 20000, stone: 20, cap: 10000, resource: 'wood', desc: 'üï≥Ô∏è Wood Pit', icon: 'ü™µ' },
                STONE_PIT: { food: 8000, wood: 40000, stone: 40, cap: 10000, resource: 'stone', desc: 'üï≥Ô∏è Stone Pit', icon: 'ü™®' },
                METAL_PIT: { food: 16000, wood: 80000, stone: 80, cap: 10000, resource: 'metal', desc: 'üï≥Ô∏è Metal Pit', icon: '‚öôÔ∏è' }
            },
            
            WATER_PROXIMITY: { MAX_DISTANCE: 5, MIN_EFFICIENCY: 0.3 },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GEOLOGICAL ELEVATION & WATER CYCLE SYSTEM
            // Based on 3 million years of Earth's glacial cycles
            // Water rises/falls slowly over centuries, not ticks
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            ELEVATION_SYSTEM: {
                ENABLED: true,
                
                // Elevation levels (0-10 scale, 0 = deepest ocean, 10 = highest peak)
                SEA_LEVEL_BASE: 3,              // Starting sea level
                SEA_LEVEL_MIN: 1,               // Ice age minimum (glaciers lock water)
                SEA_LEVEL_MAX: 6,               // Interglacial maximum (ice melts)
                
                // How often water level can change (in game years)
                UPDATE_INTERVAL_YEARS: 100,     // Check every 100 years
                CHANGE_CHANCE: 0.15,            // 15% chance to change each check
                
                // Coastal warning thresholds
                FLOOD_WARNING_MARGIN: 1,        // Warn if elevation <= sea_level + 1
                HIGH_GROUND_BONUS: 2,           // Tiles 2+ above sea level are safe
                
                // Elevation-based building costs (harder to build on highlands)
                COST_THRESHOLD: 4,              // Start cost increase at elevation 4+
                COST_INCREASE_PER_LEVEL: 0.10,  // 10% more per elevation above threshold
                
                // Geological periods (based on real paleoclimate data)
                // Each period lasts ~100k years in real time, we compress it
                GEOLOGICAL_PERIODS: [
                    { name: "Warm Interglacial", seaLevel: 5, duration: 20 },   // 20 centuries warm
                    { name: "Cooling Transition", seaLevel: 4, duration: 10 },
                    { name: "Glacial Advance", seaLevel: 3, duration: 30 },     // 30 centuries ice age
                    { name: "Deep Ice Age", seaLevel: 2, duration: 20 },        // Glaciers at maximum
                    { name: "Glacial Retreat", seaLevel: 3, duration: 10 },
                    { name: "Warming Transition", seaLevel: 4, duration: 10 }
                ]
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // MAP EXPANSION SYSTEM
            // Tribes can explore outward, but world has finite "flat earth" edge
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            MAP_EXPANSION: {
                ENABLED: true,
                INITIAL_SIZE: 250,              // Starting map size (current)
                MAX_SIZE: 500,                  // Maximum expandable size
                EXPANSION_CHUNKS: 50,           // Tiles added per expansion
                EDGE_BUFFER: 10,                // Distance from edge to trigger warning
                
                // Flat Earth boundary - the world ends here!
                BOUNDARY_MESSAGE: "Your scouts report the land ends in a great void. The elders speak of the World's Edge - beyond lies only darkness and falling stars.",
                EXPANSION_COST: { food: 10000, wood: 5000 } // Cost to scout new territory
            }
        };
        // Historical ages for civilization advancement
        const AGES = [{n:"PALEOLITHIC",p:0,m:1},{n:"NEOLITHIC",p:500,m:1.5},{n:"BRONZE",p:2000,m:2},{n:"IRON",p:5000,m:3}];

        // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        // ‚ïë MODULE 2: PROGRESSION - Unlock & Advancement System               ‚ïë
        // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        // Tracks game progress and manages feature unlocking
        // Stage 0: Exploring ‚Üí Stage 1: Settlement ‚Üí Stage 2: Industrial
        
        const PROGRESSION = {
            stage: 0, // 0=exploring, 1=settlement, 2=industrial_unlocked
            nomadsFound: 0,
            berriesNeeded: 5,
            settlementBonus: 0, // Gold comes much later - start with 0
            settlementYear: 0,
            unlockedLevels: [1], // Level 1 is first buildable level (Level 0 = WANDER epoch only)
            unlockedIndustrialLevels: [1], // Industrial levels unlocked (Level 1 always available after industrial unlock)
            unlockedCommercialLevels: [1], // Commercial levels unlocked (Level 1 always available)
            
            reset() {
                this.stage = 0;
                this.nomadsFound = 0;
                this.settlementYear = 0;
                this.unlockedLevels = [1]; // Level 1 is first buildable level
                this.unlockedIndustrialLevels = [1]; // Reset industrial levels
                this.unlockedCommercialLevels = [1]; // Reset commercial levels
            },
            
            // Update unlocked building levels based on population AND building requirements
            updateUnlockedLevels(game) {
                let pop = game.pop || 0;
                let newUnlocks = [1]; // Level 1 always available
                
                // Check each residential building's unlock requirements
                let resBuildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let building of resBuildings) {
                    if(building.level === 1) continue; // Level 1 always unlocked
                    
                    let req = building.unlockReq;
                    if(!req) continue;
                    
                    // Use the universal unlock checker
                    let { met, reasons } = this.checkUnlockRequirements(req, game);
                    
                    if(met && !newUnlocks.includes(building.level)) {
                        newUnlocks.push(building.level);
                    }
                }
                
                // Check for new residential unlocks and notify
                for(let lvl of newUnlocks) {
                    if(!this.unlockedLevels.includes(lvl)) {
                        let building = CFG.BUILDING_DB['RES_' + lvl];
                        if(building) {
                            Controller.toast(`üéâ UNLOCKED: ${building.name} (Level ${lvl})!`);
                        }
                    }
                }
                
                this.unlockedLevels = newUnlocks;
                
                // Update industrial levels - requires same residential level unlocked
                // Industrial L2 requires Residential L2 unlocked, etc.
                let newIndUnlocks = [1]; // L1 always available
                if(this.unlockedLevels.includes(2)) newIndUnlocks.push(2);
                if(this.unlockedLevels.includes(3)) newIndUnlocks.push(3);
                if(this.unlockedLevels.includes(4)) newIndUnlocks.push(4);
                
                // Notify new industrial unlocks
                for(let lvl of newIndUnlocks) {
                    if(!this.unlockedIndustrialLevels.includes(lvl) && CFG.INDUSTRIAL_LEVELS[lvl]) {
                        Controller.toast(`üè≠ INDUSTRIAL UNLOCKED: ${CFG.INDUSTRIAL_LEVELS[lvl].name}!`);
                    }
                }
                
                this.unlockedIndustrialLevels = newIndUnlocks;
                
                // Update commercial levels - requires same residential level unlocked
                // Commercial L2 requires Residential L2 unlocked, etc.
                let newComUnlocks = [1]; // L1 always available
                if(this.unlockedLevels.includes(2)) newComUnlocks.push(2);
                if(this.unlockedLevels.includes(3)) newComUnlocks.push(3);
                if(this.unlockedLevels.includes(4)) newComUnlocks.push(4);
                
                // Notify new commercial unlocks
                for(let lvl of newComUnlocks) {
                    if(!this.unlockedCommercialLevels.includes(lvl)) {
                        let comBuilding = CFG.BUILDING_DB['COM_' + lvl];
                        if(comBuilding) {
                            Controller.toast(`üè™ COMMERCIAL UNLOCKED: ${comBuilding.name}!`);
                        }
                    }
                }
                
                this.unlockedCommercialLevels = newComUnlocks;
            },
            
            /**
             * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             * UNIVERSAL UNLOCK REQUIREMENT CHECKER
             * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             * Checks ANY combination of unlock requirements dynamically.
             * 
             * Supported requirement types:
             *   - pop: number           ‚Üí Minimum population
             *   - resources: {wood: n}  ‚Üí Must have X of resource in stock
             *   - buildings: {type, level?, count, category?} ‚Üí Must have X buildings
             *   - tech: string[]        ‚Üí Must have researched technologies (future)
             *   - year: number          ‚Üí Must reach year X
             *   - level: number         ‚Üí Player must be at civilization level X
             *   - custom: function      ‚Üí Custom check function (advanced)
             * 
             * Example unlockReq:
             * {
             *     pop: 5000,
             *     resources: { wood: 500, stone: 200 },
             *     buildings: { type: 'IND', level: 2, count: 3 },
             *     year: 50
             * }
             * 
             * Returns: { met: boolean, reasons: string[] }
             *   - met: true if ALL requirements are satisfied
             *   - reasons: array of unmet requirement descriptions (for UI)
             * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             */
            checkUnlockRequirements(req, game) {
                if(!req) return { met: true, reasons: [] };
                
                let unmetReasons = [];
                
                // --- POPULATION ---
                if(req.pop !== undefined) {
                    let currentPop = game.pop || 0;
                    if(currentPop < req.pop) {
                        unmetReasons.push(`Need ${req.pop.toLocaleString()} population (have ${currentPop.toLocaleString()})`);
                    }
                }
                
                // --- RESOURCES ---
                if(req.resources) {
                    for(let [resource, amount] of Object.entries(req.resources)) {
                        let current = game.res?.[resource] || 0;
                        if(current < amount) {
                            unmetReasons.push(`Need ${amount.toLocaleString()} ${resource} (have ${current.toLocaleString()})`);
                        }
                    }
                }
                
                // --- BUILDINGS ---
                if(req.buildings) {
                    // Build a count map of all buildings
                    let buildingCounts = this._countBuildings(game);
                    
                    // Support single building requirement or array of requirements
                    let buildingReqs = Array.isArray(req.buildings) ? req.buildings : [req.buildings];
                    
                    for(let bReq of buildingReqs) {
                        let count = 0;
                        
                        if(bReq.id) {
                            // Specific building ID (e.g., 'WELL', 'GRANARY')
                            count = buildingCounts.byId[bReq.id] || 0;
                        } else if(bReq.type && bReq.level !== undefined) {
                            // Type + Level combo (e.g., IND level 2)
                            let key = bReq.type + '_' + bReq.level;
                            count = buildingCounts.byTypeLevel[key] || 0;
                        } else if(bReq.type) {
                            // Any building of type (e.g., any IND)
                            count = buildingCounts.byType[bReq.type] || 0;
                        } else if(bReq.category) {
                            // Any building in category
                            count = buildingCounts.byCategory[bReq.category] || 0;
                        }
                        
                        let required = bReq.count || 1;
                        if(count < required) {
                            let desc = bReq.id || (bReq.type + (bReq.level ? ' L' + bReq.level : ''));
                            unmetReasons.push(`Need ${required}x ${desc} buildings (have ${count})`);
                        }
                    }
                }
                
                // --- YEAR ---
                if(req.year !== undefined) {
                    let currentYear = game.year || 0;
                    if(currentYear < req.year) {
                        unmetReasons.push(`Need to reach Year ${req.year} (current: ${currentYear})`);
                    }
                }
                
                // --- CIVILIZATION LEVEL ---
                if(req.level !== undefined) {
                    let currentLevel = game.civLevel || game.level || 1;
                    if(currentLevel < req.level) {
                        unmetReasons.push(`Need Civilization Level ${req.level} (current: ${currentLevel})`);
                    }
                }
                
                // --- TECHNOLOGIES (Future-proofing) ---
                if(req.tech) {
                    let techs = Array.isArray(req.tech) ? req.tech : [req.tech];
                    let researchedTechs = game.technologies || game.techs || [];
                    for(let tech of techs) {
                        if(!researchedTechs.includes(tech)) {
                            unmetReasons.push(`Need to research: ${tech}`);
                        }
                    }
                }
                
                // --- ACHIEVEMENTS (Future-proofing) ---
                if(req.achievements) {
                    let achievements = Array.isArray(req.achievements) ? req.achievements : [req.achievements];
                    let earnedAchievements = game.achievements || [];
                    for(let ach of achievements) {
                        if(!earnedAchievements.includes(ach)) {
                            unmetReasons.push(`Need achievement: ${ach}`);
                        }
                    }
                }
                
                // --- CUSTOM FUNCTION (Advanced) ---
                if(req.custom && typeof req.custom === 'function') {
                    try {
                        let customResult = req.custom(game);
                        if(customResult !== true) {
                            unmetReasons.push(customResult || 'Custom requirement not met');
                        }
                    } catch(e) {
                        console.error('Custom unlock check failed:', e);
                    }
                }
                
                return {
                    met: unmetReasons.length === 0,
                    reasons: unmetReasons
                };
            },
            
            /**
             * Helper: Count all buildings by various groupings
             * Returns { byId, byType, byTypeLevel, byCategory }
             */
            _countBuildings(game) {
                let counts = {
                    byId: {},         // e.g., { 'WELL': 3, 'GRANARY': 1 }
                    byType: {},       // e.g., { 'IND': 5, 'COM': 3 }
                    byTypeLevel: {},  // e.g., { 'IND_1': 2, 'IND_2': 3 }
                    byCategory: {}    // e.g., { 'RESIDENTIAL': 10, 'INDUSTRIAL': 5 }
                };
                
                let buildings = game.blds || [];
                
                for(let b of buildings) {
                    // By type + level
                    let typeKey = b.t + '_' + (b.lvl || 1);
                    counts.byTypeLevel[typeKey] = (counts.byTypeLevel[typeKey] || 0) + 1;
                    
                    // By type only
                    counts.byType[b.t] = (counts.byType[b.t] || 0) + 1;
                    
                    // By specific building ID (if stored)
                    if(b.id) {
                        counts.byId[b.id] = (counts.byId[b.id] || 0) + 1;
                    }
                    
                    // By category (lookup from BUILDING_DB)
                    let fullId = b.t + '_' + (b.lvl || 1);
                    let bDef = CFG.BUILDING_DB[fullId];
                    if(bDef && bDef.category) {
                        counts.byCategory[bDef.category] = (counts.byCategory[bDef.category] || 0) + 1;
                    }
                }
                
                return counts;
            },
            
            /**
             * Get human-readable unlock requirements for UI display
             */
            getUnlockRequirementsText(req, game) {
                if(!req) return 'Always available';
                
                let { met, reasons } = this.checkUnlockRequirements(req, game);
                
                if(met) return '‚úÖ All requirements met';
                
                return reasons.map(r => '‚ùå ' + r).join('\n');
            },

            /**
             * Industrial tier unlock guidance
             * Returns { met, text } with a concise explanation
             */
            getIndustrialUnlockInfo(level, game) {
                // Prefer BUILDING_DB.popUnlock if available
                const b = CFG.BUILDING_DB['IND_' + level];
                const reqPop = (b && typeof b.popUnlock === 'number') ? b.popUnlock : (level === 1 ? 0 : (level === 2 ? 100 : level === 3 ? 500 : level === 4 ? 2000 : 0));
                const havePop = (game && game.pop) ? game.pop : 0;
                const met = havePop >= reqPop;
                if(reqPop === 0) return { met: true, text: '‚úÖ Available' };
                const text = met
                    ? '‚úÖ Requirement met'
                    : `üîí Need ${reqPop.toLocaleString()} population (have ${havePop.toLocaleString()})`;
                return { met, text };
            },
            
            checkUnlock(game) {
                // Update building level unlocks based on population
                this.updateUnlockedLevels(game);
                
                if(this.stage === 0 && game.food >= this.berriesNeeded && this.nomadsFound >= 1) {
                    this.stage = 1;
                    game.res = this.settlementBonus;
                    this.settlementYear = game.year;
                    return 'settlement';
                }
                if(this.stage === 1) {
                    // Unlock hunting at stage 1 (no requirements)
                    this.stage = 2;
                    return 'industrial';
                }
                return false;
            }
        };

        // --- 2. NOISE ---
        const Noise = {
            seed: 1,
            init(s) { this.seed = s; },
            hash(x,y) { let h = Math.sin(x*12.98+y*78.23+this.seed)*43758.54; return h-Math.floor(h); },
            mix(a,b,t) { return a*(1-t)+b*t; },
            val(x,y) {
                let i=Math.floor(x), j=Math.floor(y), f={x:x-i, y:y-j};
                let u={x:f.x*f.x*(3-2*f.x), y:f.y*f.y*(3-2*f.y)};
                let a=this.hash(i,j), b=this.hash(i+1,j), c=this.hash(i,j+1), d=this.hash(i+1,j+1);
                return this.mix(this.mix(a,b,u.x), this.mix(c,d,u.x), u.y);
            },
            fbm(x,y) {
                let t=0, a=0.5;
                for(let i=0; i<5; i++) { t+=this.val(x,y)*a; x*=2; y*=2; a*=0.5; }
                return t;
            }
        };

        // --- 3. RENDERER ---
        const Renderer = {
            cvs: null, ctx: null, w: 0, h: 0, time: 0, particles: [], effects: [],
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // PERFORMANCE OPTIMIZATIONS - Caching and dirty tracking
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            _gradientCache: new Map(),  // Cache gradients to avoid recreation
            _lastCam: { x: 0, y: 0, z: 1 },  // Track camera changes
            _minimapCanvas: null,  // Offscreen canvas for minimap
            _minimapDirty: true,   // Flag to rebuild minimap
            _lastMinimapUpdate: 0,
            _frameSkipCounter: 0,
            
            // Get or create cached gradient
            getCachedGradient(c, key, createFn) {
                if(!this._gradientCache.has(key)) {
                    this._gradientCache.set(key, createFn());
                    // Limit cache size to prevent memory bloat
                    if(this._gradientCache.size > 100) {
                        const firstKey = this._gradientCache.keys().next().value;
                        this._gradientCache.delete(firstKey);
                    }
                }
                return this._gradientCache.get(key);
            },
            
            // Check if camera moved significantly
            cameraChanged(cam) {
                const threshold = 0.5;
                const changed = Math.abs(cam.x - this._lastCam.x) > threshold ||
                               Math.abs(cam.y - this._lastCam.y) > threshold ||
                               Math.abs(cam.z - this._lastCam.z) > 0.01;
                if(changed) {
                    this._lastCam = { x: cam.x, y: cam.y, z: cam.z };
                    this._minimapDirty = true;
                }
                return changed;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // TINY NEOLITHIC PEOPLE SYSTEM - Little figures walking around
            // Super lightweight, only updates visible area, pooled objects
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            tinyPeople: [],
            get maxTinyPeople() {
                let pop = (window.Game && Game.pop) ? Game.pop : 1;
                return Math.max(1, Math.ceil(pop * 1.1));
            },
            lastPeopleUpdate: 0,
            
            initTinyPeople() {
                this.tinyPeople = [];
            },
            
            updateTinyPeople(game, sc, ec, sr, er) {
                // PERFORMANCE: Only update every 250ms (was 150ms)
                let now = performance.now();
                if(now - this.lastPeopleUpdate < 250) return;
                this.lastPeopleUpdate = now;
                
                // Process people who finished their journey - give them new destinations!
                for(let p of this.tinyPeople) {
                    if(p.progress >= 1) {
                        // Arrived! Pick a new random action
                        let action = Math.random();
                        if(action < 0.3) {
                            // Stop and do an activity (idle animation)
                            p.x = p.destX;
                            p.y = p.destY;
                            p.activity = Math.floor(Math.random() * 4); // 0=rest, 1=work, 2=look around, 3=wave
                            p.activityTime = now;
                            p.activityDuration = 1500 + Math.random() * 2000; // 1.5-3.5 seconds
                            p.progress = -1; // Special: doing activity
                        } else {
                            // Keep walking to new destination
                            p.x = p.destX;
                            p.y = p.destY;
                            // Pick nearby tile (1-3 tiles away)
                            let dist = 1 + Math.floor(Math.random() * 3);
                            let angle = Math.random() * Math.PI * 2;
                            p.destX = Math.round(p.x + Math.cos(angle) * dist);
                            p.destY = Math.round(p.y + Math.sin(angle) * dist);
                            p.destX = Math.max(0, Math.min(199, p.destX));
                            p.destY = Math.max(0, Math.min(199, p.destY));
                            p.flip = p.destX > p.x;
                            p.progress = 0;
                            p.speed = 0.008 + Math.random() * 0.006; // Faster between tiles
                        }
                    } else if(p.progress === -1) {
                        // Doing activity - check if done
                        if(now - p.activityTime > p.activityDuration) {
                            // Done with activity, start walking
                            let dist = 1 + Math.floor(Math.random() * 2);
                            let angle = Math.random() * Math.PI * 2;
                            p.destX = Math.round(p.x + Math.cos(angle) * dist);
                            p.destY = Math.round(p.y + Math.sin(angle) * dist);
                            p.destX = Math.max(0, Math.min(199, p.destX));
                            p.destY = Math.max(0, Math.min(199, p.destY));
                            p.flip = p.destX > p.x;
                            p.progress = 0;
                            p.speed = 0.008 + Math.random() * 0.006;
                            p.activity = null;
                        }
                    }
                }
                
                // Remove people who went off-screen
                this.tinyPeople = this.tinyPeople.filter(p => {
                    if(p.x < sc - 3 || p.x > ec + 3 || p.y < sr - 3 || p.y > er + 3) return false;
                    return true;
                });
                
                // Spawn new people near buildings (if under cap)
                if(this.tinyPeople.length < this.maxTinyPeople && game.blds && game.blds.length > 0) {
                    let visibleBlds = game.blds.filter(b => b.x >= sc && b.x <= ec && b.y >= sr && b.y <= er);
                    if(visibleBlds.length > 0 && Math.random() < 0.12) {
                        let srcBld = visibleBlds[Math.floor(Math.random() * visibleBlds.length)];
                        // Start near the building, walk 1-2 tiles
                        let dist = 1 + Math.floor(Math.random() * 2);
                        let angle = Math.random() * Math.PI * 2;
                        this.tinyPeople.push({
                            x: srcBld.x, y: srcBld.y,
                            destX: Math.round(srcBld.x + Math.cos(angle) * dist),
                            destY: Math.round(srcBld.y + Math.sin(angle) * dist),
                            progress: 0,
                            speed: 0.008 + Math.random() * 0.006,
                            type: Math.floor(Math.random() * 3),
                            flip: Math.random() > 0.5,
                            activity: null
                        });
                    }
                    
                    // Also spawn along roads
                    if(game.tiles && Math.random() < 0.08) {
                        for(let attempt = 0; attempt < 3; attempt++) {
                            let rx = sc + Math.floor(Math.random() * (ec - sc));
                            let ry = sr + Math.floor(Math.random() * (er - sr));
                            if(rx >= 0 && rx < 200 && ry >= 0 && ry < 200) {
                                let tile = game.tiles[rx][ry];
                                if(tile && tile.road && tile.explored) {
                                    let dist = 1 + Math.floor(Math.random() * 2);
                                    let dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                                    let dir = dirs[Math.floor(Math.random() * 4)];
                                    this.tinyPeople.push({
                                        x: rx, y: ry,
                                        destX: Math.max(0, Math.min(199, rx + dir[0] * dist)),
                                        destY: Math.max(0, Math.min(199, ry + dir[1] * dist)),
                                        progress: 0,
                                        speed: 0.008 + Math.random() * 0.006,
                                        type: Math.floor(Math.random() * 3),
                                        flip: dir[0] > 0,
                                        activity: null
                                    });
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Update positions for walking people
                for(let p of this.tinyPeople) {
                    if(p.progress >= 0) p.progress += p.speed;
                }
            },
            
            drawTinyPeople(c, T) {
                let now = performance.now();
                
                // Draw each tiny person
                for(let p of this.tinyPeople) {
                    let px, py;
                    let isWalking = p.progress >= 0 && p.progress < 1;
                    
                    if(p.progress === -1) {
                        // Doing activity - stay in place
                        px = p.x * T + T/2;
                        py = p.y * T + T/2;
                    } else {
                        // Walking
                        let prog = Math.max(0, Math.min(1, p.progress));
                        px = (p.x + (p.destX - p.x) * prog) * T + T/2;
                        py = (p.y + (p.destY - p.y) * prog) * T + T/2;
                    }
                    
                    // Body color based on type
                    let bodyColor = p.type === 0 ? '#8B7355' : p.type === 1 ? '#6B4423' : '#A0522D';
                    let skinColor = '#D2B48C';
                    
                    c.save();
                    c.translate(px, py);
                    if(p.flip) c.scale(-1, 1);
                    
                    // Different poses based on activity
                    if(p.activity === 0) {
                        // RESTING - sitting down
                        c.fillStyle = skinColor;
                        c.fillRect(-1, -2, 2, 2); // Head
                        c.fillStyle = bodyColor;
                        c.fillRect(-2, 0, 4, 2); // Sitting body
                        
                    } else if(p.activity === 1) {
                        // WORKING - bent over with tool moving
                        let workBob = Math.sin(now * 0.012) * 2;
                        c.fillStyle = skinColor;
                        c.fillRect(-1, -1 + workBob * 0.3, 2, 2); // Head bobbing
                        c.fillStyle = bodyColor;
                        c.fillRect(-1, 1, 2, 2); // Bent body
                        // Tool swinging
                        c.fillStyle = '#808080';
                        c.fillRect(2, -1 + workBob, 1, 3);
                        
                    } else if(p.activity === 2) {
                        // LOOKING AROUND - turning head
                        let lookDir = Math.sin(now * 0.003) > 0;
                        c.save();
                        if(lookDir) c.scale(-1, 1);
                        c.fillStyle = skinColor;
                        c.fillRect(-1, -3, 2, 2); // Head
                        c.fillStyle = bodyColor;
                        c.fillRect(-1, -1, 2, 3); // Body
                        c.fillRect(-1, 2, 1, 2); // Legs standing
                        c.fillRect(0, 2, 1, 2);
                        c.restore();
                        
                    } else if(p.activity === 3) {
                        // WAVING - arm up and down
                        let waveUp = Math.sin(now * 0.015) > 0;
                        c.fillStyle = skinColor;
                        c.fillRect(-1, -3, 2, 2); // Head
                        c.fillStyle = bodyColor;
                        c.fillRect(-1, -1, 2, 3); // Body
                        c.fillRect(-1, 2, 1, 2); // Legs
                        c.fillRect(0, 2, 1, 2);
                        // Waving arm
                        c.fillStyle = skinColor;
                        c.fillRect(1, waveUp ? -4 : -2, 1, 2);
                        
                    } else {
                        // WALKING - normal animation
                        let bob = Math.sin(now * 0.015 + p.x * 10) * 1.5;
                        c.translate(0, bob);
                        
                        c.fillStyle = bodyColor;
                        c.fillRect(-1, -1, 2, 3); // Body
                        c.fillStyle = skinColor;
                        c.fillRect(-1, -3, 2, 2); // Head
                        
                        // Walking legs
                        let legOffset = Math.sin(now * 0.02 + p.x * 5) > 0 ? 1 : 0;
                        c.fillStyle = bodyColor;
                        c.fillRect(-1, 2, 1, 1 + legOffset);
                        c.fillRect(0, 2, 1, 2 - legOffset);
                        
                        // Carrying item
                        if(p.type === 0) {
                            c.fillStyle = '#DAA520';
                            c.fillRect(1, -1, 1, 2);
                        } else if(p.type === 1) {
                            c.fillStyle = '#808080';
                            c.fillRect(1, -2, 1, 3);
                        }
                    }
                    
                    c.restore();
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // MICRO-ANIMATIONS: Tiny details on buildings for life
            // Fire flickers, smoke puffs, water ripples - all super lightweight
            // PERFORMANCE: Skip when zoomed out or every other frame
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            _lastAnimFrame: 0,
            drawBuildingAnimations(c, game, sc, ec, sr, er, T, cam) {
                // PERFORMANCE: Skip animations when zoomed out
                if(cam && cam.z < 0.6) return;
                
                // PERFORMANCE: Only draw animations every other frame
                this._lastAnimFrame++;
                if(this._lastAnimFrame % 2 !== 0) return;
                
                let time = performance.now();
                
                // Draw animations for buildings in view
                for(let b of game.blds) {
                    if(b.x < sc - 1 || b.x > ec || b.y < sr - 1 || b.y > er) continue;
                    
                    let px = b.x * T;
                    let py = b.y * T;
                    
                    // INDUSTRIAL: Smoke puffs for higher levels
                    if(b.t === 'IND' && b.lvl >= 3) {
                        let smokeX = px + T * 0.7;
                        let smokeY = py + T * 0.2;
                        // Rising smoke particle
                        let smokeOffset = (time * 0.001 + b.x * 10) % 1;
                        let smokeAlpha = 0.3 * (1 - smokeOffset);
                        c.fillStyle = `rgba(180, 180, 180, ${smokeAlpha})`;
                        c.beginPath();
                        c.arc(smokeX + Math.sin(time * 0.003) * 2, smokeY - smokeOffset * 12, 2 + smokeOffset * 2, 0, 6.28);
                        c.fill();
                    }
                    
                    // COMMERCIAL: Tiny flag/banner flutter
                    if(b.t === 'COM' && b.lvl >= 2) {
                        let flagX = px + T * 0.8;
                        let flagY = py + T * 0.15;
                        let flutter = Math.sin(time * 0.006 + b.x * 5) * 2;
                        c.fillStyle = '#D4A017';
                        c.beginPath();
                        c.moveTo(flagX, flagY);
                        c.lineTo(flagX + 4 + flutter, flagY + 2);
                        c.lineTo(flagX, flagY + 4);
                        c.closePath();
                        c.fill();
                    }
                    
                    // WELLS: Water ripple
                    if(b.t === 'WELL') {
                        let wellCx = px + T * 0.5;
                        let wellCy = py + T * 0.55;
                        let rippleRadius = 3 + (time * 0.002 % 1) * 4;
                        let rippleAlpha = 0.3 * (1 - (rippleRadius - 3) / 4);
                        c.strokeStyle = `rgba(100, 180, 255, ${rippleAlpha})`;
                        c.lineWidth = 1;
                        c.beginPath();
                        c.arc(wellCx, wellCy, rippleRadius, 0, 6.28);
                        c.stroke();
                    }
                }
                
                // PERFORMANCE: Skip residential tile animations when many buildings
                if(game.blds.length > 50) return;
                
                // Draw animations for residential tiles
                for(let x = sc; x < ec; x++) {
                    for(let y = sr; y < er; y++) {
                        let tile = game.tiles[x][y];
                        if(tile.zone === 'R' && tile.building && tile.building.level >= 2) {
                            // Tiny campfire flicker for huts
                            let px = x * T;
                            let py = y * T;
                            let flickerSize = 2 + Math.sin(time * 0.01 + x * 7) * 0.5;
                            c.fillStyle = `rgba(255, ${150 + Math.sin(time * 0.015) * 50}, 50, 0.7)`;
                            c.beginPath();
                            c.arc(px + T * 0.3, py + T * 0.7, flickerSize, 0, 6.28);
                            c.fill();
                        }
                    }
                }
            },
            
            // Helper function to draw rounded rectangles
            roundRect(c, x, y, w, h, r) {
                if(r > w/2) r = w/2;
                if(r > h/2) r = h/2;
                c.beginPath();
                c.moveTo(x + r, y);
                c.lineTo(x + w - r, y);
                c.quadraticCurveTo(x + w, y, x + w, y + r);
                c.lineTo(x + w, y + h - r);
                c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                c.lineTo(x + r, y + h);
                c.quadraticCurveTo(x, y + h, x, y + h - r);
                c.lineTo(x, y + r);
                c.quadraticCurveTo(x, y, x + r, y);
                c.closePath();
            },
            
            // Helper to fill rounded rectangle
            fillRoundRect(c, x, y, w, h, r) {
                this.roundRect(c, x, y, w, h, r);
                c.fill();
            },
            
            // Helper to stroke rounded rectangle
            strokeRoundRect(c, x, y, w, h, r) {
                this.roundRect(c, x, y, w, h, r);
                c.stroke();
            },
            
            init() {
                this.cvs = document.getElementById('cvs');
                this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.resize(); window.onresize = () => this.resize();
            },
            addWoodChips(tileX, tileY) {
                // Wood chip burst effect
                const start = performance.now();
                const duration = 600;
                const chips = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2) * (i / 8) + Math.random()*0.3;
                    const speed = 0.5 + Math.random()*0.7;
                    chips.push({ angle, speed });
                }
                this.effects.push({ type: 'woodchips', x: tileX, y: tileY, start, duration, chips });
            },
            addDust(tileX, tileY) {
                // 3-second cartoonish dust cloud effect
                const start = performance.now();
                const duration = 9000;
                const puffs = [];
                // Precompute puff offsets for a consistent look
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2) * (i / 6);
                    const radius = 0.18 + (i % 2) * 0.06; // tile-relative radius
                    puffs.push({ angle, radius });
                }
                this.effects.push({ type: 'dust', x: tileX, y: tileY, start, duration, puffs });
            },
            resize() {
                let vp = document.getElementById('viewport');
                let dpr = window.devicePixelRatio || 1;
                this.w = vp.clientWidth; this.h = vp.clientHeight;
                this.cvs.width = this.w * dpr; this.cvs.height = this.h * dpr;
                this.ctx.scale(dpr, dpr); this.ctx.imageSmoothingEnabled = false;
            },
            draw(cam) {
                let c = this.ctx, T = CFG.TILE; this.time += 0.05;
                c.save(); c.setTransform(1,0,0,1,0,0); c.fillStyle="#000"; c.fillRect(0,0,this.cvs.width,this.cvs.height); c.restore();
                
                if(!Game || !Game.tiles) {
                    c.restore();
                    return;
                }
                
                c.save(); c.translate(this.w/2, this.h/2); c.scale(cam.z, cam.z); c.translate(-cam.x, -cam.y);

                let sc = Math.max(0, Math.floor((cam.x - (this.w/cam.z)/2)/T));
                let ec = Math.min(CFG.W, Math.ceil((cam.x + (this.w/cam.z)/2)/T));
                let sr = Math.max(0, Math.floor((cam.y - (this.h/cam.z)/2)/T));
                let er = Math.min(CFG.H, Math.ceil((cam.y + (this.h/cam.z)/2)/T));

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // VICTORIAN MAP THEME - Hand-drawn cartographic style
                // Sepia tones, ink lines, parchment texture
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                for(let x=sc; x<ec; x++) for(let y=sr; y<er; y++) {
                    let t = Game.tiles[x][y];
                    let seed = (x * 7 + y * 13) % 100; // Deterministic variation
                    
                    // Fog of war - aged parchment unexplored areas
                    if (!t.explored) {
                        c.fillStyle = "#C8B8A0";
                        c.fillRect(x*T, y*T, T, T);
                        // Ink border edge effect
                        c.strokeStyle = 'rgba(60,40,20,0.3)';
                        c.lineWidth = 1;
                        c.strokeRect(x*T, y*T, T, T);
                        continue;
                    }
                    
                    // === BASE TERRAIN - Victorian map colors ===
                    c.fillStyle = CFG.COLORS[t.type];
                    c.fillRect(x*T, y*T, T, T);
                    
                    // === TERRAIN-SPECIFIC VICTORIAN STYLING ===
                    if(t.type === 'GRASS') {
                        // Parchment green with subtle stippling
                        c.fillStyle = '#C9D4A0';
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Hand-drawn stipple dots (cartographic grass) - reduced for performance
                        if(seed % 7 === 0) {
                            c.fillStyle = 'rgba(100,120,60,0.35)';
                            c.fillRect(x*T + T*0.3, y*T + T*0.4, 1, 1);
                            c.fillRect(x*T + T*0.6, y*T + T*0.7, 1, 1);
                        }
                        
                    } else if(t.type === 'SAND') {
                        // Sandy parchment with fine dots
                        c.fillStyle = '#D4C4A8';
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Simplified stipple for sand - performance optimized
                        if(seed % 8 === 0) {
                            c.fillStyle = 'rgba(160,140,100,0.25)';
                            c.fillRect(x*T + (seed % 10), y*T + ((seed*2) % 10), 2, 2);
                        }
                        
                    } else if(t.type === 'WATER' || t.type === 'RIVER' || t.type === 'DEEP') {
                        // Victorian water - horizontal ink lines (optimized)
                        let waterColor = t.type === 'DEEP' ? '#4A6B8A' : t.type === 'WATER' ? '#6B8FAD' : '#7FA0B8';
                        c.fillStyle = waterColor;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Draw wave lines only on every 3rd tile for performance
                        if((x + y) % 3 === 0) {
                            c.strokeStyle = 'rgba(40,60,80,0.3)';
                            c.lineWidth = 0.5;
                            let ly = y*T + T*0.5;
                            c.beginPath();
                            c.moveTo(x*T + 2, ly);
                            c.lineTo(x*T + T - 2, ly);
                            c.stroke();
                        }
                        
                    } else if(t.type === 'STONE' || t.type === 'ROCK') {
                        // Rocky terrain - simplified for performance
                        c.fillStyle = '#9A9A8A';
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Minimal hatching only on some tiles
                        if(seed % 5 === 0) {
                            c.strokeStyle = 'rgba(60,50,40,0.3)';
                            c.lineWidth = 0.5;
                            c.beginPath();
                            c.moveTo(x*T + 2, y*T + 2);
                            c.lineTo(x*T + T*0.4, y*T + T*0.4);
                            c.stroke();
                        }
                        
                    } else if(t.type === 'FOREST') {
                        // Forest floor - muted green
                        c.fillStyle = '#A8B888';
                        c.fillRect(x*T, y*T, T, T);
                        
                    } else if(t.type === 'SNOW') {
                        // Snow - near white
                        c.fillStyle = '#E8E8E0';
                        c.fillRect(x*T, y*T, T, T);
                    }
                    
                    // Parchment aging - reduced frequency for performance
                    if(seed % 11 === 0) {
                        c.fillStyle = 'rgba(80,60,40,0.04)';
                        c.fillRect(x*T + seed % (T-4), y*T + (seed*3) % (T-4), 2, 2);
                    }
                    
                    // Draw berry entity - Cave painting style berry clusters (OPTIMIZED)
                    if(t.entity && t.entity.type === 'BERRY') {
                        let bx = x*T+T/2;
                        let by = y*T+T/2;
                        
                        // Yoshi's Island style berry bush
                        // Draw cute bush base first
                        c.fillStyle = '#60C060';
                        c.beginPath();
                        c.arc(bx - 8, by + 8, 8, 0, 6.28);
                        c.arc(bx + 8, by + 8, 8, 0, 6.28);
                        c.arc(bx, by + 4, 10, 0, 6.28);
                        c.fill();
                        
                        // Bush highlight
                        c.fillStyle = '#90E890';
                        c.beginPath();
                        c.arc(bx - 6, by + 4, 4, 0, 6.28);
                        c.arc(bx + 4, by + 2, 3, 0, 6.28);
                        c.fill();
                        
                        // PERFORMANCE: Draw simplified berries without per-berry gradients
                        let berryCount = 3 + Math.floor((x + y) % 3);
                        let positions = [
                            {x: 0, y: -8}, {x: -7, y: -2}, {x: 7, y: -2},
                            {x: -4, y: 4}, {x: 4, y: 4}
                        ];
                        
                        // Use solid colors instead of gradients for performance
                        let berryColor = t.entity.is_poisonous ? '#C878F0' : '#FF6090';
                        let berryHighlight = t.entity.is_poisonous ? '#E0B0FF' : '#FF90B0';
                        
                        for(let i = 0; i < berryCount; i++) {
                            let pos = positions[i];
                            let bpx = bx + pos.x, bpy = by + pos.y;
                            
                            // Berry with simple fill (PERFORMANCE: no gradient)
                            c.fillStyle = berryColor;
                            c.beginPath();
                            c.arc(bpx, bpy, 6, 0, 6.28);
                            c.fill();
                            
                            // Black outline for cartoon look
                            c.strokeStyle = 'rgba(0,0,0,0.3)';
                            c.lineWidth = 1.5;
                            c.stroke();
                            
                            // Big cute shine spot (gives 3D effect without gradient)
                            c.fillStyle = berryHighlight;
                            c.beginPath();
                            c.arc(bpx-2, bpy-3, 3, 0, 6.28);
                            c.fill();
                            
                            c.fillStyle = 'rgba(255,255,255,0.8)';
                            c.beginPath();
                            c.arc(bpx-2, bpy-2, 2, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // Draw nomad entity - Cave painting style stick figure with spear (ANIMATED)
                    if(t.entity && t.entity.type === 'NOMAD') {
                        let nx = x*T + T/2, ny = y*T + T/2;
                        let scale = T/64;
                        
                        // Idle animation - subtle swaying and breathing
                        let time = performance.now() / 1000;
                        let uniqueOffset = (x * 7 + y * 13) % 100; // Unique offset per nomad
                        let sway = Math.sin(time * 1.2 + uniqueOffset) * 1.5 * scale; // Side sway
                        let breathe = Math.sin(time * 2 + uniqueOffset) * 0.8 * scale; // Breathing bob
                        let armWave = Math.sin(time * 0.8 + uniqueOffset) * 2 * scale; // Subtle arm movement
                        
                        // All nomads look the same (don't reveal hostility)
                        c.strokeStyle = "#8B5A2B"; // Darker brown for better contrast
                        c.lineWidth = 2;
                        c.lineCap = "round";
                        c.lineJoin = "round";
                        
                        // Head (circle) - with sway
                        c.beginPath();
                        c.arc(nx + sway, ny - 18*scale + breathe, 5*scale, 0, 6.28);
                        c.stroke();
                        
                        // Body (vertical line) - slight sway
                        c.beginPath();
                        c.moveTo(nx + sway * 0.8, ny - 13*scale + breathe);
                        c.lineTo(nx + sway * 0.3, ny + 5*scale);
                        c.stroke();
                        
                        // Arms (one raised holding spear) - animated
                        c.beginPath();
                        c.moveTo(nx + sway * 0.6, ny - 8*scale + breathe * 0.5);
                        c.lineTo(nx - 8*scale + armWave, ny - 15*scale + breathe); // Left arm raised, animated
                        c.moveTo(nx + sway * 0.6, ny - 8*scale + breathe * 0.5);
                        c.lineTo(nx + 8*scale + sway * 0.2, ny - 2*scale - armWave * 0.3); // Right arm down
                        c.stroke();
                        
                        // Legs (idle stance with weight shift)
                        let legShift = Math.sin(time * 0.6 + uniqueOffset) * 1.5 * scale;
                        c.beginPath();
                        c.moveTo(nx + sway * 0.3, ny + 5*scale);
                        c.lineTo(nx - 6*scale + legShift, ny + 15*scale); // Left leg
                        c.moveTo(nx + sway * 0.3, ny + 5*scale);
                        c.lineTo(nx + 6*scale - legShift * 0.5, ny + 15*scale); // Right leg
                        c.stroke();
                        
                        // Spear (in raised hand) - follows arm
                        c.strokeStyle = "#8B7355";
                        c.lineWidth = 1.5;
                        c.beginPath();
                        c.moveTo(nx - 8*scale + armWave, ny - 15*scale + breathe);
                        c.lineTo(nx - 10*scale + armWave * 0.8, ny - 28*scale + breathe * 0.5); // Spear shaft
                        c.stroke();
                        
                        // Spear tip - follows spear
                        c.fillStyle = "#555";
                        c.beginPath();
                        c.moveTo(nx - 10*scale + armWave * 0.8, ny - 28*scale + breathe * 0.5);
                        c.lineTo(nx - 12*scale + armWave * 0.8, ny - 24*scale + breathe * 0.5);
                        c.lineTo(nx - 8*scale + armWave * 0.8, ny - 24*scale + breathe * 0.5);
                        c.fill();
                    }
                    
                    if(t.road) this.drawRoad(c, x, y, T);
                    else if(t.stoneDeposit) this.drawStoneDeposit(c, x*T, y*T, t.stoneDeposit);
                    else if(t.tree && !t.bld) this.drawTree(c, x*T, y*T, t.type);
                    else if(t.type === 'WATER' || t.type === 'RIVER') this.drawWaterAnim(c, x*T, y*T);
                    else if(t.type === 'SAND') this.drawGrain(c, x*T, y*T);

                    if (Game.vm === 'POL' && t.pol > 0) { c.fillStyle = `rgba(100,0,100,${Math.min(t.pol/100, 0.6)})`; c.fillRect(x*T, y*T, T, T); }
                    
                    // DESIRABILITY HEATMAP VIEW
                    if (Game.vm === 'DESIRABILITY') {
                        let desirability = Game.calculateDesirability(x, y, 1);
                        // Color gradient: Red (0) -> Yellow (0.5) -> Green (1.0) -> Blue (1.5+)
                        let r, g, b, alpha = 0.5;
                        if(desirability < 0.3) {
                            r = 255; g = Math.floor(desirability * 850); b = 0;
                        } else if(desirability < 0.7) {
                            r = Math.floor(255 - (desirability - 0.3) * 600); g = 255; b = 0;
                        } else if(desirability < 1.2) {
                            r = 0; g = 255; b = Math.floor((desirability - 0.7) * 510);
                        } else {
                            r = 0; g = Math.floor(255 - (desirability - 1.2) * 200); b = 255;
                        }
                        c.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Show value on hover
                        if(Math.abs(Controller.mx - x) === 0 && Math.abs(Controller.my - y) === 0) {
                            c.fillStyle = 'rgba(0,0,0,0.9)';
                            c.fillRect(x*T - 10, y*T - 25, 70, 20);
                            c.fillStyle = '#fff';
                            c.font = 'bold 11px sans-serif';
                            c.textAlign = 'left';
                            c.fillText(`D: ${desirability.toFixed(2)}`, x*T - 5, y*T - 10);
                        }
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // ELEVATION VIEW OVERLAY - DISABLED FOR MYSTERY
                    // Player must discover flood risks through gameplay, not overlays
                    // Sea level and elevation data only revealed when road connects to water
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if(Controller.showElevation && Game.geology) { // Toggle with elevation debug button
                        const seaLevel = Game.geology.currentSeaLevel;
                        const elev = t.elevation;
                        const diff = elev - seaLevel; // How far above/below sea level
                        
                        let overlayColor;
                        if(t.type === 'WATER' || t.type === 'DEEP' || t.type === 'RIVER') {
                            // Already water - show depth
                            overlayColor = 'rgba(0, 50, 150, 0.4)';
                        } else if(diff < 0) {
                            // BELOW SEA LEVEL - RED - This tile WILL flood!
                            overlayColor = 'rgba(255, 0, 0, 0.5)';
                        } else if(diff < 0.5) {
                            // VERY HIGH RISK - ORANGE - Floods soon
                            overlayColor = 'rgba(255, 100, 0, 0.45)';
                        } else if(diff < 1.0) {
                            // WARNING - YELLOW - Could flood in warming period
                            overlayColor = 'rgba(255, 200, 0, 0.4)';
                        } else if(diff < 2.0) {
                            // SAFE - GREEN - Above current risk
                            overlayColor = 'rgba(0, 180, 0, 0.3)';
                        } else {
                            // HIGH GROUND - BLUE - Very safe
                            overlayColor = 'rgba(0, 100, 255, 0.25)';
                        }
                        
                        c.fillStyle = overlayColor;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Show elevation number on tile (small text)
                        c.fillStyle = 'rgba(255,255,255,0.9)';
                        c.font = 'bold 9px sans-serif';
                        c.textAlign = 'center';
                        c.textBaseline = 'middle';
                        c.fillText(elev.toFixed(1), x*T + T/2, y*T + T/2);
                        
                        // Show detailed info on hover
                        if(Math.abs(Controller.mx - x) === 0 && Math.abs(Controller.my - y) === 0) {
                            c.fillStyle = 'rgba(0,0,0,0.95)';
                            c.fillRect(x*T - 10, y*T - 45, 90, 40);
                            c.fillStyle = '#fff';
                            c.font = 'bold 10px sans-serif';
                            c.textAlign = 'left';
                            c.fillText(`Elev: ${elev.toFixed(1)}`, x*T - 5, y*T - 35);
                            c.fillText(`Sea: ${seaLevel.toFixed(1)}`, x*T - 5, y*T - 23);
                            c.fillStyle = diff < 0.5 ? '#FF6666' : (diff < 1.0 ? '#FFCC00' : '#66FF66');
                            c.fillText(diff < 0 ? 'FLOODING!' : `+${diff.toFixed(1)} safe`, x*T - 5, y*T - 11);
                        }
                    }
                }
                
                // Draw wander wells (Level 0 structures)
                if(Game.wanderWells && Game.wanderWells.length > 0) {
                    for(let well of Game.wanderWells) {
                        let wx = well.x * T + T/2;
                        let wy = well.y * T + T/2;
                        
                        // Stone ring around well
                        c.fillStyle = '#6B6B6B';
                        c.beginPath();
                        c.arc(wx, wy, T * 0.45, 0, 6.28);
                        c.fill();
                        
                        // Inner dark hole
                        c.fillStyle = '#1A1A1A';
                        c.beginPath();
                        c.arc(wx, wy, T * 0.3, 0, 6.28);
                        c.fill();
                        
                        // Water shimmer inside
                        c.fillStyle = '#3B9EDB';
                        c.beginPath();
                        c.arc(wx, wy - 2, T * 0.2, 0, 6.28);
                        c.fill();
                        
                        // Highlight on water
                        c.fillStyle = 'rgba(255,255,255,0.4)';
                        c.beginPath();
                        c.arc(wx - 4, wy - 4, T * 0.08, 0, 6.28);
                        c.fill();
                        
                        // Stone texture dots
                        c.fillStyle = '#888';
                        for(let i = 0; i < 6; i++) {
                            let angle = (i / 6) * Math.PI * 2;
                            let sx = wx + Math.cos(angle) * T * 0.35;
                            let sy = wy + Math.sin(angle) * T * 0.35;
                            c.beginPath();
                            c.arc(sx, sy, 2, 0, 6.28);
                            c.fill();
                        }
                    }
                }
                
                // Draw player - LOGICAL LARRY the cute caveman!
                if (Game.player) {
                    let px = Game.player.x * T + T/2;
                    let py = Game.player.y * T + T/2;
                    let scale = T/64;
                    let dir = Game.player.direction || 'down';
                    
                    // Check bash animation state
                    let isBashing = Game.player.bashTime && (performance.now() - Game.player.bashTime) < 300;
                    let bashProgress = isBashing ? (performance.now() - Game.player.bashTime) / 300 : 0;
                    let facing = (dir === 'right') ? 1 : (dir === 'left') ? -1 : 0;
                    
                    // Soft shadow under character
                    c.fillStyle = 'rgba(0,0,0,0.2)';
                    c.beginPath();
                    c.ellipse(px, py + 12*scale, 8*scale, 3*scale, 0, 0, 6.28);
                    c.fill();
                    
                    // === LOGICAL LARRY - Clean cute caveman ===
                    
                    // Small neat feet (brown fur boots)
                    c.fillStyle = '#8B6914';
                    c.beginPath();
                    c.ellipse(px - 4*scale, py + 10*scale, 3*scale, 2*scale, 0, 0, 6.28);
                    c.ellipse(px + 4*scale, py + 10*scale, 3*scale, 2*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#5D4510';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    // Short stubby legs
                    c.fillStyle = '#DDA675';
                    c.fillRect(px - 5*scale, py + 4*scale, 4*scale, 7*scale);
                    c.fillRect(px + 1*scale, py + 4*scale, 4*scale, 7*scale);
                    
                    // Body - brown fur tunic (clean rounded shape)
                    c.fillStyle = '#A0522D';
                    c.beginPath();
                    c.ellipse(px, py - 2*scale, 8*scale, 9*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#6B3A1E';
                    c.lineWidth = 1.5;
                    c.stroke();
                    
                    // Fur texture dots on tunic
                    c.fillStyle = '#8B4513';
                    c.beginPath();
                    c.arc(px - 3*scale, py - 4*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 2*scale, py + 1*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 4*scale, py - 3*scale, 1*scale, 0, 6.28);
                    c.fill();
                    
                    // Belt (bone belt!)
                    c.fillStyle = '#F5F5DC';
                    c.fillRect(px - 7*scale, py + 2*scale, 14*scale, 2*scale);
                    c.strokeStyle = '#B8A080';
                    c.lineWidth = 0.8;
                    c.strokeRect(px - 7*scale, py + 2*scale, 14*scale, 2*scale);
                    
                    // Cute round head
                    c.fillStyle = '#DDA675';
                    c.beginPath();
                    c.arc(px, py - 14*scale, 9*scale, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#B8865C';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Messy brown hair (clean tufts)
                    c.fillStyle = '#5D3A1A';
                    c.beginPath();
                    c.arc(px - 5*scale, py - 21*scale, 4*scale, 0, 6.28);
                    c.arc(px, py - 23*scale, 4*scale, 0, 6.28);
                    c.arc(px + 5*scale, py - 20*scale, 3.5*scale, 0, 6.28);
                    c.arc(px - 7*scale, py - 17*scale, 3*scale, 0, 6.28);
                    c.arc(px + 7*scale, py - 16*scale, 3*scale, 0, 6.28);
                    c.fill();
                    
                    // Eyes (big and friendly)
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.ellipse(px - 3*scale, py - 15*scale, 3*scale, 3.5*scale, 0, 0, 6.28);
                    c.ellipse(px + 3*scale, py - 15*scale, 3*scale, 3.5*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#333';
                    c.lineWidth = 0.8;
                    c.stroke();
                    
                    // Pupils (look in direction)
                    c.fillStyle = '#222';
                    c.beginPath();
                    c.arc(px - 3*scale + facing*scale, py - 15*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 3*scale + facing*scale, py - 15*scale, 1.5*scale, 0, 6.28);
                    c.fill();
                    
                    // Eye shine
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.arc(px - 3.5*scale + facing*0.5*scale, py - 16*scale, 0.7*scale, 0, 6.28);
                    c.arc(px + 2.5*scale + facing*0.5*scale, py - 16*scale, 0.7*scale, 0, 6.28);
                    c.fill();
                    
                    // Small nose
                    c.fillStyle = '#C9966C';
                    c.beginPath();
                    c.ellipse(px + facing*scale, py - 12*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                    c.fill();
                    
                    // Friendly smile
                    c.strokeStyle = '#804020';
                    c.lineWidth = 1.2;
                    c.beginPath();
                    c.arc(px, py - 9*scale, 3*scale, 0.3, 2.84);
                    c.stroke();
                    
                    // Stone club - with bash animation
                    c.save();
                    if(isBashing) {
                        let swingAngle = Math.sin(bashProgress * Math.PI) * -0.7;
                        c.translate(px + 10*scale, py - 6*scale);
                        c.rotate(swingAngle);
                        c.translate(-(px + 10*scale), -(py - 6*scale));
                    }
                    
                    // Club handle (wood)
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.roundRect(px + 8*scale, py - 8*scale, 3*scale, 14*scale, 1);
                    c.fill();
                    c.strokeStyle = '#5D4E3A';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    // Club head (stone)
                    c.fillStyle = '#808080';
                    c.beginPath();
                    c.ellipse(px + 10*scale, py - 10*scale, 5*scale, 6*scale, 0.2, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#555';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    c.restore();
                    
                    // Bash impact stars
                    if(isBashing && bashProgress > 0.3 && bashProgress < 0.7) {
                        c.fillStyle = '#FFD700';
                        let starX = px + 16*scale;
                        let starY = py + 4*scale;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.arc(starX + (i-1)*4*scale, starY + Math.sin(i)*3*scale, 2*scale, 0, 6.28);
                            c.fill();
                        }
                    }
                }
                
                // Draw ancient animals - PERFORMANCE OPTIMIZED version
                // Only render animals that are visible and limit detail based on zoom
                Game.animals.forEach((animal, idx) => {
                    // PERFORMANCE: Skip every other animal when zoomed out
                    if(cam.z < 0.5 && idx % 2 !== 0) return;
                    
                    let tile = Game.tiles[animal.x][animal.y];
                    if(!tile.explored) return;
                    
                    // PERFORMANCE: Skip if outside visible range
                    if(animal.x < sc - 1 || animal.x > ec + 1 || animal.y < sr - 1 || animal.y > er + 1) return;
                    
                    let ax = animal.x * T + T/2;
                    let ay = animal.y * T + T/2;
                    let scale = T/64;
                    
                    // PERFORMANCE: Simplified animation (only update every few frames)
                    let time = Math.floor(performance.now() / 100) / 10; // Quantized time
                    let uniqueOffset = (animal.x * 11 + animal.y * 17) % 100;
                    let headBob = Math.sin(time * 0.8 + uniqueOffset) * 2 * scale;
                    let breathe = Math.sin(time * 1.5 + uniqueOffset) * 1 * scale;
                    
                    // Get animal config
                    let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                    
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    
                    // PERFORMANCE: Simple shadow (no gradient)
                    c.fillStyle = 'rgba(0,0,0,0.2)';
                    c.beginPath();
                    c.ellipse(ax, ay + 16*scale, 12*scale, 4*scale, 0, 0, 6.28);
                    c.fill();
                    
                    if(animal.type === 'DEER') {
                        // SIMPLIFIED DEER - solid colors instead of gradients
                        
                        // Back legs
                        c.fillStyle = '#C8A070';
                        c.beginPath();
                        c.ellipse(ax - 8*scale, ay + 12*scale, 3*scale, 8*scale, 0.1, 0, 6.28);
                        c.ellipse(ax + 4*scale, ay + 12*scale, 3*scale, 8*scale, -0.1, 0, 6.28);
                        c.fill();
                        
                        // Hooves
                        c.fillStyle = '#4A3A2A';
                        c.beginPath();
                        c.ellipse(ax - 8*scale, ay + 19*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.ellipse(ax + 4*scale, ay + 19*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Main body - solid color
                        c.fillStyle = '#D4B890';
                        c.beginPath();
                        c.ellipse(ax - 2*scale, ay, 16*scale, 10*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Belly highlight
                        c.fillStyle = 'rgba(255,252,245,0.6)';
                        c.beginPath();
                        c.ellipse(ax - 2*scale, ay + 4*scale, 10*scale, 5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Front legs
                        c.fillStyle = '#C8A878';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 10*scale, 2.5*scale, 9*scale, 0.15, 0, 6.28);
                        c.ellipse(ax + 8*scale, ay + 10*scale, 2.5*scale, 9*scale, -0.15, 0, 6.28);
                        c.fill();
                        
                        // Front hooves
                        c.fillStyle = '#4A3A2A';
                        c.beginPath();
                        c.ellipse(ax - 11*scale, ay + 18*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.ellipse(ax + 9*scale, ay + 18*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Neck - solid
                        c.fillStyle = '#E8D8B8';
                        c.beginPath();
                        c.moveTo(ax + 6*scale, ay - 4*scale);
                        c.quadraticCurveTo(ax + 10*scale, ay - 14*scale, ax + 16*scale, ay - 16*scale);
                        c.quadraticCurveTo(ax + 20*scale, ay - 14*scale, ax + 18*scale, ay - 6*scale);
                        c.closePath();
                        c.fill();
                        
                        // Head - solid
                        c.fillStyle = '#D8C8A8';
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay - 16*scale + headBob, 7*scale, 5*scale, 0.3, 0, 6.28);
                        c.fill();
                        
                        // Snout
                        c.fillStyle = '#E8D8C0';
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay - 14*scale + headBob, 4*scale, 3*scale, 0.2, 0, 6.28);
                        c.fill();
                        
                        // Nose
                        c.fillStyle = '#3A2A1A';
                        c.beginPath();
                        c.ellipse(ax + 27*scale, ay - 14*scale + headBob, 1.5*scale, 1*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#2A1A0A';
                        c.beginPath();
                        c.ellipse(ax + 19*scale, ay - 17*scale + headBob, 2*scale, 2.5*scale, 0.1, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#FFF';
                        c.beginPath();
                        c.arc(ax + 18*scale, ay - 18*scale + headBob, 0.8*scale, 0, 6.28);
                        c.fill();
                        
                        // Ear
                        c.fillStyle = '#D8C098';
                        c.beginPath();
                        c.ellipse(ax + 14*scale, ay - 22*scale + headBob, 3*scale, 5*scale, -0.4, 0, 6.28);
                        c.fill();
                        
                        // Antlers
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 2.5;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(ax + 12*scale, ay - 20*scale);
                        c.quadraticCurveTo(ax + 8*scale, ay - 28*scale, ax + 6*scale, ay - 34*scale);
                        c.stroke();
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(ax + 10*scale, ay - 24*scale);
                        c.lineTo(ax + 4*scale, ay - 26*scale);
                        c.moveTo(ax + 8*scale, ay - 28*scale);
                        c.lineTo(ax + 2*scale, ay - 30*scale);
                        c.stroke();
                        
                        // White tail
                        c.fillStyle = '#FFF8F0';
                        c.beginPath();
                        c.ellipse(ax - 16*scale, ay - 2*scale, 4*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        
                    } else if(animal.type === 'BISON') {
                        // SIMPLIFIED BISON - solid colors
                        
                        // Back legs
                        c.fillStyle = '#5C4530';
                        c.beginPath();
                        c.moveTo(ax - 10*scale, ay + 6*scale);
                        c.lineTo(ax - 12*scale, ay + 18*scale);
                        c.lineTo(ax - 8*scale, ay + 18*scale);
                        c.lineTo(ax - 6*scale, ay + 6*scale);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#2A2018';
                        c.fillRect(ax - 12*scale, ay + 16*scale, 5*scale, 3*scale);
                        
                        // Rear body
                        c.fillStyle = '#6B5038';
                        c.beginPath();
                        c.ellipse(ax - 4*scale, ay + 2*scale, 14*scale, 10*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Front legs
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.moveTo(ax + 6*scale, ay + 6*scale);
                        c.lineTo(ax + 4*scale, ay + 18*scale);
                        c.lineTo(ax + 8*scale, ay + 18*scale);
                        c.lineTo(ax + 10*scale, ay + 6*scale);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#2A2018';
                        c.fillRect(ax + 4*scale, ay + 16*scale, 5*scale, 3*scale);
                        
                        // Massive hump
                        c.fillStyle = '#4A3820';
                        c.beginPath();
                        c.ellipse(ax + 6*scale, ay - 6*scale, 14*scale, 14*scale, -0.2, 0, 6.28);
                        c.fill();
                        
                        // Head
                        c.fillStyle = '#5C4830';
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay + 2*scale, 8*scale, 7*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Snout
                        c.fillStyle = '#5C4830';
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay + 5*scale, 5*scale, 4*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Nose
                        c.fillStyle = '#2A2018';
                        c.beginPath();
                        c.ellipse(ax + 27*scale, ay + 5*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#1A0A00';
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay - 1*scale, 2*scale, 1.8*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Horns
                        c.strokeStyle = '#3A3028';
                        c.lineWidth = 3.5;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(ax + 14*scale, ay - 4*scale);
                        c.quadraticCurveTo(ax + 10*scale, ay - 10*scale, ax + 14*scale, ay - 12*scale);
                        c.stroke();
                        
                    } else if(animal.type === 'MAMMOTH') {
                        // SIMPLIFIED MAMMOTH - solid colors
                        
                        // Back legs
                        c.fillStyle = '#5C4838';
                        c.beginPath();
                        c.moveTo(ax - 12*scale, ay + 8*scale);
                        c.lineTo(ax - 16*scale, ay + 22*scale);
                        c.lineTo(ax - 8*scale, ay + 22*scale);
                        c.lineTo(ax - 4*scale, ay + 8*scale);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 23*scale, 5*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Main body
                        c.fillStyle = '#6B5040';
                        c.beginPath();
                        c.ellipse(ax, ay + 2*scale, 22*scale, 16*scale, 0.05, 0, 6.28);
                        c.fill();
                        
                        // Front leg
                        c.fillStyle = '#5C4838';
                        c.beginPath();
                        c.moveTo(ax + 10*scale, ay + 10*scale);
                        c.lineTo(ax + 8*scale, ay + 22*scale);
                        c.lineTo(ax + 16*scale, ay + 22*scale);
                        c.lineTo(ax + 18*scale, ay + 10*scale);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax + 12*scale, ay + 23*scale, 5*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Shoulder hump
                        c.fillStyle = '#5A4030';
                        c.beginPath();
                        c.ellipse(ax + 6*scale, ay - 8*scale, 14*scale, 12*scale, -0.1, 0, 6.28);
                        c.fill();
                        
                        // Head
                        c.fillStyle = '#5A4030';
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay - 2*scale, 10*scale, 11*scale, 0.15, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#2A1A08';
                        c.beginPath();
                        c.ellipse(ax + 26*scale, ay - 6*scale, 2.5*scale, 2*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Trunk
                        c.fillStyle = '#6B5040';
                        c.beginPath();
                        c.moveTo(ax + 32*scale, ay + 2*scale);
                        c.quadraticCurveTo(ax + 40*scale, ay + 8*scale, ax + 38*scale, ay + 18*scale);
                        c.quadraticCurveTo(ax + 36*scale, ay + 24*scale, ax + 32*scale, ay + 22*scale);
                        c.quadraticCurveTo(ax + 30*scale, ay + 16*scale, ax + 32*scale, ay + 8*scale);
                        c.closePath();
                        c.fill();
                        
                        // Tusks
                        c.strokeStyle = '#F8F0E0';
                        c.lineWidth = 5;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(ax + 26*scale, ay + 4*scale);
                        c.quadraticCurveTo(ax + 32*scale, ay + 12*scale, ax + 26*scale, ay + 18*scale);
                        c.quadraticCurveTo(ax + 20*scale, ay + 22*scale, ax + 16*scale, ay + 18*scale);
                        c.stroke();
                        c.beginPath();
                        c.ellipse(ax, ay + 12*scale, 14*scale, 5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Back flippers
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 8*scale, 6*scale, 3*scale, -0.6, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 12*scale, ay + 8*scale, 6*scale, 3*scale, 0.6, 0, 6.28);
                        c.fill();
                        
                        // Shell (oval dome) with gradient
                        let shellGrad = c.createRadialGradient(ax - 2*scale, ay - 4*scale, 2*scale, ax, ay + 2*scale, 16*scale);
                        shellGrad.addColorStop(0, '#7CAA7C');
                        shellGrad.addColorStop(0.5, '#5A8A5A');
                        shellGrad.addColorStop(1, '#3D6B3D');
                        c.fillStyle = shellGrad;
                        c.beginPath();
                        c.ellipse(ax, ay, 14*scale, 10*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Shell border
                        c.strokeStyle = '#2D5B2D';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Shell pattern (hexagonal plates)
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1.5;
                        // Center plate
                        c.beginPath();
                        c.ellipse(ax, ay - 1*scale, 5*scale, 4*scale, 0, 0, 6.28);
                        c.stroke();
                        // Side plates
                        c.beginPath();
                        c.ellipse(ax - 7*scale, ay, 4*scale, 3*scale, 0.3, 0, 6.28);
                        c.stroke();
                        c.beginPath();
                        c.ellipse(ax + 7*scale, ay, 4*scale, 3*scale, -0.3, 0, 6.28);
                        c.stroke();
                        
                        // Front flippers
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 10*scale, ay - 4*scale, 8*scale, 4*scale, -0.8, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1;
                        c.stroke();
                        c.beginPath();
                        c.ellipse(ax + 10*scale, ay - 4*scale, 8*scale, 4*scale, 0.8, 0, 6.28);
                        c.fill();
                        c.stroke();
                        
                        // Head
                        let headGrad = c.createRadialGradient(ax + 14*scale, ay - 4*scale, 1*scale, ax + 16*scale, ay - 2*scale, 8*scale);
                        headGrad.addColorStop(0, '#8BC88B');
                        headGrad.addColorStop(1, '#5A8A5A');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 16*scale, ay - 3*scale, 6*scale, 5*scale, 0.2, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Cute eye
                        c.fillStyle = '#222';
                        c.beginPath();
                        c.arc(ax + 18*scale, ay - 5*scale, 2*scale, 0, 6.28);
                        c.fill();
                        // Eye shine
                        c.fillStyle = '#fff';
                        c.beginPath();
                        c.arc(ax + 18.5*scale, ay - 5.5*scale, 0.8*scale, 0, 6.28);
                        c.fill();
                        
                        // Cute smile
                        c.strokeStyle = '#3D6B3D';
                        c.lineWidth = 1.5;
                        c.beginPath();
                        c.arc(ax + 17*scale, ay - 1*scale, 2*scale, 0.2, Math.PI - 0.2);
                        c.stroke();
                        
                        // Tiny tail
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 15*scale, ay + 2*scale, 3*scale, 2*scale, -0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    // Show hit count with cute style
                    if(animal.hits > 0) {
                        // Red heart damage indicator
                        c.fillStyle = '#FF6060';
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText(`üíî ${animal.hits}/${config.hitToKill}`, ax, ay - 26*scale);
                    }
                });

                // Draw zoned residential buildings with road connection check
                for(let x=sc; x<ec; x++) {
                    for(let y=sr; y<er; y++) {
                        let tile = Game.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            this.drawZonedRes(c, x*T, y*T, tile.building, x, y);
                            
                            // Check road connection for residential zones
                            let hasRoad = false;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H && Game.tiles[nx][ny].road) {
                                        hasRoad = true;
                                        break;
                                    }
                                }
                                if(hasRoad) break;
                            }
                            // Draw "!" indicator if no road connection
                            if(!hasRoad) {
                                this.drawIcon(c, x*T + T/2, y*T + T/2, "!", "red");
                            }
                        }
                    }
                }

                // Draw build effects (e.g., dust clouds)
                const now = performance.now();
                // Remove expired effects
                this.effects = this.effects.filter(e => (now - e.start) < e.duration);
                for(const e of this.effects) {
                    if(e.type === 'dust') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.8;
                        const wobble = this.time * 1.5;
                        for(const puff of e.puffs) {
                            const baseR = puff.radius * T * (1 + 0.4*Math.sin(wobble + puff.angle * 2));
                            const dx = Math.cos(puff.angle) * baseR * (1 + 0.3*Math.sin(wobble + puff.angle));
                            const dy = Math.sin(puff.angle) * baseR * (1 + 0.3*Math.cos(wobble + puff.angle));
                            const size = T * (0.12 + 0.06*Math.sin(wobble + puff.angle)) * (1 - progress);
                            c.fillStyle = `rgba(240, 220, 200, ${alpha})`;
                            c.beginPath();
                            c.ellipse(cx + dx, cy + dy, size, size * 0.85, 0, 0, Math.PI*2);
                            c.fill();
                            c.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
                            c.lineWidth = 1;
                            c.stroke();
                        }
                    } else if(e.type === 'woodchips') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.9;
                        for(const chip of e.chips) {
                            const dist = T * chip.speed * progress * (0.7 + Math.random()*0.3);
                            const dx = Math.cos(chip.angle) * dist;
                            const dy = Math.sin(chip.angle) * dist;
                            const size = T * (0.07 + Math.random()*0.03) * (1 - progress*0.7);
                            c.save();
                            c.translate(cx + dx, cy + dy);
                            c.rotate(chip.angle + progress*2);
                            c.fillStyle = `rgba(180, 120, 60, ${alpha})`;
                            c.fillRect(-size/2, -size/6, size, size/3);
                            c.restore();
                        }
                    }
                }

                Game.blds.forEach(b => {
                    if (b.x < sc-2 || b.x > ec || b.y < sr-2 || b.y > er) return;
                    let bx = b.x * T, by = b.y * T;
                    // COM/IND/WELL/STORAGE_PITS are 1x1; others are 2x2
                    let size = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') ? T : 2 * T;
                    
                    // Only draw shadow for 2x2 buildings
                    if(size > T) {
                        c.fillStyle = "rgba(0,0,0,0.3)"; c.beginPath(); c.roundRect(bx+10, by+15, size-20, size-20, 10); c.fill();
                    }
                    
                    // Highlight if hovering
                    let isHover = Controller.mx >= b.x && Controller.mx < b.x + (size/T) && Controller.my >= b.y && Controller.my < b.y + (size/T);
                    if(isHover && Controller.tool === 'PAN') {
                        c.fillStyle = "rgba(255, 255, 0, 0.3)";
                        c.fillRect(bx, by, size, size);
                    }
                    
                    // Only draw base rect for 2x2 buildings (1x1 are handled in their draw functions)
                    if(size > T) {
                        c.fillStyle = CFG.COLORS[b.t]; c.beginPath(); c.roundRect(bx, by, size, size, 4); c.fill();
                    }
                    
                    if (b.t === 'COM') this.drawCom(c, bx, by, b);
                    else if (b.t === 'IND') this.drawInd(c, bx, by, b);
                    else if (b.t === 'CHIEF') this.drawChief(c, bx, by, b);
                    else if (b.t === 'CLAN_CHIEF') this.drawClanChief(c, bx, by, b);
                    else if (b.t === 'DOCK') this.drawDock(c, bx, by, b);
                    else if (b.t === 'WELL') this.drawWell(c, bx, by, b);
                    else if (b.t === 'BASKET') this.drawBasket(c, bx, by, b);
                    else if (b.t === 'POTTERY') this.drawPottery(c, bx, by, b);
                    else if (b.t === 'GRANARY') this.drawGranary(c, bx, by, b);
                    else if (b.t === 'PALACE') this.drawPalace(c, bx, by, b);
                    else if (b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') this.drawStoragePit(c, bx, by, b);

                    // Show building info on hover
                    if(isHover && Controller.tool === 'PAN') {
                        let upgradeCost = Game.getUpgradeCost(b.lvl);
                        let effPct = Math.floor(b.efficiency * 100);
                        let effColor = b.efficiency > 0.8 ? 'üü¢' : (b.efficiency > 0.4 ? 'üü°' : 'üî¥');
                        
                        let infoText = `L${b.lvl} ${effColor}${effPct}%`;
                        if(b.t === 'COM' || b.t === 'IND') infoText += ` | ${Math.floor(Game.getBuildingProduction(b) * b.efficiency)}`;
                        if(b.lvl < 200) infoText += ` | ‚Üë$${Math.floor(upgradeCost)}`;
                        if(!b.conn) infoText += ' | ‚ö†Ô∏èNO ROAD';
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.9)";
                        c.fillRect(bx - 10, by - 30, size + 20, 25);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 9px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(infoText, bx + size/2, by - 17);
                    }

                    // Don't draw white box around buildings
                    if (b.t !== 'RES' && !b.conn) this.drawIcon(c, bx + size/2, by + size/2, "!", "red");
                });

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // TINY NEOLITHIC PEOPLE - Walking between zones and along roads
                // PERFORMANCE: Skip when zoomed out
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(cam.z >= 0.5) {
                    this.updateTinyPeople(Game, sc, ec, sr, er);
                    this.drawTinyPeople(c, T);
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // BUILDING MICRO-ANIMATIONS - Smoke, flames, ripples
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.drawBuildingAnimations(c, Game, sc, ec, sr, er, T, cam);

                this.drawParticles(c);

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SIMCITY-STYLE PAINT TRAIL: Show painted tiles while dragging
                // Includes smooth connecting lines and pulsing cursor
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(Controller.zoneDrag && Controller.zoneDragBuilt && Controller.zoneDragBuilt.size > 0) {
                    const trailColors = {
                        'ROAD': 'rgba(150, 150, 150, 0.6)',
                        'RES': 'rgba(76, 175, 80, 0.6)',   // Green
                        'COM': 'rgba(33, 150, 243, 0.6)',  // Blue
                        'IND': 'rgba(255, 193, 7, 0.6)'    // Yellow
                    };
                    let trailColor = trailColors[Controller.zoneDragTool] || 'rgba(255, 255, 255, 0.6)';
                    
                    // Draw all painted tiles with glow effect
                    c.shadowBlur = 15;
                    c.shadowColor = trailColor;
                    c.fillStyle = trailColor;
                    for(let key of Controller.zoneDragBuilt) {
                        let [px, py] = key.split(',').map(Number);
                        c.fillRect(px * T, py * T, T, T);
                    }
                    c.shadowBlur = 0;
                    
                    // Animated pulsing glow on current cursor position
                    let pulse = 0.7 + 0.3 * Math.sin(performance.now() / 100);
                    let glowColor = trailColor.replace('0.6', String(pulse));
                    c.strokeStyle = glowColor;
                    c.lineWidth = 5;
                    c.shadowBlur = 20;
                    c.shadowColor = glowColor;
                    c.strokeRect(Controller.mx * T + 2, Controller.my * T + 2, T - 4, T - 4);
                    c.shadowBlur = 0;
                    
                    // Draw count indicator
                    c.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    c.fillRect(10, 10, 200, 40);
                    c.fillStyle = '#fff';
                    c.font = 'bold 18px Arial';
                    const toolNames = {'ROAD': 'üõ£Ô∏è Roads', 'RES': 'üè† Residential', 'COM': 'üè™ Commercial', 'IND': 'üè≠ Industrial'};
                    let toolName = toolNames[Controller.zoneDragTool] || 'Building';
                    c.fillText(`Painting ${toolName}: ${Controller.zoneDragCount}`, 20, 35);
                }

                if (Controller.tool !== 'PAN' && Controller.tool !== 'NONE') {
                    let gx = Controller.mx, gy = Controller.my;
                    // All zones are 1x1 (ROAD, WELL, BULL, RES, COM, IND, DEMOLISH), only special buildings are 2x2
                    let sz = (Controller.tool=='ROAD'||Controller.tool=='WELL'||Controller.tool=='BULL'||Controller.tool=='RES'||Controller.tool=='COM'||Controller.tool=='IND'||Controller.tool=='DEMOLISH')?1:2;
                    let dx = gx; let dy = gy;
                    
                    let valid = true;
                    if (Controller.tool === 'BULL') valid = Game.blds.some(b => {
                        // COM, IND, WELL are 1x1 per documentation
                        let bSz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2;
                        return gx>=b.x && gx<b.x+bSz && gy>=b.y && gy<b.y+bSz;
                    }) || Game.tiles[gx][gy].road || Game.tiles[gx][gy].zone;
                    else valid = Game.isValid(dx, dy, Controller.tool);

                    c.fillStyle = valid ? CFG.COLORS.OK : CFG.COLORS.NO;
                    c.fillRect(dx*T, dy*T, sz*T, sz*T);
                    // Cursor border matches fill color for cleaner look
                    c.strokeStyle = valid ? "rgba(76, 175, 80, 0.8)" : "rgba(244, 67, 54, 0.8)";
                    c.lineWidth = 3;
                    c.strokeRect(dx*T, dy*T, sz*T, sz*T);
                    
                    // PREVIEW: Show estimated capacity for RES zones
                    if(Controller.tool === 'RES' && valid) {
                        let previewDesirability = Game.calculateDesirability(dx, dy, sz);
                        let startEra = CFG.ERAS[0];
                        let previewCap = Math.floor(startEra.capacity * previewDesirability);
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.85)";
                        c.fillRect(dx*T, dy*T - 40, sz*T, 35);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 11px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(`Zone: ${startEra.name}`, dx*T + sz*T/2, dy*T - 28);
                        c.font = "10px sans-serif";
                        c.fillStyle = previewDesirability > 1.5 ? "#4CAF50" : (previewDesirability > 1.0 ? "#FFC107" : "#FF5252");
                        c.fillText(`Est. Capacity: ${previewCap}`, dx*T + sz*T/2, dy*T - 17);
                        c.font = "9px sans-serif";
                        c.fillStyle = "#FFFFFF";
                        c.fillText(`Desirability: ${Math.floor(previewDesirability*100)}%`, dx*T + sz*T/2, dy*T - 6);
                    }
                }
                c.restore();
            },
            drawRoad(c, x, y, T) {
                // Wider, more realistic grey path
                const tx = x * T, ty = y * T;
                const cx = tx + T/2, cy = ty + T/2;
                const lineWidth = Math.max(8, Math.floor(T * 0.26));

                // Neighbor connections
                const up = (y > 0) && !!Game.tiles[x][y-1].road;
                const down = (y < CFG.H - 1) && !!Game.tiles[x][y+1].road;
                const left = (x > 0) && !!Game.tiles[x-1][y].road;
                const right = (x < CFG.W - 1) && !!Game.tiles[x+1][y].road;

                // Main center stroke (dark grey)
                c.lineCap = 'round';
                c.lineJoin = 'round';
                c.strokeStyle = '#555555';
                c.lineWidth = lineWidth + 2;
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                // Always draw the short center stub so isolated tiles look rounded
                c.moveTo(cx, cy);
                c.lineTo(cx + 0.01, cy + 0.01);
                c.stroke();

                // Lighter inner strip to suggest compacted dirt
                c.strokeStyle = '#7a7a7a';
                c.lineWidth = Math.max(4, Math.floor(lineWidth * 0.5));
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                c.stroke();

                // Subtle edge shading for realism
                c.lineWidth = 1.5;
                c.strokeStyle = 'rgba(0,0,0,0.25)';
                if (up) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty); c.stroke(); }
                if (down) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty + T); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty + T); c.stroke(); }
                if (left) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx, cy + lineWidth/2); c.stroke(); }
                if (right) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx + T, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx + T, cy + lineWidth/2); c.stroke(); }

                // Deterministic speckles/pebbles along path (seeded by coords)
                const seed = ((x * 73856093) ^ (y * 19349663)) >>> 0;
                const rand = (n) => Math.abs(Math.sin(seed + n) * 10000) % 1;
                c.fillStyle = '#666';
                for (let i = 0; i < 4; i++) {
                    let t = 0.2 + i * 0.2 + rand(i) * 0.1; // position along axis
                    let px = cx + ( (left || right) ? (t - 0.5) * T : 0 );
                    let py = cy + ( (up || down) ? (t - 0.5) * T : 0 );
                    // offset perpendicular
                    let ox = (rand(i+10) - 0.5) * lineWidth * 0.6;
                    let oy = (rand(i+20) - 0.5) * lineWidth * 0.6;
                    if (left || right) { py = cy; px = tx + t * T; oy = (rand(i+20)-0.5) * lineWidth * 0.2; }
                    if (up || down) { px = cx; py = ty + t * T; ox = (rand(i+10)-0.5) * lineWidth * 0.2; }
                    c.beginPath();
                    c.ellipse(px + ox, py + oy, Math.max(1, Math.floor(lineWidth*0.12)), Math.max(1, Math.floor(lineWidth*0.08)), 0, 0, 6.28);
                    c.fill();
                }
            },
            drawWaterAnim(c, x, y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.strokeStyle = "rgba(255,255,255,0.2)"; c.lineWidth = 2*scale; 
                let offset = Math.sin(this.time + x) * 5*scale; 
                c.beginPath(); 
                c.moveTo(x*T+10*scale, y*T+T/2+offset); 
                c.quadraticCurveTo(x*T+T/2, y*T+20*scale+offset, x*T+54*scale, y*T+T/2+offset); 
                c.stroke(); 
            },
            drawStoneDeposit(c, x, y, deposit) {
                let T = CFG.TILE;
                let cx = x + T/2;
                let cy = y + T*0.7;
                let scale = T/64;
                
                // Determine color based on metal value (gradient from gray to gold)
                let metalValue = deposit.metal;
                let ratio = (metalValue - CFG.STONE_DEPOSITS.MIN_METAL) / (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL);
                
                // Color progression: Gray -> Blue -> Purple -> Gold
                let r, g, b;
                if(ratio < 0.33) {
                    // Gray to Blue
                    let t = ratio / 0.33;
                    r = Math.floor(120 + (80 - 120) * t);
                    g = Math.floor(120 + (160 - 120) * t);
                    b = Math.floor(120 + (240 - 120) * t);
                } else if(ratio < 0.66) {
                    // Blue to Purple
                    let t = (ratio - 0.33) / 0.33;
                    r = Math.floor(80 + (180 - 80) * t);
                    g = Math.floor(160 + (80 - 160) * t);
                    b = Math.floor(240 + (200 - 240) * t);
                } else {
                    // Purple to Gold
                    let t = (ratio - 0.66) / 0.34;
                    r = Math.floor(180 + (255 - 180) * t);
                    g = Math.floor(80 + (215 - 80) * t);
                    b = Math.floor(200 + (0 - 200) * t);
                }
                
                let baseColor = `rgb(${r},${g},${b})`;
                let darkColor = `rgb(${Math.floor(r*0.6)},${Math.floor(g*0.6)},${Math.floor(b*0.6)})`;
                let lightColor = `rgb(${Math.min(255, Math.floor(r*1.4))},${Math.min(255, Math.floor(g*1.4))},${Math.min(255, Math.floor(b*1.4))})`;
                
                // Shadow
                c.fillStyle = 'rgba(0,0,0,0.4)';
                c.beginPath();
                c.ellipse(cx + 4*scale, cy + 10*scale, 18*scale, 8*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - black outline
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy, 22*scale, 20*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - colored
                c.fillStyle = baseColor;
                c.beginPath();
                c.ellipse(cx, cy, 20*scale, 18*scale, 0, 0, 6.28);
                c.fill();
                
                // Dark patch (bottom right)
                c.fillStyle = darkColor;
                c.beginPath();
                c.ellipse(cx + 8*scale, cy + 6*scale, 8*scale, 7*scale, 0, 0, 6.28);
                c.fill();
                
                // Bright highlight (top left)
                c.fillStyle = lightColor;
                c.beginPath();
                c.ellipse(cx - 6*scale, cy - 6*scale, 8*scale, 7*scale, 0.3, 0, 6.28);
                c.fill();
                
                // Shine spot (Mario-style)
                c.fillStyle = 'rgba(255,255,255,0.8)';
                c.beginPath();
                c.ellipse(cx - 8*scale, cy - 8*scale, 4*scale, 3*scale, -0.3, 0, 6.28);
                c.fill();
                
                // Smaller shine
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.beginPath();
                c.arc(cx + 4*scale, cy - 4*scale, 2*scale, 0, 6.28);
                c.fill();
                
                // Metal value shown in tooltip on hover, not displayed on tile
            },
            drawTree(c, x, y, t) {
                // VICTORIAN MAP STYLE TREES - Small cartographic clusters
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;
                let seed = ((x/T) * 7 + (y/T) * 13) % 100;
                let numTrees = 2 + (seed % 3);
                let inkColor = 'rgba(60,80,50,0.9)';
                c.fillStyle = inkColor;
                c.lineWidth = 1;
                
                if(t == 'PINE' || t == 'SNOW') {
                    for(let i = 0; i < numTrees; i++) {
                        let tx = x + T*0.2 + (seed + i*31) % (T*0.6);
                        let ty = y + T*0.3 + ((seed + i*17) % (T*0.5));
                        let size = 4 + (i % 2) * 2;
                        c.beginPath();
                        c.moveTo(tx, ty - size);
                        c.lineTo(tx - size*0.6, ty + size*0.3);
                        c.lineTo(tx + size*0.6, ty + size*0.3);
                        c.closePath();
                        c.fill();
                    }
                } else {
                    for(let i = 0; i < numTrees; i++) {
                        let tx = x + T*0.15 + (seed + i*23) % (T*0.7);
                        let ty = y + T*0.25 + ((seed + i*19) % (T*0.5));
                        let size = 3 + (i % 2) * 1.5;
                        c.strokeStyle = 'rgba(100,80,50,0.8)';
                        c.beginPath();
                        c.moveTo(tx, ty);
                        c.lineTo(tx, ty + size);
                        c.stroke();
                        c.fillStyle = inkColor;
                        c.beginPath();
                        c.arc(tx, ty - size*0.3, size, 0, 6.28);
                        c.fill();
                    }
                }
            },
            drawZonedRes(c, x, y, bld, gridX, gridY) {
                let lvl = bld.level || 0;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;
                let desirability = bld.desirability || 1.0;
                
                // Check if within Chief's Hut radius for gold border
                let hasChiefBonus = false;
                let chiefHuts = Game.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(gridX - chief.x, 2) + Math.pow(gridY - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChiefBonus = true;
                        break;
                    }
                }
                
                // Get building level info from BUILDING_LEVELS config (not ERAS)
                let buildingConfig = CFG.BUILDING_LEVELS[lvl] || CFG.BUILDING_LEVELS[0];
                let era = { name: buildingConfig.name }; // Use building name, not era name
                
                // LEVEL 0 EVOLUTION VARIANTS
                // (Level 0 is Wanderer/Empty, so we don't draw buildings for it usually)
                
                // Ensure variant is set (default to deterministic random if missing)
                if (bld.variant === undefined) {
                    bld.variant = (gridX + gridY * 57) % 4;
                }
                let variant = bld.variant;

                // === BIRDS EYE VIEW MODE ===
                if(Game.vm === 'BIRDSEYE') {
                    // === SNES SIMCITY STYLE RESIDENTIAL ===
                    // Each level has a distinctly different cute look
                    
                    // Cute shadow for depth
                    c.fillStyle = 'rgba(0,0,0,0.2)';
                    c.beginPath();
                    c.ellipse(cx + 3, cy + T*0.2, T*0.35, T*0.15, 0, 0, 6.28);
                    c.fill();

                    if(lvl === 1) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 1: AMAZONIAN TREE SHELTER - 4-State Variant System
                        // V0 = Abandoned: Collapsed platform, fallen thatch, dead tree, gray/rotted
                        // V1 = Low Activity: Worn but functional, partial roof, basic structure
                        // V2 = Medium Activity: Well-maintained, good roof, vines, some decoration
                        // V3 = High Activity: Thriving, lush canopy, fireflies, decorations, people
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const isAbandoned = variant === 0;
                        const isLow = variant === 1;
                        const isMedium = variant === 2;
                        const isHigh = variant === 3;
                        
                        // Animation speeds vary by variant (abandoned = still, high = lively)
                        const swayAmount = isAbandoned ? 0 : (isLow ? 0.006 : (isMedium ? 0.012 : 0.018));
                        const sway = Math.sin(t * 0.5) * swayAmount;
                        const leafRustle = Math.sin(t * 1.8) * (isAbandoned ? 0 : (isLow ? 0.008 : 0.018));
                        
                        // === VARIANT-BASED COLOR PALETTE ===
                        // V0: Gray/dead tones, V1: Faded browns, V2: Warm browns, V3: Rich earth tones
                        const barkDark = isAbandoned ? '#2A2A2A' : (isLow ? '#2D1810' : (isMedium ? '#3D2820' : '#4D3830'));
                        const barkMid = isAbandoned ? '#4A4A4A' : (isLow ? '#4A3525' : (isMedium ? '#5A4535' : '#6A5545'));
                        const barkLight = isAbandoned ? '#6A6A6A' : (isLow ? '#6D5040' : (isMedium ? '#7D6050' : '#8D7060'));
                        const logMain = isAbandoned ? '#5A5A5A' : (isLow ? '#5D4037' : (isMedium ? '#6D5047' : '#8D7067'));
                        const logDark = isAbandoned ? '#3A3A3A' : (isLow ? '#3E2723' : (isMedium ? '#4E3733' : '#5E4743'));
                        const logHighlight = isAbandoned ? '#7A7A7A' : '#9D8070';
                        // Vines/plants: dead gray for V0, sparse for V1, lush for V2-V3
                        const vineColor = isAbandoned ? '#4A4A3A' : (isLow ? '#3A5020' : '#4A6030');
                        const ropeColor = isAbandoned ? '#6A6A5A' : '#8B7355';
                        // Thatch: rotted gray for V0, worn for V1, good for V2+
                        const thatchDark = isAbandoned ? '#4A4A3A' : (isLow ? '#4A5B20' : '#5A6B30');
                        const thatchMid = isAbandoned ? '#5A5A4A' : (isLow ? '#6A7B35' : '#7A8B45');
                        const thatchLight = isAbandoned ? '#7A7A6A' : (isLow ? '#8A9B50' : '#9AAB60');
                        const palmGreen = isAbandoned ? '#3A3A2A' : (isLow ? '#2D5B15' : (isMedium ? '#3D6B25' : '#4D7B35'));
                        const palmLight = isAbandoned ? '#5A5A4A' : (isLow ? '#4D7B35' : '#5D8B45');
                        
                        // === TREE TRUNK (condition varies by variant) ===
                        // Shadow at base
                        c.fillStyle = `rgba(0,0,0,${isAbandoned ? 0.25 : 0.4})`;
                        c.beginPath();
                        c.ellipse(cx + T*0.02, cy + T*0.38, T*0.22, T*0.06, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Root buttresses (massive jungle tree roots)
                        c.fillStyle = barkDark;
                        // Left buttress root
                        c.beginPath();
                        c.moveTo(cx - T*0.25, cy + T*0.35);
                        c.quadraticCurveTo(cx - T*0.22, cy + T*0.15, cx - T*0.12, cy + T*0.05);
                        c.lineTo(cx - T*0.08, cy + T*0.08);
                        c.quadraticCurveTo(cx - T*0.15, cy + T*0.2, cx - T*0.18, cy + T*0.35);
                        c.closePath();
                        c.fill();
                        // Right buttress root
                        c.beginPath();
                        c.moveTo(cx + T*0.25, cy + T*0.35);
                        c.quadraticCurveTo(cx + T*0.22, cy + T*0.15, cx + T*0.12, cy + T*0.05);
                        c.lineTo(cx + T*0.08, cy + T*0.08);
                        c.quadraticCurveTo(cx + T*0.15, cy + T*0.2, cx + T*0.18, cy + T*0.35);
                        c.closePath();
                        c.fill();
                        
                        // Main trunk (tapers upward with natural curve)
                        let trunkGrad = c.createLinearGradient(cx - T*0.15, cy, cx + T*0.15, cy);
                        trunkGrad.addColorStop(0, barkDark);
                        trunkGrad.addColorStop(0.3, barkMid);
                        trunkGrad.addColorStop(0.7, barkLight);
                        trunkGrad.addColorStop(1, barkMid);
                        c.fillStyle = trunkGrad;
                        c.beginPath();
                        c.moveTo(cx - T*0.14, cy + T*0.35);
                        c.quadraticCurveTo(cx - T*0.12 + sway*T, cy + T*0.1, cx - T*0.1, cy - T*0.1);
                        c.lineTo(cx - T*0.07, cy - T*0.42);
                        c.lineTo(cx + T*0.07, cy - T*0.42);
                        c.lineTo(cx + T*0.1, cy - T*0.1);
                        c.quadraticCurveTo(cx + T*0.12 + sway*T, cy + T*0.1, cx + T*0.14, cy + T*0.35);
                        c.closePath();
                        c.fill();
                        
                        // Bark texture (deep vertical crevices)
                        c.strokeStyle = barkDark;
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 8; i++) {
                            let bx = cx - T*0.1 + (i * T*0.028);
                            let offset = Math.sin(i * 0.8) * T*0.01;
                            c.beginPath();
                            c.moveTo(bx + offset, cy + T*0.3);
                            c.bezierCurveTo(bx + offset + sway*T, cy + T*0.1, bx - offset, cy - T*0.1, bx + offset*0.5, cy - T*0.35);
                            c.stroke();
                        }
                        
                        // Bark knots and burls
                        c.fillStyle = barkDark;
                        c.beginPath();
                        c.ellipse(cx + T*0.04, cy + T*0.12, T*0.025, T*0.035, 0.3, 0, Math.PI*2);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx - T*0.05, cy - T*0.05, T*0.02, T*0.025, -0.2, 0, Math.PI*2);
                        c.fill();
                        // Knot rings
                        c.strokeStyle = '#2A1A10';
                        c.lineWidth = 0.5;
                        c.beginPath();
                        c.arc(cx + T*0.04, cy + T*0.12, T*0.012, 0, Math.PI*2);
                        c.stroke();
                        
                        // Moss patches on trunk (green for active, gray/dead for abandoned)
                        if(!isAbandoned) {
                            c.fillStyle = isLow ? 'rgba(60,100,40,0.4)' : 'rgba(80,120,50,0.5)';
                            c.beginPath();
                            c.ellipse(cx - T*0.08, cy + T*0.18, T*0.03, T*0.05, -0.3, 0, Math.PI*2);
                            c.fill();
                            c.beginPath();
                            c.ellipse(cx + T*0.06, cy - T*0.02, T*0.025, T*0.04, 0.4, 0, Math.PI*2);
                            c.fill();
                        } else {
                            // Dead gray lichen for abandoned
                            c.fillStyle = 'rgba(90,90,80,0.4)';
                            c.beginPath();
                            c.ellipse(cx - T*0.08, cy + T*0.18, T*0.025, T*0.04, -0.3, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === MAIN SUPPORT BRANCHES (V0: one broken branch) ===
                        // Left main branch
                        c.fillStyle = barkMid;
                        c.beginPath();
                        c.moveTo(cx - T*0.08, cy + T*0.02);
                        c.quadraticCurveTo(cx - T*0.2, cy - T*0.05, cx - T*0.38, cy - T*0.12);
                        c.lineTo(cx - T*0.36, cy - T*0.18);
                        c.quadraticCurveTo(cx - T*0.18, cy - T*0.12, cx - T*0.06, cy - T*0.04);
                        c.closePath();
                        c.fill();
                        // Branch bark texture
                        c.strokeStyle = barkDark;
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx - T*0.1, cy - T*0.01);
                        c.quadraticCurveTo(cx - T*0.22, cy - T*0.08, cx - T*0.34, cy - T*0.14);
                        c.stroke();
                        
                        // Right main branch (broken stub for abandoned)
                        if(isAbandoned) {
                            // Broken branch stub
                            c.fillStyle = barkMid;
                            c.beginPath();
                            c.moveTo(cx + T*0.08, cy + T*0.02);
                            c.quadraticCurveTo(cx + T*0.15, cy - T*0.03, cx + T*0.22, cy - T*0.06);
                            c.lineTo(cx + T*0.2, cy - T*0.1);
                            c.quadraticCurveTo(cx + T*0.12, cy - T*0.06, cx + T*0.06, cy - T*0.04);
                            c.closePath();
                            c.fill();
                            // Broken end (jagged)
                            c.fillStyle = '#5A4A3A';
                            c.beginPath();
                            c.moveTo(cx + T*0.2, cy - T*0.1);
                            c.lineTo(cx + T*0.24, cy - T*0.08);
                            c.lineTo(cx + T*0.22, cy - T*0.06);
                            c.closePath();
                            c.fill();
                            // Fallen branch on ground
                            c.fillStyle = '#4A4A4A';
                            c.beginPath();
                            c.ellipse(cx + T*0.3, cy + T*0.35, T*0.12, T*0.03, 0.3, 0, Math.PI*2);
                            c.fill();
                        } else {
                            c.fillStyle = barkMid;
                            c.beginPath();
                            c.moveTo(cx + T*0.08, cy + T*0.02);
                            c.quadraticCurveTo(cx + T*0.2, cy - T*0.05, cx + T*0.38, cy - T*0.12);
                            c.lineTo(cx + T*0.36, cy - T*0.18);
                            c.quadraticCurveTo(cx + T*0.18, cy - T*0.12, cx + T*0.06, cy - T*0.04);
                            c.closePath();
                            c.fill();
                            c.strokeStyle = barkDark;
                            c.beginPath();
                            c.moveTo(cx + T*0.1, cy - T*0.01);
                            c.quadraticCurveTo(cx + T*0.22, cy - T*0.08, cx + T*0.34, cy - T*0.14);
                            c.stroke();
                        }
                        
                        // === DIAGONAL SUPPORT POLES (V0: broken/missing) ===
                        c.strokeStyle = logDark;
                        c.lineWidth = 4;
                        c.lineCap = 'round';
                        // Left diagonal brace (always present)
                        c.beginPath();
                        c.moveTo(cx - T*0.32, cy - T*0.08);
                        c.lineTo(cx - T*0.08, cy + T*0.15);
                        c.stroke();
                        // Right diagonal brace (broken for V0)
                        if(!isAbandoned) {
                            c.beginPath();
                            c.moveTo(cx + T*0.32, cy - T*0.08);
                            c.lineTo(cx + T*0.08, cy + T*0.15);
                            c.stroke();
                        } else {
                            // Broken brace hanging
                            c.beginPath();
                            c.moveTo(cx + T*0.15, cy + T*0.05);
                            c.lineTo(cx + T*0.08, cy + T*0.15);
                            c.stroke();
                            // Fallen piece on ground
                            c.fillStyle = '#4A4A4A';
                            c.fillRect(cx + T*0.2, cy + T*0.38, T*0.15, T*0.025);
                        }
                        
                        // === LOG PLATFORM FLOOR (V0: holes/missing logs) ===
                        // Platform underside shadow
                        c.fillStyle = 'rgba(0,0,0,0.35)';
                        c.beginPath();
                        c.moveTo(cx - T*0.4, cy + T*0.06);
                        c.lineTo(cx + T*0.4, cy + T*0.06);
                        c.lineTo(cx + T*0.38, cy + T*0.12);
                        c.lineTo(cx - T*0.38, cy + T*0.12);
                        c.closePath();
                        c.fill();
                        
                        // Cross-beam supports under platform
                        c.fillStyle = logDark;
                        c.fillRect(cx - T*0.35, cy + T*0.0, T*0.7, T*0.025);
                        if(!isAbandoned) {
                            c.fillRect(cx - T*0.32, cy + T*0.03, T*0.64, T*0.02);
                        }
                        
                        // Individual platform logs (V0: skip some for holes)
                        const missingLogs = isAbandoned ? [2, 5] : (isLow ? [4] : []);
                        for(let i = 0; i < 7; i++) {
                            // Skip missing logs for abandoned/low variants
                            if(missingLogs.includes(i)) {
                                // Draw hole shadow instead
                                if(isAbandoned) {
                                    c.fillStyle = 'rgba(0,0,0,0.5)';
                                    let logY = cy - T*0.15 + i * T*0.032;
                                    c.fillRect(cx - T*0.15, logY - T*0.014, T*0.3, T*0.028);
                                }
                                continue;
                            }
                            
                            let logY = cy - T*0.15 + i * T*0.032;
                            let logVariation = (i * 17 + variant) % 3;
                            let thisLogColor = logVariation === 0 ? logMain : logVariation === 1 ? logDark : logHighlight;
                            let logWidth = isAbandoned ? T*0.65 : T*0.72 + (Math.sin(i) * T*0.02);
                            
                            // Log shadow
                            c.fillStyle = 'rgba(0,0,0,0.15)';
                            c.fillRect(cx - logWidth/2 + T*0.01, logY - T*0.012 + T*0.005, logWidth, T*0.028);
                            
                            // Main log body
                            c.fillStyle = thisLogColor;
                            c.fillRect(cx - logWidth/2, logY - T*0.014, logWidth, T*0.028);
                            
                            // Log end grain (left)
                            c.beginPath();
                            c.ellipse(cx - logWidth/2, logY, T*0.022, T*0.014, 0, 0, Math.PI*2);
                            c.fill();
                            // Inner rings on end grain
                            c.strokeStyle = logDark;
                            c.lineWidth = 0.5;
                            c.beginPath();
                            c.arc(cx - logWidth/2, logY, T*0.008, 0, Math.PI*2);
                            c.stroke();
                            c.beginPath();
                            c.arc(cx - logWidth/2, logY, T*0.015, 0, Math.PI*2);
                            c.stroke();
                            
                            // Log end grain (right)
                            c.fillStyle = thisLogColor;
                            c.beginPath();
                            c.ellipse(cx + logWidth/2, logY, T*0.022, T*0.014, 0, 0, Math.PI*2);
                            c.fill();
                            c.strokeStyle = logDark;
                            c.beginPath();
                            c.arc(cx + logWidth/2, logY, T*0.008, 0, Math.PI*2);
                            c.stroke();
                            c.beginPath();
                            c.arc(cx + logWidth/2, logY, T*0.015, 0, Math.PI*2);
                            c.stroke();
                            
                            // Wood grain lines on log surface
                            c.strokeStyle = 'rgba(0,0,0,0.12)';
                            c.lineWidth = 0.5;
                            c.beginPath();
                            c.moveTo(cx - logWidth/2 + T*0.05, logY - T*0.003);
                            c.lineTo(cx + logWidth/2 - T*0.05, logY - T*0.003 + Math.sin(i)*T*0.002);
                            c.stroke();
                        }
                        
                        // === ROPE/VINE LASHINGS (detailed wrapping) ===
                        // Left lashing cluster
                        c.strokeStyle = ropeColor;
                        c.lineWidth = 2.5;
                        c.lineCap = 'round';
                        // Vertical wraps
                        for(let w = 0; w < 4; w++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.3 + w*T*0.015, cy - T*0.14);
                            c.lineTo(cx - T*0.3 + w*T*0.015, cy + T*0.0);
                            c.stroke();
                        }
                        // X-lashing pattern
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx - T*0.34, cy - T*0.1);
                        c.lineTo(cx - T*0.24, cy - T*0.02);
                        c.moveTo(cx - T*0.24, cy - T*0.1);
                        c.lineTo(cx - T*0.34, cy - T*0.02);
                        c.stroke();
                        // Knot
                        c.fillStyle = ropeColor;
                        c.beginPath();
                        c.arc(cx - T*0.29, cy - T*0.06, T*0.022, 0, Math.PI*2);
                        c.fill();
                        c.strokeStyle = '#6A5335';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Right lashing cluster
                        c.strokeStyle = ropeColor;
                        c.lineWidth = 2.5;
                        for(let w = 0; w < 4; w++) {
                            c.beginPath();
                            c.moveTo(cx + T*0.27 + w*T*0.015, cy - T*0.14);
                            c.lineTo(cx + T*0.27 + w*T*0.015, cy + T*0.0);
                            c.stroke();
                        }
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx + T*0.24, cy - T*0.1);
                        c.lineTo(cx + T*0.34, cy - T*0.02);
                        c.moveTo(cx + T*0.34, cy - T*0.1);
                        c.lineTo(cx + T*0.24, cy - T*0.02);
                        c.stroke();
                        c.fillStyle = ropeColor;
                        c.beginPath();
                        c.arc(cx + T*0.29, cy - T*0.06, T*0.022, 0, Math.PI*2);
                        c.fill();
                        c.strokeStyle = '#6A5335';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // === RAILING POSTS AND RAILS (V0: broken/fallen) ===
                        c.fillStyle = logDark;
                        const railY = cy - T*0.22;
                        const deckY = cy - T*0.15;
                        
                        if(isAbandoned) {
                            // Only 2 posts remain, leaning
                            c.save();
                            c.translate(cx - T*0.34, railY);
                            c.rotate(0.15);
                            c.fillRect(-T*0.012, 0, T*0.024, (deckY - railY + T*0.02));
                            c.restore();
                            c.fillRect(cx + T*0.15 - T*0.012, railY, T*0.024, deckY - railY + T*0.02);
                            // Broken rail piece
                            c.fillStyle = logMain;
                            c.save();
                            c.translate(cx - T*0.2, railY + T*0.01);
                            c.rotate(-0.1);
                            c.fillRect(0, 0, T*0.25, T*0.018);
                            c.restore();
                        } else if(isLow) {
                            // 3 posts, worn
                            const lowPostPositions = [cx - T*0.34, cx, cx + T*0.34];
                            for(let px of lowPostPositions) {
                                c.fillRect(px - T*0.012, railY, T*0.024, deckY - railY + T*0.02);
                                c.fillStyle = logMain;
                                c.beginPath();
                                c.arc(px, railY, T*0.012, 0, Math.PI*2);
                                c.fill();
                                c.fillStyle = logDark;
                            }
                            c.fillStyle = logMain;
                            c.fillRect(cx - T*0.36, railY + T*0.005, T*0.72, T*0.018);
                        } else {
                            // Full railing for V2/V3
                            const postPositions = [cx - T*0.34, cx - T*0.15, cx + T*0.15, cx + T*0.34];
                            for(let px of postPositions) {
                                c.fillRect(px - T*0.012, railY, T*0.024, deckY - railY + T*0.02);
                                c.fillStyle = logMain;
                                c.beginPath();
                                c.arc(px, railY, T*0.015, 0, Math.PI*2);
                                c.fill();
                                c.fillStyle = logDark;
                            }
                            // Top rail
                            c.fillStyle = logMain;
                            c.fillRect(cx - T*0.36, railY + T*0.005, T*0.72, T*0.02);
                            // Rail highlight
                            c.strokeStyle = 'rgba(255,255,255,0.15)';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.moveTo(cx - T*0.35, railY + T*0.008);
                            c.lineTo(cx + T*0.35, railY + T*0.008);
                            c.stroke();
                        }
                        
                        // === WOVEN PALM WALL (V0: holey/collapsed, V1: worn) ===
                        if(isAbandoned) {
                            // Collapsed wall - just partial frame
                            c.fillStyle = '#3A3A3A';
                            c.fillRect(cx - T*0.2, cy - T*0.35, T*0.15, T*0.12);
                            // Fallen thatch debris
                            c.fillStyle = '#4A4A3A';
                            c.beginPath();
                            c.ellipse(cx - T*0.1, cy - T*0.08, T*0.08, T*0.03, 0.2, 0, Math.PI*2);
                            c.fill();
                        } else if(isLow) {
                            // Worn wall with holes
                            c.fillStyle = thatchDark;
                            c.fillRect(cx - T*0.22, cy - T*0.36, T*0.44, T*0.15);
                            // Holes in wall
                            c.fillStyle = 'rgba(0,0,0,0.4)';
                            c.beginPath();
                            c.ellipse(cx + T*0.08, cy - T*0.3, T*0.04, T*0.03, 0, 0, Math.PI*2);
                            c.fill();
                            // Basic weave
                            c.strokeStyle = thatchMid;
                            c.lineWidth = 1.5;
                            for(let row = 0; row < 4; row++) {
                                let wy = cy - T*0.34 + row * T*0.035;
                                c.beginPath();
                                c.moveTo(cx - T*0.2, wy);
                                c.lineTo(cx + T*0.2, wy);
                                c.stroke();
                            }
                        } else {
                            // Full woven wall for V2/V3
                            c.fillStyle = thatchDark;
                            c.fillRect(cx - T*0.25, cy - T*0.38, T*0.5, T*0.18);
                            // Weave pattern (horizontal palm strips)
                            c.strokeStyle = thatchMid;
                            c.lineWidth = 2;
                            for(let row = 0; row < 5; row++) {
                                let wy = cy - T*0.36 + row * T*0.035;
                                c.beginPath();
                                c.moveTo(cx - T*0.24, wy);
                                c.lineTo(cx + T*0.24, wy);
                                c.stroke();
                            }
                            // Vertical woven strips
                            c.lineWidth = 1.5;
                            for(let col = 0; col < 8; col++) {
                                let wx = cx - T*0.22 + col * T*0.06;
                                c.strokeStyle = (col % 2 === 0) ? thatchLight : thatchDark;
                                c.beginPath();
                                c.moveTo(wx, cy - T*0.38);
                                c.lineTo(wx, cy - T*0.2);
                                c.stroke();
                            }
                        }
                        
                        // === ROOF SUPPORT POSTS (V0: missing one) ===
                        c.fillStyle = logDark;
                        if(!isAbandoned) {
                            c.fillRect(cx - T*0.23, cy - T*0.2, T*0.03, T*0.08);
                            c.fillRect(cx + T*0.2, cy - T*0.2, T*0.03, T*0.08);
                            // Rope ties on posts
                            c.strokeStyle = ropeColor;
                            c.lineWidth = 1.5;
                            c.beginPath();
                            c.arc(cx - T*0.215, cy - T*0.16, T*0.018, 0, Math.PI*2);
                            c.stroke();
                            c.beginPath();
                            c.arc(cx + T*0.215, cy - T*0.16, T*0.018, 0, Math.PI*2);
                            c.stroke();
                        } else {
                            // Only left post remains, leaning
                            c.save();
                            c.translate(cx - T*0.23, cy - T*0.2);
                            c.rotate(-0.1);
                            c.fillRect(0, 0, T*0.03, T*0.08);
                            c.restore();
                        }
                        
                        // === THATCH ROOF (V0: collapsed, V1: sparse, V2-V3: full) ===
                        if(isAbandoned) {
                            // Collapsed roof - just frame skeleton
                            c.strokeStyle = '#4A4A4A';
                            c.lineWidth = 3;
                            c.beginPath();
                            c.moveTo(cx - T*0.22, cy - T*0.2);
                            c.lineTo(cx - T*0.05, cy - T*0.35);
                            c.stroke();
                            // Fallen thatch on ground
                            c.fillStyle = '#4A4A3A';
                            c.beginPath();
                            c.ellipse(cx + T*0.15, cy + T*0.32, T*0.12, T*0.04, 0.2, 0, Math.PI*2);
                            c.fill();
                        } else if(isLow) {
                            // Sparse roof - partial coverage
                            c.strokeStyle = logDark;
                            c.lineWidth = 3;
                            c.beginPath();
                            c.moveTo(cx - T*0.25, cy - T*0.2);
                            c.lineTo(cx, cy - T*0.38 + sway*T*2);
                            c.lineTo(cx + T*0.25, cy - T*0.2);
                            c.stroke();
                            // Sparse thatch (2 layers)
                            for(let layer = 0; layer < 2; layer++) {
                                let layerY = cy - T*0.2 - layer * T*0.07;
                                let layerWidth = T*0.28 - layer * T*0.06;
                                c.fillStyle = thatchMid;
                                c.beginPath();
                                c.moveTo(cx - layerWidth, layerY);
                                c.lineTo(cx, layerY - T*0.07 + sway*T*2);
                                c.lineTo(cx + layerWidth, layerY);
                                c.closePath();
                                c.fill();
                            }
                        } else {
                            // Full roof for V2/V3
                            // Roof frame poles
                            c.strokeStyle = logDark;
                            c.lineWidth = 4;
                            c.beginPath();
                            c.moveTo(cx - T*0.28, cy - T*0.2);
                            c.lineTo(cx, cy - T*0.45 + sway*T*2);
                            c.lineTo(cx + T*0.28, cy - T*0.2);
                            c.stroke();
                            
                            // Ridge pole
                            c.lineWidth = 3;
                            c.beginPath();
                            c.moveTo(cx, cy - T*0.45 + sway*T*2);
                            c.lineTo(cx, cy - T*0.42 + sway*T*2);
                            c.stroke();
                        
                            // Thatch layers (overlapping palm fronds)
                        for(let layer = 0; layer < 4; layer++) {
                            let layerY = cy - T*0.2 - layer * T*0.06;
                            let layerWidth = T*0.32 - layer * T*0.05;
                            let layerColor = layer % 2 === 0 ? thatchMid : thatchDark;
                            
                            c.fillStyle = layerColor;
                            c.beginPath();
                            c.moveTo(cx - layerWidth, layerY);
                            c.lineTo(cx, layerY - T*0.08 + sway*T*2);
                            c.lineTo(cx + layerWidth, layerY);
                            c.closePath();
                            c.fill();
                            
                            // Frond texture
                            c.strokeStyle = layer % 2 === 0 ? thatchDark : thatchLight;
                            c.lineWidth = 1;
                            for(let f = 0; f < 6; f++) {
                                let fx = cx - layerWidth + T*0.05 + f * (layerWidth*2 - T*0.1) / 5;
                                let fy = layerY - (Math.abs(fx - cx) / layerWidth) * T*0.06;
                                c.beginPath();
                                c.moveTo(fx, fy + sway*T);
                                c.lineTo(fx + T*0.01, fy - T*0.04 + sway*T);
                                c.stroke();
                            }
                        }
                        
                            // Roof overhang fringe (hanging palm strips)
                            c.strokeStyle = thatchDark;
                            c.lineWidth = 1;
                            for(let f = 0; f < 14; f++) {
                                let fx = cx - T*0.32 + f * T*0.05;
                                let fwave = Math.sin(t*2 + f*0.5) * T*0.008;
                                c.beginPath();
                                c.moveTo(fx, cy - T*0.18);
                                c.lineTo(fx + fwave, cy - T*0.14);
                                c.stroke();
                            }
                        } // End of V2/V3 roof else block
                        
                        // === NOTCHED LOG LADDER (V0: fallen, V1: worn) ===
                        if(isAbandoned) {
                            // Fallen ladder on ground
                            c.fillStyle = '#4A4A4A';
                            c.save();
                            c.translate(cx - T*0.1, cy + T*0.35);
                            c.rotate(0.3);
                            c.fillRect(0, 0, T*0.06, T*0.25);
                            c.restore();
                        } else {
                            // Standing ladder
                            c.fillStyle = logMain;
                            c.save();
                            c.translate(cx, cy + T*0.18);
                            c.rotate(isLow ? 0.2 : 0.15); // More lean for worn
                            c.fillRect(-T*0.04, -T*0.04, T*0.08, T*0.32);
                            // Notches carved into log
                            c.fillStyle = logDark;
                            const numNotches = isLow ? 4 : 5;
                            for(let n = 0; n < numNotches; n++) {
                                c.fillRect(-T*0.05, T*0.02 + n*T*0.055, T*0.1, T*0.015);
                                c.fillStyle = 'rgba(0,0,0,0.2)';
                                c.fillRect(-T*0.04, T*0.025 + n*T*0.055, T*0.08, T*0.008);
                                c.fillStyle = logDark;
                            }
                            c.restore();
                        }
                        
                        // === HANGING VINES (V0: dead/absent, V1: sparse, V2-V3: lush) ===
                        if(isAbandoned) {
                            // Dead dried vines
                            c.strokeStyle = '#5A5A4A';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.moveTo(cx - T*0.36, cy - T*0.15);
                            c.lineTo(cx - T*0.38, cy - T*0.05);
                            c.stroke();
                        } else if(isLow) {
                            // Sparse vines
                            c.strokeStyle = vineColor;
                            c.lineWidth = 1.5;
                            c.beginPath();
                            c.moveTo(cx - T*0.36, cy - T*0.15);
                            c.quadraticCurveTo(cx - T*0.40, cy + T*0.02, cx - T*0.38, cy + T*0.15);
                            c.stroke();
                        } else {
                            // Full lush vines for V2/V3
                            c.strokeStyle = vineColor;
                            c.lineWidth = 2;
                            // Left hanging vine
                            c.beginPath();
                            c.moveTo(cx - T*0.36, cy - T*0.15);
                            c.quadraticCurveTo(cx - T*0.42 + Math.sin(t*0.7)*T*0.02, cy + T*0.05, cx - T*0.38, cy + T*0.2);
                            c.stroke();
                            // Right hanging vine
                            c.beginPath();
                            c.moveTo(cx + T*0.36, cy - T*0.15);
                            c.quadraticCurveTo(cx + T*0.42 + Math.sin(t*0.7 + 1)*T*0.02, cy + T*0.08, cx + T*0.4, cy + T*0.25);
                            c.stroke();
                            // Vine leaves
                            c.fillStyle = isHigh ? '#5A8A40' : '#4A7A30';
                            c.beginPath();
                            c.ellipse(cx - T*0.4, cy + T*0.0, T*0.025, T*0.012, 0.5, 0, Math.PI*2);
                            c.fill();
                            c.beginPath();
                            c.ellipse(cx + T*0.42, cy + T*0.12, T*0.02, T*0.01, -0.3, 0, Math.PI*2);
                            c.fill();
                            // Extra leaves for V3
                            if(isHigh) {
                                c.beginPath();
                                c.ellipse(cx - T*0.38, cy + T*0.1, T*0.02, T*0.01, 0.3, 0, Math.PI*2);
                                c.fill();
                                c.beginPath();
                                c.ellipse(cx + T*0.4, cy + T*0.05, T*0.018, T*0.009, -0.2, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                        // === PEOPLE ON PLATFORM (V0: none, V1: 0-1, V2: 1-2, V3: 2-3) ===
                        const maxPeople = isAbandoned ? 0 : (isLow ? 1 : (isMedium ? 2 : 3));
                        const numPeople = Math.min(maxPeople, Math.ceil((bld.pop || 0) / 5));
                        if(numPeople > 0) {
                            for(let p = 0; p < numPeople; p++) {
                                let px = cx - T*0.18 + p * T*0.16;
                                let py = cy - T*0.26 + Math.sin(t*0.8 + p*1.5)*T*0.004;
                                let facing = p % 2 === 0 ? 1 : -1;
                                
                                // Body/torso (seated)
                                c.fillStyle = isMedium || isHigh ? '#8B6B4B' : '#A07B5B';
                                c.beginPath();
                                c.moveTo(px - T*0.022, py + T*0.05);
                                c.lineTo(px - T*0.028, py + T*0.02);
                                c.lineTo(px + T*0.028, py + T*0.02);
                                c.lineTo(px + T*0.022, py + T*0.05);
                                c.closePath();
                                c.fill();
                                
                                // Legs (crossed/seated)
                                c.fillStyle = '#C49464';
                                c.beginPath();
                                c.ellipse(px, py + T*0.055, T*0.025, T*0.012, 0, 0, Math.PI*2);
                                c.fill();
                                
                                // Head
                                c.fillStyle = '#D4A574';
                                c.beginPath();
                                c.ellipse(px, py - T*0.005, T*0.022, T*0.028, 0, 0, Math.PI*2);
                                c.fill();
                                
                                // Hair
                                c.fillStyle = ['#1A0A00', '#2A1510', '#3A2520', '#1A0A00'][p];
                                c.beginPath();
                                c.ellipse(px, py - T*0.02, T*0.024, T*0.018, 0, Math.PI, Math.PI*2);
                                c.fill();
                                // Side hair
                                c.fillRect(px - T*0.022, py - T*0.02, T*0.008, T*0.018);
                                c.fillRect(px + T*0.014, py - T*0.02, T*0.008, T*0.018);
                                
                                // Arm (working motion)
                                c.strokeStyle = '#D4A574';
                                c.lineWidth = T*0.012;
                                c.lineCap = 'round';
                                c.beginPath();
                                c.moveTo(px + facing*T*0.025, py + T*0.025);
                                let armWave = p === 1 ? Math.sin(t*2)*T*0.015 : 0;
                                c.lineTo(px + facing*T*0.045, py + T*0.01 + armWave);
                                c.stroke();
                            }
                        }
                        
                        // === TREE CANOPY (V0: dead/bare, V1: sparse, V2-V3: lush) ===
                        if(isAbandoned) {
                            // Dead bare branches
                            c.strokeStyle = '#4A4A4A';
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(cx - T*0.05, cy - T*0.42);
                            c.lineTo(cx - T*0.15, cy - T*0.52);
                            c.moveTo(cx + T*0.05, cy - T*0.42);
                            c.lineTo(cx + T*0.12, cy - T*0.5);
                            c.stroke();
                            // A few dead leaves
                            c.fillStyle = '#5A5A4A';
                            c.beginPath();
                            c.ellipse(cx - T*0.12, cy - T*0.5, T*0.03, T*0.015, 0.3, 0, Math.PI*2);
                            c.fill();
                        } else if(isLow) {
                            // Sparse canopy
                            c.fillStyle = '#2D5B15';
                            for(let i = 0; i < 3; i++) {
                                let lx = cx - T*0.1 + i * T*0.1 + Math.sin(t*0.6 + i)*T*leafRustle;
                                let ly = cy - T*0.5 - (i%2)*T*0.04;
                                c.beginPath();
                                c.ellipse(lx, ly, T*0.05, T*0.025, 0.2 + i*0.3 + sway, 0, Math.PI*2);
                                c.fill();
                            }
                        } else {
                            // Full lush canopy for V2/V3
                            // Back layer leaves (darker)
                            c.fillStyle = '#2D5B15';
                            const backLeaves = isHigh ? 7 : 6;
                            for(let i = 0; i < backLeaves; i++) {
                                let lx = cx - T*0.2 + i * T*0.08 + Math.sin(t*0.6 + i)*T*leafRustle;
                                let ly = cy - T*0.52 - (i%2)*T*0.05;
                                c.beginPath();
                                c.ellipse(lx, ly, T*0.07, T*0.03, 0.2 + i*0.25 + sway, 0, Math.PI*2);
                                c.fill();
                            }
                            // Front layer leaves (brighter)
                            c.fillStyle = palmGreen;
                            for(let i = 0; i < 5; i++) {
                                let lx = cx - T*0.12 + i * T*0.07 + Math.sin(t*0.8 + i)*T*leafRustle;
                                let ly = cy - T*0.48 - (i%2)*T*0.04;
                                c.beginPath();
                                c.ellipse(lx, ly, T*0.055, T*0.028, 0.3 + i*0.22 + sway, 0, Math.PI*2);
                                c.fill();
                            }
                            // Highlight leaves
                            c.fillStyle = palmLight;
                            for(let i = 0; i < 3; i++) {
                                let lx = cx - T*0.05 + i * T*0.08 + Math.sin(t + i)*T*leafRustle*0.8;
                                let ly = cy - T*0.44 - (i%2)*T*0.03;
                                c.beginPath();
                                c.ellipse(lx, ly, T*0.04, T*0.02, -0.1 + i*0.3 + sway, 0, Math.PI*2);
                                c.fill();
                            }
                            // Extra lush leaves for V3
                            if(isHigh) {
                                c.fillStyle = '#4D8B35';
                                for(let i = 0; i < 4; i++) {
                                    let lx = cx - T*0.15 + i * T*0.1 + Math.sin(t*0.9 + i)*T*leafRustle;
                                    let ly = cy - T*0.56 - (i%2)*T*0.03;
                                    c.beginPath();
                                    c.ellipse(lx, ly, T*0.045, T*0.022, 0.1 + i*0.2 + sway, 0, Math.PI*2);
                                    c.fill();
                                }
                            }
                        }
                        
                        // === ATMOSPHERIC DETAILS ===
                        // Firefly/sparkle particles (V2-V3 only)
                        if(!isAbandoned && !isLow && (bld.pop || 0) > 0) {
                            let sparkle = Math.sin(t*3) > 0.7;
                            if(sparkle) {
                                c.fillStyle = 'rgba(255,255,200,0.6)';
                                c.beginPath();
                                c.arc(cx + Math.sin(t)*T*0.2, cy - T*0.1 + Math.cos(t*0.7)*T*0.1, T*0.01, 0, Math.PI*2);
                                c.fill();
                            }
                            // Extra fireflies for V3
                            if(isHigh && Math.sin(t*2.5 + 1) > 0.75) {
                                c.beginPath();
                                c.arc(cx - T*0.15 + Math.sin(t*0.8)*T*0.1, cy - T*0.2 + Math.cos(t*0.5)*T*0.08, T*0.008, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                    } else if(lvl === 2) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 2: GROUND PIT SHELTER - Professional Sunken Earth Dwelling
                        // Inspired by prehistoric pit houses, Native American earth lodges
                        // Detailed excavated pit with proper drainage, fire pit, drying rack, sleeping areas
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const flicker = Math.sin(t * 4) * 0.3 + 0.7;
                        const smokeWave = Math.sin(t * 0.6);
                        
                        // === COLOR PALETTE (variant affects wear/quality) ===
                        const earthDark = variant === 0 ? '#3A2A1A' : '#4A3A2A';
                        const earthMid = variant === 0 ? '#5D4D3D' : variant === 1 ? '#6D5D4D' : '#7D6D5D';
                        const earthLight = variant >= 2 ? '#9D8D7D' : '#8D7D6D';
                        const stoneGray = variant === 0 ? '#5A5A5A' : '#7A7A7A';
                        const strawGold = variant === 0 ? '#A08030' : variant === 1 ? '#C0A050' : '#E0C070';
                        const strawDark = '#8A7020';
                        const woodBrown = '#5D4037';
                        const woodDark = '#3E2723';
                        const meatRed = '#8B3A3A';
                        const meatDark = '#5A2020';
                        
                        // === GROUND AROUND PIT (disturbed earth) ===
                        // Outer ring of excavated dirt
                        let dirtGrad = c.createRadialGradient(cx, cy + T*0.05, T*0.15, cx, cy + T*0.05, T*0.45);
                        dirtGrad.addColorStop(0, earthMid);
                        dirtGrad.addColorStop(0.6, earthLight);
                        dirtGrad.addColorStop(1, '#6B8B5A'); // Grass edge
                        c.fillStyle = dirtGrad;
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.05, T*0.45, T*0.3, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Dirt pile from excavation (mounded at back)
                        c.fillStyle = earthLight;
                        c.beginPath();
                        c.ellipse(cx + T*0.2, cy - T*0.2, T*0.18, T*0.08, -0.3, 0, Math.PI*2);
                        c.fill();
                        c.fillStyle = earthMid;
                        c.beginPath();
                        c.ellipse(cx + T*0.18, cy - T*0.22, T*0.12, T*0.05, -0.3, 0, Math.PI*2);
                        c.fill();
                        
                        // === PIT ITSELF (sunken area with depth) ===
                        // Pit rim shadow
                        c.fillStyle = 'rgba(0,0,0,0.3)';
                        c.beginPath();
                        c.ellipse(cx - T*0.02, cy + T*0.1, T*0.36, T*0.22, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Pit interior (layered for depth)
                        c.fillStyle = earthDark;
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.08, T*0.34, T*0.2, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Pit floor
                        c.fillStyle = '#2A1A0A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.12, T*0.28, T*0.14, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Dirt texture in pit floor
                        c.fillStyle = earthDark;
                        for(let i = 0; i < 6; i++) {
                            let px = cx - T*0.2 + (i%3) * T*0.15 + Math.sin(i)*T*0.03;
                            let py = cy + T*0.08 + Math.floor(i/3) * T*0.06;
                            c.beginPath();
                            c.ellipse(px, py, T*0.03, T*0.015, i*0.5, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === STONE-LINED FIRE PIT (center feature) ===
                        // Fire pit ring (stones)
                        c.fillStyle = stoneGray;
                        for(let i = 0; i < 8; i++) {
                            let angle = i * Math.PI / 4;
                            let sx = cx - T*0.12 + Math.cos(angle) * T*0.08;
                            let sy = cy + T*0.06 + Math.sin(angle) * T*0.04;
                            c.beginPath();
                            c.ellipse(sx, sy, T*0.025, T*0.018, angle, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Fire if occupied
                        if(bld.pop > 0) {
                            // Ember glow
                            let glowGrad = c.createRadialGradient(cx - T*0.12, cy + T*0.06, 0, cx - T*0.12, cy + T*0.06, T*0.1);
                            glowGrad.addColorStop(0, `rgba(255,150,50,${0.6 * flicker})`);
                            glowGrad.addColorStop(0.5, `rgba(255,80,0,${0.3 * flicker})`);
                            glowGrad.addColorStop(1, 'rgba(255,50,0,0)');
                            c.fillStyle = glowGrad;
                            c.beginPath();
                            c.arc(cx - T*0.12, cy + T*0.06, T*0.1, 0, Math.PI*2);
                            c.fill();
                            
                            // Fire base (embers)
                            c.fillStyle = '#FF4400';
                            c.beginPath();
                            c.ellipse(cx - T*0.12, cy + T*0.06, T*0.04, T*0.02, 0, 0, Math.PI*2);
                            c.fill();
                            
                            // Flames (animated)
                            let flames = [
                                {x: -0.14, h: 0.08, w: 0.025, phase: 0},
                                {x: -0.12, h: 0.12, w: 0.03, phase: 0.5},
                                {x: -0.10, h: 0.09, w: 0.025, phase: 1}
                            ];
                            for(let flame of flames) {
                                let fh = flame.h * (0.8 + Math.sin(t*5 + flame.phase)*0.2);
                                let fx = cx + flame.x*T + Math.sin(t*3 + flame.phase)*T*0.01;
                                
                                // Outer flame (orange)
                                c.fillStyle = '#FF6600';
                                c.beginPath();
                                c.moveTo(fx - T*flame.w, cy + T*0.06);
                                c.quadraticCurveTo(fx - T*flame.w*0.5, cy + T*0.06 - T*fh*0.5, fx, cy + T*0.06 - T*fh);
                                c.quadraticCurveTo(fx + T*flame.w*0.5, cy + T*0.06 - T*fh*0.5, fx + T*flame.w, cy + T*0.06);
                                c.fill();
                                
                                // Inner flame (yellow)
                                c.fillStyle = '#FFCC00';
                                c.beginPath();
                                c.moveTo(fx - T*flame.w*0.5, cy + T*0.06);
                                c.quadraticCurveTo(fx, cy + T*0.06 - T*fh*0.7, fx + T*flame.w*0.5, cy + T*0.06);
                                c.fill();
                            }
                            
                            // Smoke rising
                            for(let i = 0; i < 4; i++) {
                                let sy = cy - T*0.05 - i*T*0.08 - smokeWave*T*0.02;
                                let sx = cx - T*0.12 + Math.sin(t*0.5 + i*0.8)*T*0.04;
                                let size = (3 + i) * (1 - i*0.15);
                                c.fillStyle = `rgba(140,140,140,${0.4 - i*0.08})`;
                                c.beginPath();
                                c.arc(sx, sy, size, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                        // === STRAW BEDDING AREA ===
                        // Main bedding pile
                        c.fillStyle = strawGold;
                        c.beginPath();
                        c.ellipse(cx + T*0.1, cy + T*0.12, T*0.15, T*0.08, 0.2, 0, Math.PI*2);
                        c.fill();
                        
                        // Straw texture (individual straws)
                        c.strokeStyle = strawDark;
                        c.lineWidth = 1;
                        for(let i = 0; i < 12; i++) {
                            let sx = cx + T*0.02 + (i%4) * T*0.05;
                            let sy = cy + T*0.08 + Math.floor(i/4) * T*0.03;
                            let angle = (i * 0.4) - 0.8;
                            c.beginPath();
                            c.moveTo(sx, sy);
                            c.lineTo(sx + Math.cos(angle)*T*0.04, sy + Math.sin(angle)*T*0.02);
                            c.stroke();
                        }
                        
                        // === DRYING RACK (A-frame with meat) ===
                        // Main poles (A-frame)
                        c.strokeStyle = woodBrown;
                        c.lineWidth = 4;
                        c.lineCap = 'round';
                        // Left pole
                        c.beginPath();
                        c.moveTo(cx + T*0.22, cy + T*0.2);
                        c.lineTo(cx + T*0.28, cy - T*0.28);
                        c.stroke();
                        // Right pole
                        c.beginPath();
                        c.moveTo(cx + T*0.42, cy + T*0.2);
                        c.lineTo(cx + T*0.36, cy - T*0.28);
                        c.stroke();
                        // Cross bar
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(cx + T*0.26, cy - T*0.18);
                        c.lineTo(cx + T*0.38, cy - T*0.18);
                        c.stroke();
                        // Lower cross bar
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx + T*0.24, cy - T*0.05);
                        c.lineTo(cx + T*0.40, cy - T*0.05);
                        c.stroke();
                        
                        // Rope lashings
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.arc(cx + T*0.32, cy - T*0.26, T*0.02, 0, Math.PI*2);
                        c.stroke();
                        
                        // Hanging meat strips
                        let meatCount = variant >= 2 ? 4 : variant >= 1 ? 3 : 2;
                        for(let i = 0; i < meatCount; i++) {
                            let mx = cx + T*0.25 + i * T*0.04;
                            // Meat strip (dark to light gradient)
                            c.fillStyle = meatDark;
                            c.fillRect(mx, cy - T*0.16, T*0.025, T*0.1);
                            c.fillStyle = meatRed;
                            c.fillRect(mx + T*0.003, cy - T*0.14, T*0.018, T*0.06);
                            // Fat/sinew highlights
                            c.fillStyle = '#C8A080';
                            c.fillRect(mx + T*0.005, cy - T*0.12, T*0.012, T*0.015);
                        }
                        
                        // === PEOPLE (sleeping or working) ===
                        if(bld.pop > 0) {
                            let numPeople = Math.min(2, Math.ceil(bld.pop / 8));
                            for(let p = 0; p < numPeople; p++) {
                                if(p === 0) {
                                    // Person lying on straw
                                    let px = cx + T*0.1, py = cy + T*0.1;
                                    // Body (horizontal)
                                    c.fillStyle = '#A07B5B';
                                    c.beginPath();
                                    c.ellipse(px, py, T*0.06, T*0.025, -0.2, 0, Math.PI*2);
                                    c.fill();
                                    // Head
                                    c.fillStyle = '#D4A574';
                                    c.beginPath();
                                    c.arc(px - T*0.07, py - T*0.01, T*0.025, 0, Math.PI*2);
                                    c.fill();
                                    // Hair
                                    c.fillStyle = '#2A1A0A';
                                    c.beginPath();
                                    c.arc(px - T*0.07, py - T*0.02, T*0.022, Math.PI, Math.PI*2);
                                    c.fill();
                                } else {
                                    // Person sitting by fire
                                    let px = cx - T*0.25, py = cy + T*0.05;
                                    // Body
                                    c.fillStyle = '#8B6B4B';
                                    c.fillRect(px - T*0.02, py - T*0.03, T*0.04, T*0.06);
                                    // Head
                                    c.fillStyle = '#D4A574';
                                    c.beginPath();
                                    c.arc(px, py - T*0.055, T*0.022, 0, Math.PI*2);
                                    c.fill();
                                    // Hair
                                    c.fillStyle = '#1A0A00';
                                    c.beginPath();
                                    c.arc(px, py - T*0.065, T*0.02, Math.PI, Math.PI*2);
                                    c.fill();
                                }
                            }
                        }
                        
                        // === TOOLS/DETAILS (variant dependent) ===
                        if(variant >= 1) {
                            // Stone tools near fire
                            c.fillStyle = '#6A6A6A';
                            c.beginPath();
                            c.moveTo(cx - T*0.28, cy + T*0.1);
                            c.lineTo(cx - T*0.32, cy + T*0.08);
                            c.lineTo(cx - T*0.30, cy + T*0.14);
                            c.closePath();
                            c.fill();
                        }
                        if(variant >= 2) {
                            // Pottery/basket
                            c.fillStyle = '#A08060';
                            c.beginPath();
                            c.ellipse(cx - T*0.35, cy + T*0.12, T*0.03, T*0.025, 0, 0, Math.PI*2);
                            c.fill();
                            c.fillStyle = '#806040';
                            c.beginPath();
                            c.ellipse(cx - T*0.35, cy + T*0.11, T*0.02, T*0.01, 0, 0, Math.PI*2);
                            c.fill();
                        }
                        
                    } else if(lvl === 3) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 3: EARTH LODGE / GROUND CAVE - Professional Subterranean Dwelling
                        // Inspired by Plains Indian earth lodges, European Neolithic pit houses
                        // Mounded earth structure with timber frame, smoke hole, decorated entrance
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const smokeRise = Math.sin(t * 0.5);
                        const glowPulse = Math.sin(t * 2) * 0.15 + 0.85;
                        
                        // === COLOR PALETTE ===
                        const earthBase = variant === 0 ? '#5D4D3D' : variant === 1 ? '#6D5D4D' : '#7D6D5D';
                        const earthDark = variant === 0 ? '#3D2D1D' : '#4D3D2D';
                        const earthLight = variant >= 2 ? '#9D8D7D' : '#8D7D6D';
                        const grassGreen = variant === 0 ? '#4A6A2A' : '#5A8A3A';
                        const grassLight = '#7AAA5A';
                        const stoneGray = '#6A6A6A';
                        const stoneDark = '#4A4A4A';
                        const woodBrown = '#5A4030';
                        
                        // === GROUND SHADOW ===
                        c.fillStyle = 'rgba(0,0,0,0.25)';
                        c.beginPath();
                        c.ellipse(cx + T*0.02, cy + T*0.22, T*0.42, T*0.1, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // === EARTH MOUND (main structure) ===
                        // Base earth layer
                        let moundGrad = c.createRadialGradient(cx, cy - T*0.1, 0, cx, cy, T*0.5);
                        moundGrad.addColorStop(0, earthLight);
                        moundGrad.addColorStop(0.5, earthBase);
                        moundGrad.addColorStop(1, earthDark);
                        c.fillStyle = moundGrad;
                        c.beginPath();
                        c.moveTo(cx - T*0.48, cy + T*0.2);
                        c.quadraticCurveTo(cx - T*0.45, cy - T*0.15, cx - T*0.2, cy - T*0.35);
                        c.quadraticCurveTo(cx, cy - T*0.42, cx + T*0.2, cy - T*0.35);
                        c.quadraticCurveTo(cx + T*0.45, cy - T*0.15, cx + T*0.48, cy + T*0.2);
                        c.closePath();
                        c.fill();
                        
                        // Earth texture (dirt patches)
                        c.fillStyle = earthDark;
                        let patches = [{x:-0.25, y:-0.15}, {x:0.1, y:-0.25}, {x:0.3, y:-0.1}, {x:-0.1, y:-0.05}];
                        for(let p of patches) {
                            c.beginPath();
                            c.ellipse(cx + p.x*T, cy + p.y*T, T*0.05, T*0.025, p.x, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === GRASS ON TOP (living roof) ===
                        // Grass base patches
                        c.fillStyle = grassGreen;
                        for(let i = 0; i < 8; i++) {
                            let gx = cx - T*0.35 + i * T*0.1 + Math.sin(i)*T*0.02;
                            let gy = cy - T*0.25 - Math.sin(i*0.8)*T*0.1;
                            c.beginPath();
                            c.ellipse(gx, gy, T*0.06, T*0.025, i*0.2, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Individual grass blades
                        c.strokeStyle = grassGreen;
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 15; i++) {
                            let gx = cx - T*0.32 + i * T*0.045;
                            let baseY = cy - T*0.22 - Math.sin(i*0.6)*T*0.12;
                            let sway = Math.sin(t + i*0.5) * T*0.01;
                            c.beginPath();
                            c.moveTo(gx, baseY);
                            c.quadraticCurveTo(gx + sway, baseY - T*0.04, gx + sway*1.5, baseY - T*0.07);
                            c.stroke();
                        }
                        // Highlight grass
                        c.strokeStyle = grassLight;
                        c.lineWidth = 1;
                        for(let i = 0; i < 8; i++) {
                            let gx = cx - T*0.28 + i * T*0.08;
                            let baseY = cy - T*0.24 - Math.sin(i*0.7)*T*0.1;
                            c.beginPath();
                            c.moveTo(gx, baseY);
                            c.lineTo(gx + Math.sin(t + i)*T*0.01, baseY - T*0.05);
                            c.stroke();
                        }
                        
                        // === ENTRANCE (stone-lined arch) ===
                        // Entrance shadow/depth
                        c.fillStyle = '#0A0500';
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy + T*0.2);
                        c.lineTo(cx - T*0.18, cy - T*0.02);
                        c.quadraticCurveTo(cx - T*0.05, cy - T*0.12, cx + T*0.08, cy - T*0.02);
                        c.lineTo(cx + T*0.1, cy + T*0.2);
                        c.closePath();
                        c.fill();
                        
                        // Stone arch frame
                        c.fillStyle = stoneGray;
                        // Left stone pillar
                        c.beginPath();
                        c.moveTo(cx - T*0.22, cy + T*0.2);
                        c.lineTo(cx - T*0.24, cy + T*0.02);
                        c.lineTo(cx - T*0.18, cy - T*0.04);
                        c.lineTo(cx - T*0.14, cy + T*0.02);
                        c.lineTo(cx - T*0.16, cy + T*0.2);
                        c.closePath();
                        c.fill();
                        // Right stone pillar
                        c.beginPath();
                        c.moveTo(cx + T*0.12, cy + T*0.2);
                        c.lineTo(cx + T*0.1, cy + T*0.02);
                        c.lineTo(cx + T*0.06, cy - T*0.04);
                        c.lineTo(cx + T*0.12, cy - T*0.02);
                        c.lineTo(cx + T*0.16, cy + T*0.2);
                        c.closePath();
                        c.fill();
                        // Arch keystone
                        c.beginPath();
                        c.moveTo(cx - T*0.12, cy - T*0.02);
                        c.quadraticCurveTo(cx - T*0.05, cy - T*0.1, cx + T*0.02, cy - T*0.02);
                        c.quadraticCurveTo(cx - T*0.05, cy - T*0.06, cx - T*0.12, cy - T*0.02);
                        c.fill();
                        
                        // Stone texture lines
                        c.strokeStyle = stoneDark;
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy + T*0.08);
                        c.lineTo(cx - T*0.17, cy + T*0.08);
                        c.moveTo(cx + T*0.11, cy + T*0.1);
                        c.lineTo(cx + T*0.14, cy + T*0.1);
                        c.stroke();
                        
                        // === INTERIOR GLOW (fire inside) ===
                        if(bld.pop > 0) {
                            let glowGrad = c.createRadialGradient(cx - T*0.05, cy + T*0.08, 0, cx - T*0.05, cy + T*0.05, T*0.15);
                            glowGrad.addColorStop(0, `rgba(255,120,40,${0.7 * glowPulse})`);
                            glowGrad.addColorStop(0.5, `rgba(255,80,20,${0.4 * glowPulse})`);
                            glowGrad.addColorStop(1, 'rgba(255,50,0,0)');
                            c.fillStyle = glowGrad;
                            c.beginPath();
                            c.ellipse(cx - T*0.05, cy + T*0.08, T*0.12, T*0.08, 0, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === SMOKE HOLE / CHIMNEY ===
                        // Stone chimney stack
                        c.fillStyle = stoneGray;
                        c.beginPath();
                        c.moveTo(cx + T*0.2, cy - T*0.32);
                        c.lineTo(cx + T*0.18, cy - T*0.42);
                        c.lineTo(cx + T*0.28, cy - T*0.42);
                        c.lineTo(cx + T*0.26, cy - T*0.32);
                        c.closePath();
                        c.fill();
                        
                        // Chimney stone detail
                        c.strokeStyle = stoneDark;
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx + T*0.19, cy - T*0.36);
                        c.lineTo(cx + T*0.27, cy - T*0.36);
                        c.moveTo(cx + T*0.185, cy - T*0.39);
                        c.lineTo(cx + T*0.275, cy - T*0.39);
                        c.stroke();
                        
                        // Smoke rising from chimney
                        if(bld.pop > 0) {
                            for(let i = 0; i < 5; i++) {
                                let sy = cy - T*0.46 - i*T*0.08 - smokeRise*T*0.03;
                                let sx = cx + T*0.23 + Math.sin(t*0.4 + i*0.7)*T*0.05;
                                let size = (4 + i*0.8) * (1 - i*0.1);
                                c.fillStyle = `rgba(150,150,150,${0.5 - i*0.08})`;
                                c.beginPath();
                                c.arc(sx, sy, size, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                        // === DECORATIONS (variant dependent) ===
                        if(variant >= 1) {
                            // Skull/bones above entrance
                            c.fillStyle = '#E8E0D8';
                            c.beginPath();
                            c.ellipse(cx - T*0.05, cy - T*0.08, T*0.03, T*0.025, 0, 0, Math.PI*2);
                            c.fill();
                            // Eye sockets
                            c.fillStyle = '#2A2A2A';
                            c.beginPath();
                            c.arc(cx - T*0.06, cy - T*0.085, T*0.008, 0, Math.PI*2);
                            c.arc(cx - T*0.04, cy - T*0.085, T*0.008, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        if(variant >= 2) {
                            // Antler rack decoration
                            c.strokeStyle = '#D8D0C8';
                            c.lineWidth = 2;
                            c.lineCap = 'round';
                            // Left antler
                            c.beginPath();
                            c.moveTo(cx - T*0.28, cy - T*0.02);
                            c.lineTo(cx - T*0.35, cy - T*0.12);
                            c.lineTo(cx - T*0.32, cy - T*0.08);
                            c.moveTo(cx - T*0.33, cy - T*0.1);
                            c.lineTo(cx - T*0.38, cy - T*0.14);
                            c.stroke();
                            // Right antler
                            c.beginPath();
                            c.moveTo(cx + T*0.18, cy - T*0.02);
                            c.lineTo(cx + T*0.25, cy - T*0.12);
                            c.lineTo(cx + T*0.22, cy - T*0.08);
                            c.moveTo(cx + T*0.23, cy - T*0.1);
                            c.lineTo(cx + T*0.28, cy - T*0.14);
                            c.stroke();
                        }
                        
                        if(variant >= 3) {
                            // Hide door flap
                            c.fillStyle = '#8B7355';
                            c.beginPath();
                            c.moveTo(cx - T*0.14, cy - T*0.02);
                            c.quadraticCurveTo(cx - T*0.08, cy + T*0.05, cx - T*0.12, cy + T*0.15);
                            c.lineTo(cx + T*0.02, cy + T*0.15);
                            c.quadraticCurveTo(cx, cy + T*0.05, cx + T*0.04, cy - T*0.02);
                            c.closePath();
                            c.fill();
                            // Hide texture
                            c.strokeStyle = '#6A5A4A';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.moveTo(cx - T*0.08, cy + T*0.02);
                            c.lineTo(cx - T*0.06, cy + T*0.1);
                            c.stroke();
                        }
                        
                        // === WOOD PILE (side detail) ===
                        c.fillStyle = woodBrown;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.ellipse(cx + T*0.38 + i*T*0.03, cy + T*0.15 - i*T*0.02, T*0.015, T*0.025, 0.3, 0, Math.PI*2);
                            c.fill();
                        }
                        
                    } else if(lvl === 4) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 4: TIPI VILLAGE - Authentic Plains-Style Dwelling Settlement
                        // Inspired by Lakota, Cheyenne, Blackfoot tipi designs
                        // Multiple tipis with authentic buffalo hide, painted symbols, smoke flaps
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const windSway = Math.sin(t * 0.8) * 0.02;
                        const smokeRise = Math.sin(t * 0.5);
                        const fireGlow = Math.sin(t * 3) * 0.2 + 0.8;
                        
                        // === COLOR PALETTE ===
                        const hideBase = variant === 0 ? '#C4A484' : variant === 1 ? '#D4B494' : variant === 2 ? '#E4C4A4' : '#F4D4B4';
                        const hideShade = variant === 0 ? '#A48464' : variant === 1 ? '#B49474' : variant === 2 ? '#C4A484' : '#D4B494';
                        const hideHighlight = variant >= 2 ? '#FFF8F0' : '#F8EFE0';
                        const poleColor = '#5A4A3A';
                        const poleDark = '#3A2A1A';
                        const paintRed = variant >= 1 ? '#8B2222' : '#6B1212';
                        const paintBlue = variant >= 2 ? '#2B5588' : '#1B4578';
                        const paintYellow = '#C9A030';
                        
                        // === GROUND (trampled earth around tipis) ===
                        c.fillStyle = '#7A6A5A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.18, T*0.45, T*0.12, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Ground texture (worn patches)
                        c.fillStyle = '#6A5A4A';
                        for(let i = 0; i < 5; i++) {
                            let gx = cx - T*0.3 + i*T*0.15 + Math.sin(i)*T*0.02;
                            c.beginPath();
                            c.ellipse(gx, cy + T*0.16, T*0.06, T*0.025, i*0.3, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === SECONDARY TIPI (background, smaller) ===
                        if(variant >= 1) {
                            let stx = cx + T*0.22, sty = cy + T*0.02;
                            let sScale = 0.55;
                            
                            // Hide body
                            let bgGrad = c.createLinearGradient(stx - T*0.15, sty, stx + T*0.15, sty);
                            bgGrad.addColorStop(0, hideShade);
                            bgGrad.addColorStop(0.5, hideBase);
                            bgGrad.addColorStop(1, hideShade);
                            c.fillStyle = bgGrad;
                            c.beginPath();
                            c.moveTo(stx, sty - T*0.28);
                            c.lineTo(stx - T*0.15, sty + T*0.12);
                            c.lineTo(stx + T*0.15, sty + T*0.12);
                            c.closePath();
                            c.fill();
                            
                            // Poles
                            c.strokeStyle = poleColor;
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(stx - T*0.03, sty - T*0.28);
                            c.lineTo(stx - T*0.08, sty - T*0.38);
                            c.moveTo(stx + T*0.03, sty - T*0.28);
                            c.lineTo(stx + T*0.08, sty - T*0.38);
                            c.stroke();
                            
                            // Door
                            c.fillStyle = '#2A1A0A';
                            c.beginPath();
                            c.ellipse(stx, sty + T*0.06, T*0.04, T*0.05, 0, 0, Math.PI);
                            c.fill();
                        }
                        
                        // === MAIN TIPI (foreground, detailed) ===
                        // Shadow under tipi
                        c.fillStyle = 'rgba(0,0,0,0.2)';
                        c.beginPath();
                        c.ellipse(cx - T*0.05, cy + T*0.2, T*0.28, T*0.06, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Hide body with gradient
                        let hideGrad = c.createLinearGradient(cx - T*0.3, cy, cx + T*0.3, cy);
                        hideGrad.addColorStop(0, hideShade);
                        hideGrad.addColorStop(0.3, hideBase);
                        hideGrad.addColorStop(0.7, hideHighlight);
                        hideGrad.addColorStop(1, hideShade);
                        c.fillStyle = hideGrad;
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy - T*0.48);
                        c.lineTo(cx - T*0.32, cy + T*0.2);
                        c.lineTo(cx + T*0.28, cy + T*0.2);
                        c.closePath();
                        c.fill();
                        
                        // Hide seams (vertical stitching lines)
                        c.strokeStyle = hideShade;
                        c.lineWidth = 1;
                        for(let i = 0; i < 4; i++) {
                            let sx = cx - T*0.2 + i*T*0.1;
                            let topY = cy - T*0.35 + i*T*0.05;
                            c.beginPath();
                            c.moveTo(sx, topY);
                            c.lineTo(sx - T*0.02 + i*T*0.02, cy + T*0.18);
                            c.stroke();
                        }
                        
                        // Stitch marks
                        c.strokeStyle = '#8A7A6A';
                        c.lineWidth = 1;
                        for(let i = 0; i < 8; i++) {
                            let sx = cx - T*0.22 + i*T*0.06;
                            let sy = cy + T*0.08 - Math.abs(i-4)*T*0.02;
                            c.beginPath();
                            c.moveTo(sx - T*0.008, sy - T*0.01);
                            c.lineTo(sx + T*0.008, sy + T*0.01);
                            c.stroke();
                        }
                        
                        // === SMOKE FLAPS (distinctive tipi feature) ===
                        // Left smoke flap
                        c.fillStyle = hideBase;
                        c.beginPath();
                        c.moveTo(cx - T*0.08, cy - T*0.48);
                        c.quadraticCurveTo(cx - T*0.2 + windSway*T, cy - T*0.55, cx - T*0.18, cy - T*0.35);
                        c.lineTo(cx - T*0.08, cy - T*0.40);
                        c.closePath();
                        c.fill();
                        // Pole through flap
                        c.strokeStyle = poleColor;
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx - T*0.15, cy - T*0.35);
                        c.lineTo(cx - T*0.2 + windSway*T, cy - T*0.58);
                        c.stroke();
                        
                        // Right smoke flap
                        c.fillStyle = hideBase;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.48);
                        c.quadraticCurveTo(cx + T*0.15 - windSway*T, cy - T*0.55, cx + T*0.12, cy - T*0.35);
                        c.lineTo(cx, cy - T*0.40);
                        c.closePath();
                        c.fill();
                        // Pole through flap
                        c.beginPath();
                        c.moveTo(cx + T*0.1, cy - T*0.35);
                        c.lineTo(cx + T*0.15 - windSway*T, cy - T*0.58);
                        c.stroke();
                        
                        // === POLES (bundle extending from top) ===
                        c.strokeStyle = poleColor;
                        c.lineWidth = 2.5;
                        c.lineCap = 'round';
                        // Multiple poles splaying out
                        let poleAngles = [-0.5, -0.25, 0, 0.2, 0.4];
                        for(let angle of poleAngles) {
                            c.beginPath();
                            c.moveTo(cx - T*0.05, cy - T*0.48);
                            c.lineTo(cx - T*0.05 + Math.sin(angle)*T*0.15, cy - T*0.65);
                            c.stroke();
                        }
                        // Pole ends (darker)
                        c.fillStyle = poleDark;
                        for(let angle of poleAngles) {
                            c.beginPath();
                            c.arc(cx - T*0.05 + Math.sin(angle)*T*0.15, cy - T*0.65, T*0.012, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === PAINTED DESIGNS ===
                        // Decorative band at base
                        c.strokeStyle = paintRed;
                        c.lineWidth = 4;
                        c.beginPath();
                        c.moveTo(cx - T*0.28, cy + T*0.12);
                        c.lineTo(cx + T*0.24, cy + T*0.12);
                        c.stroke();
                        
                        // Geometric triangle pattern
                        c.fillStyle = paintRed;
                        for(let i = 0; i < 5; i++) {
                            let tx = cx - T*0.22 + i*T*0.1;
                            c.beginPath();
                            c.moveTo(tx, cy + T*0.08);
                            c.lineTo(tx - T*0.03, cy + T*0.15);
                            c.lineTo(tx + T*0.03, cy + T*0.15);
                            c.closePath();
                            c.fill();
                        }
                        
                        // Upper band
                        c.strokeStyle = paintBlue;
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy - T*0.15);
                        c.lineTo(cx + T*0.16, cy - T*0.15);
                        c.stroke();
                        
                        // Sun symbol (if higher variant)
                        if(variant >= 2) {
                            c.fillStyle = paintYellow;
                            c.beginPath();
                            c.arc(cx - T*0.05, cy - T*0.25, T*0.04, 0, Math.PI*2);
                            c.fill();
                            // Sun rays
                            c.strokeStyle = paintYellow;
                            c.lineWidth = 2;
                            for(let i = 0; i < 8; i++) {
                                let angle = i * Math.PI/4;
                                c.beginPath();
                                c.moveTo(cx - T*0.05 + Math.cos(angle)*T*0.05, cy - T*0.25 + Math.sin(angle)*T*0.05);
                                c.lineTo(cx - T*0.05 + Math.cos(angle)*T*0.07, cy - T*0.25 + Math.sin(angle)*T*0.07);
                                c.stroke();
                            }
                        }
                        
                        // Buffalo symbol (if max variant)
                        if(variant >= 3) {
                            c.fillStyle = paintRed;
                            // Buffalo body
                            c.beginPath();
                            c.ellipse(cx + T*0.05, cy - T*0.02, T*0.04, T*0.025, 0, 0, Math.PI*2);
                            c.fill();
                            // Buffalo hump
                            c.beginPath();
                            c.arc(cx + T*0.03, cy - T*0.04, T*0.02, 0, Math.PI, true);
                            c.fill();
                            // Head
                            c.beginPath();
                            c.arc(cx + T*0.08, cy - T*0.02, T*0.015, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === DOOR OPENING ===
                        // Dark interior
                        c.fillStyle = '#1A0A00';
                        c.beginPath();
                        c.moveTo(cx - T*0.1, cy + T*0.18);
                        c.quadraticCurveTo(cx - T*0.1, cy + T*0.02, cx - T*0.05, cy - T*0.02);
                        c.quadraticCurveTo(cx, cy + T*0.02, cx, cy + T*0.18);
                        c.closePath();
                        c.fill();
                        
                        // Interior fire glow
                        if(bld.pop > 0) {
                            let intGlow = c.createRadialGradient(cx - T*0.05, cy + T*0.1, 0, cx - T*0.05, cy + T*0.1, T*0.12);
                            intGlow.addColorStop(0, `rgba(255,120,40,${0.6 * fireGlow})`);
                            intGlow.addColorStop(1, 'rgba(255,60,0,0)');
                            c.fillStyle = intGlow;
                            c.beginPath();
                            c.arc(cx - T*0.05, cy + T*0.1, T*0.12, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Door flap (partially open)
                        c.fillStyle = '#7A5A3A';
                        c.beginPath();
                        c.moveTo(cx - T*0.1, cy + T*0.18);
                        c.quadraticCurveTo(cx - T*0.15, cy + T*0.08, cx - T*0.12, cy);
                        c.lineTo(cx - T*0.1, cy + T*0.18);
                        c.closePath();
                        c.fill();
                        
                        // === ACCESSORIES AROUND TIPI ===
                        // Firewood pile
                        c.fillStyle = '#4A3A2A';
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.ellipse(cx + T*0.32 + i*T*0.025, cy + T*0.18 - i*T*0.015, T*0.012, T*0.03, 0.3, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Drying hide (if variant 2+)
                        if(variant >= 2) {
                            c.fillStyle = hideShade;
                            c.beginPath();
                            c.moveTo(cx - T*0.38, cy + T*0.1);
                            c.lineTo(cx - T*0.42, cy - T*0.05);
                            c.lineTo(cx - T*0.35, cy - T*0.05);
                            c.closePath();
                            c.fill();
                            // Frame poles
                            c.strokeStyle = poleColor;
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(cx - T*0.44, cy + T*0.12);
                            c.lineTo(cx - T*0.42, cy - T*0.08);
                            c.moveTo(cx - T*0.33, cy + T*0.12);
                            c.lineTo(cx - T*0.35, cy - T*0.08);
                            c.stroke();
                        }
                        
                        // === SMOKE FROM TOP ===
                        if(bld.pop > 0) {
                            for(let i = 0; i < 5; i++) {
                                let sy = cy - T*0.55 - i*T*0.08 - smokeRise*T*0.03;
                                let sx = cx - T*0.05 + Math.sin(t*0.4 + i*0.7)*T*0.04;
                                let size = (4 + i*0.8) * (1 - i*0.08);
                                c.fillStyle = `rgba(180,180,180,${0.45 - i*0.07})`;
                                c.beginPath();
                                c.arc(sx, sy, size, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                    } else if(lvl === 5) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 5: LOG LONGHOUSE - Authentic Iroquois/Haudenosaunee Extended Dwelling
                        // Inspired by traditional longhouse construction: elm bark walls, barrel roof
                        // Detailed with compartment divisions, multiple smoke holes, storage platforms
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const smokeRise = Math.sin(t * 0.6);
                        const fireGlow = Math.sin(t * 3) * 0.15 + 0.85;
                        
                        // === COLOR PALETTE ===
                        const barkBase = variant === 0 ? '#5A4A3A' : variant === 1 ? '#6A5A4A' : variant === 2 ? '#7A6A5A' : '#8A7A6A';
                        const barkDark = variant === 0 ? '#3A2A1A' : '#4A3A2A';
                        const barkLight = variant >= 2 ? '#9A8A7A' : '#8A7A6A';
                        const frameWood = '#4A3828';
                        const roofBark = variant === 0 ? '#4A4030' : variant === 1 ? '#5A5040' : '#6A6050';
                        const strawYellow = '#C9A960';
                        
                        // === GROUND SHADOW ===
                        c.fillStyle = 'rgba(0,0,0,0.25)';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.24, T*0.48, T*0.1, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // === MAIN STRUCTURE BODY ===
                        // Bark-covered walls (base rectangle)
                        let wallGrad = c.createLinearGradient(cx - T*0.42, cy, cx + T*0.42, cy);
                        wallGrad.addColorStop(0, barkDark);
                        wallGrad.addColorStop(0.2, barkBase);
                        wallGrad.addColorStop(0.8, barkLight);
                        wallGrad.addColorStop(1, barkDark);
                        c.fillStyle = wallGrad;
                        c.fillRect(cx - T*0.42, cy - T*0.05, T*0.84, T*0.28);
                        
                        // Horizontal bark strip lines (layered construction)
                        c.strokeStyle = barkDark;
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.42, cy + i*T*0.06);
                            c.lineTo(cx + T*0.42, cy + i*T*0.06);
                            c.stroke();
                        }
                        
                        // Vertical bark seams
                        c.strokeStyle = '#3A2818';
                        c.lineWidth = 1;
                        for(let i = 0; i < 7; i++) {
                            let sx = cx - T*0.38 + i*T*0.12;
                            c.beginPath();
                            c.moveTo(sx, cy - T*0.05);
                            c.lineTo(sx, cy + T*0.23);
                            c.stroke();
                        }
                        
                        // === BARREL ROOF (distinctive longhouse feature) ===
                        // Main curved roof surface
                        let roofGrad = c.createLinearGradient(cx, cy - T*0.4, cx, cy - T*0.05);
                        roofGrad.addColorStop(0, barkLight);
                        roofGrad.addColorStop(0.5, roofBark);
                        roofGrad.addColorStop(1, barkDark);
                        c.fillStyle = roofGrad;
                        c.beginPath();
                        c.moveTo(cx - T*0.42, cy - T*0.05);
                        c.quadraticCurveTo(cx - T*0.42, cy - T*0.38, cx, cy - T*0.42);
                        c.quadraticCurveTo(cx + T*0.42, cy - T*0.38, cx + T*0.42, cy - T*0.05);
                        c.closePath();
                        c.fill();
                        
                        // Roof bark strip texture
                        c.strokeStyle = barkDark;
                        c.lineWidth = 2;
                        for(let i = 0; i < 7; i++) {
                            let rx = cx - T*0.36 + i*T*0.12;
                            let curveHeight = Math.sin((i/6) * Math.PI) * T*0.12;
                            c.beginPath();
                            c.moveTo(rx, cy - T*0.05);
                            c.lineTo(rx, cy - T*0.28 - curveHeight);
                            c.stroke();
                        }
                        
                        // Horizontal roof bands (lashing strips)
                        c.strokeStyle = frameWood;
                        c.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            let ry = cy - T*0.12 - i*T*0.1;
                            let curveIn = i * T*0.06;
                            c.beginPath();
                            c.moveTo(cx - T*0.40 + curveIn, ry);
                            c.quadraticCurveTo(cx, ry - T*0.05 - curveIn*0.5, cx + T*0.40 - curveIn, ry);
                            c.stroke();
                        }
                        
                        // === SMOKE HOLES (3 along the roof ridge) ===
                        for(let h = 0; h < 3; h++) {
                            let hx = cx - T*0.22 + h*T*0.22;
                            // Hole opening
                            c.fillStyle = '#1A0A00';
                            c.beginPath();
                            c.ellipse(hx, cy - T*0.40, T*0.035, T*0.02, 0, 0, Math.PI*2);
                            c.fill();
                            
                            // Smoke from each hole
                            if(bld.pop > 0) {
                                for(let i = 0; i < 3; i++) {
                                    let sy = cy - T*0.44 - i*T*0.07 - smokeRise*T*0.02;
                                    let sx = hx + Math.sin(t*0.5 + i + h*2)*T*0.025;
                                    let size = (3 + i*0.5) * (1 - i*0.2);
                                    c.fillStyle = `rgba(160,160,160,${0.4 - i*0.1})`;
                                    c.beginPath();
                                    c.arc(sx, sy, size, 0, Math.PI*2);
                                    c.fill();
                                }
                            }
                        }
                        
                        // === END WALLS (rounded) ===
                        // Left end (entrance side)
                        c.fillStyle = barkBase;
                        c.beginPath();
                        c.arc(cx - T*0.42, cy + T*0.05, T*0.18, Math.PI*0.5, Math.PI*1.5, false);
                        c.fill();
                        
                        // Right end
                        c.beginPath();
                        c.arc(cx + T*0.42, cy + T*0.05, T*0.18, -Math.PI*0.5, Math.PI*0.5, false);
                        c.fill();
                        
                        // === ENTRANCE (rounded doorway) ===
                        // Door opening (dark)
                        c.fillStyle = '#0A0500';
                        c.beginPath();
                        c.ellipse(cx - T*0.42, cy + T*0.06, T*0.08, T*0.12, 0, Math.PI*0.6, Math.PI*1.4, false);
                        c.fill();
                        
                        // Interior glow from fire
                        if(bld.pop > 0) {
                            let intGlow = c.createRadialGradient(cx - T*0.42, cy + T*0.08, 0, cx - T*0.42, cy + T*0.06, T*0.1);
                            intGlow.addColorStop(0, `rgba(255,100,30,${0.5 * fireGlow})`);
                            intGlow.addColorStop(1, 'rgba(255,60,0,0)');
                            c.fillStyle = intGlow;
                            c.beginPath();
                            c.arc(cx - T*0.42, cy + T*0.08, T*0.1, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Door frame
                        c.strokeStyle = frameWood;
                        c.lineWidth = 3;
                        c.beginPath();
                        c.ellipse(cx - T*0.42, cy + T*0.06, T*0.09, T*0.13, 0, Math.PI*0.55, Math.PI*1.45, false);
                        c.stroke();
                        
                        // Hide door flap (hanging to side)
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.moveTo(cx - T*0.52, cy - T*0.04);
                        c.quadraticCurveTo(cx - T*0.55, cy + T*0.08, cx - T*0.50, cy + T*0.16);
                        c.lineTo(cx - T*0.48, cy + T*0.16);
                        c.quadraticCurveTo(cx - T*0.52, cy + T*0.06, cx - T*0.50, cy - T*0.02);
                        c.closePath();
                        c.fill();
                        
                        // === CLAN SYMBOL (on end wall) ===
                        if(variant >= 1) {
                            // Turtle clan symbol
                            c.fillStyle = '#3A2A1A';
                            c.beginPath();
                            c.ellipse(cx - T*0.42, cy - T*0.08, T*0.04, T*0.03, 0, 0, Math.PI*2);
                            c.fill();
                            // Shell pattern
                            c.strokeStyle = '#5A4A3A';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.moveTo(cx - T*0.44, cy - T*0.08);
                            c.lineTo(cx - T*0.40, cy - T*0.08);
                            c.moveTo(cx - T*0.42, cy - T*0.1);
                            c.lineTo(cx - T*0.42, cy - T*0.06);
                            c.stroke();
                        }
                        
                        // === STORAGE/DRYING RACK (outside) ===
                        if(variant >= 2) {
                            // A-frame rack
                            c.strokeStyle = frameWood;
                            c.lineWidth = 3;
                            c.lineCap = 'round';
                            c.beginPath();
                            c.moveTo(cx + T*0.32, cy + T*0.23);
                            c.lineTo(cx + T*0.36, cy - T*0.05);
                            c.moveTo(cx + T*0.48, cy + T*0.23);
                            c.lineTo(cx + T*0.44, cy - T*0.05);
                            c.stroke();
                            // Cross bars
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(cx + T*0.34, cy + T*0.02);
                            c.lineTo(cx + T*0.46, cy + T*0.02);
                            c.moveTo(cx + T*0.33, cy + T*0.1);
                            c.lineTo(cx + T*0.47, cy + T*0.1);
                            c.stroke();
                            
                            // Hanging items (corn, meat)
                            // Corn bundles
                            c.fillStyle = strawYellow;
                            for(let i = 0; i < 2; i++) {
                                c.beginPath();
                                c.ellipse(cx + T*0.36 + i*T*0.06, cy + T*0.06, T*0.015, T*0.035, 0, 0, Math.PI*2);
                                c.fill();
                            }
                            // Meat strips
                            c.fillStyle = '#8B4A3A';
                            c.fillRect(cx + T*0.42, cy + T*0.03, T*0.025, T*0.06);
                        }
                        
                        // === FIREWOOD STACK ===
                        c.fillStyle = '#4A3A2A';
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.ellipse(cx - T*0.35 + (i%2)*T*0.04, cy + T*0.22 - Math.floor(i/2)*T*0.025, T*0.015, T*0.025, 0.2 + i*0.2, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // === PEOPLE OUTSIDE (if populated) ===
                        if(bld.pop > 0 && variant >= 2) {
                            // Person sitting
                            let px = cx + T*0.2, py = cy + T*0.18;
                            c.fillStyle = '#8B6B4B';
                            c.fillRect(px - T*0.015, py - T*0.04, T*0.03, T*0.04);
                            c.fillStyle = '#D4A574';
                            c.beginPath();
                            c.arc(px, py - T*0.06, T*0.018, 0, Math.PI*2);
                            c.fill();
                            c.fillStyle = '#1A0A00';
                            c.beginPath();
                            c.arc(px, py - T*0.07, T*0.015, Math.PI, Math.PI*2);
                            c.fill();
                        }
                        
                    } else if(lvl >= 6) {
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // LEVEL 6: OLD GROWTH LOG COMPOUND - Massive Multi-Building Settlement
                        // Inspired by Norse longhouse settlements, Pacific Northwest plank houses
                        // Features: Great hall, secondary buildings, totem pole, palisade fence
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        
                        const t = Renderer.time || 0;
                        const smokeRise = Math.sin(t * 0.5);
                        const fireGlow = Math.sin(t * 3) * 0.15 + 0.85;
                        const flagWave = Math.sin(t * 2) * 0.1;
                        
                        // === COLOR PALETTE ===
                        const logBase = variant === 0 ? '#5A4535' : variant === 1 ? '#6A5545' : variant === 2 ? '#7A6555' : '#8A7565';
                        const logDark = variant === 0 ? '#3A2515' : '#4A3525';
                        const logLight = variant >= 2 ? '#9A8575' : '#8A7565';
                        const logEnd = '#4A3020';
                        const roofGreen = variant === 0 ? '#3A5530' : variant === 1 ? '#4A6540' : '#5A7550';
                        const roofDark = '#2A4520';
                        const stoneGray = '#6A6A6A';
                        const stoneDark = '#4A4A4A';
                        
                        // === GROUND (packed earth courtyard) ===
                        c.fillStyle = 'rgba(0,0,0,0.25)';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.24, T*0.48, T*0.12, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // Courtyard ground
                        c.fillStyle = '#7A6A5A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.2, T*0.44, T*0.1, 0, 0, Math.PI*2);
                        c.fill();
                        
                        // === PALISADE FENCE (background) ===
                        c.fillStyle = logDark;
                        // Back fence posts
                        for(let i = 0; i < 9; i++) {
                            let fx = cx - T*0.42 + i*T*0.1;
                            let fh = T*0.15 + Math.sin(i*0.5)*T*0.02;
                            c.fillRect(fx, cy - T*0.35 - fh, T*0.03, fh);
                            // Pointed tops
                            c.beginPath();
                            c.moveTo(fx, cy - T*0.35 - fh);
                            c.lineTo(fx + T*0.015, cy - T*0.38 - fh);
                            c.lineTo(fx + T*0.03, cy - T*0.35 - fh);
                            c.fill();
                        }
                        
                        // === SECONDARY BUILDING (storage shed, background) ===
                        // Small log structure
                        c.fillStyle = logBase;
                        c.globalAlpha = 0.95;
                        c.fillRect(cx + T*0.18, cy - T*0.02, T*0.28, T*0.2);
                        
                        // Log end details
                        c.fillStyle = logEnd;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.arc(cx + T*0.18, cy + i*T*0.05, T*0.018, 0, Math.PI*2);
                            c.arc(cx + T*0.46, cy + i*T*0.05, T*0.018, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Small peaked roof
                        c.fillStyle = roofGreen;
                        c.beginPath();
                        c.moveTo(cx + T*0.14, cy - T*0.02);
                        c.lineTo(cx + T*0.32, cy - T*0.2);
                        c.lineTo(cx + T*0.5, cy - T*0.02);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = roofDark;
                        c.lineWidth = 1;
                        c.stroke();
                        c.globalAlpha = 1;
                        
                        // === MAIN GREAT HALL (foreground, detailed) ===
                        // Thick log wall structure with gradient
                        let wallGrad = c.createLinearGradient(cx - T*0.4, cy, cx + T*0.15, cy);
                        wallGrad.addColorStop(0, logDark);
                        wallGrad.addColorStop(0.3, logBase);
                        wallGrad.addColorStop(0.7, logLight);
                        wallGrad.addColorStop(1, logBase);
                        c.fillStyle = wallGrad;
                        c.fillRect(cx - T*0.4, cy - T*0.12, T*0.58, T*0.34);
                        
                        // Horizontal log lines (massive hewn logs)
                        c.strokeStyle = logDark;
                        c.lineWidth = 2;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.4, cy - T*0.08 + i*T*0.07);
                            c.lineTo(cx + T*0.18, cy - T*0.08 + i*T*0.07);
                            c.stroke();
                        }
                        
                        // Notched corner log ends (detailed with rings)
                        c.fillStyle = logEnd;
                        for(let i = 0; i < 5; i++) {
                            // Left corner
                            c.beginPath();
                            c.arc(cx - T*0.42, cy - T*0.08 + i*T*0.07, T*0.028, 0, Math.PI*2);
                            c.fill();
                            // Right corner
                            c.beginPath();
                            c.arc(cx + T*0.2, cy - T*0.08 + i*T*0.07, T*0.028, 0, Math.PI*2);
                            c.fill();
                        }
                        // Growth rings on log ends
                        c.strokeStyle = '#3A2010';
                        c.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.arc(cx - T*0.42, cy - T*0.08 + i*T*0.07, T*0.015, 0, Math.PI*2);
                            c.stroke();
                            c.beginPath();
                            c.arc(cx + T*0.2, cy - T*0.08 + i*T*0.07, T*0.015, 0, Math.PI*2);
                            c.stroke();
                        }
                        
                        // === PEAKED SOD/BARK ROOF ===
                        // Main roof surface
                        let roofGrad = c.createLinearGradient(cx - T*0.1, cy - T*0.45, cx - T*0.1, cy - T*0.12);
                        roofGrad.addColorStop(0, roofGreen);
                        roofGrad.addColorStop(1, roofDark);
                        c.fillStyle = roofGrad;
                        c.beginPath();
                        c.moveTo(cx - T*0.45, cy - T*0.12);
                        c.lineTo(cx - T*0.11, cy - T*0.45);
                        c.lineTo(cx + T*0.23, cy - T*0.12);
                        c.closePath();
                        c.fill();
                        
                        // Roof texture (bark/sod strips)
                        c.strokeStyle = roofDark;
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 4; i++) {
                            let ry = cy - T*0.18 - i*T*0.07;
                            let shrink = i * T*0.06;
                            c.beginPath();
                            c.moveTo(cx - T*0.40 + shrink, ry);
                            c.lineTo(cx + T*0.18 - shrink, ry);
                            c.stroke();
                        }
                        
                        // Ridge pole at peak
                        c.strokeStyle = logBase;
                        c.lineWidth = 4;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(cx - T*0.11, cy - T*0.45);
                        c.lineTo(cx - T*0.11, cy - T*0.48);
                        c.stroke();
                        
                        // === STONE FOUNDATION ===
                        c.fillStyle = stoneGray;
                        c.fillRect(cx - T*0.42, cy + T*0.2, T*0.9, T*0.06);
                        // Individual stones
                        c.strokeStyle = stoneDark;
                        c.lineWidth = 1;
                        for(let i = 0; i < 10; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.4 + i*T*0.09, cy + T*0.2);
                            c.lineTo(cx - T*0.4 + i*T*0.09, cy + T*0.26);
                            c.stroke();
                        }
                        
                        // === MAIN ENTRANCE (carved doorway) ===
                        // Door frame
                        c.fillStyle = logDark;
                        c.fillRect(cx - T*0.22, cy - T*0.02, T*0.15, T*0.24);
                        // Door opening
                        c.fillStyle = '#0A0500';
                        c.fillRect(cx - T*0.2, cy, T*0.11, T*0.2);
                        
                        // Interior fire glow
                        if(bld.pop > 0) {
                            let intGlow = c.createRadialGradient(cx - T*0.145, cy + T*0.12, 0, cx - T*0.145, cy + T*0.1, T*0.12);
                            intGlow.addColorStop(0, `rgba(255,100,30,${0.6 * fireGlow})`);
                            intGlow.addColorStop(1, 'rgba(255,60,0,0)');
                            c.fillStyle = intGlow;
                            c.beginPath();
                            c.arc(cx - T*0.145, cy + T*0.12, T*0.12, 0, Math.PI*2);
                            c.fill();
                        }
                        
                        // Carved door frame decoration
                        c.strokeStyle = '#8A6A4A';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx - T*0.22, cy - T*0.02);
                        c.lineTo(cx - T*0.22, cy + T*0.22);
                        c.moveTo(cx - T*0.07, cy - T*0.02);
                        c.lineTo(cx - T*0.07, cy + T*0.22);
                        c.stroke();
                        
                        // === ANTLER/BONE DECORATION ABOVE DOOR ===
                        c.strokeStyle = '#E8E0D8';
                        c.lineWidth = 2.5;
                        c.lineCap = 'round';
                        // Left antler
                        c.beginPath();
                        c.moveTo(cx - T*0.22, cy - T*0.06);
                        c.lineTo(cx - T*0.3, cy - T*0.15);
                        c.lineTo(cx - T*0.26, cy - T*0.1);
                        c.moveTo(cx - T*0.28, cy - T*0.12);
                        c.lineTo(cx - T*0.34, cy - T*0.18);
                        c.stroke();
                        // Right antler
                        c.beginPath();
                        c.moveTo(cx - T*0.07, cy - T*0.06);
                        c.lineTo(cx + T*0.01, cy - T*0.15);
                        c.lineTo(cx - T*0.03, cy - T*0.1);
                        c.moveTo(cx - T*0.01, cy - T*0.12);
                        c.lineTo(cx + T*0.05, cy - T*0.18);
                        c.stroke();
                        
                        // === TOTEM POLE (if variant >= 1) ===
                        if(variant >= 1) {
                            let tx = cx + T*0.4, ty = cy + T*0.2;
                            
                            // Main pole
                            c.fillStyle = '#6B4423';
                            c.fillRect(tx - T*0.04, ty - T*0.55, T*0.08, T*0.55);
                            
                            // Carved face sections
                            // Top face (bird/eagle)
                            c.fillStyle = '#8B5A2B';
                            c.beginPath();
                            c.ellipse(tx, ty - T*0.45, T*0.05, T*0.06, 0, 0, Math.PI*2);
                            c.fill();
                            // Beak
                            c.fillStyle = '#C9A030';
                            c.beginPath();
                            c.moveTo(tx, ty - T*0.45);
                            c.lineTo(tx + T*0.06, ty - T*0.43);
                            c.lineTo(tx, ty - T*0.41);
                            c.closePath();
                            c.fill();
                            // Eyes
                            c.fillStyle = '#FFF';
                            c.beginPath();
                            c.arc(tx - T*0.02, ty - T*0.47, T*0.012, 0, Math.PI*2);
                            c.arc(tx + T*0.02, ty - T*0.47, T*0.012, 0, Math.PI*2);
                            c.fill();
                            c.fillStyle = '#000';
                            c.beginPath();
                            c.arc(tx - T*0.02, ty - T*0.47, T*0.006, 0, Math.PI*2);
                            c.arc(tx + T*0.02, ty - T*0.47, T*0.006, 0, Math.PI*2);
                            c.fill();
                            
                            // Middle face (bear)
                            c.fillStyle = '#5B3A1B';
                            c.beginPath();
                            c.ellipse(tx, ty - T*0.28, T*0.055, T*0.065, 0, 0, Math.PI*2);
                            c.fill();
                            // Bear ears
                            c.beginPath();
                            c.arc(tx - T*0.04, ty - T*0.34, T*0.02, 0, Math.PI*2);
                            c.arc(tx + T*0.04, ty - T*0.34, T*0.02, 0, Math.PI*2);
                            c.fill();
                            // Bear snout
                            c.fillStyle = '#7B5A3B';
                            c.beginPath();
                            c.ellipse(tx, ty - T*0.26, T*0.025, T*0.02, 0, 0, Math.PI*2);
                            c.fill();
                            // Bear eyes
                            c.fillStyle = '#FFF';
                            c.beginPath();
                            c.arc(tx - T*0.02, ty - T*0.3, T*0.01, 0, Math.PI*2);
                            c.arc(tx + T*0.02, ty - T*0.3, T*0.01, 0, Math.PI*2);
                            c.fill();
                            
                            // Bottom section (wings/arms)
                            c.fillStyle = '#4B2A0B';
                            // Left wing
                            c.beginPath();
                            c.moveTo(tx - T*0.04, ty - T*0.15);
                            c.lineTo(tx - T*0.1, ty - T*0.08);
                            c.lineTo(tx - T*0.04, ty - T*0.02);
                            c.closePath();
                            c.fill();
                            // Right wing
                            c.beginPath();
                            c.moveTo(tx + T*0.04, ty - T*0.15);
                            c.lineTo(tx + T*0.1, ty - T*0.08);
                            c.lineTo(tx + T*0.04, ty - T*0.02);
                            c.closePath();
                            c.fill();
                            
                            // Painted details (red/blue)
                            c.strokeStyle = '#8B2222';
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(tx - T*0.04, ty - T*0.38);
                            c.lineTo(tx + T*0.04, ty - T*0.38);
                            c.stroke();
                        }
                        
                        // === FIRE PIT IN COURTYARD ===
                        if(variant >= 2 && bld.pop > 0) {
                            let fx = cx + T*0.05, fy = cy + T*0.15;
                            // Stone ring
                            c.fillStyle = stoneGray;
                            for(let i = 0; i < 6; i++) {
                                let angle = i * Math.PI / 3;
                                c.beginPath();
                                c.arc(fx + Math.cos(angle)*T*0.05, fy + Math.sin(angle)*T*0.025, T*0.018, 0, Math.PI*2);
                                c.fill();
                            }
                            // Fire
                            c.fillStyle = '#FF6600';
                            c.beginPath();
                            c.moveTo(fx - T*0.03, fy);
                            c.quadraticCurveTo(fx, fy - T*0.06 - Math.sin(t*4)*T*0.01, fx + T*0.03, fy);
                            c.fill();
                            c.fillStyle = '#FFCC00';
                            c.beginPath();
                            c.moveTo(fx - T*0.015, fy);
                            c.quadraticCurveTo(fx, fy - T*0.04, fx + T*0.015, fy);
                            c.fill();
                        }
                        
                        // === SMOKE FROM BOTH BUILDINGS ===
                        if(bld.pop > 0) {
                            // Main hall smoke (from smoke hole)
                            for(let i = 0; i < 4; i++) {
                                let sy = cy - T*0.52 - i*T*0.08 - smokeRise*T*0.03;
                                let sx = cx - T*0.11 + Math.sin(t*0.4 + i*0.7)*T*0.04;
                                let size = (5 + i*0.8) * (1 - i*0.1);
                                c.fillStyle = `rgba(160,160,160,${0.45 - i*0.08})`;
                                c.beginPath();
                                c.arc(sx, sy, size, 0, Math.PI*2);
                                c.fill();
                            }
                            // Secondary building smoke
                            for(let i = 0; i < 3; i++) {
                                let sy = cy - T*0.26 - i*T*0.06 - smokeRise*T*0.02;
                                let sx = cx + T*0.32 + Math.sin(t*0.5 + i)*T*0.03;
                                let size = (3 + i*0.5) * (1 - i*0.15);
                                c.fillStyle = `rgba(150,150,150,${0.35 - i*0.1})`;
                                c.beginPath();
                                c.arc(sx, sy, size, 0, Math.PI*2);
                                c.fill();
                            }
                        }
                        
                        // === FLAG/BANNER (if max variant) ===
                        if(variant >= 3) {
                            // Pole
                            c.strokeStyle = logDark;
                            c.lineWidth = 3;
                            c.beginPath();
                            c.moveTo(cx - T*0.35, cy - T*0.12);
                            c.lineTo(cx - T*0.35, cy - T*0.55);
                            c.stroke();
                            
                            // Flag
                            c.fillStyle = '#8B2222';
                            c.beginPath();
                            c.moveTo(cx - T*0.35, cy - T*0.55);
                            c.quadraticCurveTo(cx - T*0.25 + flagWave*T, cy - T*0.48, cx - T*0.2, cy - T*0.5);
                            c.lineTo(cx - T*0.2, cy - T*0.42);
                            c.quadraticCurveTo(cx - T*0.25 + flagWave*T, cy - T*0.44, cx - T*0.35, cy - T*0.45);
                            c.closePath();
                            c.fill();
                        }
                    }
                    
                    // Gold border if within Chief's Hut radius
                    if(hasChiefBonus) {
                        c.strokeStyle = "#FFD700";
                        c.lineWidth = 3;
                        c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                    }
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                
                // Get variant name from config
                let variantConfig = null;
                let variantName = buildingConfig.name;
                if(buildingConfig.variants && buildingConfig.variants[variant]) {
                    variantConfig = buildingConfig.variants[variant];
                    variantName = variantConfig.name;
                }
                
                // Color based on level AND variant - Generate colors dynamically
                // Each level gets progressively more vibrant/prestigious colors
                const generateLevelColors = (level) => {
                    // Base hue shifts from brown (30) through green (120) to blue (200) to purple (280)
                    let hueBase = 30 + (level - 1) * 15;
                    if(hueBase > 360) hueBase = hueBase % 360;
                    
                    // Saturation increases with level
                    let sat = Math.min(70, 30 + level * 3);
                    
                    return [
                        `hsla(${hueBase}, ${sat - 20}%, 25%, 0.8)`,   // Abandoned - Dark
                        `hsla(${hueBase}, ${sat}%, 35%, 0.85)`,       // Low - Medium
                        `hsla(${hueBase}, ${sat + 10}%, 45%, 0.9)`,   // Medium - Bright
                        `hsla(${hueBase}, ${sat + 15}%, 55%, 0.95)`   // High - Vibrant
                    ];
                };
                
                // Named colors for first 4 levels for thematic consistency
                let levelColors = {
                    1: [ // Pit level - Brown tones
                        'rgba(101, 67, 33, 0.8)',    
                        'rgba(141, 110, 99, 0.85)',  
                        'rgba(180, 140, 100, 0.9)',  
                        'rgba(212, 180, 130, 0.95)'  
                    ],
                    2: [ // Leather Tent level - Leather/hide tones
                        'rgba(90, 70, 50, 0.8)',     
                        'rgba(139, 90, 43, 0.85)',   
                        'rgba(160, 120, 80, 0.9)',   
                        'rgba(188, 152, 106, 0.95)'  
                    ],
                    3: [ // Mud Brick level - Clay/adobe tones
                        'rgba(80, 60, 40, 0.8)',     
                        'rgba(140, 100, 60, 0.85)',  
                        'rgba(180, 130, 80, 0.9)',   
                        'rgba(210, 160, 100, 0.95)'  
                    ],
                    4: [ // Log House - Wood tones
                        'rgba(60, 40, 20, 0.8)',     
                        'rgba(100, 70, 40, 0.85)', 
                        'rgba(139, 90, 43, 0.9)',  
                        'rgba(160, 120, 60, 0.95)'  
                    ]
                };
                
                // Get color for this level and variant
                let colorArray = levelColors[lvl] || generateLevelColors(lvl);
                let fillColor = colorArray[Math.min(variant, colorArray.length - 1)];
                
                // Check for overcrowding
                let levelCfg = CFG.BUILDING_LEVELS[lvl] || {};
                let capacity = levelCfg.capacity || 20;
                let pop = bld.pop || 0;
                let isOvercrowded = pop > capacity;
                let isAbandoned = variant === 0 || pop === 0;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Draw building with VARIANT-SPECIFIC artwork for each level
                // Variant 0 = Abandoned, 1 = Low, 2 = Medium, 3 = High
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                if(lvl === 1) {
                    // ‚ïê‚ïê‚ïê LEVEL 1: TREE SHELTER - Nest/Platform variations ‚ïê‚ïê‚ïê
                    if(variant === 0) {
                        // ABANDONED NEST - Dead tree, fallen nest
                        c.fillStyle = '#4A4540';
                        c.fillRect(cx - T*0.08, y + T*0.2, T*0.16, T*0.6); // Dead trunk
                        c.fillStyle = '#5A5248';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, y + T*0.75, T*0.15, T*0.08, 0.2, 0, 6.28);
                        c.fill(); // Fallen debris
                    } else if(variant === 1) {
                        // SMALL NEST - Young tree, simple nest
                        c.fillStyle = '#5A4528';
                        c.fillRect(cx - T*0.06, y + T*0.35, T*0.12, T*0.5);
                        c.fillStyle = '#3A6A25';
                        c.beginPath();
                        c.arc(cx, y + T*0.3, T*0.15, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#7A6040';
                        c.beginPath();
                        c.ellipse(cx, y + T*0.45, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                    } else if(variant === 2) {
                        // TREE PLATFORM - Solid platform
                        c.fillStyle = '#5A3D25';
                        c.fillRect(cx - T*0.1, y + T*0.25, T*0.2, T*0.6);
                        c.fillStyle = '#2E5E1A';
                        c.beginPath();
                        c.arc(cx, y + T*0.2, T*0.22, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#8B6914';
                        c.fillRect(cx - T*0.18, y + T*0.4, T*0.36, T*0.08);
                        c.fillStyle = '#5C4A3D';
                        c.beginPath();
                        c.moveTo(cx - T*0.1, y + T*0.4);
                        c.lineTo(cx, y + T*0.28);
                        c.lineTo(cx + T*0.1, y + T*0.4);
                        c.closePath();
                        c.fill();
                    } else {
                        // STURDY TREEHOUSE - Full structure
                        c.fillStyle = '#3D2817';
                        c.fillRect(cx - T*0.12, y + T*0.2, T*0.24, T*0.65);
                        c.fillStyle = '#1E4D0F';
                        c.beginPath();
                        c.arc(cx - T*0.08, y + T*0.15, T*0.18, 0, 6.28);
                        c.arc(cx + T*0.08, y + T*0.12, T*0.2, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#8B6914';
                        c.beginPath();
                        c.ellipse(cx, y + T*0.38, T*0.2, T*0.1, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#C4A035';
                        c.beginPath();
                        c.moveTo(cx, y + T*0.2);
                        c.lineTo(cx - T*0.15, y + T*0.38);
                        c.lineTo(cx + T*0.15, y + T*0.38);
                        c.closePath();
                        c.fill();
                        c.fillStyle = 'rgba(255, 180, 100, 0.5)';
                        c.beginPath();
                        c.arc(cx, y + T*0.35, T*0.04, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 2) {
                    // ‚ïê‚ïê‚ïê LEVEL 2: GROUND PIT - Pit variations ‚ïê‚ïê‚ïê
                    if(variant === 0) {
                        // COLLAPSED PIT - Rubble pile
                        c.fillStyle = '#4D4030';
                        c.fillRect(x + T*0.1, y + T*0.4, T*0.8, T*0.5);
                        c.fillStyle = '#5A5045';
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.arc(cx - T*0.15 + i*T*0.1, cy + T*0.1, T*0.08, 0, 6.28);
                            c.fill();
                        }
                    } else if(variant === 1) {
                        // SHALLOW SCRAPE - Simple depression
                        c.fillStyle = '#5D4E37';
                        c.fillRect(x + T*0.1, y + T*0.35, T*0.8, T*0.55);
                        c.fillStyle = '#3A2A1A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.25, T*0.12, 0, 0, 6.28);
                        c.fill();
                    } else if(variant === 2) {
                        // DUG PIT - Proper pit with supports
                        c.fillStyle = '#5D4E37';
                        c.fillRect(x + T*0.08, y + T*0.3, T*0.84, T*0.6);
                        c.fillStyle = '#2A1A0A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.05, T*0.3, T*0.18, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A3728';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy + T*0.2);
                        c.lineTo(cx - T*0.2, cy - T*0.15);
                        c.moveTo(cx + T*0.2, cy + T*0.2);
                        c.lineTo(cx + T*0.2, cy - T*0.15);
                        c.stroke();
                    } else {
                        // COVERED PIT DWELLING - Full dwelling
                        c.fillStyle = '#5D4E37';
                        c.fillRect(x + T*0.05, y + T*0.25, T*0.9, T*0.65);
                        c.fillStyle = '#2A1A0A';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.08, T*0.35, T*0.2, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#C4A035';
                        for(let i = 0; i < 5; i++) {
                            c.fillRect(cx - T*0.25 + i*T*0.1, cy, T*0.06, T*0.12);
                        }
                        c.strokeStyle = '#4A3728';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(cx - T*0.25, cy - T*0.2);
                        c.lineTo(cx - T*0.25, cy + T*0.15);
                        c.moveTo(cx + T*0.25, cy - T*0.2);
                        c.lineTo(cx + T*0.25, cy + T*0.15);
                        c.moveTo(cx - T*0.28, cy - T*0.12);
                        c.lineTo(cx + T*0.28, cy - T*0.12);
                        c.stroke();
                        // Fire glow
                        c.fillStyle = 'rgba(255, 150, 50, 0.4)';
                        c.beginPath();
                        c.arc(cx, cy + T*0.2, T*0.08, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 3) {
                    // ‚ïê‚ïê‚ïê LEVEL 3: GROUND CAVE - Cave variations ‚ïê‚ïê‚ïê
                    if(variant === 0) {
                        // COLLAPSED CAVE - Rubble pile
                        c.fillStyle = '#4A4540';
                        c.beginPath();
                        c.moveTo(x + T*0.1, y + T*0.85);
                        c.quadraticCurveTo(cx, y + T*0.2, x + T*0.9, y + T*0.85);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#5A5550';
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.arc(cx - T*0.1 + i*T*0.1, cy + T*0.15, T*0.1, 0, 6.28);
                            c.fill();
                        }
                    } else if(variant === 1) {
                        // SMALL CAVE - Basic overhang
                        c.fillStyle = '#5D5550';
                        c.beginPath();
                        c.moveTo(x + T*0.15, y + T*0.85);
                        c.quadraticCurveTo(cx, y + T*0.25, x + T*0.85, y + T*0.85);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#1A1510';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.15, T*0.1, T*0.12, 0, 0, Math.PI);
                        c.fill();
                    } else if(variant === 2) {
                        // DEEP CAVE - Larger with fire glow
                        c.fillStyle = '#5D5045';
                        c.beginPath();
                        c.moveTo(x + T*0.1, y + T*0.85);
                        c.quadraticCurveTo(cx, y + T*0.15, x + T*0.9, y + T*0.85);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#4A7A2A';
                        c.beginPath();
                        c.ellipse(cx, y + T*0.22, T*0.12, T*0.06, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#0A0505';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.12, T*0.12, T*0.15, 0, 0, Math.PI);
                        c.fill();
                        c.fillStyle = 'rgba(255, 120, 40, 0.5)';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.18, T*0.08, T*0.1, 0, 0, Math.PI);
                        c.fill();
                    } else {
                        // CAVE COMPLEX - Full dwelling with chimney
                        c.fillStyle = '#5D4E37';
                        c.beginPath();
                        c.moveTo(x + T*0.05, y + T*0.85);
                        c.quadraticCurveTo(cx - T*0.15, y + T*0.1, cx, y + T*0.08);
                        c.quadraticCurveTo(cx + T*0.15, y + T*0.1, x + T*0.95, y + T*0.85);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#4A7A2A';
                        c.beginPath();
                        c.ellipse(cx - T*0.1, y + T*0.18, T*0.15, T*0.08, -0.2, 0, 6.28);
                        c.ellipse(cx + T*0.12, y + T*0.15, T*0.12, T*0.06, 0.2, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#6B6B6B';
                        c.beginPath();
                        c.moveTo(cx - T*0.18, cy + T*0.25);
                        c.lineTo(cx - T*0.15, cy - T*0.05);
                        c.quadraticCurveTo(cx, cy - T*0.15, cx + T*0.15, cy - T*0.05);
                        c.lineTo(cx + T*0.18, cy + T*0.25);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#0A0505';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.12, T*0.15, 0, 0, Math.PI);
                        c.fill();
                        c.fillStyle = 'rgba(255, 150, 50, 0.7)';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.15, T*0.1, T*0.12, 0, 0, Math.PI);
                        c.fill();
                        c.fillStyle = '#5A5A5A';
                        c.fillRect(cx + T*0.2, y + T*0.05, T*0.08, T*0.25);
                        c.fillStyle = 'rgba(200, 200, 200, 0.4)';
                        c.beginPath();
                        c.arc(cx + T*0.24, y + T*0.02, T*0.04, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 4) {
                    // ‚ïê‚ïê‚ïê LEVEL 4: TIPI VILLAGE - Tipi variations ‚ïê‚ïê‚ïê
                    const drawSmallTipi = (tx, ty, size, collapsed = false) => {
                        if(collapsed) {
                            c.strokeStyle = '#5C4A3D';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.moveTo(tx - size*0.15, ty + size*0.1);
                            c.lineTo(tx + size*0.1, ty - size*0.05);
                            c.stroke();
                            c.fillStyle = '#8A7A68';
                            c.beginPath();
                            c.ellipse(tx, ty + size*0.05, size*0.1, size*0.04, 0.3, 0, 6.28);
                            c.fill();
                            return;
                        }
                        c.fillStyle = '#E8DCC8';
                        c.beginPath();
                        c.moveTo(tx, ty - size*0.4);
                        c.lineTo(tx - size*0.2, ty + size*0.2);
                        c.lineTo(tx + size*0.2, ty + size*0.2);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#5C4A3D';
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(tx - size*0.03, ty - size*0.35);
                        c.lineTo(tx - size*0.08, ty - size*0.5);
                        c.moveTo(tx + size*0.03, ty - size*0.35);
                        c.lineTo(tx + size*0.08, ty - size*0.5);
                        c.stroke();
                        c.fillStyle = '#1A0F05';
                        c.beginPath();
                        c.ellipse(tx, ty + size*0.1, size*0.05, size*0.08, 0, 0, 6.28);
                        c.fill();
                    };
                    
                    if(variant === 0) {
                        drawSmallTipi(cx - T*0.1, cy, T*0.5, true);
                        drawSmallTipi(cx + T*0.15, cy + T*0.05, T*0.4, true);
                    } else if(variant === 1) {
                        drawSmallTipi(cx, cy + T*0.05, T*0.6, false);
                    } else if(variant === 2) {
                        drawSmallTipi(cx - T*0.12, cy + T*0.02, T*0.55, false);
                        drawSmallTipi(cx + T*0.15, cy + T*0.08, T*0.45, false);
                        c.fillStyle = '#FF6B35';
                        c.beginPath();
                        c.arc(cx + T*0.02, cy + T*0.3, T*0.04, 0, 6.28);
                        c.fill();
                    } else {
                        drawSmallTipi(cx - T*0.15, cy, T*0.55, false);
                        drawSmallTipi(cx + T*0.18, cy + T*0.05, T*0.5, false);
                        c.fillStyle = '#FF6B35';
                        c.beginPath();
                        c.arc(cx + T*0.02, cy + T*0.28, T*0.05, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#FFD93D';
                        c.beginPath();
                        c.arc(cx + T*0.02, cy + T*0.26, T*0.03, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 5) {
                    // ‚ïê‚ïê‚ïê LEVEL 5: LONGHOUSE - Longhouse variations ‚ïê‚ïê‚ïê
                    if(variant === 0) {
                        // RUINED LONGHOUSE
                        c.fillStyle = '#4A3A2D';
                        c.fillRect(cx - T*0.25, cy + T*0.05, T*0.4, T*0.2);
                        c.fillStyle = '#8A7A55';
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.ellipse(cx - T*0.15 + i*T*0.1, cy, T*0.05, T*0.03, i*0.2, 0, 6.28);
                            c.fill();
                        }
                    } else if(variant === 1) {
                        // SMALL LONGHOUSE
                        c.fillStyle = '#5C3A1D';
                        c.fillRect(cx - T*0.2, cy, T*0.4, T*0.25);
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.moveTo(cx - T*0.22, cy);
                        c.lineTo(cx, cy - T*0.15);
                        c.lineTo(cx + T*0.22, cy);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#1A0F05';
                        c.fillRect(cx - T*0.04, cy + T*0.1, T*0.08, T*0.12);
                    } else if(variant === 2) {
                        // FAMILY LONGHOUSE
                        c.fillStyle = '#5C3A1D';
                        c.fillRect(cx - T*0.28, cy - T*0.02, T*0.56, T*0.3);
                        c.fillStyle = '#C4A035';
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.02, T*0.3, T*0.15, 0, Math.PI, 0);
                        c.fill();
                        c.fillStyle = '#1A0F05';
                        c.fillRect(cx - T*0.05, cy + T*0.08, T*0.1, T*0.15);
                    } else {
                        // CLAN LONGHOUSE
                        c.fillStyle = '#7B5030';
                        c.fillRect(cx - T*0.35, cy - T*0.05, T*0.7, T*0.35);
                        c.fillStyle = '#C4A035';
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.05, T*0.38, T*0.2, 0, Math.PI, 0);
                        c.fill();
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.3 + i*T*0.15, cy - T*0.05);
                            c.quadraticCurveTo(cx - T*0.3 + i*T*0.15, cy - T*0.18, cx - T*0.25 + i*T*0.12, cy - T*0.05);
                            c.stroke();
                        }
                        c.fillStyle = '#1A0F05';
                        c.fillRect(cx - T*0.06, cy + T*0.08, T*0.12, T*0.18);
                        c.fillStyle = '#8B6914';
                        c.fillRect(cx - T*0.05, cy + T*0.1, T*0.1, T*0.06);
                        c.fillStyle = 'rgba(180, 180, 180, 0.4)';
                        c.beginPath();
                        c.arc(cx - T*0.12, cy - T*0.2, T*0.02, 0, 6.28);
                        c.arc(cx + T*0.12, cy - T*0.2, T*0.02, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 6) {
                    // ‚ïê‚ïê‚ïê LEVEL 6: LOG COMPOUND - Compound variations ‚ïê‚ïê‚ïê
                    if(variant === 0) {
                        // ABANDONED COMPOUND
                        c.fillStyle = '#4A3A2D';
                        c.fillRect(cx - T*0.2, cy + T*0.02, T*0.3, T*0.18);
                        c.fillStyle = '#5A4A3D';
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.arc(cx - T*0.15 + i*T*0.1, cy, T*0.04, 0, 6.28);
                            c.fill();
                        }
                    } else if(variant === 1) {
                        // SMALL COMPOUND
                        c.fillStyle = '#5C3A1D';
                        c.fillRect(cx - T*0.18, cy - T*0.02, T*0.32, T*0.22);
                        c.fillStyle = '#4A2E15';
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy - T*0.02);
                        c.lineTo(cx - T*0.02, cy - T*0.18);
                        c.lineTo(cx + T*0.16, cy - T*0.02);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#4A3728';
                        c.lineWidth = 1;
                        for(let i = 0; i < 2; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.28 + i*T*0.08, cy + T*0.22);
                            c.lineTo(cx - T*0.28 + i*T*0.08, cy + T*0.28);
                            c.stroke();
                        }
                    } else if(variant === 2) {
                        // GROWING COMPOUND
                        c.fillStyle = '#5C3A1D';
                        c.fillRect(cx - T*0.25, cy - T*0.05, T*0.35, T*0.25);
                        c.fillStyle = '#4A2E15';
                        c.beginPath();
                        c.moveTo(cx - T*0.28, cy - T*0.05);
                        c.lineTo(cx - T*0.08, cy - T*0.22);
                        c.lineTo(cx + T*0.12, cy - T*0.05);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#6B4423';
                        c.fillRect(cx + T*0.08, cy + T*0.05, T*0.18, T*0.15);
                        c.fillStyle = '#5C3A1D';
                        c.beginPath();
                        c.moveTo(cx + T*0.06, cy + T*0.05);
                        c.lineTo(cx + T*0.17, cy - T*0.05);
                        c.lineTo(cx + T*0.28, cy + T*0.05);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#4A3728';
                        c.lineWidth = 1;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.32 + i*T*0.06, cy + T*0.22);
                            c.lineTo(cx - T*0.32 + i*T*0.06, cy + T*0.28);
                            c.stroke();
                        }
                    } else {
                        // GRAND LOG COMPOUND
                        c.fillStyle = '#5C3A1D';
                        c.fillRect(cx - T*0.3, cy - T*0.08, T*0.45, T*0.3);
                        c.fillStyle = '#4A2E15';
                        c.beginPath();
                        c.moveTo(cx - T*0.35, cy - T*0.08);
                        c.lineTo(cx - T*0.08, cy - T*0.32);
                        c.lineTo(cx + T*0.18, cy - T*0.08);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#6B4423';
                        c.fillRect(cx + T*0.1, cy + T*0.02, T*0.22, T*0.2);
                        c.fillStyle = '#5C3A1D';
                        c.beginPath();
                        c.moveTo(cx + T*0.08, cy + T*0.02);
                        c.lineTo(cx + T*0.21, cy - T*0.1);
                        c.lineTo(cx + T*0.34, cy + T*0.02);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#8B4513';
                        c.fillRect(cx + T*0.32, cy - T*0.2, T*0.06, T*0.42);
                        c.fillStyle = '#FFD700';
                        c.beginPath();
                        c.arc(cx + T*0.35, cy - T*0.12, T*0.04, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A3728';
                        c.lineWidth = 2;
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.38 + i*T*0.06, cy + T*0.25);
                            c.lineTo(cx - T*0.38 + i*T*0.06, cy + T*0.32);
                            c.stroke();
                        }
                    }
                    
                } else {
                    // DEFAULT - Square building for unknown levels
                    c.fillStyle = isAbandoned ? '#4A4A4A' : fillColor;
                    c.fillRect(x + 4, y + 4, T - 8, T - 8);
                    c.strokeStyle = isAbandoned ? '#333' : '#3E2723';
                    c.lineWidth = 2;
                    c.strokeRect(x + 4, y + 4, T - 8, T - 8);
                }
                
                // ABANDONED INDICATOR - Gray X overlay
                if(isAbandoned) {
                    c.strokeStyle = 'rgba(100, 50, 50, 0.7)';
                    c.lineWidth = 3;
                    c.beginPath();
                    c.moveTo(x + 8, y + 8);
                    c.lineTo(x + T - 8, y + T - 8);
                    c.moveTo(x + T - 8, y + 8);
                    c.lineTo(x + 8, y + T - 8);
                    c.stroke();
                }
                
                // OVERCROWDED INDICATOR - Red pulsing border
                if(isOvercrowded) {
                    let pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    c.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
                    c.lineWidth = 3;
                    c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                    
                    // Warning icon
                    c.fillStyle = '#FF0000';
                    c.font = 'bold 12px sans-serif';
                    c.textAlign = 'right';
                    c.fillText('‚ö†Ô∏è', x + T - 2, y + 12);
                }
                
                // Gold border if within Chief's Hut radius
                if(hasChiefBonus && !isOvercrowded) {
                    c.strokeStyle = "#FFD700";
                    c.lineWidth = 2;
                    c.strokeRect(x + 1, y + 1, T - 2, T - 2);
                }
                
                // Show population count at top with color coding
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.font = "bold " + Math.floor(T/5) + "px sans-serif";
                c.fillStyle = isOvercrowded ? '#FF4444' : (isAbandoned ? '#888' : '#FFFFFF');
                c.fillText(`üë•${pop}/${capacity}`, cx, y + T/5);
                
                // Building name in center
                let displayName = variantConfig ? variantConfig.name : buildingConfig.name;
                c.font = "bold " + Math.floor(T/7) + "px sans-serif";
                c.fillStyle = isAbandoned ? '#666' : '#FFFFFF';
                
                // Show building type icon instead of long names
                let icon = 'üè†';
                if(lvl === 1) icon = isAbandoned ? 'ü™π' : (variant >= 2 ? 'üèïÔ∏è' : 'ü™∫');
                else if(lvl === 2) icon = isAbandoned ? 'üï≥Ô∏è' : (variant >= 2 ? 'üè†' : 'üü´');
                else if(lvl === 3) icon = isAbandoned ? 'ü™®' : (variant >= 2 ? 'üèîÔ∏è' : '‚õ∞Ô∏è');
                else if(lvl === 4) icon = isAbandoned ? '‚õ∫' : (variant >= 2 ? 'üé™' : '‚õ∫');
                else if(lvl === 5) icon = isAbandoned ? 'üèöÔ∏è' : (variant >= 2 ? 'üèòÔ∏è' : 'üè†');
                else if(lvl === 6) icon = isAbandoned ? 'üèöÔ∏è' : (variant >= 2 ? 'üèØ' : 'üèòÔ∏è');
                
                c.font = Math.floor(T/3) + "px sans-serif";
                c.fillText(icon, cx, cy + 2);
                
                // Level indicator at bottom
                c.font = Math.floor(T/6) + "px sans-serif";
                c.fillStyle = '#FFFFFF';
                c.fillText(`L${lvl}`, cx, y + T - 6);
            },
            drawRes(c,x,y,b) {
                let lvl = b.lvl || 1;
                let cx = x + 32, cy = y + 32;
                let desirability = b.desirability || 1.0;
                
                // Visual feedback: High desirability = brighter/warmer, Low = darker/smaller
                let brightness = Math.min(1.5, Math.max(0.6, desirability));
                let scale = Math.min(1.1, Math.max(0.85, 0.9 + desirability * 0.1));
                
                // Determine architectural era based on level (1-200)
                if(lvl <= 40) {
                    // PRIMITIVE (1-40): Mud huts ‚Üí Stone huts
                    let progress = (lvl - 1) / 39;
                    let baseSize = 18 + progress * 8;
                    let roofHeight = 28 + progress * 12;
                    
                    c.fillStyle = "rgba(0,0,0,0.2)";
                    c.beginPath();
                    c.ellipse(cx, cy + 22, baseSize + 2, 6, 0, 0, 6.28);
                    c.fill();
                    
                    // Walls transition mud ‚Üí stone
                    let mudColor = [141, 110, 99];
                    let stoneColor = [120, 120, 120];
                    let wallColor = mudColor.map((m, i) => Math.floor((m + (stoneColor[i] - m) * progress) * brightness));
                    c.fillStyle = `rgb(${wallColor[0]}, ${wallColor[1]}, ${wallColor[2]})`;
                    c.beginPath();
                    c.arc(cx, cy, baseSize * scale, 0, 6.28);
                    c.fill();
                    
                    // Roof
                    let roofColor = lvl > 20 ? "#8B7355" : "#D4A574";
                    c.fillStyle = roofColor;
                    c.beginPath();
                    c.moveTo(cx - (baseSize + 4) * scale, cy);
                    c.lineTo(cx + (baseSize + 4) * scale, cy);
                    c.lineTo(cx, cy - roofHeight * scale);
                    c.fill();
                    
                    // High desirability: Smoke from chimney
                    if(desirability > 1.5 && Math.random() > 0.7) {
                        Renderer.particles.push({x: cx, y: cy - roofHeight * scale - 5, l: 30, c: "rgba(200,200,200,0.6)"});
                    }
                } else if(lvl <= 80) {
                    // ANCIENT (41-80): Stone houses ‚Üí Roman villas
                    let progress = (lvl - 41) / 39;
                    let width = (40 + progress * 15) * scale;
                    let height = (30 + progress * 10) * scale;
                    
                    c.fillStyle = `rgba(160, 130, 109, ${brightness})`;
                    c.fillRect(cx - width/2, cy - height/2, width, height);
                    
                    // Columns appear as we progress
                    if(lvl > 60) {
                        c.fillStyle = "#D4C5B9";
                        for(let i = 0; i < 3; i++) {
                            c.fillRect(cx - width/2 + 10 + i * 15, cy - height/2, 5, height);
                        }
                    }
                    
                    // Roof
                    c.fillStyle = "#8B4513";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 5, cy - height/2);
                    c.lineTo(cx + width/2 + 5, cy - height/2);
                    c.lineTo(cx, cy - height/2 - 20);
                    c.fill();
                } else if(lvl <= 120) {
                    // MEDIEVAL (81-120): Wooden houses ‚Üí Stone manors
                    let progress = (lvl - 81) / 39;
                    let stories = Math.floor(1 + progress * 2);
                    let width = 35 * scale;
                    let storyHeight = 18 * scale;
                    
                    for(let s = 0; s < stories; s++) {
                        let baseColor = s % 2 === 0 ? [101, 67, 33] : [139, 115, 85];
                        c.fillStyle = `rgb(${Math.floor(baseColor[0]*brightness)}, ${Math.floor(baseColor[1]*brightness)}, ${Math.floor(baseColor[2]*brightness)})`;
                        c.fillRect(cx - width/2, cy + 10 - s * storyHeight, width, storyHeight);
                        
                        // Windows
                        c.fillStyle = "#FFE4B5";
                        c.fillRect(cx - 8, cy + 15 - s * storyHeight, 6, 8);
                        c.fillRect(cx + 2, cy + 15 - s * storyHeight, 6, 8);
                    }
                    
                    // Roof
                    c.fillStyle = "#8B0000";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx + width/2 + 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx, cy - 5 - stories * storyHeight);
                    c.fill();
                } else if(lvl <= 160) {
                    // INDUSTRIAL (121-160): Brick apartments ‚Üí Early skyscrapers
                    let progress = (lvl - 121) / 39;
                    let stories = Math.floor(3 + progress * 5);
                    let width = 32 * scale;
                    let storyHeight = 12 * scale;
                    
                    c.fillStyle = "#8B4513";
                    c.fillRect(cx - width/2, cy + 15 - stories * storyHeight, width, stories * storyHeight);
                    
                    // Grid of windows
                    c.fillStyle = "#FFD700";
                    for(let s = 0; s < stories; s++) {
                        for(let w = 0; w < 2; w++) {
                            c.fillRect(cx - 12 + w * 14, cy + 18 - s * storyHeight, 8, 6);
                        }
                    }
                    
                    // Flat roof
                    c.fillStyle = "#696969";
                    c.fillRect(cx - width/2 - 2, cy + 15 - stories * storyHeight - 3, width + 4, 3);
                    
                    // High desirability: Smoke particles
                    if(desirability > 1.3 && Math.random() > 0.8) {
                        Renderer.particles.push({x: cx + 10, y: cy + 15 - stories * storyHeight - 10, l: 25, c: "rgba(180,180,180,0.5)"});
                    }
                } else {
                    // MODERN/FUTURISTIC (161-200): Skyscrapers ‚Üí Mega towers
                    let progress = (lvl - 161) / 39;
                    let stories = Math.floor(8 + progress * 12);
                    let width = 28 * scale;
                    let storyHeight = 10 * scale;
                    
                    // Main tower
                    let gradient = c.createLinearGradient(cx - width/2, 0, cx + width/2, 0);
                    gradient.addColorStop(0, "#4A90E2");
                    gradient.addColorStop(1, "#50C878");
                    c.fillStyle = gradient;
                    c.fillRect(cx - width/2, cy + 20 - stories * storyHeight, width, stories * storyHeight);
                    
                    // High-tech windows
                    c.fillStyle = lvl > 180 ? "#00FFFF" : "#87CEEB";
                    for(let s = 0; s < stories; s++) {
                        c.fillRect(cx - 10, cy + 22 - s * storyHeight, 20, 6);
                    }
                    
                    // Futuristic top (for highest levels)
                    if(lvl > 180) {
                        c.fillStyle = "#FF00FF";
                        c.beginPath();
                        c.arc(cx, cy + 20 - stories * storyHeight - 5, 5, 0, 6.28);
                        c.fill();
                    }
                }
                
                // Level indicator
                c.fillStyle = "#FFFFFF";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText(`L${lvl}`, cx, y + 60);
            },
            drawCom(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;
                let variant = b.variant || 1;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ROLLERCOASTER TYCOON STYLE ISOMETRIC COMMERCIAL BUILDINGS
                // Professional orthographic 3/4 view with proper depth, shadows, and detail
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                const t = Renderer.time || 0;
                
                // === ISOMETRIC HELPER FUNCTIONS ===
                const isoX = (px, py) => cx + (px - py) * 0.5;
                const isoY = (px, py, pz) => cy + (px + py) * 0.25 - pz * 0.5;
                
                // Draw isometric box (RCT style)
                const drawIsoBox = (bx, by, bz, w, d, h, topColor, leftColor, rightColor) => {
                    // Top face
                    c.fillStyle = topColor;
                    c.beginPath();
                    c.moveTo(isoX(bx, by), isoY(bx, by, bz + h));
                    c.lineTo(isoX(bx + w, by), isoY(bx + w, by, bz + h));
                    c.lineTo(isoX(bx + w, by + d), isoY(bx + w, by + d, bz + h));
                    c.lineTo(isoX(bx, by + d), isoY(bx, by + d, bz + h));
                    c.closePath();
                    c.fill();
                    
                    // Left face (darker)
                    c.fillStyle = leftColor;
                    c.beginPath();
                    c.moveTo(isoX(bx, by), isoY(bx, by, bz + h));
                    c.lineTo(isoX(bx, by + d), isoY(bx, by + d, bz + h));
                    c.lineTo(isoX(bx, by + d), isoY(bx, by + d, bz));
                    c.lineTo(isoX(bx, by), isoY(bx, by, bz));
                    c.closePath();
                    c.fill();
                    
                    // Right face (medium)
                    c.fillStyle = rightColor;
                    c.beginPath();
                    c.moveTo(isoX(bx, by + d), isoY(bx, by + d, bz + h));
                    c.lineTo(isoX(bx + w, by + d), isoY(bx + w, by + d, bz + h));
                    c.lineTo(isoX(bx + w, by + d), isoY(bx + w, by + d, bz));
                    c.lineTo(isoX(bx, by + d), isoY(bx, by + d, bz));
                    c.closePath();
                    c.fill();
                };
                
                // Draw isometric roof (peaked)
                const drawIsoRoof = (bx, by, bz, w, d, peakH, roofColor, shadowColor) => {
                    let midX = bx + w/2;
                    // Front slope
                    c.fillStyle = roofColor;
                    c.beginPath();
                    c.moveTo(isoX(bx, by + d), isoY(bx, by + d, bz));
                    c.lineTo(isoX(midX, by + d), isoY(midX, by + d, bz + peakH));
                    c.lineTo(isoX(bx + w, by + d), isoY(bx + w, by + d, bz));
                    c.closePath();
                    c.fill();
                    // Back slope (darker)
                    c.fillStyle = shadowColor;
                    c.beginPath();
                    c.moveTo(isoX(bx, by), isoY(bx, by, bz));
                    c.lineTo(isoX(midX, by), isoY(midX, by, bz + peakH));
                    c.lineTo(isoX(midX, by + d), isoY(midX, by + d, bz + peakH));
                    c.lineTo(isoX(bx, by + d), isoY(bx, by + d, bz));
                    c.closePath();
                    c.fill();
                    // Right slope
                    c.fillStyle = roofColor;
                    c.beginPath();
                    c.moveTo(isoX(bx + w, by), isoY(bx + w, by, bz));
                    c.lineTo(isoX(midX, by), isoY(midX, by, bz + peakH));
                    c.lineTo(isoX(midX, by + d), isoY(midX, by + d, bz + peakH));
                    c.lineTo(isoX(bx + w, by + d), isoY(bx + w, by + d, bz));
                    c.closePath();
                    c.fill();
                };
                
                // === VICTORIAN COLOR PALETTE ===
                const VIC = {
                    PARCHMENT: '#E8DCC8',      // Light background
                    PARCHMENT_DARK: '#D4C4A8', // Darker parchment
                    INK: '#3A3020',            // Dark outlines/shadows
                    SEPIA: '#704020',          // Brown accents
                    EARTH_LIGHT: '#C4A882',    // Light earth
                    EARTH_MED: '#A89070',      // Medium earth
                    EARTH_DARK: '#8B7355',     // Dark earth
                    WOOD_LIGHT: '#A67B5B',     // Light wood
                    WOOD_MED: '#8B6914',       // Medium wood
                    WOOD_DARK: '#6D4C41',      // Dark wood
                    STONE_LIGHT: '#9A9A8A',    // Light stone
                    STONE_MED: '#7A7A6A',      // Medium stone
                    STONE_DARK: '#5A5A4A',     // Dark stone
                    FIRE_HOT: '#D4652F',       // Flame orange
                    FIRE_WARM: '#D4A03D',      // Flame yellow
                    FIRE_EMBER: '#8B3020',     // Ember red
                    PELT_LIGHT: '#B8956E',     // Light pelt
                    PELT_MED: '#A67B5B',       // Medium pelt
                    PELT_DARK: '#5C4033',      // Dark pelt (bear)
                    ABANDONED: '#6A6A5A'       // Gray for abandoned
                };
                
                // === PRIMITIVE HELPER FUNCTIONS ===
                
                // Draw isometric rough stone
                const drawStone = (sx, sy, size, angle, isAbandoned) => {
                    // Shadow
                    c.fillStyle = 'rgba(58,48,32,0.3)';
                    c.beginPath();
                    c.ellipse(sx + 1, sy + 2, size, size*0.6, angle, 0, 6.28);
                    c.fill();
                    // Stone body
                    c.fillStyle = isAbandoned ? VIC.STONE_DARK : VIC.STONE_MED;
                    c.beginPath();
                    c.ellipse(sx, sy, size*1.1, size*0.65, angle, 0, 6.28);
                    c.fill();
                    // Highlight
                    c.fillStyle = isAbandoned ? VIC.STONE_MED : VIC.STONE_LIGHT;
                    c.beginPath();
                    c.ellipse(sx - size*0.2, sy - size*0.2, size*0.4, size*0.25, 0, 0, 6.28);
                    c.fill();
                };
                
                // Draw isometric log
                const drawLog = (lx, ly, length, thickness, angle, isAbandoned) => {
                    // Shadow
                    c.fillStyle = 'rgba(58,48,32,0.25)';
                    c.beginPath();
                    c.ellipse(lx + 2, ly + 2, length, thickness*0.5, angle, 0, 6.28);
                    c.fill();
                    // Log body
                    c.fillStyle = isAbandoned ? VIC.STONE_DARK : VIC.WOOD_DARK;
                    c.beginPath();
                    c.ellipse(lx, ly, length, thickness, angle, 0, 6.28);
                    c.fill();
                    // Bark texture
                    c.strokeStyle = isAbandoned ? VIC.STONE_MED : VIC.WOOD_MED;
                    c.lineWidth = 0.5;
                    c.beginPath();
                    c.ellipse(lx, ly, length*0.7, thickness*0.6, angle, 0, 6.28);
                    c.stroke();
                };
                
                // Draw fire/flames with animation
                const drawFire = (fx, fy, size, intensity) => {
                    let flicker = Math.sin(t * 4) * size * 0.08;
                    // Base glow
                    c.fillStyle = VIC.FIRE_HOT;
                    c.beginPath();
                    c.ellipse(fx, fy + size*0.15, size*0.8, size*0.35, 0, 0, 6.28);
                    c.fill();
                    // Main flame
                    c.fillStyle = VIC.FIRE_HOT;
                    c.beginPath();
                    c.moveTo(fx - size*0.6, fy + size*0.2);
                    c.quadraticCurveTo(fx - size*0.3, fy - size*0.8 + flicker, fx, fy - size*0.4);
                    c.quadraticCurveTo(fx + size*0.3, fy - size - flicker, fx + size*0.6, fy + size*0.2);
                    c.closePath();
                    c.fill();
                    // Inner flame
                    c.fillStyle = VIC.FIRE_WARM;
                    c.beginPath();
                    c.moveTo(fx - size*0.3, fy + size*0.1);
                    c.quadraticCurveTo(fx, fy - size*0.5 + flicker, fx + size*0.3, fy + size*0.1);
                    c.closePath();
                    c.fill();
                    // Hot core (high intensity)
                    if(intensity >= 3) {
                        c.fillStyle = VIC.PARCHMENT;
                        c.beginPath();
                        c.ellipse(fx, fy - size*0.1, size*0.2, size*0.12, 0, 0, 6.28);
                        c.fill();
                    }
                };
                
                // Draw embers (low fire)
                const drawEmbers = (ex, ey, size) => {
                    c.fillStyle = VIC.INK;
                    c.beginPath();
                    c.ellipse(ex, ey, size, size*0.55, 0, 0, 6.28);
                    c.fill();
                    // Glowing embers
                    c.fillStyle = VIC.FIRE_EMBER;
                    for(let e = 0; e < 4; e++) {
                        let eox = Math.sin(e*2.1) * size*0.5;
                        let eoy = Math.cos(e*2.1) * size*0.25;
                        c.beginPath();
                        c.arc(ex + eox, ey + eoy, size*0.15, 0, 6.28);
                        c.fill();
                    }
                };
                
                // Draw hanging pelt
                const drawPelt = (px, py, width, height, color, isAbandoned) => {
                    c.fillStyle = isAbandoned ? VIC.ABANDONED : color;
                    c.beginPath();
                    c.ellipse(px, py, width, height, 0.1, 0, 6.28);
                    c.fill();
                    // Inner detail
                    c.fillStyle = isAbandoned ? VIC.STONE_DARK : VIC.WOOD_MED;
                    c.beginPath();
                    c.ellipse(px, py + height*0.15, width*0.6, height*0.6, 0.1, 0, 6.28);
                    c.fill();
                };
                
                // Draw ground shadow
                const drawGroundShadow = (gx, gy, width, height) => {
                    c.fillStyle = 'rgba(58,48,32,0.2)';
                    c.beginPath();
                    c.ellipse(gx, gy, width, height, 0, 0, 6.28);
                    c.fill();
                };
                
                // === GROUND SHADOW (all buildings) ===
                c.fillStyle = 'rgba(58,48,32,0.2)';
                c.beginPath();
                c.ellipse(cx, cy + T*0.15, T*0.4, T*0.18, 0, 0, 6.28);
                c.fill();
                
                if(lvl === 1) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 1: PEBBLE TRADE FIRE - Primitive stone circle fire pit
                    // A ring of rough stones around a central fire for trading pebbles/goods
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Packed earth ground (isometric ellipse) with texture
                    c.fillStyle = variant === 0 ? '#8A8070' : '#C4A882';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.44, T*0.3, 0, 0, 6.28);
                    c.fill();
                    
                    // Ground texture - worn paths and dirt patches
                    c.fillStyle = variant === 0 ? '#7A7060' : '#B89870';
                    c.beginPath();
                    c.ellipse(cx - T*0.15, cy + T*0.08, T*0.12, T*0.06, 0.3, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.ellipse(cx + T*0.12, cy - T*0.05, T*0.1, T*0.05, -0.2, 0, 6.28);
                    c.fill();
                    
                    // Charred inner area around fire - darker scorched earth
                    c.fillStyle = variant === 0 ? '#4A4540' : '#5D4D40';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.24, T*0.16, 0, 0, 6.28);
                    c.fill();
                    
                    // Ash ring
                    c.fillStyle = variant === 0 ? '#5A5550' : '#6A5A50';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.18, T*0.11, 0, 0, 6.28);
                    c.fill();
                    
                    // Stone circle - 10 rough stones with full isometric depth
                    const stoneColors = ['#8A8A7A', '#7A7A6A', '#9A9A8A', '#6A6A5A', '#858575'];
                    for(let i = 0; i < 10; i++) {
                        let angle = (i / 10) * Math.PI * 2 - Math.PI/2;
                        let sx = Math.cos(angle) * T * 0.34;
                        let sy = Math.sin(angle) * T * 0.2; // Flattened for isometric
                        let stoneSize = T * (0.055 + (i % 3) * 0.012);
                        
                        // Stone shadow (deeper)
                        c.fillStyle = 'rgba(58,48,32,0.4)';
                        c.beginPath();
                        c.ellipse(cx + sx + 2, cy + sy + 3, stoneSize*1.1, stoneSize*0.6, angle*0.3, 0, 6.28);
                        c.fill();
                        
                        // Stone body (varied colors and sizes)
                        c.fillStyle = variant === 0 ? '#5A5A4A' : stoneColors[i % 5];
                        c.beginPath();
                        c.ellipse(cx + sx, cy + sy, stoneSize*1.15, stoneSize*0.7, angle*0.3, 0, 6.28);
                        c.fill();
                        
                        // Stone highlight (top-left)
                        c.fillStyle = variant === 0 ? '#7A7A6A' : '#BBBBAA';
                        c.beginPath();
                        c.ellipse(cx + sx - stoneSize*0.3, cy + sy - stoneSize*0.2, stoneSize*0.35, stoneSize*0.2, 0, 0, 6.28);
                        c.fill();
                        
                        // Stone dark edge
                        c.fillStyle = variant === 0 ? '#4A4A3A' : '#5A5A4A';
                        c.beginPath();
                        c.ellipse(cx + sx + stoneSize*0.25, cy + sy + stoneSize*0.15, stoneSize*0.25, stoneSize*0.15, 0.5, 0, 6.28);
                        c.fill();
                    }
                    
                    // Fire pit contents based on activity
                    if(variant === 0) {
                        // Cold ashes - gray pile with texture
                        c.fillStyle = '#5A5A5A';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.14, T*0.08, 0, 0, 6.28);
                        c.fill();
                        // Ash texture
                        c.fillStyle = '#6A6A6A';
                        c.beginPath();
                        c.ellipse(cx - T*0.03, cy - T*0.02, T*0.05, T*0.03, 0, 0, 6.28);
                        c.fill();
                        // Charred wood remnants
                        c.fillStyle = '#3A3A3A';
                        c.fillRect(cx - T*0.06, cy - T*0.01, T*0.08, T*0.02);
                        c.fillRect(cx + T*0.02, cy + T*0.02, T*0.05, T*0.015);
                    } else if(variant === 1) {
                        // Embers - low activity with glowing coals
                        c.fillStyle = '#4A3A2A';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.14, T*0.08, 0, 0, 6.28);
                        c.fill();
                        // Wood pieces
                        c.fillStyle = '#3D2D1D';
                        c.fillRect(cx - T*0.05, cy - T*0.01, T*0.07, T*0.02);
                        // Glowing embers (more detailed)
                        c.fillStyle = '#8B3020';
                        for(let e = 0; e < 6; e++) {
                            let ex = (Math.sin(e*1.8) * T*0.07);
                            let ey = (Math.cos(e*1.8) * T*0.04);
                            c.beginPath();
                            c.arc(cx + ex, cy + ey, T*0.018 + (e%2)*T*0.008, 0, 6.28);
                            c.fill();
                        }
                        // Ember glow effect
                        c.fillStyle = 'rgba(212,101,47,0.3)';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                    } else {
                        // Active fire (variant 2-3) - enhanced flames
                        // Fire glow on ground
                        c.fillStyle = 'rgba(212,101,47,0.25)';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.02, T*0.18, T*0.1, 0, 0, 6.28);
                        c.fill();
                        
                        // Fire base (orange glow)
                        c.fillStyle = '#D4652F';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.02, T*0.12, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Wood in fire
                        c.fillStyle = '#3D2D1D';
                        c.fillRect(cx - T*0.08, cy + T*0.01, T*0.1, T*0.025);
                        c.fillRect(cx + T*0.01, cy - T*0.01, T*0.08, T*0.02);
                        
                        // Main flame shapes (animated)
                        let flicker = Math.sin(t * 4) * T * 0.015;
                        let flicker2 = Math.cos(t * 5) * T * 0.01;
                        
                        // Back flame
                        c.fillStyle = '#C44820';
                        c.beginPath();
                        c.moveTo(cx - T*0.06, cy + T*0.02);
                        c.quadraticCurveTo(cx - T*0.02, cy - T*0.14 + flicker, cx + T*0.02, cy - T*0.08);
                        c.quadraticCurveTo(cx + T*0.05, cy - T*0.1 - flicker2, cx + T*0.06, cy + T*0.02);
                        c.closePath();
                        c.fill();
                        
                        // Main flame
                        c.fillStyle = '#D4652F';
                        c.beginPath();
                        c.moveTo(cx - T*0.08, cy + T*0.03);
                        c.quadraticCurveTo(cx - T*0.04, cy - T*0.16 + flicker, cx, cy - T*0.1);
                        c.quadraticCurveTo(cx + T*0.04, cy - T*0.18 - flicker, cx + T*0.08, cy + T*0.03);
                        c.closePath();
                        c.fill();
                        
                        // Inner yellow flame
                        c.fillStyle = '#D4A03D';
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy + T*0.02);
                        c.quadraticCurveTo(cx, cy - T*0.1 + flicker2, cx + T*0.05, cy + T*0.02);
                        c.closePath();
                        c.fill();
                        
                        // Bright hot core
                        c.fillStyle = '#FFCC66';
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.02, T*0.03, T*0.02, 0, 0, 6.28);
                        c.fill();
                        
                        // Sparks (variant 3)
                        if(variant >= 3) {
                            c.fillStyle = '#FFAA33';
                            for(let s = 0; s < 4; s++) {
                                let sparkX = cx + Math.sin(t*3 + s*1.5) * T*0.06;
                                let sparkY = cy - T*0.12 - Math.abs(Math.sin(t*4 + s*2)) * T*0.08;
                                c.beginPath();
                                c.arc(sparkX, sparkY, T*0.008, 0, 6.28);
                                c.fill();
                            }
                            // White hot center
                            c.fillStyle = '#FFFFEE';
                            c.beginPath();
                            c.ellipse(cx, cy - T*0.01, T*0.02, T*0.012, 0, 0, 6.28);
                            c.fill();
                        }
                        
                        // Smoke wisps
                        c.fillStyle = 'rgba(180,170,160,0.35)';
                        let smokeY = Math.sin(t * 2) * T * 0.02;
                        c.beginPath();
                        c.ellipse(cx + T*0.02, cy - T*0.22 + smokeY, T*0.04, T*0.025, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx - T*0.03, cy - T*0.28 + smokeY*0.8, T*0.03, T*0.02, 0, 0, 6.28);
                        c.fill();
                    }
                    
                    // Scattered trade pebbles/items around the fire - more detailed
                    if(variant >= 1) {
                        // Small pebbles (trade goods) with shadows
                        const pebblePositions = [
                            {x: -T*0.3, y: T*0.1, col: '#A89070', size: 0.035},
                            {x: T*0.28, y: -T*0.06, col: '#C4A882', size: 0.03},
                            {x: -T*0.22, y: -T*0.14, col: '#8B7355', size: 0.028},
                            {x: T*0.18, y: T*0.12, col: '#B89870', size: 0.025}
                        ];
                        for(let p of pebblePositions) {
                            // Shadow
                            c.fillStyle = 'rgba(58,48,32,0.3)';
                            c.beginPath();
                            c.ellipse(cx + p.x + 1, cy + p.y + 1, T*p.size, T*p.size*0.6, 0, 0, 6.28);
                            c.fill();
                            // Pebble
                            c.fillStyle = p.col;
                            c.beginPath();
                            c.ellipse(cx + p.x, cy + p.y, T*p.size, T*p.size*0.65, 0, 0, 6.28);
                            c.fill();
                            // Highlight
                            c.fillStyle = '#DDD';
                            c.beginPath();
                            c.ellipse(cx + p.x - T*0.008, cy + p.y - T*0.006, T*p.size*0.3, T*p.size*0.2, 0, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // Extra goods for high activity
                    if(variant >= 2) {
                        // Shell/bead
                        c.fillStyle = '#F5DEB3';
                        c.beginPath();
                        c.ellipse(cx + T*0.35, cy + T*0.05, T*0.02, T*0.015, 0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        c.fillStyle = '#B89A70';
                        c.beginPath();
                        c.ellipse(cx + T*0.32, cy + T*0.14, T*0.038, T*0.028, 0.3, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#9A8A70';
                        c.beginPath();
                        c.ellipse(cx - T*0.35, cy + T*0.12, T*0.032, T*0.022, -0.2, 0, 6.28);
                        c.fill();
                        // Pottery piece
                        c.fillStyle = '#A0522D';
                        c.beginPath();
                        c.ellipse(cx - T*0.28, cy - T*0.08, T*0.022, T*0.035, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#CD853F';
                        c.beginPath();
                        c.ellipse(cx - T*0.28, cy - T*0.105, T*0.018, T*0.01, 0, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 2) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 2: SQUIRREL TRADE CAMP - Lean-to shelter with pelt rack
                    // Primitive A-frame shelter with hanging squirrel pelts for trade
                    // 4 VARIANT STATES: Abandoned ‚Üí Low ‚Üí Medium ‚Üí High Activity
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // === GROUND - varies by activity ===
                    // Base ground
                    c.fillStyle = variant === 0 ? '#6A6A5A' : variant === 1 ? '#7A8A5A' : '#8B9A6B';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.05, T*0.44, T*0.28, 0, 0, 6.28);
                    c.fill();
                    
                    // Ground texture patches
                    if(variant === 0) {
                        // Overgrown patches (abandoned)
                        c.fillStyle = '#5A5A4A';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.1, T*0.1, T*0.05, 0.3, 0, 6.28);
                        c.fill();
                    } else {
                        // Worn paths (active)
                        c.fillStyle = variant >= 2 ? '#A89060' : '#8A8A5A';
                        c.beginPath();
                        c.ellipse(cx - T*0.1, cy + T*0.12, T*0.12, T*0.06, 0.2, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx + T*0.15, cy + T*0.08, T*0.1, T*0.05, -0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    // Grass tufts - more for higher variants
                    if(variant >= 1) {
                        c.fillStyle = variant >= 2 ? '#6A9A4A' : '#5A7A4A';
                        c.beginPath();
                        c.ellipse(cx - T*0.35, cy + T*0.18, T*0.04, T*0.02, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx + T*0.38, cy + T*0.15, T*0.035, T*0.018, 0, 0, 6.28);
                        c.fill();
                        if(variant >= 2) {
                            c.beginPath();
                            c.ellipse(cx - T*0.28, cy - T*0.12, T*0.03, T*0.015, 0.5, 0, 6.28);
                            c.fill();
                            c.beginPath();
                            c.ellipse(cx + T*0.32, cy + T*0.22, T*0.035, T*0.018, -0.3, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // === LEAN-TO SHELTER (left side) ===
                    // Shelter condition varies by variant
                    
                    // Back support pole
                    c.fillStyle = variant === 0 ? '#4A4A3A' : variant === 1 ? '#5D4037' : '#6D4C41';
                    c.beginPath();
                    c.moveTo(cx - T*0.32, cy + T*0.2);
                    c.lineTo(cx - T*0.3, cy - T*0.18);
                    c.lineTo(cx - T*0.26, cy - T*0.18);
                    c.lineTo(cx - T*0.28, cy + T*0.2);
                    c.closePath();
                    c.fill();
                    
                    // V0: Broken/leaning pole detail
                    if(variant === 0) {
                        c.fillStyle = '#3A3A2A';
                        c.beginPath();
                        c.moveTo(cx - T*0.28, cy - T*0.1);
                        c.lineTo(cx - T*0.24, cy - T*0.08);
                        c.lineTo(cx - T*0.26, cy - T*0.05);
                        c.closePath();
                        c.fill();
                    }
                    
                    // Front support pole
                    c.fillStyle = variant === 0 ? '#4A4A3A' : variant === 1 ? '#5D4037' : '#6D4C41';
                    c.beginPath();
                    c.moveTo(cx - T*0.06, cy + T*0.22);
                    c.lineTo(cx - T*0.04, cy + T*0.0);
                    c.lineTo(cx - T*0.01, cy + T*0.0);
                    c.lineTo(cx - T*0.03, cy + T*0.22);
                    c.closePath();
                    c.fill();
                    
                    // Thatch roof - condition varies
                    if(variant === 0) {
                        // Tattered/holey thatch
                        c.fillStyle = '#5A5A4A';
                        c.beginPath();
                        c.moveTo(cx - T*0.34, cy - T*0.2);
                        c.lineTo(cx + T*0.0, cy - T*0.02);
                        c.lineTo(cx + T*0.0, cy + T*0.06);
                        c.lineTo(cx - T*0.34, cy - T*0.1);
                        c.closePath();
                        c.fill();
                        // Holes in thatch
                        c.fillStyle = '#6A6A5A';
                        c.beginPath();
                        c.ellipse(cx - T*0.2, cy - T*0.08, T*0.03, T*0.02, 0.5, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx - T*0.12, cy - T*0.02, T*0.025, T*0.015, 0.3, 0, 6.28);
                        c.fill();
                    } else {
                        // Intact thatch - thickness varies
                        c.fillStyle = variant === 1 ? '#8A6A4A' : variant === 2 ? '#A67B5B' : '#B88B6B';
                        c.beginPath();
                        c.moveTo(cx - T*0.34, cy - T*0.2);
                        c.lineTo(cx + T*0.02, cy - T*0.02);
                        c.lineTo(cx + T*0.02, cy + T*0.1);
                        c.lineTo(cx - T*0.34, cy - T*0.08);
                        c.closePath();
                        c.fill();
                        
                        // Thatch texture lines
                        c.strokeStyle = variant === 1 ? '#6A5A3A' : '#8B6914';
                        c.lineWidth = variant >= 2 ? 1.5 : 1;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.32 + i*T*0.065, cy - T*0.18 + i*T*0.032);
                            c.lineTo(cx - T*0.32 + i*T*0.065, cy - T*0.06 + i*T*0.032);
                            c.stroke();
                        }
                        
                        // V3: Extra thick thatch overhang
                        if(variant >= 3) {
                            c.fillStyle = '#C49B7B';
                            c.beginPath();
                            c.moveTo(cx - T*0.36, cy - T*0.22);
                            c.lineTo(cx - T*0.34, cy - T*0.2);
                            c.lineTo(cx - T*0.34, cy - T*0.1);
                            c.lineTo(cx - T*0.36, cy - T*0.12);
                            c.closePath();
                            c.fill();
                        }
                    }
                    
                    // === PELT DRYING RACK (right side) ===
                    // Rack posts - condition varies
                    c.fillStyle = variant === 0 ? '#4A4A3A' : variant === 1 ? '#5D4037' : '#6D4C41';
                    
                    if(variant === 0) {
                        // Broken/tilted posts
                        c.fillRect(cx + T*0.08, cy - T*0.06, 3, T*0.24);
                        c.save();
                        c.translate(cx + T*0.32, cy + T*0.18);
                        c.rotate(-0.2);
                        c.fillRect(0, -T*0.2, 3, T*0.2);
                        c.restore();
                    } else {
                        // Upright posts
                        c.fillRect(cx + T*0.1, cy - T*0.12, 3, T*0.3);
                        c.fillRect(cx + T*0.34, cy - T*0.1, 3, T*0.28);
                    }
                    
                    // Crossbar
                    if(variant === 0) {
                        // Fallen crossbar
                        c.fillStyle = '#4A4A3A';
                        c.beginPath();
                        c.moveTo(cx + T*0.1, cy + T*0.12);
                        c.lineTo(cx + T*0.32, cy + T*0.15);
                        c.lineTo(cx + T*0.32, cy + T*0.18);
                        c.lineTo(cx + T*0.1, cy + T*0.15);
                        c.closePath();
                        c.fill();
                    } else {
                        // Intact crossbar
                        c.fillStyle = variant === 1 ? '#6A5A4A' : '#8B7355';
                        c.beginPath();
                        c.moveTo(cx + T*0.09, cy - T*0.12);
                        c.lineTo(cx + T*0.37, cy - T*0.1);
                        c.lineTo(cx + T*0.37, cy - T*0.06);
                        c.lineTo(cx + T*0.09, cy - T*0.08);
                        c.closePath();
                        c.fill();
                    }
                    
                    // === HANGING PELTS - number varies by variant ===
                    if(variant >= 1) {
                        // Pelt 1 (always present when active)
                        c.fillStyle = variant === 1 ? '#8A6A4A' : '#A67B5B';
                        c.beginPath();
                        c.ellipse(cx + T*0.16, cy + T*0.02, T*0.042, T*0.09, 0.1, 0, 6.28);
                        c.fill();
                        // Pelt belly (lighter)
                        c.fillStyle = variant === 1 ? '#7A5A3A' : '#8B6914';
                        c.beginPath();
                        c.ellipse(cx + T*0.16, cy + T*0.04, T*0.028, T*0.055, 0.1, 0, 6.28);
                        c.fill();
                        // Tail tuft
                        c.fillStyle = variant === 1 ? '#6A5A4A' : '#7A6A4A';
                        c.beginPath();
                        c.ellipse(cx + T*0.16, cy + T*0.1, T*0.015, T*0.025, 0, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 2) {
                        // Pelt 2 (medium+ activity)
                        c.fillStyle = '#B8956E';
                        c.beginPath();
                        c.ellipse(cx + T*0.27, cy + T*0.03, T*0.038, T*0.08, -0.1, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#9A7A5A';
                        c.beginPath();
                        c.ellipse(cx + T*0.27, cy + T*0.05, T*0.024, T*0.05, -0.1, 0, 6.28);
                        c.fill();
                        // Tail
                        c.fillStyle = '#8A6A4A';
                        c.beginPath();
                        c.ellipse(cx + T*0.27, cy + T*0.1, T*0.012, T*0.022, 0, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        // Pelt 3 (premium - high activity)
                        c.fillStyle = '#C4A080';
                        c.beginPath();
                        c.ellipse(cx + T*0.21, cy - T*0.0, T*0.035, T*0.075, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#A89060';
                        c.beginPath();
                        c.ellipse(cx + T*0.21, cy + T*0.02, T*0.022, T*0.045, 0, 0, 6.28);
                        c.fill();
                        
                        // Pelt 4 (bonus premium)
                        c.fillStyle = '#D4B090';
                        c.beginPath();
                        c.ellipse(cx + T*0.32, cy + T*0.02, T*0.032, T*0.07, 0.15, 0, 6.28);
                        c.fill();
                    }
                    
                    // === CAMPFIRE - V0: cold, V1: embers, V2-3: fire ===
                    // Fire pit base
                    c.fillStyle = variant === 0 ? '#5A5A5A' : '#4A3A2A';
                    c.beginPath();
                    c.ellipse(cx - T*0.15, cy + T*0.22, T*0.07, T*0.04, 0, 0, 6.28);
                    c.fill();
                    
                    if(variant === 0) {
                        // Cold ashes
                        c.fillStyle = '#6A6A6A';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.21, T*0.05, T*0.028, 0, 0, 6.28);
                        c.fill();
                        // Scattered charcoal
                        c.fillStyle = '#4A4A4A';
                        c.beginPath();
                        c.ellipse(cx - T*0.12, cy + T*0.2, T*0.015, T*0.01, 0.5, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(cx - T*0.18, cy + T*0.22, T*0.012, T*0.008, -0.3, 0, 6.28);
                        c.fill();
                    } else if(variant === 1) {
                        // Glowing embers
                        c.fillStyle = '#3A2A1A';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.21, T*0.05, T*0.028, 0, 0, 6.28);
                        c.fill();
                        // Embers
                        c.fillStyle = '#8B3020';
                        for(let e = 0; e < 5; e++) {
                            let ex = Math.sin(e*1.5) * T*0.03;
                            let ey = Math.cos(e*1.5) * T*0.015;
                            c.beginPath();
                            c.arc(cx - T*0.15 + ex, cy + T*0.21 + ey, T*0.012, 0, 6.28);
                            c.fill();
                        }
                        // Ember glow
                        c.fillStyle = 'rgba(212,101,47,0.2)';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.2, T*0.06, T*0.035, 0, 0, 6.28);
                        c.fill();
                    } else {
                        // Active fire (V2-V3)
                        let flicker = Math.sin(t * 5) * T * 0.008;
                        let flicker2 = Math.cos(t * 4) * T * 0.006;
                        
                        // Fire glow on ground
                        c.fillStyle = 'rgba(212,101,47,0.2)';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.2, T*0.1, T*0.055, 0, 0, 6.28);
                        c.fill();
                        
                        // Back flame
                        c.fillStyle = '#C44820';
                        c.beginPath();
                        c.moveTo(cx - T*0.19, cy + T*0.21);
                        c.quadraticCurveTo(cx - T*0.15, cy + T*0.1 + flicker2, cx - T*0.11, cy + T*0.21);
                        c.closePath();
                        c.fill();
                        
                        // Main flame
                        c.fillStyle = '#D4652F';
                        c.beginPath();
                        c.moveTo(cx - T*0.2, cy + T*0.22);
                        c.quadraticCurveTo(cx - T*0.15, cy + T*0.08 + flicker, cx - T*0.1, cy + T*0.22);
                        c.closePath();
                        c.fill();
                        
                        // Inner yellow
                        c.fillStyle = '#D4A03D';
                        c.beginPath();
                        c.moveTo(cx - T*0.18, cy + T*0.21);
                        c.quadraticCurveTo(cx - T*0.15, cy + T*0.12 + flicker, cx - T*0.12, cy + T*0.21);
                        c.closePath();
                        c.fill();
                        
                        // V3: Bigger fire + sparks + smoke
                        if(variant >= 3) {
                            // Hot core
                            c.fillStyle = '#FFCC66';
                            c.beginPath();
                            c.ellipse(cx - T*0.15, cy + T*0.18, T*0.025, T*0.015, 0, 0, 6.28);
                            c.fill();
                            
                            // Sparks
                            c.fillStyle = '#FFAA33';
                            for(let s = 0; s < 3; s++) {
                                let sx = cx - T*0.15 + Math.sin(t*3 + s*2) * T*0.04;
                                let sy = cy + T*0.12 - Math.abs(Math.sin(t*4 + s*1.5)) * T*0.06;
                                c.beginPath();
                                c.arc(sx, sy, T*0.006, 0, 6.28);
                                c.fill();
                            }
                            
                            // Smoke wisp
                            c.fillStyle = 'rgba(180,170,160,0.3)';
                            let smokeY = Math.sin(t * 2) * T * 0.015;
                            c.beginPath();
                            c.ellipse(cx - T*0.14, cy + T*0.04 + smokeY, T*0.025, T*0.018, 0, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // === TRADE GOODS - amount varies ===
                    if(variant >= 1) {
                        // Nuts/acorns
                        c.fillStyle = '#A89070';
                        c.beginPath();
                        c.ellipse(cx + T*0.05, cy + T*0.24, T*0.022, T*0.015, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.ellipse(cx + T*0.1, cy + T*0.26, T*0.018, T*0.012, 0.5, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 2) {
                        // More nuts + small pelt bundle
                        c.fillStyle = '#9A8060';
                        c.beginPath();
                        c.ellipse(cx + T*0.0, cy + T*0.28, T*0.02, T*0.012, -0.3, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#7A6A5A';
                        c.beginPath();
                        c.ellipse(cx - T*0.02, cy + T*0.26, T*0.025, T*0.018, 0.2, 0, 6.28);
                        c.fill();
                        // Small rolled pelt
                        c.fillStyle = '#A67B5B';
                        c.beginPath();
                        c.ellipse(cx + T*0.18, cy + T*0.2, T*0.03, T*0.02, 0.8, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        // Abundant goods
                        c.fillStyle = '#B89060';
                        c.beginPath();
                        c.ellipse(cx + T*0.15, cy + T*0.26, T*0.02, T*0.014, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#8A7050';
                        c.beginPath();
                        c.ellipse(cx + T*0.22, cy + T*0.24, T*0.018, T*0.012, 0.4, 0, 6.28);
                        c.fill();
                        // Basket of nuts
                        c.fillStyle = '#8B6914';
                        c.beginPath();
                        c.ellipse(cx - T*0.28, cy + T*0.18, T*0.035, T*0.025, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#A89070';
                        c.beginPath();
                        c.ellipse(cx - T*0.28, cy + T*0.16, T*0.028, T*0.015, 0, 0, 6.28);
                        c.fill();
                    }
                    
                    // === TRADER FIGURES ===
                    if(variant >= 2) {
                        // Trader 1 (sitting by fire)
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.ellipse(cx - T*0.02, cy + T*0.18, T*0.032, T*0.048, 0, 0, 6.28);
                        c.fill();
                        // Head
                        c.fillStyle = '#D2B48C';
                        c.beginPath();
                        c.arc(cx - T*0.02, cy + T*0.12, T*0.02, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        // Trader 2 (by rack)
                        c.fillStyle = '#7A6A55';
                        c.beginPath();
                        c.ellipse(cx + T*0.38, cy + T*0.1, T*0.028, T*0.042, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#C4A882';
                        c.beginPath();
                        c.arc(cx + T*0.38, cy + T*0.05, T*0.018, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 3) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 3: FIRE MEET CAMP - Tribal council gathering area
                    // Large central fire with log seating circle and totem pole
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Cleared meeting ground (larger area)
                    c.fillStyle = variant === 0 ? '#7A7568' : '#C4A882';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.02, T*0.44, T*0.3, 0, 0, 6.28);
                    c.fill();
                    
                    // Inner ceremonial area (darker packed earth)
                    c.fillStyle = variant === 0 ? '#5A5550' : '#A89070';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.32, T*0.2, 0, 0, 6.28);
                    c.fill();
                    
                    // === LOG SEATING CIRCLE (6 logs) ===
                    const logPositions = [
                        {angle: 0, dist: 0.36},
                        {angle: Math.PI/3, dist: 0.35},
                        {angle: 2*Math.PI/3, dist: 0.34},
                        {angle: Math.PI, dist: 0.36},
                        {angle: 4*Math.PI/3, dist: 0.35},
                        {angle: 5*Math.PI/3, dist: 0.34}
                    ];
                    
                    for(let log of logPositions) {
                        let lx = Math.cos(log.angle) * T * log.dist;
                        let ly = Math.sin(log.angle) * T * log.dist * 0.55; // Flatten for isometric
                        
                        // Log shadow
                        c.fillStyle = 'rgba(58,48,32,0.25)';
                        c.beginPath();
                        c.ellipse(cx + lx + 1, cy + ly + 2, T*0.08, T*0.025, log.angle, 0, 6.28);
                        c.fill();
                        
                        // Log body (brown cylinder shape)
                        c.fillStyle = variant === 0 ? '#5A5A4A' : '#6D4C41';
                        c.beginPath();
                        c.ellipse(cx + lx, cy + ly, T*0.08, T*0.03, log.angle, 0, 6.28);
                        c.fill();
                        
                        // Log top highlight
                        c.fillStyle = variant === 0 ? '#6A6A5A' : '#8B7355';
                        c.beginPath();
                        c.ellipse(cx + lx, cy + ly - 1, T*0.06, T*0.02, log.angle, 0, 6.28);
                        c.fill();
                        
                        // Log end grain detail
                        c.fillStyle = variant === 0 ? '#4A4A3A' : '#5D4037';
                        c.beginPath();
                        c.arc(cx + lx + Math.cos(log.angle)*T*0.06, cy + ly + Math.sin(log.angle)*T*0.02, T*0.02, 0, 6.28);
                        c.fill();
                    }
                    
                    // === CENTRAL FIRE PIT (larger than level 1) ===
                    // Stone ring
                    c.fillStyle = variant === 0 ? '#5A5A5A' : '#8A8A7A';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.18, T*0.11, 0, 0, 6.28);
                    c.fill();
                    
                    // Inner charred pit
                    c.fillStyle = variant === 0 ? '#3A3A3A' : '#4A3A2A';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.14, T*0.085, 0, 0, 6.28);
                    c.fill();
                    
                    // Fire based on activity
                    if(variant === 0) {
                        // Cold ashes
                        c.fillStyle = '#4A4A4A';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                    } else if(variant === 1) {
                        // Smoldering embers
                        c.fillStyle = '#5A4A3A';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                        // Glowing embers
                        c.fillStyle = '#8B3020';
                        for(let e = 0; e < 5; e++) {
                            c.beginPath();
                            c.arc(cx + Math.sin(e*1.5)*T*0.06, cy + Math.cos(e*1.5)*T*0.035, T*0.018, 0, 6.28);
                            c.fill();
                        }
                    } else {
                        // Active communal fire (larger flames)
                        let flicker = Math.sin(t * 3.5) * T * 0.012;
                        
                        // Fire base glow
                        c.fillStyle = '#D4652F';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.02, T*0.12, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Main flame
                        c.fillStyle = '#D4652F';
                        c.beginPath();
                        c.moveTo(cx - T*0.1, cy + T*0.04);
                        c.quadraticCurveTo(cx - T*0.06, cy - T*0.14 + flicker, cx - T*0.02, cy - T*0.08);
                        c.quadraticCurveTo(cx, cy - T*0.18 - flicker, cx + T*0.02, cy - T*0.08);
                        c.quadraticCurveTo(cx + T*0.06, cy - T*0.14 + flicker, cx + T*0.1, cy + T*0.04);
                        c.closePath();
                        c.fill();
                        
                        // Inner yellow flame
                        c.fillStyle = '#D4A03D';
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy + T*0.02);
                        c.quadraticCurveTo(cx - T*0.02, cy - T*0.1 + flicker, cx, cy - T*0.06);
                        c.quadraticCurveTo(cx + T*0.02, cy - T*0.1 - flicker, cx + T*0.05, cy + T*0.02);
                        c.closePath();
                        c.fill();
                        
                        // Bright core for high activity
                        if(variant >= 3) {
                            c.fillStyle = '#E8DCC8';
                            c.beginPath();
                            c.ellipse(cx, cy - T*0.03, T*0.03, T*0.02, 0, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // === TOTEM/MARKER POLE (right side) ===
                    // Pole shadow
                    c.fillStyle = 'rgba(58,48,32,0.2)';
                    c.beginPath();
                    c.ellipse(cx + T*0.32, cy + T*0.18, T*0.04, T*0.02, 0.3, 0, 6.28);
                    c.fill();
                    
                    // Main pole
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#6D4C41';
                    c.fillRect(cx + T*0.3, cy - T*0.2, T*0.04, T*0.38);
                    
                    // Pole top cap
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#5D4037';
                    c.beginPath();
                    c.ellipse(cx + T*0.32, cy - T*0.2, T*0.025, T*0.015, 0, 0, 6.28);
                    c.fill();
                    
                    // Decorative bands/carvings
                    if(variant >= 1) {
                        c.fillStyle = '#8B3020';
                        c.fillRect(cx + T*0.295, cy - T*0.15, T*0.05, T*0.03);
                        c.fillStyle = '#D4A03D';
                        c.fillRect(cx + T*0.295, cy - T*0.05, T*0.05, T*0.03);
                    }
                    if(variant >= 2) {
                        c.fillStyle = '#4A6A8A';
                        c.fillRect(cx + T*0.295, cy + T*0.05, T*0.05, T*0.03);
                    }
                    
                } else if(lvl === 4) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 4: BARTER BOULDER - Large flat trading stones/boulders
                    // Massive boulders with flat tops used as trading surfaces
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Packed earth trading ground
                    c.fillStyle = variant === 0 ? '#6A6558' : '#B89870';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.08, T*0.45, T*0.28, 0, 0, 6.28);
                    c.fill();
                    
                    // Ground texture - worn paths
                    c.fillStyle = variant === 0 ? '#5A5548' : '#A88860';
                    c.beginPath();
                    c.ellipse(cx - T*0.1, cy + T*0.05, T*0.2, T*0.1, 0.3, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.ellipse(cx + T*0.15, cy + T*0.1, T*0.15, T*0.08, -0.2, 0, 6.28);
                    c.fill();
                    
                    // === MAIN TRADING BOULDER (large, center-left) ===
                    // Boulder shadow
                    c.fillStyle = 'rgba(58,48,32,0.35)';
                    c.beginPath();
                    c.ellipse(cx - T*0.12, cy + T*0.18, T*0.18, T*0.08, 0.1, 0, 6.28);
                    c.fill();
                    
                    // Boulder base (dark side)
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#5A5A4A';
                    c.beginPath();
                    c.moveTo(cx - T*0.28, cy + T*0.1);
                    c.quadraticCurveTo(cx - T*0.32, cy - T*0.05, cx - T*0.2, cy - T*0.12);
                    c.lineTo(cx + T*0.05, cy - T*0.1);
                    c.quadraticCurveTo(cx + T*0.12, cy + T*0.02, cx + T*0.08, cy + T*0.12);
                    c.lineTo(cx - T*0.28, cy + T*0.1);
                    c.closePath();
                    c.fill();
                    
                    // Boulder top (flat trading surface)
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#8A8A7A';
                    c.beginPath();
                    c.moveTo(cx - T*0.25, cy - T*0.02);
                    c.lineTo(cx - T*0.18, cy - T*0.12);
                    c.lineTo(cx + T*0.08, cy - T*0.1);
                    c.lineTo(cx + T*0.1, cy);
                    c.lineTo(cx - T*0.25, cy - T*0.02);
                    c.closePath();
                    c.fill();
                    
                    // Boulder highlight
                    c.fillStyle = variant === 0 ? '#7A7A6A' : '#AAAAAA';
                    c.beginPath();
                    c.ellipse(cx - T*0.1, cy - T*0.08, T*0.06, T*0.025, 0.2, 0, 6.28);
                    c.fill();
                    
                    // Boulder texture/cracks
                    c.strokeStyle = variant === 0 ? '#5A5A4A' : '#6A6A5A';
                    c.lineWidth = 0.8;
                    c.beginPath();
                    c.moveTo(cx - T*0.15, cy - T*0.05);
                    c.lineTo(cx - T*0.05, cy - T*0.08);
                    c.stroke();
                    c.beginPath();
                    c.moveTo(cx - T*0.2, cy + T*0.02);
                    c.lineTo(cx - T*0.08, cy - T*0.02);
                    c.stroke();
                    
                    // === SECONDARY BOULDER (right, smaller) ===
                    c.fillStyle = 'rgba(58,48,32,0.3)';
                    c.beginPath();
                    c.ellipse(cx + T*0.22, cy + T*0.16, T*0.12, T*0.05, -0.2, 0, 6.28);
                    c.fill();
                    
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#6A6A5A';
                    c.beginPath();
                    c.moveTo(cx + T*0.1, cy + T*0.1);
                    c.quadraticCurveTo(cx + T*0.08, cy, cx + T*0.18, cy - T*0.04);
                    c.lineTo(cx + T*0.32, cy - T*0.02);
                    c.quadraticCurveTo(cx + T*0.35, cy + T*0.08, cx + T*0.3, cy + T*0.12);
                    c.lineTo(cx + T*0.1, cy + T*0.1);
                    c.closePath();
                    c.fill();
                    
                    c.fillStyle = variant === 0 ? '#7A7A6A' : '#9A9A8A';
                    c.beginPath();
                    c.moveTo(cx + T*0.12, cy + T*0.04);
                    c.lineTo(cx + T*0.2, cy - T*0.02);
                    c.lineTo(cx + T*0.32, cy);
                    c.lineTo(cx + T*0.28, cy + T*0.06);
                    c.closePath();
                    c.fill();
                    
                    // === STACKED STONES (back, for height) ===
                    // Bottom stone
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#7A7A6A';
                    c.beginPath();
                    c.ellipse(cx - T*0.25, cy - T*0.1, T*0.08, T*0.05, 0.3, 0, 6.28);
                    c.fill();
                    // Top stone
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#8A8A7A';
                    c.beginPath();
                    c.ellipse(cx - T*0.24, cy - T*0.16, T*0.055, T*0.035, 0.2, 0, 6.28);
                    c.fill();
                    c.fillStyle = variant === 0 ? '#7A7A6A' : '#9A9A8A';
                    c.beginPath();
                    c.ellipse(cx - T*0.25, cy - T*0.18, T*0.04, T*0.02, 0, 0, 6.28);
                    c.fill();
                    
                    // === TRADE GOODS ON BOULDER SURFACES ===
                    if(variant >= 1) {
                        // Pottery on main boulder
                        c.fillStyle = '#A0522D';
                        c.beginPath();
                        c.ellipse(cx - T*0.08, cy - T*0.06, T*0.025, T*0.04, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#CD853F';
                        c.beginPath();
                        c.ellipse(cx - T*0.08, cy - T*0.09, T*0.02, T*0.01, 0, 0, 6.28);
                        c.fill();
                        
                        // Flint/tools on secondary boulder
                        c.fillStyle = '#708090';
                        c.beginPath();
                        c.moveTo(cx + T*0.2, cy + T*0.0);
                        c.lineTo(cx + T*0.24, cy - T*0.02);
                        c.lineTo(cx + T*0.22, cy + T*0.04);
                        c.closePath();
                        c.fill();
                    }
                    
                    if(variant >= 2) {
                        // More pottery
                        c.fillStyle = '#8B4513';
                        c.beginPath();
                        c.ellipse(cx + T*0.0, cy - T*0.04, T*0.02, T*0.035, 0, 0, 6.28);
                        c.fill();
                        
                        // Beads/shells scattered
                        c.fillStyle = '#F5DEB3';
                        c.beginPath();
                        c.arc(cx - T*0.15, cy - T*0.06, T*0.012, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.arc(cx + T*0.26, cy + T*0.02, T*0.01, 0, 6.28);
                        c.fill();
                        
                        // Small pebbles/goods on ground
                        c.fillStyle = '#B89A70';
                        c.beginPath();
                        c.ellipse(cx + T*0.0, cy + T*0.2, T*0.02, T*0.012, 0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        // Abundant goods - busy trading
                        c.fillStyle = '#D4A03D';
                        c.beginPath();
                        c.ellipse(cx - T*0.02, cy - T*0.02, T*0.018, T*0.028, 0, 0, 6.28);
                        c.fill();
                        
                        // Pelts draped on boulder
                        c.fillStyle = '#A67B5B';
                        c.beginPath();
                        c.ellipse(cx + T*0.04, cy - T*0.08, T*0.035, T*0.02, 0.5, 0, 6.28);
                        c.fill();
                        
                        // More ground goods
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.ellipse(cx - T*0.2, cy + T*0.18, T*0.022, T*0.014, -0.2, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#9A8A6A';
                        c.beginPath();
                        c.ellipse(cx + T*0.32, cy + T*0.2, T*0.018, T*0.012, 0.4, 0, 6.28);
                        c.fill();
                    }
                    
                    // === TRADER FIGURE ===
                    if(variant >= 2) {
                        // Standing/sitting trader by main boulder
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.ellipse(cx + T*0.02, cy + T*0.12, T*0.035, T*0.055, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#D2B48C';
                        c.beginPath();
                        c.arc(cx + T*0.02, cy + T*0.05, T*0.022, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl === 5) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 5: BLANKET MARKET - Trading blankets on ground with goods
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // === GROUND BASE (packed dirt trading area) ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#C4A882';
                    c.beginPath();
                    c.moveTo(cx, cy - T*0.35);
                    c.lineTo(cx + T*0.45, cy);
                    c.lineTo(cx, cy + T*0.35);
                    c.lineTo(cx - T*0.45, cy);
                    c.closePath();
                    c.fill();
                    
                    // Ground texture (worn paths)
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#B89870';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.35, T*0.18, 0, 0, 6.28);
                    c.fill();
                    
                    // === TRADING BLANKET 1 (left, red/brown zigzag) ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#8B4513';
                    c.beginPath();
                    c.moveTo(cx - T*0.32, cy - T*0.08);
                    c.lineTo(cx - T*0.08, cy - T*0.2);
                    c.lineTo(cx + T*0.02, cy - T*0.12);
                    c.lineTo(cx - T*0.22, cy);
                    c.closePath();
                    c.fill();
                    // Zigzag pattern
                    c.strokeStyle = variant === 0 ? '#4A4A3A' : '#D4A03D';
                    c.lineWidth = 1.5;
                    c.beginPath();
                    c.moveTo(cx - T*0.28, cy - T*0.06);
                    c.lineTo(cx - T*0.22, cy - T*0.12);
                    c.lineTo(cx - T*0.16, cy - T*0.08);
                    c.lineTo(cx - T*0.10, cy - T*0.14);
                    c.stroke();
                    
                    // === TRADING BLANKET 2 (center, tan/cream stripes) ===
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#D4C4A4';
                    c.beginPath();
                    c.moveTo(cx - T*0.12, cy + T*0.02);
                    c.lineTo(cx + T*0.12, cy - T*0.1);
                    c.lineTo(cx + T*0.22, cy);
                    c.lineTo(cx - T*0.02, cy + T*0.12);
                    c.closePath();
                    c.fill();
                    // Stripe pattern
                    c.strokeStyle = variant === 0 ? '#5A5A4A' : '#A67B5B';
                    c.lineWidth = 1;
                    for(let i = 0; i < 3; i++) {
                        c.beginPath();
                        c.moveTo(cx - T*0.08 + i*T*0.08, cy + T*0.0 - i*T*0.03);
                        c.lineTo(cx + T*0.02 + i*T*0.08, cy + T*0.06 - i*T*0.03);
                        c.stroke();
                    }
                    
                    // === TRADING BLANKET 3 (right, blue/gray) ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#6B7B8B';
                    c.beginPath();
                    c.moveTo(cx + T*0.08, cy + T*0.08);
                    c.lineTo(cx + T*0.28, cy - T*0.02);
                    c.lineTo(cx + T*0.38, cy + T*0.08);
                    c.lineTo(cx + T*0.18, cy + T*0.18);
                    c.closePath();
                    c.fill();
                    
                    // === GOODS ON BLANKETS ===
                    // Pottery on blanket 1
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#A0522D';
                    c.beginPath();
                    c.ellipse(cx - T*0.2, cy - T*0.1, T*0.03, T*0.05, 0, 0, 6.28);
                    c.fill();
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#CD853F';
                    c.beginPath();
                    c.ellipse(cx - T*0.2, cy - T*0.14, T*0.025, T*0.012, 0, 0, 6.28);
                    c.fill();
                    
                    // Shells/beads on blanket 2
                    if(variant >= 1) {
                        c.fillStyle = variant === 0 ? '#7A7A6A' : '#F5DEB3';
                        c.beginPath();
                        c.ellipse(cx + T*0.02, cy + T*0.02, T*0.02, T*0.015, 0.3, 0, 6.28);
                        c.fill();
                        c.fillStyle = variant === 0 ? '#6A6A5A' : '#E8DCC8';
                        c.beginPath();
                        c.ellipse(cx + T*0.08, cy - T*0.02, T*0.015, T*0.01, -0.2, 0, 6.28);
                        c.fill();
                    }
                    
                    // Stone tools on blanket 3
                    if(variant >= 2) {
                        c.fillStyle = variant === 0 ? '#4A4A3A' : '#708090';
                        c.beginPath();
                        c.moveTo(cx + T*0.2, cy + T*0.06);
                        c.lineTo(cx + T*0.24, cy + T*0.04);
                        c.lineTo(cx + T*0.22, cy + T*0.1);
                        c.closePath();
                        c.fill();
                    }
                    
                    // === SIMPLE AWNING/SHADE STRUCTURE ===
                    // Wooden poles
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#6D4C41';
                    c.fillRect(cx - T*0.35, cy - T*0.15, 2, T*0.25);
                    c.fillRect(cx + T*0.32, cy + T*0.1, 2, T*0.22);
                    
                    // Woven shade (partial)
                    c.fillStyle = variant === 0 ? '#5A5A4A' : 'rgba(139,105,20,0.6)';
                    c.beginPath();
                    c.moveTo(cx - T*0.36, cy - T*0.15);
                    c.lineTo(cx - T*0.1, cy - T*0.25);
                    c.lineTo(cx + T*0.1, cy - T*0.18);
                    c.lineTo(cx - T*0.16, cy - T*0.08);
                    c.closePath();
                    c.fill();
                    
                    // === VENDOR FIGURE (sitting by blankets) ===
                    if(variant >= 1) {
                        // Body (sitting)
                        c.fillStyle = variant === 0 ? '#5A5A4A' : '#8B7355';
                        c.beginPath();
                        c.ellipse(cx - T*0.28, cy + T*0.12, T*0.04, T*0.06, 0, 0, 6.28);
                        c.fill();
                        // Head
                        c.fillStyle = variant === 0 ? '#6A6A5A' : '#D2B48C';
                        c.beginPath();
                        c.arc(cx - T*0.28, cy + T*0.04, T*0.025, 0, 6.28);
                        c.fill();
                    }
                    
                    // === EXTRA DETAILS FOR HIGH ACTIVITY ===
                    if(variant >= 3) {
                        // Second vendor/customer
                        c.fillStyle = variant === 0 ? '#5A5A4A' : '#7B6B55';
                        c.beginPath();
                        c.ellipse(cx + T*0.25, cy + T*0.22, T*0.035, T*0.05, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#C4A882';
                        c.beginPath();
                        c.arc(cx + T*0.25, cy + T*0.15, T*0.02, 0, 6.28);
                        c.fill();
                    }
                    
                } else if(lvl >= 6) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 6: BEAR MARKET - Large bear pelt trading complex
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // === LARGE TRADING GROUND ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#B89870';
                    c.beginPath();
                    c.moveTo(cx, cy - T*0.4);
                    c.lineTo(cx + T*0.48, cy);
                    c.lineTo(cx, cy + T*0.4);
                    c.lineTo(cx - T*0.48, cy);
                    c.closePath();
                    c.fill();
                    
                    // Inner worn area
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#A88860';
                    c.beginPath();
                    c.ellipse(cx, cy, T*0.3, T*0.15, 0, 0, 6.28);
                    c.fill();
                    
                    // === LARGE BEAR PELT DISPLAY (centerpiece) ===
                    // Pelt rack frame (A-frame)
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#5D4037';
                    // Left leg
                    c.beginPath();
                    c.moveTo(cx - T*0.2, cy + T*0.1);
                    c.lineTo(cx - T*0.05, cy - T*0.22);
                    c.lineTo(cx - T*0.02, cy - T*0.2);
                    c.lineTo(cx - T*0.16, cy + T*0.1);
                    c.closePath();
                    c.fill();
                    // Right leg
                    c.beginPath();
                    c.moveTo(cx + T*0.2, cy + T*0.08);
                    c.lineTo(cx + T*0.05, cy - T*0.22);
                    c.lineTo(cx + T*0.02, cy - T*0.2);
                    c.lineTo(cx + T*0.16, cy + T*0.08);
                    c.closePath();
                    c.fill();
                    // Crossbar
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#6D4C41';
                    c.fillRect(cx - T*0.15, cy - T*0.2, T*0.3, 3);
                    
                    // Large hanging bear pelt
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#5C4033';
                    c.beginPath();
                    c.moveTo(cx - T*0.12, cy - T*0.18);
                    c.lineTo(cx + T*0.12, cy - T*0.18);
                    c.lineTo(cx + T*0.15, cy + T*0.02);
                    c.lineTo(cx + T*0.08, cy + T*0.08);
                    c.lineTo(cx, cy + T*0.1);
                    c.lineTo(cx - T*0.08, cy + T*0.08);
                    c.lineTo(cx - T*0.15, cy + T*0.02);
                    c.closePath();
                    c.fill();
                    // Bear head shape on pelt
                    c.fillStyle = variant === 0 ? '#3A3A2A' : '#4A3A2A';
                    c.beginPath();
                    c.arc(cx, cy - T*0.12, T*0.05, 0, 6.28);
                    c.fill();
                    // Ears
                    c.beginPath();
                    c.arc(cx - T*0.04, cy - T*0.16, T*0.015, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.arc(cx + T*0.04, cy - T*0.16, T*0.015, 0, 6.28);
                    c.fill();
                    
                    // === SIDE LEAN-TO SHELTER (left) ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#6D4C41';
                    c.fillRect(cx - T*0.42, cy - T*0.1, 2, T*0.22);
                    c.fillRect(cx - T*0.28, cy - T*0.05, 2, T*0.18);
                    // Thatch roof
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#A67B5B';
                    c.beginPath();
                    c.moveTo(cx - T*0.44, cy - T*0.1);
                    c.lineTo(cx - T*0.26, cy - T*0.05);
                    c.lineTo(cx - T*0.26, cy + T*0.08);
                    c.lineTo(cx - T*0.44, cy + T*0.05);
                    c.closePath();
                    c.fill();
                    
                    // Small pelts hanging in shelter
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#7B5B3B';
                    c.beginPath();
                    c.ellipse(cx - T*0.36, cy, T*0.04, T*0.06, 0.2, 0, 6.28);
                    c.fill();
                    
                    // === SIDE LEAN-TO SHELTER (right) ===
                    c.fillStyle = variant === 0 ? '#5A5A4A' : '#5D4037';
                    c.fillRect(cx + T*0.28, cy + T*0.02, 2, T*0.18);
                    c.fillRect(cx + T*0.42, cy + T*0.06, 2, T*0.14);
                    // Thatch
                    c.fillStyle = variant === 0 ? '#6A6A5A' : '#9A7050';
                    c.beginPath();
                    c.moveTo(cx + T*0.26, cy + T*0.02);
                    c.lineTo(cx + T*0.44, cy + T*0.06);
                    c.lineTo(cx + T*0.44, cy + T*0.16);
                    c.lineTo(cx + T*0.26, cy + T*0.12);
                    c.closePath();
                    c.fill();
                    
                    // === CENTRAL FIRE PIT ===
                    // Fire pit stones
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#6B5B4B';
                    for(let i = 0; i < 6; i++) {
                        let angle = i * 1.047;
                        let fx = cx + Math.cos(angle) * T*0.12 + T*0.02;
                        let fy = cy + Math.sin(angle) * T*0.06 + T*0.2;
                        c.beginPath();
                        c.ellipse(fx, fy, T*0.025, T*0.018, angle, 0, 6.28);
                        c.fill();
                    }
                    // Fire
                    if(variant >= 1) {
                        c.fillStyle = '#D4661A';
                        c.beginPath();
                        c.moveTo(cx + T*0.02, cy + T*0.24);
                        c.lineTo(cx - T*0.03, cy + T*0.16);
                        c.lineTo(cx + T*0.02, cy + T*0.13);
                        c.lineTo(cx + T*0.07, cy + T*0.16);
                        c.closePath();
                        c.fill();
                        c.fillStyle = '#FFAA00';
                        c.beginPath();
                        c.arc(cx + T*0.02, cy + T*0.18, T*0.025, 0, 6.28);
                        c.fill();
                    }
                    
                    // === BEAR SKULL TOTEM (decoration) ===
                    // Pole
                    c.fillStyle = variant === 0 ? '#4A4A3A' : '#5D4037';
                    c.fillRect(cx + T*0.32, cy - T*0.18, 3, T*0.2);
                    // Bear skull
                    c.fillStyle = variant === 0 ? '#7A7A6A' : '#E8DCC8';
                    c.beginPath();
                    c.ellipse(cx + T*0.335, cy - T*0.22, T*0.035, T*0.025, 0, 0, 6.28);
                    c.fill();
                    // Eye sockets
                    c.fillStyle = variant === 0 ? '#3A3A2A' : '#3A3020';
                    c.beginPath();
                    c.arc(cx + T*0.32, cy - T*0.23, T*0.008, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.arc(cx + T*0.35, cy - T*0.23, T*0.008, 0, 6.28);
                    c.fill();
                    
                    // === TRADERS/CUSTOMERS ===
                    if(variant >= 2) {
                        // Trader 1 (left)
                        c.fillStyle = variant === 0 ? '#5A5A4A' : '#8B7355';
                        c.beginPath();
                        c.ellipse(cx - T*0.32, cy + T*0.16, T*0.035, T*0.05, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#C4A882';
                        c.beginPath();
                        c.arc(cx - T*0.32, cy + T*0.1, T*0.022, 0, 6.28);
                        c.fill();
                    }
                    
                    if(variant >= 3) {
                        // Trader 2 (right)
                        c.fillStyle = variant === 0 ? '#5A5A4A' : '#7B6B55';
                        c.beginPath();
                        c.ellipse(cx + T*0.18, cy + T*0.28, T*0.03, T*0.045, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#D4B896';
                        c.beginPath();
                        c.arc(cx + T*0.18, cy + T*0.22, T*0.02, 0, 6.28);
                        c.fill();
                        
                        // Extra pelt bundle (goods)
                        c.fillStyle = '#5C4033';
                        c.beginPath();
                        c.ellipse(cx - T*0.1, cy + T*0.26, T*0.04, T*0.025, 0.3, 0, 6.28);
                        c.fill();
                    }
                }
                
                // === ACTIVITY INDICATOR (subtle smoke/activity) ===
                if(variant >= 2) {
                    c.fillStyle = 'rgba(200,200,200,0.3)';
                    let smokeY = Math.sin(t * 2) * T * 0.02;
                    c.beginPath();
                    c.ellipse(cx + T*0.15, cy - T*0.35 + smokeY, T*0.04, T*0.025, 0, 0, 6.28);
                    c.fill();
                }
            },
            drawInd(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;  // Center for 1x1 tile
                
                // Get config and variant for this industrial level
                let levelConfig = CFG.INDUSTRIAL_LEVELS[lvl];
                let variant = b.variant || 1; // 0=abandoned, 1=low, 2=medium, 3=high
                
                // === BIRDS EYE VIEW MODE - SNES-style cute industrial buildings ===
                if(Game.vm === 'BIRDSEYE') {
                    
                    if(lvl === 1) {
                        // =============================
                        // LEVEL 1: BIRD HUNTING RANGE - Clean forest with sign
                        // =============================
                        
                        // Ground - clean grass
                        c.fillStyle = '#5A8D32';
                        c.fillRect(x, y, T, T);
                        
                        // Simple grass tufts
                        c.fillStyle = '#6BA33E';
                        c.beginPath();
                        c.ellipse(x + T*0.2, y + T*0.7, T*0.05, T*0.02, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.7, y + T*0.8, T*0.04, T*0.02, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - 2, cy + T*0.05, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.2, cy - T*0.2, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.2, cy - T*0.2, T*0.4, T*0.22);
                        
                        // Bird icon on sign
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('üê¶', cx, cy - T*0.02);
                        
                    } else if(lvl === 2) {
                        // =============================
                        // LEVEL 2: GRUB DIGGING PIT - Dirt patch with sign
                        // =============================
                        
                        // Ground - dirt/soil
                        c.fillStyle = '#8B7355';
                        c.fillRect(x, y, T, T);
                        
                        // Digging pit (simple dark circle)
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.15, T*0.2, T*0.12, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx + T*0.15, cy - T*0.1, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.05, cy - T*0.3, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.05, cy - T*0.3, T*0.4, T*0.22);
                        
                        // Worm/grub icon
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ü™±', cx + T*0.15, cy - T*0.12);
                        
                    } else if(lvl === 3) {
                        // =============================
                        // LEVEL 3: STONE KNAPPING SITE - Rock area with sign
                        // =============================
                        
                        // Ground - rocky gray
                        c.fillStyle = '#9E9E9E';
                        c.fillRect(x, y, T, T);
                        
                        // A few rocks
                        c.fillStyle = '#757575';
                        c.beginPath();
                        c.ellipse(x + T*0.25, y + T*0.65, T*0.12, T*0.08, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.6, y + T*0.75, T*0.08, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - 2, cy - T*0.1, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.2, cy - T*0.3, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.2, cy - T*0.3, T*0.4, T*0.22);
                        
                        // Stone icon
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ü™®', cx, cy - T*0.12);
                        
                    } else if(lvl === 4) {
                        // =============================
                        // LEVEL 4: TURTLE HUNTING GROUND - Wetland hunting area
                        // =============================
                        
                        // Ground - marshy/wetland
                        c.fillStyle = '#4A6E4A';
                        c.fillRect(x, y, T, T);
                        
                        // Water puddles
                        c.fillStyle = '#4A8BC2';
                        c.beginPath();
                        c.ellipse(x + T*0.25, y + T*0.6, T*0.15, T*0.08, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.7, y + T*0.75, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Reeds
                        c.strokeStyle = '#3E5E3E';
                        c.lineWidth = 2;
                        for(let i = 0; i < 4; i++) {
                            let rx = x + T*0.1 + i*T*0.08;
                            c.beginPath();
                            c.moveTo(rx, y + T*0.5);
                            c.lineTo(rx + (i%2 ? 2 : -2), y + T*0.3);
                            c.stroke();
                        }
                        
                        // Turtle shell decoration
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.ellipse(cx + T*0.1, cy - T*0.1, T*0.12, T*0.08, 0, 0, 6.28);
                        c.fill();
                        // Shell pattern
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx + T*0.1, cy - T*0.18);
                        c.lineTo(cx + T*0.1, cy - T*0.02);
                        c.moveTo(cx, cy - T*0.1);
                        c.lineTo(cx + T*0.22, cy - T*0.1);
                        c.stroke();
                        
                        // Hunting sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - T*0.2, cy - T*0.05, 4, T*0.3);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.38, cy - T*0.25, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.38, cy - T*0.25, T*0.4, T*0.22);
                        
                        // Turtle icon
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('üê¢', cx - T*0.18, cy - T*0.07);
                        
                    } else if(lvl === 5) {
                        // =============================
                        // LEVEL 5: BEAR PIT - Hunting trap/processing area
                        // =============================
                        
                        // Ground - forest floor
                        c.fillStyle = '#5E4E3E';
                        c.fillRect(x, y, T, T);
                        
                        // Pit trap (dark hole with wooden edge)
                        c.fillStyle = '#1E1E1E';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.25, T*0.15, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden pit frame
                        c.strokeStyle = '#6D4C41';
                        c.lineWidth = 4;
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.27, T*0.17, 0, 0, 6.28);
                        c.stroke();
                        
                        // Stakes in pit (dangerous!)
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            let sx = cx - T*0.1 + i*T*0.1;
                            c.beginPath();
                            c.moveTo(sx, cy + T*0.15);
                            c.lineTo(sx, cy + T*0.02);
                            c.stroke();
                        }
                        
                        // Bear hide on rack nearby
                        c.fillStyle = '#5D4037';
                        c.fillRect(x + T*0.05, cy - T*0.35, T*0.25, T*0.18);
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 1;
                        c.strokeRect(x + T*0.05, cy - T*0.35, T*0.25, T*0.18);
                        
                        // Drying rack posts
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.02, cy - T*0.4, 4, T*0.28);
                        c.fillRect(x + T*0.28, cy - T*0.4, 4, T*0.28);
                        
                        // Bear paw prints decoration
                        if(variant >= 2) {
                            c.fillStyle = '#4E3E2E';
                            c.font = 'bold 10px sans-serif';
                            c.fillText('üêæ', x + T*0.75, y + T*0.25);
                        }
                        
                        // Sign
                        c.fillStyle = '#D4B896';
                        c.fillRect(x + T*0.65, cy - T*0.3, T*0.3, T*0.18);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.65, cy - T*0.3, T*0.3, T*0.18);
                        c.font = 'bold 12px sans-serif';
                        c.fillText('üêª', x + T*0.8, cy - T*0.15);
                        
                    } else if(lvl >= 6) {
                        // =============================
                        // LEVEL 6: BUFFALO GROUNDS - Large hunting/processing complex
                        // =============================
                        
                        // Ground - plains grass
                        c.fillStyle = '#8B9B68';
                        c.fillRect(x, y, T, T);
                        
                        // Tall prairie grass patches
                        c.fillStyle = '#A8B87A';
                        for(let i = 0; i < 5; i++) {
                            let gx = x + T*0.1 + i*T*0.18;
                            let gy = y + T*0.6 + (i%2)*T*0.15;
                            c.beginPath();
                            c.ellipse(gx, gy, T*0.06, T*0.03, 0, 0, 6.28);
                            c.fill();
                        }
                        
                        // Processing shelter (larger structure)
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.55, y + T*0.15, T*0.4, T*0.35);
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.55, y + T*0.15, T*0.4, T*0.35);
                        
                        // Thatched roof
                        c.fillStyle = '#D4B896';
                        c.beginPath();
                        c.moveTo(x + T*0.5, y + T*0.17);
                        c.lineTo(x + T*0.75, y - T*0.05);
                        c.lineTo(x + T, y + T*0.17);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Buffalo hide drying racks
                        c.fillStyle = '#8B4513';
                        c.fillRect(x + T*0.05, y + T*0.2, T*0.35, T*0.02);
                        // Posts
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.05, y + T*0.2, 4, T*0.35);
                        c.fillRect(x + T*0.38, y + T*0.2, 4, T*0.35);
                        
                        // Hanging hides
                        c.fillStyle = '#A0522D';
                        c.fillRect(x + T*0.1, y + T*0.22, T*0.12, T*0.2);
                        c.fillRect(x + T*0.25, y + T*0.22, T*0.1, T*0.18);
                        
                        // Buffalo skull decoration
                        c.fillStyle = '#F5F5DC';
                        c.beginPath();
                        c.ellipse(x + T*0.2, y + T*0.7, T*0.08, T*0.05, 0, 0, 6.28);
                        c.fill();
                        // Horns
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.arc(x + T*0.2, y + T*0.7, T*0.12, Math.PI*1.1, Math.PI*1.5);
                        c.stroke();
                        c.beginPath();
                        c.arc(x + T*0.2, y + T*0.7, T*0.12, Math.PI*1.5, Math.PI*1.9);
                        c.stroke();
                        
                        // Smoke from processing (if active)
                        if(variant > 0) {
                            let t = (Renderer.time || 0);
                            for(let i = 0; i < 2; i++) {
                                let puffY = y - T*0.1 - i*5 - Math.sin(t*0.7 + i)*2;
                                let puffX = x + T*0.75 + Math.sin(t*0.5 + i)*2;
                                c.fillStyle = `rgba(150,150,150,${0.35 - i*0.12})`;
                                c.beginPath();
                                c.arc(puffX, puffY, 3 - i*0.5, 0, 6.28);
                                c.fill();
                            }
                        }
                        
                        // Buffalo icon sign
                        c.fillStyle = '#D4B896';
                        c.fillRect(x + T*0.6, y + T*0.55, T*0.3, T*0.18);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.6, y + T*0.55, T*0.3, T*0.18);
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ü¶¨', x + T*0.75, y + T*0.68);
                    }
                    
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                // Color based on level - BROWN/ORANGE tones for industrial
                let color = '#8D6E63';  // Brown base
                if(lvl === 2) color = '#795548';  // Darker brown for Level 2
                if(lvl === 3) color = '#6D4C41';  // Even darker for Level 3
                if(lvl === 4) color = '#5D4037';  // Darkest for Level 4
                
                // Adjust for variant/activity
                if(variant === 0) color = '#424242'; // Abandoned - gray
                else if(variant === 3) color = '#FF5722'; // High activity - orange
                
                c.fillStyle = color;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);  // 1x1 tile
                
                // Border
                c.strokeStyle = variant === 3 ? '#FFD700' : '#333';
                c.lineWidth = variant === 3 ? 2 : 1;
                c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                
                // "I" label
                c.fillStyle = "#FFFFFF";
                c.font = "bold 16px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.fillText("I", cx, cy - 10);
                
                // Worker count
                let pop = b.pop || 0;
                c.font = "bold 8px sans-serif";
                c.fillText(`üë•${pop}`, cx, cy + 2);
                
                // Level number
                c.font = "bold 10px sans-serif";
                c.fillText(`L${lvl}`, cx, cy + 12);
                
                // 3-Color Activity Bar (SNES SimCity style)
                let barWidth = T - 12;
                let barHeight = 4;
                let barX = x + 6;
                let barY = y + T - 8;
                
                // Background
                c.fillStyle = '#333';
                c.fillRect(barX, barY, barWidth, barHeight);
                
                // Activity color based on variant: Yellow=Low, Green=Medium, Red=High
                let activityColor = variant === 0 ? '#666' : variant === 1 ? '#FFEB3B' : variant === 2 ? '#4CAF50' : '#F44336';
                let activityWidth = variant === 0 ? 0 : (variant / 3) * barWidth;
                c.fillStyle = activityColor;
                c.fillRect(barX, barY, activityWidth, barHeight);
            },
            drawWell(c,x,y) {
                let T = CFG.TILE;
                let cx = x + T * 0.5;
                let cy = y + T * 0.55;

                // Drop shadow (smaller, offset)
                c.save();
                c.fillStyle = 'rgba(0,0,0,0.25)';
                c.beginPath();
                c.ellipse(cx + T*0.08, cy + T*0.08, T*0.18, T*0.09, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden rim (elliptical, plank tone gradient)
                let rimGrad = c.createLinearGradient(cx, cy - T*0.12, cx, cy + T*0.12);
                rimGrad.addColorStop(0, '#8D6E63');
                rimGrad.addColorStop(1, '#5D4037');
                c.fillStyle = rimGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.18, T*0.12, 0, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#4E342E';
                c.lineWidth = 2;
                c.stroke();

                // Ambient occlusion under rim
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy + T*0.03, T*0.17, T*0.11, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Water surface (inner ellipse with highlight)
                let waterGrad = c.createLinearGradient(cx, cy - T*0.08, cx, cy + T*0.08);
                waterGrad.addColorStop(0, '#81D4FA');
                waterGrad.addColorStop(1, '#29B6F6');
                c.fillStyle = waterGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.12, T*0.08, 0, 0, Math.PI*2);
                c.fill();
                // Highlight
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#FFFFFF';
                c.beginPath();
                c.ellipse(cx - T*0.04, cy - T*0.03, T*0.06, T*0.03, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden posts (left/right) and crossbeam
                let postW = T*0.04, postH = T*0.22;
                let postY = cy - T*0.22;
                c.fillStyle = '#6D4C41';
                // Left post
                c.fillRect(cx - T*0.16, postY, postW, postH);
                // Right post
                c.fillRect(cx + T*0.12, postY, postW, postH);
                // Crossbeam
                c.fillStyle = '#8D6E63';
                c.fillRect(cx - T*0.16, postY - T*0.02, T*0.32 + postW, T*0.03);

                // Rope + bucket hint
                c.strokeStyle = '#D7CCC8';
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(cx, postY);
                c.lineTo(cx, cy - T*0.03);
                c.stroke();
                c.fillStyle = '#5D4037';
                c.fillRect(cx - T*0.015, cy - T*0.03, T*0.03, T*0.02);
            },
            drawChief(c,x,y,b) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CHIEF'S HUT - Giant Reed Castle (2x2)
                // A magnificent structure made of bundled reeds and thatch
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Shadow
                c.fillStyle = "rgba(0,0,0,0.4)";
                c.fillRect(x + 8, y + 15, T*2 - 16, T*2 - 10);
                
                // Base platform - raised wooden foundation
                c.fillStyle = "#8B7355";
                c.fillRect(x + 5, y + T*2 - 25, T*2 - 10, 20);
                
                // Main reed bundle walls - golden/tan color
                c.fillStyle = "#D4A574";
                c.fillRect(x + 15, y + 25, T*2 - 30, T*2 - 50);
                
                // Vertical reed bundle texture lines
                c.strokeStyle = "#B8956E";
                c.lineWidth = 2;
                for(let i = 0; i < 8; i++) {
                    let lx = x + 20 + i * 12;
                    c.beginPath();
                    c.moveTo(lx, y + 25);
                    c.lineTo(lx, y + T*2 - 25);
                    c.stroke();
                }
                
                // Horizontal reed bindings
                c.strokeStyle = "#5D4E37";
                c.lineWidth = 3;
                for(let j = 0; j < 4; j++) {
                    let ly = y + 35 + j * 18;
                    c.beginPath();
                    c.moveTo(x + 15, ly);
                    c.lineTo(x + T*2 - 15, ly);
                    c.stroke();
                }
                
                // Corner towers (reed bundles)
                c.fillStyle = "#C49A6C";
                c.fillRect(x + 10, y + 20, 15, T*2 - 40);
                c.fillRect(x + T*2 - 25, y + 20, 15, T*2 - 40);
                
                // Tower caps (rounded reed tops)
                c.fillStyle = "#A67B5B";
                c.beginPath();
                c.arc(x + 17, y + 20, 8, 0, Math.PI * 2);
                c.fill();
                c.beginPath();
                c.arc(x + T*2 - 18, y + 20, 8, 0, Math.PI * 2);
                c.fill();
                
                // Grand thatched roof
                c.fillStyle = "#8B7355";
                c.beginPath();
                c.moveTo(x + 5, y + 30);
                c.lineTo(x + T*2 - 5, y + 30);
                c.lineTo(cx, y + 5);
                c.closePath();
                c.fill();
                
                // Roof texture (thatch lines)
                c.strokeStyle = "#6B5344";
                c.lineWidth = 1;
                for(let r = 0; r < 6; r++) {
                    c.beginPath();
                    c.moveTo(x + 15 + r*5, y + 28 - r*3);
                    c.lineTo(cx, y + 8);
                    c.stroke();
                    c.beginPath();
                    c.moveTo(x + T*2 - 15 - r*5, y + 28 - r*3);
                    c.lineTo(cx, y + 8);
                    c.stroke();
                }
                
                // Roof crest decoration (bundled reeds at top)
                c.fillStyle = "#D4A574";
                c.beginPath();
                c.ellipse(cx, y + 5, 10, 5, 0, 0, Math.PI * 2);
                c.fill();
                
                // Central doorway (large arched entrance)
                c.fillStyle = "#2D1F14";
                c.beginPath();
                c.moveTo(cx - 15, y + T*2 - 25);
                c.lineTo(cx - 15, y + 60);
                c.quadraticCurveTo(cx, y + 45, cx + 15, y + 60);
                c.lineTo(cx + 15, y + T*2 - 25);
                c.closePath();
                c.fill();
                
                // Door frame decoration
                c.strokeStyle = "#C49A6C";
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(cx - 15, y + T*2 - 25);
                c.lineTo(cx - 15, y + 60);
                c.quadraticCurveTo(cx, y + 45, cx + 15, y + 60);
                c.lineTo(cx + 15, y + T*2 - 25);
                c.stroke();
                
                // Chief's symbol above door
                c.fillStyle = "#FFD700";
                c.beginPath();
                c.arc(cx, y + 40, 6, 0, Math.PI * 2);
                c.fill();
                
                // Smoke from roof
                if(Math.random() > 0.5) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 5, 
                        40, 
                        "rgba(200, 180, 160, 0.6)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                // Label
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("FIRST CHIEF'S HUT", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${Math.floor(CFG.CHIEF_BONUS*100)}% Culture Bonus`, cx, y + T*2 + 27);
            },
            drawClanChief(c,x,y,b) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CLAN CHIEF'S HUT - 2x2 Milestone Building
                // Unlocks Level 4-6 buildings
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Shadow
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 8, y + 12, T*2 - 16, T*2 - 12);
                
                // Stone foundation
                c.fillStyle = "#7E7E7E";
                c.fillRect(x + 10, y + T*2 - 25, T*2 - 20, 20);
                
                // Main wooden structure
                c.fillStyle = "#8B4513";
                c.fillRect(x + 15, y + 35, T*2 - 30, T*2 - 60);
                
                // Log texture
                c.strokeStyle = "#5D3D2D";
                c.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.moveTo(x + 15, y + 40 + i * 10);
                    c.lineTo(x + T*2 - 15, y + 40 + i * 10);
                    c.stroke();
                }
                
                // Sloped roof with bark
                c.fillStyle = "#3E5E3E";
                c.beginPath();
                c.moveTo(x + 5, y + 37);
                c.lineTo(cx, y + 5);
                c.lineTo(x + T*2 - 5, y + 37);
                c.closePath();
                c.fill();
                c.strokeStyle = "#2E4E2E";
                c.lineWidth = 2;
                c.stroke();
                
                // Roof texture lines
                c.strokeStyle = "#2E4E2E";
                c.lineWidth = 1;
                for(let i = 0; i < 4; i++) {
                    let xOff = -25 + i * 18;
                    c.beginPath();
                    c.moveTo(cx + xOff, y + 35);
                    c.lineTo(cx + xOff * 0.3, y + 12);
                    c.stroke();
                }
                
                // Totem pole (cultural symbol)
                c.fillStyle = "#A0522D";
                c.fillRect(x + T*2 - 25, y + 25, 12, T*2 - 35);
                
                // Totem face
                c.fillStyle = "#FFD700";
                c.beginPath();
                c.arc(x + T*2 - 19, y + 40, 8, 0, 6.28);
                c.fill();
                
                // Totem eyes
                c.fillStyle = "#1E0E00";
                c.beginPath();
                c.arc(x + T*2 - 22, y + 38, 2, 0, 6.28);
                c.arc(x + T*2 - 16, y + 38, 2, 0, 6.28);
                c.fill();
                
                // Totem beak/mouth
                c.fillStyle = "#CD853F";
                c.beginPath();
                c.moveTo(x + T*2 - 19, y + 42);
                c.lineTo(x + T*2 - 15, y + 46);
                c.lineTo(x + T*2 - 23, y + 46);
                c.closePath();
                c.fill();
                
                // Large entrance doorway
                c.fillStyle = "#2E1E0E";
                c.beginPath();
                c.arc(cx - 10, y + T*2 - 30, 15, Math.PI, 0, false);
                c.lineTo(cx + 5, y + T*2 - 5);
                c.lineTo(cx - 25, y + T*2 - 5);
                c.closePath();
                c.fill();
                
                // Fire bowl at entrance
                c.fillStyle = "#5D4037";
                c.beginPath();
                c.ellipse(cx + 20, y + T*2 - 15, 10, 6, 0, 0, 6.28);
                c.fill();
                
                // Fire flames
                if(Math.random() > 0.3) {
                    c.fillStyle = "#FF6347";
                    let flameHeight = 8 + Math.random() * 4;
                    c.beginPath();
                    c.moveTo(cx + 15, y + T*2 - 17);
                    c.lineTo(cx + 20, y + T*2 - 17 - flameHeight);
                    c.lineTo(cx + 25, y + T*2 - 17);
                    c.closePath();
                    c.fill();
                }
                
                // Cultural smoke particles
                if(Math.random() > 0.7) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 5, 
                        40, 
                        "rgba(200, 200, 200, 0.5)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                // Label
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("CLAN CHIEF'S HUT", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillStyle = "#FFFFFF";
                c.fillText("Unlocks L4-L6 Buildings", cx, y + T*2 + 27);
            },
            drawDock(c,x,y,b) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FIRST DOCK - 3x2 Milestone Building
                // Unlocks Level 7+ buildings
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let T = CFG.TILE;
                let cx = x + T*1.5, cy = y + T;
                
                // Water underneath (extends beyond building)
                c.fillStyle = "#4A8BC2";
                c.fillRect(x, y + T*0.8, T*3, T*1.2);
                
                // Water ripples
                c.strokeStyle = "#6BB3D9";
                c.lineWidth = 1;
                for(let i = 0; i < 4; i++) {
                    c.beginPath();
                    c.arc(x + T*0.5 + i*T*0.7, y + T*1.3, 8 + i*3, 0, Math.PI);
                    c.stroke();
                }
                
                // Main dock platform (wooden planks)
                c.fillStyle = "#8B7355";
                c.fillRect(x + T*0.3, y + T*0.4, T*2.4, T*0.5);
                
                // Plank lines
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                for(let i = 0; i < 8; i++) {
                    let px = x + T*0.35 + i * T*0.3;
                    c.beginPath();
                    c.moveTo(px, y + T*0.4);
                    c.lineTo(px, y + T*0.9);
                    c.stroke();
                }
                
                // Support posts going into water
                c.fillStyle = "#6D4C41";
                c.fillRect(x + T*0.5, y + T*0.9, T*0.15, T*0.7);
                c.fillRect(x + T*1.4, y + T*0.9, T*0.15, T*0.7);
                c.fillRect(x + T*2.3, y + T*0.9, T*0.15, T*0.7);
                
                // Dock shelter/warehouse
                c.fillStyle = "#A0522D";
                c.fillRect(x + T*0.8, y + T*0.05, T*1.4, T*0.4);
                c.strokeStyle = "#5D3D2D";
                c.lineWidth = 2;
                c.strokeRect(x + T*0.8, y + T*0.05, T*1.4, T*0.4);
                
                // Thatched roof
                c.fillStyle = "#D4B896";
                c.beginPath();
                c.moveTo(x + T*0.6, y + T*0.07);
                c.lineTo(x + T*1.5, y - T*0.2);
                c.lineTo(x + T*2.4, y + T*0.07);
                c.closePath();
                c.fill();
                c.strokeStyle = "#8B7355";
                c.lineWidth = 1;
                c.stroke();
                
                // Trade goods barrels/crates
                c.fillStyle = "#8B4513";
                // Barrel
                c.beginPath();
                c.ellipse(x + T*0.95, y + T*0.25, T*0.08, T*0.12, 0, 0, 6.28);
                c.fill();
                // Crate
                c.fillStyle = "#A0826D";
                c.fillRect(x + T*1.8, y + T*0.15, T*0.2, T*0.2);
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                c.strokeRect(x + T*1.8, y + T*0.15, T*0.2, T*0.2);
                
                // Boat moored at dock
                c.fillStyle = "#6D4C41";
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*1.2);
                c.lineTo(x + T*2.9, y + T*1.35);
                c.lineTo(x + T*2.5, y + T*1.5);
                c.lineTo(x + T*2.2, y + T*1.35);
                c.closePath();
                c.fill();
                
                // Boat mast
                c.strokeStyle = "#5D4037";
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*1.35);
                c.lineTo(x + T*2.5, y + T*0.95);
                c.stroke();
                
                // Sail
                c.fillStyle = "#F5F5DC";
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*0.98);
                c.lineTo(x + T*2.7, y + T*1.15);
                c.lineTo(x + T*2.5, y + T*1.25);
                c.closePath();
                c.fill();
                
                // Rope ties
                c.strokeStyle = "#D7CCC8";
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(x + T*2.3, y + T*0.85);
                c.lineTo(x + T*2.35, y + T*1.2);
                c.stroke();
                
                // Trading post sign
                c.fillStyle = "#F5DEB3";
                c.fillRect(x + T*0.4, y + T*0.55, T*0.35, T*0.2);
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                c.strokeRect(x + T*0.4, y + T*0.55, T*0.35, T*0.2);
                c.fillStyle = "#5D4037";
                c.font = "bold 8px sans-serif";
                c.textAlign = "center";
                c.fillText("‚öì", x + T*0.57, y + T*0.7);
                
                // Label
                c.fillStyle = "#4A8BC2";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("FIRST DOCK", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillStyle = "#FFFFFF";
                c.fillText("Unlocks L7+ Buildings", cx, y + T*2 + 27);
            },
            drawBasket(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#D2691E";
                c.fillRect(x + 20, y + 40, T*2 - 40, T*2 - 50);
                
                c.strokeStyle = "#8B4513";
                c.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.moveTo(x + 20, y + 40 + i * 6);
                    c.lineTo(x + T*2 - 20, y + 40 + i * 6);
                    c.stroke();
                }
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("BASKET", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.BASKET.cap} storage`, cx, y + T*2 + 27);
            },
            drawPottery(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.beginPath();
                c.moveTo(x + 30, y + 60);
                c.quadraticCurveTo(x + 25, y + 40, x + 35, y + 35);
                c.lineTo(x + T*2 - 35, y + 35);
                c.quadraticCurveTo(x + T*2 - 25, y + 40, x + T*2 - 30, y + 60);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#DAA520";
                c.fillRect(x + 35, y + 30, T*2 - 70, 5);
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("POTTERY", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.POTTERY.cap} storage`, cx, y + T*2 + 27);
            },
            drawGranary(c,x,y,b) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // NUTS STORAGE REED HOUSE - Raised reed hut for nut storage (2x2)
                // Traditional prehistoric storage with woven walls and thatched roof
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Ground shadow
                c.fillStyle = "rgba(0,0,0,0.4)";
                c.beginPath();
                c.ellipse(cx, y + T*2 - 5, T*0.8, T*0.2, 0, 0, Math.PI*2);
                c.fill();
                
                // Grassy ground patch
                c.fillStyle = "#4A5D3A";
                c.fillRect(x + 5, y + T*2 - 12, T*2 - 10, 12);
                
                // Raised wooden platform stilts
                c.fillStyle = "#5C3D1E";
                c.fillRect(x + 18, y + T*1.3, 8, T*0.65);
                c.fillRect(x + T*2 - 26, y + T*1.3, 8, T*0.65);
                c.fillRect(cx - 4, y + T*1.3, 8, T*0.65);
                
                // Platform cross-beams
                c.fillStyle = "#6B4A2D";
                c.fillRect(x + 12, y + T*1.25, T*2 - 24, 8);
                
                // Main reed house body - woven texture
                let wallGrad = c.createLinearGradient(x + 15, 0, x + T*2 - 15, 0);
                wallGrad.addColorStop(0, '#B8956A');
                wallGrad.addColorStop(0.2, '#C8A57A');
                wallGrad.addColorStop(0.5, '#D8B58A');
                wallGrad.addColorStop(0.8, '#C8A57A');
                wallGrad.addColorStop(1, '#B8956A');
                c.fillStyle = wallGrad;
                c.fillRect(x + 15, y + T*0.55, T*2 - 30, T*0.75);
                
                // Reed weave pattern - horizontal
                c.strokeStyle = '#9A7550';
                c.lineWidth = 1;
                for(let i = 0; i < 8; i++) {
                    c.beginPath();
                    c.moveTo(x + 17, y + T*0.6 + i*T*0.09);
                    c.lineTo(x + T*2 - 17, y + T*0.6 + i*T*0.09);
                    c.stroke();
                }
                // Vertical weave
                for(let i = 0; i < 12; i++) {
                    c.beginPath();
                    c.moveTo(x + 20 + i*7, y + T*0.55);
                    c.lineTo(x + 20 + i*7, y + T*1.3);
                    c.stroke();
                }
                
                // Thatched roof - layered golden straw
                let roofGrad = c.createLinearGradient(cx, y + 5, cx, y + T*0.6);
                roofGrad.addColorStop(0, '#A08050');
                roofGrad.addColorStop(0.4, '#B89060');
                roofGrad.addColorStop(0.7, '#C8A070');
                roofGrad.addColorStop(1, '#D8B080');
                c.fillStyle = roofGrad;
                c.beginPath();
                c.moveTo(x + 5, y + T*0.58);
                c.lineTo(cx, y + 8);
                c.lineTo(x + T*2 - 5, y + T*0.58);
                c.closePath();
                c.fill();
                
                // Roof thatch texture
                c.strokeStyle = '#907040';
                c.lineWidth = 1;
                for(let i = 0; i < 10; i++) {
                    let t = i / 10;
                    // Left side
                    c.beginPath();
                    c.moveTo(x + 8 + t*(T - 8), y + T*0.55 - t*T*0.42);
                    c.lineTo(x + 8 + t*(T - 8) + 8, y + T*0.55 - t*T*0.42 + 10);
                    c.stroke();
                    // Right side
                    c.beginPath();
                    c.moveTo(x + T*2 - 8 - t*(T - 8), y + T*0.55 - t*T*0.42);
                    c.lineTo(x + T*2 - 8 - t*(T - 8) - 8, y + T*0.55 - t*T*0.42 + 10);
                    c.stroke();
                }
                
                // Roof ridge pole
                c.strokeStyle = '#6B4A2D';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(x + 8, y + T*0.55);
                c.lineTo(cx, y + 10);
                c.lineTo(x + T*2 - 8, y + T*0.55);
                c.stroke();
                
                // Small entrance
                c.fillStyle = '#3A2515';
                c.beginPath();
                c.arc(cx, y + T*1.15, 12, Math.PI, 0);
                c.lineTo(cx + 12, y + T*1.28);
                c.lineTo(cx - 12, y + T*1.28);
                c.closePath();
                c.fill();
                
                // Acorn/nut emblem on roof
                c.fillStyle = '#8B5A2B';
                c.beginPath();
                c.ellipse(cx, y + T*0.35, 8, 10, 0, 0, Math.PI*2);
                c.fill();
                // Acorn cap
                c.fillStyle = '#654321';
                c.beginPath();
                c.ellipse(cx, y + T*0.27, 9, 4, 0, 0, Math.PI);
                c.fill();
                // Stem
                c.fillStyle = '#4A3520';
                c.fillRect(cx - 2, y + T*0.2, 4, 5);
                
                // Ladder on right side
                c.strokeStyle = '#5B3A1D';
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(x + T*2 - 20, y + T*1.28);
                c.lineTo(x + T*2 - 12, y + T*2 - 8);
                c.moveTo(x + T*2 - 16, y + T*1.28);
                c.lineTo(x + T*2 - 8, y + T*2 - 8);
                c.stroke();
                // Rungs
                c.lineWidth = 1.5;
                for(let i = 0; i < 4; i++) {
                    c.beginPath();
                    c.moveTo(x + T*2 - 19 + i*1.5, y + T*1.35 + i*12);
                    c.lineTo(x + T*2 - 13 + i*1.5, y + T*1.35 + i*12);
                    c.stroke();
                }
                
                // Basket of nuts near ladder
                c.fillStyle = '#A08050';
                c.beginPath();
                c.moveTo(x + 20, y + T*2 - 10);
                c.quadraticCurveTo(x + 25, y + T*2 - 18, x + 35, y + T*2 - 18);
                c.quadraticCurveTo(x + 40, y + T*2 - 10, x + 35, y + T*2 - 10);
                c.closePath();
                c.fill();
                // Nuts
                c.fillStyle = '#8B5A2B';
                c.beginPath();
                c.arc(x + 27, y + T*2 - 16, 3, 0, Math.PI*2);
                c.arc(x + 32, y + T*2 - 15, 2.5, 0, Math.PI*2);
                c.fill();
                
                // Label
                c.fillStyle = "#C4A060";
                c.font = "bold 8px sans-serif";
                c.textAlign = "center";
                c.fillText("NUTS STORAGE", cx, y + T*2 + 12);
                c.fillText("REED HOUSE", cx, y + T*2 + 21);
                c.font = "7px sans-serif";
                c.fillStyle = "#4CAF50";
                c.fillText(`+${Controller.formatNum(CFG.BUILDINGS.GRANARY.cap)} | 10% rot`, cx, y + T*2 + 30);
            },
            drawPalace(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.fillRect(x + 20, y + 30, T*2 - 40, T*2 - 35);
                
                c.fillStyle = "#FFD700";
                for(let i = 0; i < 5; i++) {
                    c.fillRect(x + 25 + i * 18, y + 30, 6, T*2 - 35);
                }
                
                c.fillStyle = "#DAA520";
                c.beginPath();
                c.moveTo(x + 15, y + 30);
                c.lineTo(x + T*2 - 15, y + 30);
                c.lineTo(cx, y + 10);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#FF6347";
                c.beginPath();
                c.arc(cx, y + 15, 5, 0, 6.28);
                c.fill();
                
                if(Math.random() > 0.7) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 10, 
                        30, 
                        "rgba(255, 215, 0, 0.8)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("PALACE", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.PALACE.cap} storage`, cx, y + T*2 + 27);
            },
            drawStoragePit(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T/2;
                let cy = y + T/2;

                // Base pit (common shape)
                c.fillStyle = '#5D4037';
                c.beginPath();
                c.ellipse(cx, cy + T*0.05, T*0.28, T*0.18, 0, 0, Math.PI*2);
                c.fill();
                c.fillStyle = '#3E2723';
                c.beginPath();
                c.ellipse(cx, cy + T*0.03, T*0.22, T*0.14, 0, 0, Math.PI*2);
                c.fill();

                // Resource-specific item inside pit
                if(b.t === 'FOOD_PIT') {
                    // Meat chunk icon
                    c.fillStyle = '#C62828';
                    c.beginPath();
                    c.arc(cx - T*0.06, cy + T*0.02, T*0.06, 0, Math.PI*2);
                    c.fill();
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.arc(cx - T*0.06, cy + T*0.02, T*0.02, 0, Math.PI*2);
                    c.fill();
                } else if(b.t === 'WOOD_PIT') {
                    // Small log
                    c.fillStyle = '#8D6E63';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.02, T*0.12, T*0.06, 0, 0, Math.PI*2);
                    c.fill();
                    c.strokeStyle = '#5D4037';
                    c.lineWidth = 1;
                    c.beginPath();
                    c.arc(cx + T*0.08, cy + T*0.02, T*0.015, 0, Math.PI*2);
                    c.stroke();
                } else if(b.t === 'STONE_PIT') {
                    // Rock chunk
                    c.fillStyle = '#9E9E9E';
                    c.beginPath();
                    c.moveTo(cx - T*0.1, cy);
                    c.lineTo(cx, cy - T*0.08);
                    c.lineTo(cx + T*0.08, cy + T*0.02);
                    c.lineTo(cx - T*0.02, cy + T*0.06);
                    c.closePath();
                    c.fill();
                } else if(b.t === 'METAL_PIT') {
                    // Gear shape (simplified)
                    c.fillStyle = '#616161';
                    c.beginPath();
                    c.arc(cx, cy, T*0.06, 0, Math.PI*2);
                    c.fill();
                    c.strokeStyle = '#424242';
                    c.lineWidth = 2;
                    for(let i=0;i<6;i++){
                        let ang = i * Math.PI/3;
                        c.beginPath();
                        c.moveTo(cx + Math.cos(ang)*T*0.06, cy + Math.sin(ang)*T*0.06);
                        c.lineTo(cx + Math.cos(ang)*T*0.09, cy + Math.sin(ang)*T*0.09);
                        c.stroke();
                    }
                }

                // Label (small)
                c.fillStyle = '#fff';
                c.font = 'bold 8px sans-serif';
                c.textAlign = 'center';
                let label = b.t === 'FOOD_PIT' ? 'FOOD' : b.t === 'WOOD_PIT' ? 'WOOD' : b.t === 'STONE_PIT' ? 'STONE' : 'METAL';
                c.fillText(label, cx, y + T - 6);
            },
            drawIcon(c,x,y,txt,color) { c.fillStyle=color; c.font="bold 24px sans-serif"; c.textAlign="center"; c.textBaseline="middle"; c.fillText(txt, x, y); },
            drawGrain(c,x,y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.fillStyle="#F9A825";
                // Use deterministic positions based on tile coordinates to prevent movement
                const tx = Math.floor(x / T);
                const ty = Math.floor(y / T);
                // Create pseudo-random but fixed positions using tile coords
                for(let i=0;i<4;i++) {
                    const seed = (tx * 7 + ty * 13 + i * 31) % 1000;
                    const px = x + (seed % T);
                    const py = y + ((seed * 17) % T);
                    c.fillRect(px, py, 3*scale, 3*scale);
                }
            },
            drawParticles(c) { 
                for (let i=this.particles.length-1; i>=0; i--) { 
                    let p=this.particles[i]; 
                    p.y-=1; 
                    p.l--; 
                    c.fillStyle=p.c; 
                    c.beginPath(); 
                    c.arc(p.x, p.y, 5, 0, 6.28); 
                    c.fill(); 
                    if(p.l<=0) {
                        if(p.active !== undefined) p.active = false; // Return to pool
                        this.particles.splice(i,1);
                    }
                } 
            }
        };

        // --- SOUND SYSTEM ---
        const SoundFX = {
            audioCtx: null,
            enabled: true,
            master: null,
            wetBus: null,
            convolver: null,
            _initialized: false,
            
            // Helper: create noise buffer
            _noiseSource(durationSec) {
                const ctx = this.audioCtx;
                const buffer = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * durationSec), ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;
                const src = ctx.createBufferSource();
                src.buffer = buffer;
                return src;
            },
            
            // Helper: create impulse response for reverb
            _createImpulse(seconds, decay) {
                const ctx = this.audioCtx;
                const length = Math.floor(ctx.sampleRate * seconds);
                const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
                for(let c=0;c<2;c++){
                    const ch = impulse.getChannelData(c);
                    for(let i=0;i<length;i++) {
                        ch[i] = (Math.random()*2 - 1) * Math.pow(1 - i/length, decay);
                    }
                }
                return impulse;
            },
            
            // Helper: send to reverb
            _sendToReverb(node, wet=0.15) {
                if(!this.convolver) return;
                const send = this.audioCtx.createGain();
                send.gain.value = wet;
                node.connect(send);
                send.connect(this.convolver);
            },
            
            init() {
                if(this._initialized) return;
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    // Master routing
                    this.master = this.audioCtx.createGain();
                    this.master.gain.value = 0.9;
                    this.master.connect(this.audioCtx.destination);

                    // Simple small-room reverb (now helpers are defined)
                    this.wetBus = this.audioCtx.createGain();
                    this.wetBus.gain.value = 0.22;
                    this.convolver = this.audioCtx.createConvolver();
                    this.convolver.buffer = this._createImpulse(0.18, 1.8);
                    this.wetBus.connect(this.audioCtx.destination);
                    this.convolver.connect(this.wetBus);
                    this._initialized = true;
                    console.log('[SoundFX] Initialized successfully');
                } catch(e) {
                    console.log('[SoundFX] Audio not supported:', e);
                    this.enabled = false;
                }
            },
            
            // Resume audio context (needed for browsers that suspend it)
            resume() {
                if(this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
            },
            
            // Realistic layered collection sounds (sample-free synthesis)
            playCollect(type) {
                console.log('[SoundFX] playCollect called with type:', type, 'enabled:', this.enabled, 'audioCtx:', !!this.audioCtx);
                if(!this.enabled || !this.audioCtx) return;
                this.resume();

                const ctx = this.audioCtx;
                const now = ctx.currentTime;

                const rnd = (min, max) => min + Math.random()*(max-min);
                
                if(type === 'food') {
                    // FOOD: Juicy berry squish + stem snap + satisfied grunt
                    
                    // 1. Wet squish (low filtered noise burst)
                    const squish = this._noiseSource(0.15);
                    const squishLP = ctx.createBiquadFilter();
                    squishLP.type = 'lowpass'; squishLP.frequency.value = rnd(400, 600);
                    const squishG = ctx.createGain();
                    squishG.gain.setValueAtTime(0, now);
                    squishG.gain.linearRampToValueAtTime(0.5, now + 0.02);
                    squishG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    squish.connect(squishLP); squishLP.connect(squishG); squishG.connect(this.master);
                    squish.start(now); squish.stop(now + 0.15);
                    
                    // 2. Stem snap (high click)
                    const snap = ctx.createOscillator(); snap.type = 'square';
                    snap.frequency.setValueAtTime(rnd(1800, 2400), now);
                    snap.frequency.exponentialRampToValueAtTime(800, now + 0.015);
                    const snapG = ctx.createGain();
                    snapG.gain.setValueAtTime(0.3, now);
                    snapG.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
                    snap.connect(snapG); snapG.connect(this.master);
                    snap.start(now); snap.stop(now + 0.03);
                    
                    // 3. Satisfied caveman grunt (low formant)
                    const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                    grunt.frequency.setValueAtTime(rnd(95, 115), now + 0.08);
                    grunt.frequency.linearRampToValueAtTime(rnd(80, 95), now + 0.22);
                    const gruntLP = ctx.createBiquadFilter(); gruntLP.type = 'lowpass'; gruntLP.frequency.value = 350;
                    const gruntG = ctx.createGain();
                    gruntG.gain.setValueAtTime(0, now + 0.08);
                    gruntG.gain.linearRampToValueAtTime(0.18, now + 0.1);
                    gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    grunt.connect(gruntLP); gruntLP.connect(gruntG); gruntG.connect(this.master);
                    this._sendToReverb(gruntG, 0.15);
                    grunt.start(now + 0.08); grunt.stop(now + 0.28);
                    return;
                }

                if(type === 'wood') {
                    // WOOD: Axe impact + wood fiber crack + resonant body
                    
                    // 1. Sharp axe impact (broadband attack)
                    const impact = this._noiseSource(0.04);
                    const impactBP = ctx.createBiquadFilter(); impactBP.type = 'bandpass'; impactBP.frequency.value = rnd(1200, 1800); impactBP.Q.value = 1.5;
                    const impactG = ctx.createGain();
                    impactG.gain.setValueAtTime(0.45, now);
                    impactG.gain.exponentialRampToValueAtTime(0.001, now + 0.035);
                    impact.connect(impactBP); impactBP.connect(impactG); impactG.connect(this.master);
                    impact.start(now); impact.stop(now + 0.04);
                    
                    // 2. Wood fiber cracking (multiple short bursts)
                    for(let i = 0; i < 3; i++) {
                        const crack = this._noiseSource(0.025);
                        const crackHP = ctx.createBiquadFilter(); crackHP.type = 'highpass'; crackHP.frequency.value = rnd(2000, 3500);
                        const crackG = ctx.createGain();
                        const t = now + 0.02 + i * 0.015;
                        crackG.gain.setValueAtTime(rnd(0.15, 0.25), t);
                        crackG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                        crack.connect(crackHP); crackHP.connect(crackG); crackG.connect(this.master);
                        crack.start(t); crack.stop(t + 0.03);
                    }
                    
                    // 3. Resonant wood body thunk (low frequency)
                    const body = ctx.createOscillator(); body.type = 'sine';
                    body.frequency.setValueAtTime(rnd(85, 110), now);
                    body.frequency.exponentialRampToValueAtTime(rnd(55, 70), now + 0.15);
                    const bodyG = ctx.createGain();
                    bodyG.gain.setValueAtTime(0, now);
                    bodyG.gain.linearRampToValueAtTime(0.35, now + 0.008);
                    bodyG.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    body.connect(bodyG); bodyG.connect(this.master);
                    this._sendToReverb(bodyG, 0.08);
                    body.start(now); body.stop(now + 0.2);
                    return;
                }

                if(type === 'metal') {
                    // METAL: Realistic ore chunk clinking with metallic ring
                    
                    // 1. Sharp metallic impact
                    const strike = this._noiseSource(0.02);
                    const strikeHP = ctx.createBiquadFilter(); strikeHP.type = 'highpass'; strikeHP.frequency.value = 2500;
                    const strikeG = ctx.createGain();
                    strikeG.gain.setValueAtTime(0.3, now);
                    strikeG.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                    strike.connect(strikeHP); strikeHP.connect(strikeG); strikeG.connect(this.master);
                    strike.start(now); strike.stop(now + 0.025);
                    
                    // 2. Metallic ring (inharmonic partials)
                    const partials = [1, 2.4, 4.5, 6.7]; // Inharmonic like real metal
                    const baseFreq = rnd(380, 450);
                    partials.forEach((ratio, i) => {
                        const o = ctx.createOscillator(); o.type = 'sine';
                        const f = baseFreq * ratio;
                        o.frequency.setValueAtTime(f, now);
                        // Slight frequency wobble for realism
                        o.frequency.setValueAtTime(f * 1.002, now + 0.1);
                        const g = ctx.createGain();
                        const vol = 0.18 / (i + 1);
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(vol, now + 0.003);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.25 - i * 0.03);
                        o.connect(g); g.connect(this.master);
                        if(i === 0) this._sendToReverb(g, 0.2);
                        o.start(now); o.stop(now + 0.3);
                    });
                    
                    // 3. Low thud (stone/ore mass)
                    const thud = ctx.createOscillator(); thud.type = 'sine';
                    thud.frequency.setValueAtTime(rnd(100, 130), now);
                    thud.frequency.exponentialRampToValueAtTime(60, now + 0.1);
                    const thudG = ctx.createGain();
                    thudG.gain.setValueAtTime(0, now);
                    thudG.gain.linearRampToValueAtTime(0.2, now + 0.005);
                    thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    thud.connect(thudG); thudG.connect(this.master);
                    thud.start(now); thud.stop(now + 0.15);
                    return;
                }

                if(type === 'stone') {
                    // STONE: Rocks clacking together + grinding
                    
                    // 1. Primary clack (two stones hitting)
                    const clack1 = this._noiseSource(0.03);
                    const clack1BP = ctx.createBiquadFilter(); clack1BP.type = 'bandpass'; clack1BP.frequency.value = rnd(800, 1100); clack1BP.Q.value = 2;
                    const clack1G = ctx.createGain();
                    clack1G.gain.setValueAtTime(0.4, now);
                    clack1G.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                    clack1.connect(clack1BP); clack1BP.connect(clack1G); clack1G.connect(this.master);
                    clack1.start(now); clack1.stop(now + 0.04);
                    
                    // 2. Secondary bounce clack
                    const clack2 = this._noiseSource(0.02);
                    const clack2BP = ctx.createBiquadFilter(); clack2BP.type = 'bandpass'; clack2BP.frequency.value = rnd(700, 900); clack2BP.Q.value = 2.5;
                    const clack2G = ctx.createGain();
                    clack2G.gain.setValueAtTime(0.2, now + 0.06);
                    clack2G.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
                    clack2.connect(clack2BP); clack2BP.connect(clack2G); clack2G.connect(this.master);
                    clack2.start(now + 0.06); clack2.stop(now + 0.1);
                    
                    // 3. Low frequency mass thump
                    const thump = ctx.createOscillator(); thump.type = 'sine';
                    thump.frequency.setValueAtTime(rnd(70, 95), now);
                    thump.frequency.exponentialRampToValueAtTime(45, now + 0.08);
                    const thumpG = ctx.createGain();
                    thumpG.gain.setValueAtTime(0, now);
                    thumpG.gain.linearRampToValueAtTime(0.25, now + 0.005);
                    thumpG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    thump.connect(thumpG); thumpG.connect(this.master);
                    this._sendToReverb(thumpG, 0.06);
                    thump.start(now); thump.stop(now + 0.12);
                    return;
                }

                if(type === 'population') {
                    // POPULATION: Caveman greeting call + response
                    
                    // 1. First voice "OOH" (formant)
                    const voice1 = ctx.createOscillator(); voice1.type = 'sawtooth';
                    voice1.frequency.setValueAtTime(rnd(110, 130), now);
                    voice1.frequency.linearRampToValueAtTime(rnd(140, 160), now + 0.12);
                    const v1Form = ctx.createBiquadFilter(); v1Form.type = 'bandpass'; v1Form.frequency.value = rnd(400, 500); v1Form.Q.value = 4;
                    const v1G = ctx.createGain();
                    v1G.gain.setValueAtTime(0, now);
                    v1G.gain.linearRampToValueAtTime(0.2, now + 0.02);
                    v1G.gain.linearRampToValueAtTime(0.15, now + 0.1);
                    v1G.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    voice1.connect(v1Form); v1Form.connect(v1G); v1G.connect(this.master);
                    this._sendToReverb(v1G, 0.12);
                    voice1.start(now); voice1.stop(now + 0.2);
                    
                    // 2. Response voice "AAH" (different formant)
                    const voice2 = ctx.createOscillator(); voice2.type = 'sawtooth';
                    voice2.frequency.setValueAtTime(rnd(130, 150), now + 0.12);
                    voice2.frequency.linearRampToValueAtTime(rnd(100, 120), now + 0.28);
                    const v2Form = ctx.createBiquadFilter(); v2Form.type = 'bandpass'; v2Form.frequency.value = rnd(700, 900); v2Form.Q.value = 3;
                    const v2G = ctx.createGain();
                    v2G.gain.setValueAtTime(0, now + 0.12);
                    v2G.gain.linearRampToValueAtTime(0.18, now + 0.14);
                    v2G.gain.linearRampToValueAtTime(0.12, now + 0.24);
                    v2G.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    voice2.connect(v2Form); v2Form.connect(v2G); v2G.connect(this.master);
                    this._sendToReverb(v2G, 0.15);
                    voice2.start(now + 0.12); voice2.stop(now + 0.32);
                    return;
                }
            },
            
            // Negative sound for damage/poison - caveman pain grunt
            playHurt() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Sharp inhale gasp (breath noise)
                const gasp = this._noiseSource(0.12);
                const gaspBP = ctx.createBiquadFilter(); gaspBP.type = 'bandpass'; gaspBP.frequency.value = rnd(800, 1200); gaspBP.Q.value = 2;
                const gaspG = ctx.createGain();
                gaspG.gain.setValueAtTime(0, now);
                gaspG.gain.linearRampToValueAtTime(0.25, now + 0.02);
                gaspG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                gasp.connect(gaspBP); gaspBP.connect(gaspG); gaspG.connect(this.master);
                gasp.start(now); gasp.stop(now + 0.12);
                
                // 2. Pain grunt "UGHH" (falling pitch formant)
                const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                grunt.frequency.setValueAtTime(rnd(180, 220), now + 0.05);
                grunt.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.35);
                const gruntForm = ctx.createBiquadFilter(); gruntForm.type = 'bandpass'; gruntForm.frequency.value = rnd(500, 700); gruntForm.Q.value = 3;
                const gruntG = ctx.createGain();
                gruntG.gain.setValueAtTime(0, now + 0.05);
                gruntG.gain.linearRampToValueAtTime(0.3, now + 0.08);
                gruntG.gain.linearRampToValueAtTime(0.2, now + 0.2);
                gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                grunt.connect(gruntForm); gruntForm.connect(gruntG); gruntG.connect(this.master);
                this._sendToReverb(gruntG, 0.1);
                grunt.start(now + 0.05); grunt.stop(now + 0.45);
                
                // 3. Impact thud (body hit)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(70, 90), now);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now);
                thudG.gain.linearRampToValueAtTime(0.25, now + 0.01);
                thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                thud.connect(thudG); thudG.connect(this.master);
                thud.start(now); thud.stop(now + 0.18);
            },
            
            // Lucky find - exciting discovery sound
            playLucky() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Bright discovery shimmer (ascending harmonics)
                [0, 0.06, 0.12].forEach((delay, i) => {
                    const o = ctx.createOscillator(); o.type = 'sine';
                    const f = 600 + i * 280;
                    o.frequency.setValueAtTime(f, now + delay);
                    o.frequency.exponentialRampToValueAtTime(f * 1.1, now + delay + 0.1);
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.18 - i * 0.03, now + delay + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.2);
                    o.connect(g); g.connect(this.master);
                    this._sendToReverb(g, 0.25);
                    o.start(now + delay); o.stop(now + delay + 0.22);
                });
                
                // 2. Excited caveman "OOH!"
                const ooh = ctx.createOscillator(); ooh.type = 'sawtooth';
                ooh.frequency.setValueAtTime(rnd(150, 180), now + 0.1);
                ooh.frequency.linearRampToValueAtTime(rnd(200, 240), now + 0.2);
                const oohForm = ctx.createBiquadFilter(); oohForm.type = 'bandpass'; oohForm.frequency.value = rnd(500, 600); oohForm.Q.value = 4;
                const oohG = ctx.createGain();
                oohG.gain.setValueAtTime(0, now + 0.1);
                oohG.gain.linearRampToValueAtTime(0.15, now + 0.12);
                oohG.gain.exponentialRampToValueAtTime(0.001, now + 0.28);
                ooh.connect(oohForm); oohForm.connect(oohG); oohG.connect(this.master);
                this._sendToReverb(oohG, 0.15);
                ooh.start(now + 0.1); ooh.stop(now + 0.3);
            },
            
            // Tree falling thud - realistic timber crash
            playThud() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                
                const ctx = this.audioCtx;
                const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Wood creaking before fall
                const creak = ctx.createOscillator(); creak.type = 'sawtooth';
                creak.frequency.setValueAtTime(rnd(180, 220), now);
                creak.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.15);
                const creakBP = ctx.createBiquadFilter(); creakBP.type = 'bandpass'; creakBP.frequency.value = rnd(300, 500); creakBP.Q.value = 5;
                const creakG = ctx.createGain();
                creakG.gain.setValueAtTime(0, now);
                creakG.gain.linearRampToValueAtTime(0.2, now + 0.02);
                creakG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                creak.connect(creakBP); creakBP.connect(creakG); creakG.connect(this.master);
                creak.start(now); creak.stop(now + 0.18);
                
                // 2. Heavy ground impact (deep bass thud)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(55, 70), now + 0.1);
                thud.frequency.exponentialRampToValueAtTime(25, now + 0.4);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now + 0.1);
                thudG.gain.linearRampToValueAtTime(0.8, now + 0.12);
                thudG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                thud.connect(thudG); thudG.connect(this.master);
                this._sendToReverb(thudG, 0.15);
                thud.start(now + 0.1); thud.stop(now + 0.55);
                
                // 3. Secondary bounce
                const bounce = ctx.createOscillator(); bounce.type = 'sine';
                bounce.frequency.setValueAtTime(rnd(40, 50), now + 0.25);
                bounce.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                const bounceG = ctx.createGain();
                bounceG.gain.setValueAtTime(0, now + 0.25);
                bounceG.gain.linearRampToValueAtTime(0.4, now + 0.26);
                bounceG.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                bounce.connect(bounceG); bounceG.connect(this.master);
                bounce.start(now + 0.25); bounce.stop(now + 0.5);
                
                // 4. Branch/leaf rustling (noise burst)
                const rustle = this._noiseSource(0.3);
                const rustleBP = ctx.createBiquadFilter(); rustleBP.type = 'bandpass'; rustleBP.frequency.value = rnd(2000, 3500); rustleBP.Q.value = 1;
                const rustleG = ctx.createGain();
                rustleG.gain.setValueAtTime(0, now + 0.08);
                rustleG.gain.linearRampToValueAtTime(0.25, now + 0.12);
                rustleG.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                rustle.connect(rustleBP); rustleBP.connect(rustleG); rustleG.connect(this.master);
                this._sendToReverb(rustleG, 0.1);
                rustle.start(now + 0.08); rustle.stop(now + 0.38);
                
                // 5. Splintering wood
                for(let i = 0; i < 4; i++) {
                    const splinter = this._noiseSource(0.02);
                    const splinterHP = ctx.createBiquadFilter(); splinterHP.type = 'highpass'; splinterHP.frequency.value = rnd(3000, 5000);
                    const splinterG = ctx.createGain();
                    const t = now + 0.1 + i * 0.03;
                    splinterG.gain.setValueAtTime(rnd(0.1, 0.2), t);
                    splinterG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                    splinter.connect(splinterHP); splinterHP.connect(splinterG); splinterG.connect(this.master);
                    splinter.start(t); splinter.stop(t + 0.025);
                }
            }
        };
        
        // Initialize sound on first user interaction
        document.addEventListener('click', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });
        document.addEventListener('keydown', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });

        // --- 4. GAME LOGIC ---
        const Game = {
            tiles:[], blds:[], res:0, food:0, water:100, pop:0, year:0, age:0, housingCap:0, waterCap:0, ordinance:false, ordEnd:0, vm:'NORMAL',
            player: null, // {x, y, health, direction}
            nomadsFound: 0,
            wolves: [], // [{x, y, hits}]
            simcityMode: false,
            pathQueue: [],
            lastMoveTime: 0, // Timer for smooth pathfinding movement
            aiEnabled: false, // AI autoplay toggle
            aiState: 'EXPLORE', // 'EXPLORE', 'GATHER', 'SETTLE', 'BUILD'
            aiTarget: null, // Current AI target position or entity
            aiLastAction: 0, // Timestamp of last AI action
            gameLog: [], // Event log for game history
            gold: 0, // Rare currency - earned by trading 5000 metal for 1 gold
            hasClanChief: false, // Tracks if Clan Chief's Hut is built (unlocks L4-L6)
            hasDock: false, // Tracks if Dock is built (unlocks L7+)
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // LORE SYSTEM - Story mode with first-time event popups
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            loreEnabled: false, // Toggle for story mode
            loreSeen: {}, // Track which lore events have been seen
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GAME STATE & INVENTORY SYSTEM
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // gameState: 'WANDER' (Epoch 0 exploration) or 'CITY' (settled, building)
            //
            // MAIN INVENTORY: Affected by nomad count
            //   - Base capacity: 150
            //   - Bonus: +100 per friendly nomad recruited
            //   - Holds: Food, Wood, Metal, Stone
            //   - Overflow: Partial pickups allowed
            //
            // POCKET INVENTORY: Separate, immutable storage
            //   - Capacity: 1000 max (anti-cheat cap)
            //   - Holds: Metal, Stone only
            //   - Source: Passive walking collection (0.01% every 5 steps)
            //   - Not affected by nomad bonuses
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            gameState: 'WANDER', // 'WANDER' or 'CITY'
            gatheringMultiplier: 1.0, // Resource gathering rate multiplier (scales with initial population)
            inventory: {
                capacity: 150,      // Base 150, +100 per nomad
                food: 0,
                wood: 0,
                metal: 0.0,        // Track as float for 0.2 increments
                stone: 0.0         // Track as float
            },
            // POCKET INVENTORY: Separate storage for passive finds (immutable, max 1000)
            // Triggered every 5 steps with 0.01% chance to find 1-5 metal OR stone
            pocket: {
                metal: 0,
                stone: 0,
                capacity: 1000     // Max 1000 total (anti-cheat cap)
            },
            stepCounter: 0,        // Track steps for passive collection (triggers at 5)
            thirstCounter: 0,      // Steps since last drink (WANDER mode thirst mechanic)
            thirst: 100,           // Current thirst level (0-100, dies at 0)
            siteTraits: [],
            totalFoodCollected: 0, // Track total food gathered for stats        // Set during settlement (e.g., ['Arid', 'Mineral Rich'])
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // WORKFORCE TRACKING - How residents are assigned
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            workforce: {
                total: 0,           // Total available workers (from residential pop)
                wellWorkers: 0,     // Assigned to wells
                roadWorkers: 0,     // Assigned to road maintenance  
                comWorkers: 0,      // Assigned to commercial buildings
                gatherers: 0,       // Remaining workers (gather/hunt)
                // Calculated needs
                wellsNeeded: 0,     // Workers needed for all wells
                roadsNeeded: 0,     // Workers needed for all roads
                comNeeded: 0,       // Workers needed for all commercial
                shortage: 0         // Worker shortage (negative = surplus)
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // NEEDS TRACKING - What people require to be happy/productive
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            needs: {
                housing: { have: 0, need: 0, satisfied: 1.0 },
                water: { have: 0, need: 0, satisfied: 1.0 },
                food: { have: 0, need: 0, satisfied: 1.0 },
                jobs: { have: 0, need: 0, satisfied: 1.0 },
                paths: { have: 0, need: 0, satisfied: 1.0 },
                overall: 1.0  // Combined satisfaction (0.0 - 1.0)
            },
            
            // Performance optimizations
            spatialGrid: null, // Fast building lookup grid
            particlePool: [], // Reusable particle objects
            terrainCache: null, // Offscreen canvas for terrain
            dirtyRegions: new Set(), // Track changed areas
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GEOLOGICAL WATER CYCLE - Slow rise/fall over centuries
            // Based on 3 million years of real glacial cycles
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            geology: {
                currentSeaLevel: 3,         // Current water level (0-10)
                periodIndex: 0,             // Current geological period
                centuriesInPeriod: 0,       // Years spent in current period
                lastUpdateYear: 0,          // Last year water was checked
                tilesFlooded: 0,            // Count of tiles lost to rising water
                tilesDrained: 0,            // Count of tiles gained from receding water
                currentPeriodName: "Warm Interglacial"
            },

            init(seed) {
                Noise.init(seed); this.tiles = []; this.blds = []; this.res=0; this.food=0; this.year=0; this.pop=4; this.age=0;
                this.peakPop = 4;  // Track highest population reached for game over screen
                this.gameOver = false; // Reset game over flag for new game
                PROGRESSION.reset();
                
                // Initialize game state & inventory (see balance values above)
                this.gameState = 'WANDER';
                this.inventory = {
                    capacity: 450,  // 150 base + 300 (3 extra people √ó 100)
                    food: 300,   // Starting supplies for 4 people
                    wood: 300,   // Starting supplies for 4 people
                    metal: 0.0,
                    stone: 0.0
                };
                // Initialize pocket inventory (separate, immutable storage for passive finds)
                this.pocket = {
                    metal: 0,
                    stone: 0,
                    capacity: 1000  // Max to prevent exploit
                };
                this.stepCounter = 0;  // Resets every 5 steps (passive collection)
                this.foodStepCounter = 0;  // Resets every 15 steps (food cost)
                this.thirstCounter = 0;   // Steps since last drink
                this.thirst = 100;        // Start fully hydrated
                this.wanderWells = [];    // Wells built in WANDER mode (Level 0)
                this.siteTraits = [];
                this.nomadsFound = 0;
                this.animals = [];
                this.simcityMode = false;
                this.pathQueue = [];
                this.settlementPos = null;
                
                // Initialize workforce tracking
                this.workforce = {
                    total: 0,
                    wellWorkers: 0,
                    roadWorkers: 0,
                    comWorkers: 0,
                    gatherers: 0,
                    wellsNeeded: 0,
                    roadsNeeded: 0,
                    comNeeded: 0,
                    shortage: 0
                };
                this.roadTileCount = 0; // Track road tiles for workforce calculation
                
                // NEW: Resource tracking for Epoch 1+
                this.wood = 0;
                this.metal = 0;
                this.stone = 0;
                
                // Reset geological state for new game
                this.geology = {
                    currentSeaLevel: CFG.ELEVATION_SYSTEM.SEA_LEVEL_BASE,
                    periodIndex: 0,
                    centuriesInPeriod: 0,
                    lastUpdateYear: 0,
                    tilesFlooded: 0,
                    tilesDrained: 0,
                    currentPeriodName: CFG.ELEVATION_SYSTEM.GEOLOGICAL_PERIODS[0].name
                };
                
                // Initialize performance structures
                this.initSpatialGrid();
                this.initParticlePool();
                this.dirtyRegions.clear();
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // GUARANTEED HIGH GROUND PATCHES (8x8 areas that will NEVER flood)
                // Scattered across map for realistic terrain with safe building zones
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let highGroundPatches = [];
                const PATCH_SIZE = 8;
                const NUM_PATCHES = Math.floor((CFG.W * CFG.H) / 2500); // ~1 patch per 50x50 area
                for(let i = 0; i < NUM_PATCHES; i++) {
                    // Random positions but avoid edges
                    let px = Math.floor(Math.random() * (CFG.W - PATCH_SIZE - 10)) + 5;
                    let py = Math.floor(Math.random() * (CFG.H - PATCH_SIZE - 10)) + 5;
                    highGroundPatches.push({x: px, y: py});
                }
                
                // Helper to check if tile is in a high ground patch
                const isInHighGroundPatch = (x, y) => {
                    for(let patch of highGroundPatches) {
                        if(x >= patch.x && x < patch.x + PATCH_SIZE && 
                           y >= patch.y && y < patch.y + PATCH_SIZE) {
                            return true;
                        }
                    }
                    return false;
                };
                
                for (let x=0; x<CFG.W; x++) {
                    this.tiles[x] = [];
                    for (let y=0; y<CFG.H; y++) {
                        // ENHANCED TERRAIN GENERATION WITH OCEANS & LAKES & IMPASSABLE MOUNTAINS
                        let h = Noise.fbm(x*0.02, y*0.02); 
                        h = (h / 1.8); // Normalize 0..1
                        
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // ELEVATION SYSTEM: Convert height to 0-10 scale with DECIMALS
                        // MORE HIGH GROUND: Bias terrain upward for realistic inhabited landscapes
                        // 0 = Deepest ocean trench
                        // 3 = Sea level (starting) - LESS of the map is below this now
                        // 5 = Hills (more common now)
                        // 8 = Mountains
                        // 10 = Highest peaks
                        // FRACTIONAL elevation means tiles flood ONE AT A TIME as sea rises!
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // UPWARD BIAS: Add +2.5 to base elevation so MORE land is at higher elevations
                        // Changed from +1.5 to +2.5 for more highlands and hills
                        let elevation = Math.round((h * 100 + 25)) / 10; // 2.5 to 12.5 -> clamped to 0-10
                        elevation = Math.min(10, Math.max(0, elevation)); // Clamp 0-10
                        
                        // GUARANTEED HIGH GROUND: Force high elevation in safe patches
                        if(isInHighGroundPatch(x, y)) {
                            // These tiles are ALWAYS safe - elevation 7-8 (never floods even at max sea level ~6)
                            elevation = 7 + Math.random() * 1.5; // 7.0 to 8.5
                        }
                        
                        // Ocean noise - creates large ocean bodies (REDUCED frequency for less water)
                        let oceanNoise = Noise.fbm(x*0.008, y*0.008); // Lower frequency = larger but fewer oceans
                        oceanNoise = (oceanNoise / 1.8);
                        
                        // Lake noise - creates inland lakes (MUCH REDUCED)
                        let lakeNoise = Noise.fbm(x*0.08+500, y*0.08+500);
                        lakeNoise = (lakeNoise / 1.8);
                        
                        // Mountain noise - creates impassable stone peaks
                        let mountainNoise = Noise.fbm(x*0.015+1000, y*0.015+1000);
                        mountainNoise = (mountainNoise / 1.8);
                        
                        // River noise
                        let r = Noise.fbm(x*0.05+100, y*0.05+100); 
                        r = (r/1.8);
                        let isRiver = Math.abs(r - 0.5) < 0.015; // Narrower rivers

                        let t = 'GRASS'; // Default
                        
                        // Get current sea level from geological system
                        let seaLevel = CFG.ELEVATION_SYSTEM.SEA_LEVEL_BASE;
                        
                        // IMPASSABLE STONE MOUNTAINS (highest elevation) - slightly more common
                        if (mountainNoise > 0.68 && h > 0.55) {
                            t = 'STONE';
                            elevation = 9 + Math.floor(Math.random() * 2); // 9-10
                        }
                        // ELEVATION-BASED WATER: Tiles below sea level are water
                        // With upward bias, MUCH LESS water is generated
                        else if (elevation < seaLevel - 1.5) {
                            t = 'DEEP';
                            elevation = Math.max(0, elevation);
                        } else if (elevation < seaLevel - 0.5) {
                            t = 'WATER';
                        }
                        // Generate inland lakes (HEAVILY REDUCED - barely any lakes)
                        // Changed from 0.08 to 0.03 for even fewer lakes
                        else if (lakeNoise < 0.03 && elevation >= seaLevel && elevation < seaLevel + 0.5) {
                            t = 'WATER';
                            elevation = seaLevel - 0.5; // Lakes are at water level
                        }
                        // Standard elevation-based terrain (MORE LAND at higher elevations)
                        else if (elevation <= seaLevel) {
                            t = 'SAND';  // Beaches at sea level
                        } else if (elevation < 5.5) {
                            t = 'GRASS'; // Lowland grass (3-5.5)
                        } else if (elevation < 7) {
                            t = 'GRASS'; // Highland grass (5.5-7) - more buildable high ground
                        } else if (elevation < 8) {
                            t = 'FOREST'; // Hills with forest (7-8)
                        } else if (elevation < 9.5) {
                            t = 'ROCK'; // Mountain slopes (8-9.5)
                        } else {
                            t = 'SNOW';
                        }

                        // Carve Rivers (avoid deep ocean, high ground patches)
                        if (isRiver && t !== 'DEEP' && t !== 'WATER' && !isInHighGroundPatch(x, y)) {
                            t = 'RIVER';
                            elevation = seaLevel; // Rivers at sea level
                        }

                        let tree = (t=='GRASS'||t=='FOREST'||t=='SNOW') && Math.random()>0.8;
                        
                        // DEEP TILE SYSTEM: Rich data model with ELEVATION
                        let tileData = { 
                            type:t, 
                            elevation: elevation,   // NEW: 0-10 elevation
                            originalType: t,        // NEW: Original terrain (for water cycle)
                            road:false, 
                            tree:tree, 
                            pol:0, 
                            bld:null, 
                            explored:false,
                            zone: null,     // 'R', 'C', 'I', or null
                            building: null, // { level, growth, desirability }
                            
                            // Resource deposits (for STONE tiles)
                            resource: null, // { type, amount, metal_yield }
                            
                            // Stone deposits (Mario-style rocks with metal)
                            stoneDeposit: null, // { metal: number }
                            
                            // Entity data (complex objects replace simple booleans)
                            entity: null    // { type, data... }
                        };
                        
                        // STONE tiles contain massive resources
                        if(t === 'STONE') {
                            tileData.resource = {
                                type: 'STONE',
                                amount: 1000000 + Math.floor(Math.random() * 500000), // 1M-1.5M stone
                                metal_yield: 0.2 // Hidden metal bonus when worked
                            };
                        }
                        
                        this.tiles[x][y] = tileData;
                    }
                }
                
                // Spawn player in a safe location
                this.spawnPlayer();
                
                // Spawn stone deposits (Mario-style rocks with metal)
                this.spawnStoneDeposits(CFG.STONE_DEPOSITS.SPAWN_COUNT);
                
                // Spawn berries randomly on land tiles
                this.spawnBerries(CFG.BERRIES.SPAWN_COUNT);
                
                // Spawn wolves (separate from other animals)
                // Wolves removed from game
                
                // Spawn other animals (deer, bison, mammoth)
                this.spawnAnimals(CFG.ANIMALS.SPAWN_COUNT);
                
                // Spawn multiple nomads
                for(let i=0; i<CFG.NOMAD.SPAWN_COUNT; i++) {
                    this.spawnNomad();
                }
                
                // HARDCORE MODE: Randomize dangerous berries and hostile nomads
                for(let x=0; x<CFG.W; x++) {
                    for(let y=0; y<CFG.H; y++) {
                        let t = this.tiles[x][y];
                        
                        // 10% Chance of Poison Berry
                        if(t.berry) {
                            t.isPoison = (Math.random() < 0.1);
                        }
                        
                        // 10% Chance of Hostile Nomad carrying 1-10 food
                        if(t.nomad) {
                            t.isHostile = (Math.random() < 0.1);
                            t.carriedFood = Math.floor(Math.random() * 10) + 1;
                        }
                    }
                }
                
                Controller.updateUI();
            },
            
            // PERFORMANCE: Spatial grid for fast building/zone lookups
            initSpatialGrid() {
                const gridSize = Math.ceil(CFG.W / CFG.PERF.SPATIAL_GRID_SIZE);
                this.spatialGrid = [];
                for(let i = 0; i < gridSize; i++) {
                    this.spatialGrid[i] = [];
                    for(let j = 0; j < gridSize; j++) {
                        this.spatialGrid[i][j] = [];
                    }
                }
            },
            
            updateSpatialGrid(x, y, obj, remove = false) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                if(gx < 0 || gy < 0 || gx >= this.spatialGrid.length || gy >= this.spatialGrid[0].length) return;
                
                if(remove) {
                    const idx = this.spatialGrid[gx][gy].indexOf(obj);
                    if(idx !== -1) this.spatialGrid[gx][gy].splice(idx, 1);
                } else {
                    this.spatialGrid[gx][gy].push(obj);
                }
            },
            
            getNearbyObjects(x, y, radius = 1) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                const gridRadius = Math.ceil(radius / CFG.PERF.SPATIAL_GRID_SIZE);
                const nearby = [];
                
                for(let dx = -gridRadius; dx <= gridRadius; dx++) {
                    for(let dy = -gridRadius; dy <= gridRadius; dy++) {
                        const gxi = gx + dx;
                        const gyi = gy + dy;
                        if(gxi >= 0 && gyi >= 0 && gxi < this.spatialGrid.length && gyi < this.spatialGrid[0].length) {
                            nearby.push(...this.spatialGrid[gxi][gyi]);
                        }
                    }
                }
                return nearby;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // RCI DEMAND CALCULATION (SimCity-style interdependent zones)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // R demand: People want to live where there are jobs (C+I)
            // C demand: Commerce needs customers (R) AND goods to sell (I)
            // I demand: Industry needs workers (R) AND buyers for goods (C)
            // Returns: {r: 0-100, c: 0-100, i: 0-100} - higher = more needed
            calculateRCIDemand() {
                let resCount = this.zoneCount || 0;
                let comCount = this.blds ? this.blds.filter(b => b.t === 'COM').length : 0;
                let indCount = this.blds ? this.blds.filter(b => b.t === 'IND').length : 0;
                let pop = this.pop || 0;
                let housingCap = this.housingCap || 0;
                
                let totalZones = resCount + comCount + indCount;
                
                // Jobs come from Commercial (10 each) and Industrial (15 each)
                let jobCapacity = (comCount * 10) + (indCount * 15);
                let unemployed = Math.max(0, pop - jobCapacity);
                let housingNeed = housingCap > 0 ? (housingCap - pop) / housingCap : 0;
                
                // === RESIDENTIAL DEMAND ===
                // High when: jobs available but housing full, or C+I exist but R doesn't
                let rDemand = 0;
                if(totalZones === 0) {
                    rDemand = 100; // Nothing built - need residential first!
                } else if(housingNeed < 0.2 && jobCapacity > pop * 0.5) {
                    rDemand = 80; // Housing nearly full but jobs available
                } else if(comCount + indCount > resCount * 0.5) {
                    rDemand = 60; // More industry than people to work it
                } else if(pop < housingCap * 0.5) {
                    rDemand = 40; // Room to grow
                } else {
                    rDemand = Math.max(10, 50 - (resCount / Math.max(1, comCount + indCount)) * 10);
                }
                
                // === COMMERCIAL DEMAND ===
                // Needs BOTH residential (customers) AND industrial (goods to sell)
                let customersPerCom = resCount > 0 ? comCount / resCount : 0;
                let goodsSupply = indCount > 0 ? comCount / indCount : 0;
                
                let cDemand = 0;
                if(resCount === 0) {
                    cDemand = 10; // No customers yet
                } else if(comCount === 0 && resCount > 0) {
                    cDemand = 90; // People but no shops!
                } else if(customersPerCom < 0.3 && indCount > 0) {
                    cDemand = 70; // Not enough shops for the people
                } else if(goodsSupply > 2) {
                    cDemand = 20; // Too many shops, not enough goods
                } else {
                    let idealComRatio = 0.5; // 1 commercial per 2 residential
                    let actualRatio = resCount > 0 ? comCount / resCount : 0;
                    cDemand = Math.max(10, Math.min(80, (idealComRatio - actualRatio) * 100 + 50));
                }
                
                // === INDUSTRIAL DEMAND ===
                // Industry provides: jobs for R, goods for C
                let workersPerInd = resCount > 0 ? indCount / resCount : 0;
                let supplyDemand = comCount > 0 ? indCount / comCount : 0;
                
                let iDemand = 0;
                if(resCount === 0) {
                    iDemand = 10; // No workers yet
                } else if(indCount === 0 && resCount > 0) {
                    iDemand = 80; // People but no industry!
                } else if(comCount > indCount * 2) {
                    iDemand = 90; // Commerce needs goods to sell!
                } else if(unemployed > pop * 0.3) {
                    iDemand = 70; // People need jobs
                } else {
                    let idealIndRatio = 0.5; // 1 industrial per 2 residential
                    let actualRatio = resCount > 0 ? indCount / resCount : 0;
                    iDemand = Math.max(10, Math.min(80, (idealIndRatio - actualRatio) * 100 + 50));
                }
                
                // Clamp all demands 0-100
                return {
                    r: Math.max(0, Math.min(100, rDemand)),
                    c: Math.max(0, Math.min(100, cDemand)),
                    i: Math.max(0, Math.min(100, iDemand))
                };
            },
            
            // PERFORMANCE: Object pooling for particles
            initParticlePool() {
                this.particlePool = [];
                for(let i = 0; i < CFG.PERF.PARTICLE_POOL_SIZE; i++) {
                    this.particlePool.push({x: 0, y: 0, l: 0, c: '', active: false});
                }
            },
            
            getPooledParticle(x, y, life, color) {
                for(let p of this.particlePool) {
                    if(!p.active) {
                        p.x = x; p.y = y; p.l = life; p.c = color; p.active = true;
                        return p;
                    }
                }
                // Pool exhausted, create new (rare)
                const p = {x, y, l: life, c: color, active: true};
                this.particlePool.push(p);
                return p;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // GEOLOGICAL WATER CYCLE UPDATE
            // Called every year, but only processes every 100 years
            // Water rises/falls based on geological periods (ice ages, interglacials)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            updateGeologicalCycle() {
                const cfg = CFG.ELEVATION_SYSTEM;
                const geo = this.geology;
                
                // Only check every 100 years (1 century)
                if(this.year - geo.lastUpdateYear < cfg.UPDATE_INTERVAL_YEARS) return;
                geo.lastUpdateYear = this.year;
                
                // Advance centuries in current period
                geo.centuriesInPeriod++;
                
                // Check if period has ended
                const currentPeriod = cfg.GEOLOGICAL_PERIODS[geo.periodIndex];
                if(geo.centuriesInPeriod >= currentPeriod.duration) {
                    // Move to next period
                    geo.periodIndex = (geo.periodIndex + 1) % cfg.GEOLOGICAL_PERIODS.length;
                    geo.centuriesInPeriod = 0;
                    
                    const newPeriod = cfg.GEOLOGICAL_PERIODS[geo.periodIndex];
                    geo.currentPeriodName = newPeriod.name;
                    
                    // Announce major geological shift
                    const oldLevel = geo.currentSeaLevel;
                    const newLevel = newPeriod.seaLevel;
                    
                    if(newLevel > oldLevel) {
                        Controller.toast(`üåä ${newPeriod.name} begins! Waters are rising as ice melts...`, 5000);
                        this.logEvent(`Year ${this.year}: ${newPeriod.name} - Sea levels rising`);
                    } else if(newLevel < oldLevel) {
                        Controller.toast(`‚ùÑÔ∏è ${newPeriod.name} begins! Waters recede as glaciers grow...`, 5000);
                        this.logEvent(`Year ${this.year}: ${newPeriod.name} - Sea levels falling`);
                    } else {
                        Controller.toast(`üåç ${newPeriod.name} begins.`, 3000);
                    }
                }
                
                // Gradual sea level change (don't jump instantly)
                const targetLevel = cfg.GEOLOGICAL_PERIODS[geo.periodIndex].seaLevel;
                if(geo.currentSeaLevel < targetLevel) {
                    // Water rising VERY slowly - 0.1 per century for gradual creep
                    const oldLevel = geo.currentSeaLevel;
                    geo.currentSeaLevel = Math.min(cfg.SEA_LEVEL_MAX, geo.currentSeaLevel + 0.1);
                    // Warn player about rising waters
                    if(Math.floor(oldLevel * 10) !== Math.floor(geo.currentSeaLevel * 10)) {
                        Controller.toast(`üì∞ Elders report: The waters creep higher each season. Coastal areas at risk.`, 4000);
                    }
                    this.applySeaLevelChange();
                } else if(geo.currentSeaLevel > targetLevel) {
                    // Water receding slowly
                    geo.currentSeaLevel = Math.max(cfg.SEA_LEVEL_MIN, geo.currentSeaLevel - 0.1);
                    this.applySeaLevelChange();
                }
            },
            
            // Apply sea level change to tiles - NOW USES FRACTIONAL ELEVATION!
            applySeaLevelChange() {
                // Use EXACT sea level (with decimals) for gradual tile-by-tile flooding
                const seaLevel = this.geology.currentSeaLevel; // No Math.floor - use full precision!
                let flooded = 0;
                let drained = 0;
                let buildingsLost = [];
                let populationDrowned = 0;
                let wellsLost = 0;
                let bldsToRemove = []; // Track blds array items to remove
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        const tile = this.tiles[x][y];
                        
                        // Skip tiles that are always water (deep ocean) or always land (mountains)
                        if(tile.elevation <= 0 || tile.elevation >= 8) continue;
                        
                        // Check if tile should be underwater at current sea level
                        // FRACTIONAL comparison means tiles flood gradually, not all at once!
                        if(tile.elevation < seaLevel && tile.type !== 'WATER' && tile.type !== 'DEEP') {
                            // FLOOD THIS TILE - DESTROY ALL STRUCTURES
                            
                            // Check for tile-based buildings first - KILL POPULATION IMMEDIATELY
                            if(tile.building || tile.zone) {
                                // Count population lost in this building
                                if(tile.building && tile.building.pop) {
                                    populationDrowned += tile.building.pop;
                                }
                                buildingsLost.push({x, y, type: tile.building?.type || tile.zone, pop: tile.building?.pop || 0});
                            }
                            
                            // Check for blds array buildings at this location (wells, COM, IND, RES, etc)
                            // These need to be tracked for removal
                            if(this.blds) {
                                for(let i = 0; i < this.blds.length; i++) {
                                    let b = this.blds[i];
                                    // Check if building occupies this tile (1x1 or 2x2 buildings)
                                    let bSize = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                                    if(x >= b.x && x < b.x + bSize && y >= b.y && y < b.y + bSize) {
                                        if(!bldsToRemove.includes(i)) {
                                            bldsToRemove.push(i);
                                            if(b.t === 'WELL') wellsLost++;
                                            // RES buildings have population
                                            if(b.t === 'RES' && b.pop) {
                                                populationDrowned += b.pop;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Check if player is on this tile - instant death!
                            if(this.player && this.player.x === x && this.player.y === y) {
                                populationDrowned += this.pop; // Everyone drowns
                                this.pop = 0;
                            }
                            
                            // DESTROY ALL STRUCTURES ON THIS TILE - Nothing visible underwater!
                            tile.type = 'WATER';
                            tile.tree = false;
                            tile.road = false;          // Remove roads
                            tile.building = null;       // Remove buildings
                            tile.zone = null;           // Remove zones
                            tile.bld = null;            // Legacy building reference
                            tile.stoneDeposit = null;   // Stone deposits wash away
                            tile.berry = false;         // Berries drown
                            flooded++;
                            this.markDirty(x, y, 1);
                        } 
                        else if(tile.elevation >= seaLevel && (tile.type === 'WATER' || tile.type === 'DEEP')) {
                            // DRAIN THIS TILE (was water, now above sea level)
                            // Only drain shallow water tiles (not deep ocean which has elevation 0-1)
                            // NOTE: Buildings do NOT come back - player must rebuild!
                            if(tile.elevation > 1) {
                                tile.type = tile.originalType || 'SAND';
                                drained++;
                                this.markDirty(x, y, 1);
                            }
                        }
                    }
                }
                
                // Remove flooded buildings from blds array (in reverse order to maintain indices)
                if(bldsToRemove.length > 0) {
                    bldsToRemove.sort((a, b) => b - a); // Sort descending
                    for(let idx of bldsToRemove) {
                        let removedBld = this.blds[idx];
                        buildingsLost.push({x: removedBld.x, y: removedBld.y, type: removedBld.t});
                        this.blds.splice(idx, 1);
                    }
                    // Force recalc of well count and other cached values
                    this.wellCount = this.blds.filter(b => b.t === 'WELL').length;
                }
                
                // KILL POPULATION FROM FLOODED BUILDINGS - With informative newspaper-style messages
                if(populationDrowned > 0) {
                    this.pop = Math.max(0, this.pop - populationDrowned);
                    this.geology.populationDrowned = (this.geology.populationDrowned || 0) + populationDrowned;
                    
                    // Newspaper-style dramatic message explaining WHY they died
                    const seaLvl = this.geology.currentSeaLevel.toFixed(1);
                    const periodName = this.geology.currentPeriodName || 'climate shift';
                    
                    // Different messages based on severity
                    if(populationDrowned > 100) {
                        Controller.toast(`\ud83d\udcf0 CATASTROPHE! ${populationDrowned} perished in the great flood! The ${periodName} brought destruction. Where you build matters...`, 8000);
                    } else if(populationDrowned > 20) {
                        Controller.toast(`\ud83c\udf0a\ud83d\udc80 ${populationDrowned} drowned in rising waters! Some areas may be safer than others...`, 6000);
                    } else {
                        Controller.toast(`\ud83c\udf0a ${populationDrowned} lost to rising waters. Perhaps higher ground would be wiser...`, 5000);
                    }
                    
                    this.logEvent(`Year ${this.year}: ${populationDrowned} drowned as waters rose to level ${seaLvl} during ${periodName}`);
                }
                
                // Report wells lost
                if(wellsLost > 0) {
                    Controller.toast(`\ud83d\udca7\ud83c\udf0a ${wellsLost} well${wellsLost > 1 ? 's' : ''} swallowed by the sea!`, 4000);
                    this.logEvent(`Year ${this.year}: ${wellsLost} wells lost to flooding`);
                }
                
                // Update stats
                this.geology.tilesFlooded += flooded;
                this.geology.tilesDrained += drained;
                
                // Warn about lost buildings
                if(buildingsLost.length > 0 && populationDrowned === 0) {
                    Controller.toast(`üíÄ Rising waters destroyed ${buildingsLost.length} building${buildingsLost.length > 1 ? 's' : ''}!`, 4000);
                }
                
                // Force terrain cache rebuild
                if(flooded > 0 || drained > 0) {
                    this.terrainCache = null;
                }
                
                // CHECK FOR GAME OVER - Everyone drowned!
                if(this.pop <= 0 && populationDrowned > 0) {
                    Controller.showGameOver('FLOOD');
                    return;
                }
                
                // Mark that a major flood event happened this year (for game over screen)
                if(populationDrowned > 0) {
                    this.lastMajorFloodYear = this.year;
                    this.lastFloodDeaths = populationDrowned;
                }
            },
            
            // Helper to determine game over reason - checks if flood was the real cause
            getGameOverReason(defaultReason) {
                // If a major flood happened this year and killed significant population, blame the flood
                if(this.lastMajorFloodYear === this.year && this.lastFloodDeaths > 0) {
                    return 'FLOOD';
                }
                return defaultReason;
            },
            
            // Check if a tile is at flood risk
            isFloodRisk(x, y) {
                if(!CFG.ELEVATION_SYSTEM.ENABLED) return false;
                const tile = this.tiles[x]?.[y];
                if(!tile) return false;
                
                const seaLevel = this.geology.currentSeaLevel;
                const margin = CFG.ELEVATION_SYSTEM.FLOOD_WARNING_MARGIN;
                
                // Tile is at risk if elevation is within warning margin of sea level
                return tile.elevation <= seaLevel + margin && tile.elevation > seaLevel;
            },
            
            // Calculate elevation-based cost multiplier
            // Building on highlands costs more (+10% per elevation above 4)
            getElevationCostMultiplier(x, y) {
                if(!CFG.ELEVATION_SYSTEM.ENABLED) return 1.0;
                const tile = this.tiles[x]?.[y];
                if(!tile) return 1.0;
                
                const threshold = CFG.ELEVATION_SYSTEM.COST_THRESHOLD || 4;
                const increasePerLevel = CFG.ELEVATION_SYSTEM.COST_INCREASE_PER_LEVEL || 0.10;
                const elevation = Math.floor(tile.elevation);
                
                if(elevation < threshold) return 1.0;
                
                // Each elevation above threshold adds 10% cost
                const levelsAbove = elevation - threshold;
                return 1.0 + (levelsAbove * increasePerLevel);
            },
            
            // Get elevation cost info (internal use - no UI text shown to player)
            // Player must discover elevation effects through gameplay mystery
            getElevationCostInfo(x, y) {
                const multiplier = this.getElevationCostMultiplier(x, y);
                const tile = this.tiles[x]?.[y];
                const elevation = tile ? Math.floor(tile.elevation) : 0;
                
                // Always return empty text - player shouldn't know about elevation costs
                return { 
                    multiplier: multiplier, 
                    text: '',  // Mystery: player doesn't know why some areas cost more
                    elevation: elevation
                };
            },
            
            // Log significant game events
            logEvent(msg) {
                if(!this.gameLog) this.gameLog = [];
                this.gameLog.push(msg);
                if(this.gameLog.length > 100) this.gameLog.shift();
                console.log('[EVENT]', msg);
            },
            
            // Get elevation info for tile (for UI display)
            getTileElevationInfo(x, y) {
                const tile = this.tiles[x]?.[y];
                if(!tile) return null;
                
                const seaLevel = this.geology.currentSeaLevel;
                const elevation = tile.elevation;
                
                let status = 'safe';
                let description = '';
                
                if(elevation < seaLevel) {
                    status = 'underwater';
                    description = 'Underwater';
                } else if(elevation < seaLevel + 1) {
                    status = 'danger';
                    description = 'Flood Risk! (coastal)';
                } else if(elevation < seaLevel + 2) {
                    status = 'warning';
                    description = 'Low ground';
                } else if(elevation >= 8) {
                    status = 'high';
                    description = 'Mountain peaks';
                } else {
                    status = 'safe';
                    description = 'Safe elevation';
                }
                
                return {
                    elevation,
                    seaLevel: Math.floor(seaLevel),
                    status,
                    description,
                    heightAboveSea: elevation - Math.floor(seaLevel)
                };
            },
            
            markDirty(x, y, size = 1) {
                if(!CFG.PERF.DIRTY_RECT_RENDERING) return;
                for(let dx = 0; dx < size; dx++) {
                    for(let dy = 0; dy < size; dy++) {
                        const key = `${x+dx},${y+dy}`;
                        this.dirtyRegions.add(key);
                    }
                }
            },
            
            spawnPlayer() {
                // Find a safe grass tile with at least 60 reachable land tiles
                function floodFillCount(tiles, x, y, maxTiles = 200) {
                    let W = tiles.length, H = tiles[0].length;
                    let seen = Array.from({length: W}, () => Array(H).fill(false));
                    let queue = [[x, y]];
                    let count = 0;
                    while(queue.length > 0 && count < maxTiles) {
                        let [cx, cy] = queue.shift();
                        if(cx < 0 || cy < 0 || cx >= W || cy >= H) continue;
                        if(seen[cx][cy]) continue;
                        let t = tiles[cx][cy].type;
                        if(!(t === 'GRASS' || t === 'FOREST' || t === 'SAND')) continue;
                        seen[cx][cy] = true;
                        count++;
                        queue.push([cx+1, cy]);
                        queue.push([cx-1, cy]);
                        queue.push([cx, cy+1]);
                        queue.push([cx, cy-1]);
                    }
                    return count;
                }
                
                function isValidSpawn(tiles, x, y) {
                    if(x < 0 || x >= tiles.length || y < 0 || y >= tiles[0].length) return false;
                    let t = tiles[x][y].type;
                    // NEVER spawn in water, ocean, river, or stone
                    return t === 'GRASS' || t === 'FOREST' || t === 'SAND' || t === 'SNOW' || t === 'ROCK';
                }
                
                // Phase 1: Try center area (20 tile radius)
                for(let attempt = 0; attempt < 100; attempt++) {
                    let x = Math.floor(CFG.W/2 + (Math.random()-0.5)*40);
                    let y = Math.floor(CFG.H/2 + (Math.random()-0.5)*40);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 60) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('‚úÖ Player spawned at', x, y, '(center search)');
                            return;
                        }
                    }
                }
                
                // Phase 2: Try wider area (whole map, but prefer land)
                for(let attempt = 0; attempt < 500; attempt++) {
                    let x = Math.floor(Math.random() * CFG.W);
                    let y = Math.floor(Math.random() * CFG.H);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 30) { // Lower threshold for fallback
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('‚úÖ Player spawned at', x, y, '(wide search)');
                            return;
                        }
                    }
                }
                
                // Phase 3: Emergency - scan entire map for ANY valid land tile
                console.warn('‚ö†Ô∏è Emergency spawn search...');
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        if(isValidSpawn(this.tiles, x, y)) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('‚úÖ Player spawned at', x, y, '(emergency)');
                            return;
                        }
                    }
                }
                
                // Phase 4: Absolute last resort - spawn at center regardless
                console.error('‚ùå No valid spawn found! Forcing center spawn.');
                let cx = Math.floor(CFG.W/2);
                let cy = Math.floor(CFG.H/2);
                this.player = {x:cx, y:cy, health:3, direction: 'down'};
                this.exploreArea(cx, cy, 5);
                Controller.cam.x = cx * CFG.TILE;
                Controller.cam.y = cy * CFG.TILE;
            },
            
            spawnBerries(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    if((tile.type=='GRASS' || tile.type=='FOREST') && !tile.entity) {
                        // DEEP DATA: Rich berry entity using CFG values (Master Design v40.0)
                        tile.entity = {
                            type: 'BERRY',
                            amount: CFG.BERRIES.FOOD_VALUE, // Fixed 10 food per spec
                            poison_chance: CFG.BERRIES.POISON_CHANCE,
                            is_poisonous: Math.random() < CFG.BERRIES.POISON_CHANCE // 10% poison
                        };
                        spawned++;
                    }
                }
            },
            
            spawnStoneDeposits(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    // Spawn on grass, forest, or rock terrain
                    if((tile.type=='GRASS' || tile.type=='FOREST' || tile.type=='ROCK') && !tile.entity && !tile.stoneDeposit && !tile.tree) {
                        // Random metal value between MIN_METAL and MAX_METAL (typically 50-500)
                        let metalValue = CFG.STONE_DEPOSITS.MIN_METAL + 
                            Math.floor(Math.random() * (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL));
                        
                        tile.stoneDeposit = {
                            metal: metalValue
                        };
                        spawned++;
                    }
                }
            },
            
            spawnNomad() {
                for(let attempt=0; attempt<200; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if((tile.type=='GRASS' || tile.type=='FOREST') && dist > 15 && !tile.entity) {
                        // DEEP DATA: Rich nomad entity using CFG values (Master Design v40.0)
                        let isHostile = Math.random() < CFG.NOMAD.HOSTILE_CHANCE; // 16% hostile
                        let hostileDamageRange = CFG.NOMAD.HOSTILE_DAMAGE;
                        let lootRanges = CFG.NOMAD.LOOT_RANGES;
                        
                        tile.entity = {
                            type: 'NOMAD',
                            pop: CFG.NOMAD.FRIENDLY_POP_BONUS, // +1 Pop
                            loot: {
                                food: lootRanges.FOOD[0] + Math.floor(Math.random() * (lootRanges.FOOD[1] - lootRanges.FOOD[0] + 1)), // 5-30
                                wood: lootRanges.WOOD[0] + Math.floor(Math.random() * (lootRanges.WOOD[1] - lootRanges.WOOD[0] + 1)), // 5-30
                                metal: lootRanges.METAL[0] + Math.floor(Math.random() * (lootRanges.METAL[1] - lootRanges.METAL[0] + 1)), // 0-10
                                stone: lootRanges.STONE[0] + Math.floor(Math.random() * (lootRanges.STONE[1] - lootRanges.STONE[0] + 1))  // 0-5
                            },
                            hostile_chance: CFG.NOMAD.HOSTILE_CHANCE,
                            is_hostile: isHostile,
                            damage: isHostile ? (hostileDamageRange[0] + Math.floor(Math.random() * (hostileDamageRange[1] - hostileDamageRange[0] + 1))) : 0 // 1-3 if hostile
                        };
                        return;
                    }
                }
            },
            
            // Spawn wolves as separate entity type (Master Design v40.0)
            // Wolves always cost -1 Pop to kill, always give +50 Food
            // spawnWolves removed - wolves no longer in game
            
            spawnAnimals(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*20 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let t = this.tiles[x][y].type;
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    
                    // Check if animal already exists on this tile (prevent overlapping)
                    let tileOccupied = this.animals.some(a => a.x === x && a.y === y);
                    
                    // Get valid animal types for this terrain
                    let validTypes = CFG.ANIMALS.TYPES.filter(type => {
                        if(type.terrain) {
                            return type.terrain.includes(t);
                        }
                        return t === 'GRASS' || t === 'FOREST'; // Default terrain for animals without terrain property
                    });
                    
                    if(validTypes.length > 0 && dist > 10 && !tileOccupied) {
                        // Calculate adjusted spawn rates for valid types
                        let totalRate = validTypes.reduce((sum, type) => sum + type.spawnRate, 0);
                        let rand = Math.random() * totalRate;
                        let cumulative = 0;
                        let animalType = validTypes[0].name; // Default to first valid type
                        
                        for(let type of validTypes) {
                            cumulative += type.spawnRate;
                            if(rand < cumulative) {
                                animalType = type.name;
                                break;
                            }
                        }
                        
                        this.animals.push({x:x, y:y, hits:0, type: animalType});
                        spawned++;
                    }
                }
                
                // BEACH TURTLES: Spawn additional turtles specifically on sand tiles
                this.spawnBeachTurtles(CFG.ANIMALS.BEACH_SPAWN_COUNT || 150);
            },
            
            spawnBeachTurtles(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*30 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let t = this.tiles[x][y].type;
                    
                    // Only spawn on SAND tiles
                    if(t !== 'SAND') continue;
                    
                    // Check if already occupied
                    let tileOccupied = this.animals.some(a => a.x === x && a.y === y);
                    if(tileOccupied) continue;
                    
                    // Distance check from player
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if(dist <= 5) continue;
                    
                    this.animals.push({x:x, y:y, hits:0, type: 'TURTLE'});
                    spawned++;
                }
            },
            
            exploreArea(cx, cy, radius) {
                for(let x=cx-radius; x<=cx+radius; x++) {
                    for(let y=cy-radius; y<=cy+radius; y++) {
                        if(x>=0 && x<CFG.W && y>=0 && y<CFG.H) {
                            let dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
                            if(dist <= radius) {
                                this.tiles[x][y].explored = true;
                            }
                        }
                    }
                }
            },
            
            getWaterProximity(x, y, size) {
                // Calculate distance to nearest water for a building
                let minDist = Infinity;
                for(let bx=x; bx<x+size; bx++) {
                    for(let by=y; by<y+size; by++) {
                        // Check surrounding area
                        for(let cx=bx-CFG.WATER_PROXIMITY.MAX_DISTANCE; cx<=bx+CFG.WATER_PROXIMITY.MAX_DISTANCE; cx++) {
                            for(let cy=by-CFG.WATER_PROXIMITY.MAX_DISTANCE; cy<=by+CFG.WATER_PROXIMITY.MAX_DISTANCE; cy++) {
                                if(cx>=0 && cx<CFG.W && cy>=0 && cy<CFG.H) {
                                    let tile = this.tiles[cx][cy];
                                    if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                        let dist = Math.sqrt((cx-bx)**2 + (cy-by)**2);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                            }
                        }
                    }
                }
                // Convert distance to efficiency (0=far, 1=adjacent)
                if(minDist === 0) return 1.0;
                if(minDist > CFG.WATER_PROXIMITY.MAX_DISTANCE) return CFG.WATER_PROXIMITY.MIN_EFFICIENCY;
                return Math.max(CFG.WATER_PROXIMITY.MIN_EFFICIENCY, 1.0 - (minDist / CFG.WATER_PROXIMITY.MAX_DISTANCE) * (1.0 - CFG.WATER_PROXIMITY.MIN_EFFICIENCY));
            },
            
            getForestProximity(x, y, size) {
                // Calculate if building is near forest
                for(let bx=x-1; bx<=x+size; bx++) {
                    for(let by=y-1; by<=y+size; by++) {
                        if(bx>=0 && bx<CFG.W && by>=0 && by<CFG.H) {
                            if(this.tiles[bx][by].type === 'FOREST') return true;
                        }
                    }
                }
                return false;
            },
            
            movePlayer(dx, dy) {
                if(!this.player) return false;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return false;
                }
                
                // FOOD COST CHECK: Block movement if no food in WANDER mode
                if(this.gameState === 'WANDER' && this.inventory.food <= 0) {
                    Controller.toast("üçñ No food! Your tribe cannot travel without food.");
                    return false;
                }
                
                let newX = this.player.x + dx;
                let newY = this.player.y + dy;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FLAT EARTH BOUNDARY - The world ends here!
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(newX < 0 || newX >= CFG.W || newY < 0 || newY >= CFG.H) {
                    if(CFG.MAP_EXPANSION.ENABLED) {
                        // Check if we've reached maximum world size
                        if(CFG.W >= CFG.MAP_EXPANSION.MAX_SIZE) {
                            Controller.toast(`üåç ${CFG.MAP_EXPANSION.BOUNDARY_MESSAGE}`, 5000);
                            this.logEvent(`Year ${this.year}: Scouts discovered the World's Edge`);
                        } else {
                            // World can still be expanded (future feature)
                            Controller.toast("üó∫Ô∏è The edge of known lands. Send scouts to explore further?", 3000);
                        }
                    }
                    return false;
                }
                
                let tile = this.tiles[newX][newY];
                
                // Block water tiles
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') return false;
                
                // Block stone deposits
                if(tile.stoneDeposit) {
                    Controller.toast("‚õ∞Ô∏è Stone deposit blocking path.");
                    return false;
                }
                
                // Block STONE terrain in WANDER mode
                if(tile.type === 'STONE' && this.gameState === 'WANDER') {
                    Controller.toast("‚õ∞Ô∏è Dense rock formation. Impassable.");
                    return false;
                }
                
                // Update direction based on movement
                if(dx > 0) this.player.direction = 'right';
                else if(dx < 0) this.player.direction = 'left';
                else if(dy > 0) this.player.direction = 'down';
                else if(dy < 0) this.player.direction = 'up';
                
                // Move player
                this.player.x = newX;
                this.player.y = newY;
                
                // FOOD COST: 1 food per 15 steps per population (in WANDER mode only)
                if(this.gameState === 'WANDER') {
                    this.foodStepCounter++;
                    if(this.foodStepCounter >= CFG.MOVEMENT.STEPS_PER_FOOD) {
                        this.foodStepCounter = 0;
                        let popCount = Math.max(1, this.pop);
                        let foodCost = popCount * CFG.MOVEMENT.FOOD_PER_PERSON;
                        this.inventory.food = Math.max(0, this.inventory.food - foodCost);
                        // Always show food cost message
                        Controller.toast(`üçñ -${foodCost} food (${popCount} people traveling) | Remaining: ${Math.floor(this.inventory.food)}`);
                        
                        // Check for starvation game over
                        if(this.inventory.food <= 0) {
                            Controller.showGameOver('LEVEL1');
                            return false;
                        }
                    }
                }
                
                // THIRST MECHANIC (WANDER mode only): Must drink water every 100 steps
                if(this.gameState === 'WANDER') {
                    this.thirstCounter++;
                    // Thirst depletes by 1 every step
                    this.thirst = Math.max(0, 100 - this.thirstCounter);
                    
                    // Check if standing on drinkable water (RIVER or WATER, NOT ocean/deep)
                    let currentTile = this.tiles[newX][newY];
                    let isDrinkableWater = currentTile && (currentTile.type === 'RIVER' || currentTile.type === 'WATER');
                    
                    // Check if near a wander well (within 1 tile)
                    let nearWanderWell = this.wanderWells && this.wanderWells.some(well => {
                        let dist = Math.abs(well.x - newX) + Math.abs(well.y - newY);
                        return dist <= 1; // Adjacent or on the well
                    });
                    
                    if(isDrinkableWater || nearWanderWell) {
                        this.thirstCounter = 0;
                        this.thirst = 100;
                        if(nearWanderWell && !isDrinkableWater) {
                            Controller.toast(`üíß Drank from your well! Thirst replenished.`);
                        } else {
                            Controller.toast(`üíß Drank from water source! Thirst replenished.`);
                        }
                    }
                    
                    // Warning at 30% thirst
                    if(this.thirst === 30) {
                        Controller.toast(`‚ö†Ô∏è Getting thirsty! Find a river or lake soon!`);
                    }
                    // Warning at 15% thirst
                    if(this.thirst === 15) {
                        Controller.toast(`üî¥ DEHYDRATED! Find water NOW or your tribe will die!`);
                    }
                    
                    // Death at 0 thirst
                    if(this.thirst <= 0) {
                        Controller.showGameOver('THIRST');
                        return false;
                    }
                }
                
                // PASSIVE COLLECTION: Every 5 steps, 0.01% chance to find 1-5 metal or stone
                this.stepCounter++;
                if(this.stepCounter >= 5) {
                    this.stepCounter = 0;
                    if(Math.random() < 0.0001) { // 0.01% chance
                        let pocketTotal = this.pocket.metal + this.pocket.stone;
                        if(pocketTotal < this.pocket.capacity) {
                            let amount = 1 + Math.floor(Math.random() * 5); // 1-5
                            let spaceLeft = this.pocket.capacity - pocketTotal;
                            amount = Math.min(amount, spaceLeft);
                            
                            if(Math.random() < 0.5) {
                                this.pocket.metal += amount;
                                Controller.toast(`‚ú® Found ${amount} metal nugget${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            } else {
                                this.pocket.stone += amount;
                                Controller.toast(`üíé Found ${amount} stone${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            }
                        }
                    }
                }
                
                // Explore around player
                this.exploreArea(newX, newY, 3);
                
                // Animals are now handled by click handler (instant kill)
                // Walking onto animal square does nothing, UNLESS it's a herd
                
                // Check for hostile herds (groups of touching animals)
                if(this.gameState === 'WANDER' && tile.animal) {
                    let adjacentAnimals = 0;
                    for(let dx = -1; dx <= 1; dx++) {
                        for(let dy = -1; dy <= 1; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            let checkX = newX + dx;
                            let checkY = newY + dy;
                            if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                                let adjacentTile = this.tiles[checkX][checkY];
                                if(adjacentTile && adjacentTile.animal) {
                                    adjacentAnimals++;
                                }
                            }
                        }
                    }
                    
                    // If 2+ adjacent animals, it's a hostile herd
                    let isHerd = adjacentAnimals >= 2;
                    
                    if(isHerd) {
                        // Hostile herd encounter - ALWAYS lose at least 1 population (unsafe hunt)
                        let popLoss = Math.max(1, Math.min(3, Math.ceil(this.pop * 0.15))); // Lose 1-3 people (15% of pop, minimum 1)
                        this.pop = Math.max(1, this.pop - popLoss); // Keep at least 1 person
                        SoundFX.playHurt();
                        let animalEmoji = tile.animal.emoji || 'ü¶å';
                        Controller.toast(`üíÄ UNSAFE HUNT! ${animalEmoji} Herd attacked! Lost ${popLoss} wanderer${popLoss > 1 ? 's' : ''}. Population: ${this.pop}`);
                        
                        // Don't remove the animal - herds are dangerous to approach
                        this.aiTarget = null;
                        this.checkProgression();
                        return; // Don't continue with movement
                    }
                }
                
                // === FOREST TILE: Passive +1 Wood (Master Design v40.0) ===
                // Stepping on FOREST terrain gives +1 wood (scavenging), doesn't destroy forest
                if(this.gameState === 'WANDER' && tile.type === 'FOREST') {
                    let woodAmount = CFG.FOREST.WOOD_PER_STEP; // +1 wood per step
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        SoundFX.playCollect('wood');
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        // Don't destroy forest - passive collection
                        Controller.toast(`üå≤ Scavenged +${woodAmount} wood (${Math.floor(this.inventory.wood)}W total)`);
                    } else if(spaceAvailable === 0) {
                        Controller.toast(`‚ö†Ô∏è Inventory full! Cannot collect wood`);
                    }
                }
                
                // Individual trees can be chopped for more wood (2-5)
                if(this.gameState === 'WANDER' && tile.tree) {
                    let woodAmount = 2 + Math.floor(Math.random() * 4); // 2-5 wood per tree
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        tile.tree = false; // Remove individual tree
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ü™µ Chopped tree! +${woodAmount} wood (${this.inventory.wood} total)`);
                    } else if(spaceAvailable > 0) {
                        this.inventory.wood += spaceAvailable;
                        tile.tree = false;
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ü™µ Chopped tree! +${spaceAvailable}/${woodAmount} wood (Inventory Full!)`);
                    } else {
                        Controller.toast(`‚ö†Ô∏è Inventory full! Cannot chop tree`);
                    }
                }
                
                // === OPEN GROUND: Rare Find (Master Design v40.0) ===
                // 0.01% chance per step on GRASS/SAND to find +1 Metal or +1 Stone
                if(this.gameState === 'WANDER' && (tile.type === 'GRASS' || tile.type === 'SAND')) {
                    if(Math.random() < CFG.OPEN_GROUND.RARE_FIND_CHANCE) {
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        if(spaceAvailable > 0) {
                            // 50% metal, 50% stone
                            if(Math.random() < CFG.OPEN_GROUND.METAL_CHANCE) {
                                this.inventory.metal += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`‚ú® Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Metal! (${this.inventory.metal}M total)`);
                            } else {
                                this.inventory.stone += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`‚ú® Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Stone! (${this.inventory.stone}S total)`);
                            }
                        }
                    }
                }
                
                // --- HARDCORE INTERACTION LOGIC (DEEP ENTITY SYSTEM) ---
                
                // Check for entity interactions
                console.log(`[Entity Debug] tile.entity:`, tile.entity, `at (${newX}, ${newY})`);
                if(tile.entity) {
                    let entity = tile.entity;
                    console.log(`[Entity Debug] Found entity type: ${entity.type}`);
                    
                    // BERRY ENTITY
                    if(entity.type === 'BERRY') {
                        if(entity.is_poisonous) {
                            // Trigger bash for poison berry
                            if(this.player) this.player.bashTime = performance.now();
                            this.pop = Math.max(0, this.pop - 1);
                            SoundFX.playHurt();
                            Controller.toast(`‚ò†Ô∏è POISON BERRY! -1 Population - YUCK!`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                            tile.entity = null; // Remove poison berry after eating
                        } else {
                            let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - totalInventory;
                            console.log(`[Berry Debug] totalInventory: ${totalInventory}, spaceAvailable: ${spaceAvailable}, berryAmount: ${entity.amount}`);
                            // Patch: Always collect as much food as possible if space allows
                            let foodToCollect = Math.min(entity.amount, spaceAvailable);
                            if(foodToCollect > 0) {
                                // Trigger bash animation AFTER confirming collection
                                if(this.player) this.player.bashTime = performance.now();
                                this.inventory.food += foodToCollect;
                                this.totalFoodCollected += foodToCollect;
                                SoundFX.playCollect('food');
                                if(foodToCollect === entity.amount) {
                                    Controller.toast(`ü´ê Found Berry! +${entity.amount} food (${Math.floor(this.inventory.food)}/${this.inventory.capacity}) - YUM!`);
                                } else {
                                    Controller.toast(`ü´ê Found Berry! +${foodToCollect}/${entity.amount} food (Inventory Full!) - YUM!`);
                                }
                                tile.entity = null; // Remove entity
                            } else {
                                // Don't bash if inventory is full
                                Controller.toast(`‚ö†Ô∏è Inventory full! (${Math.floor(totalInventory)}/${this.inventory.capacity}) - Cannot collect berry`);
                                return; // Don't remove berry if inventory completely full
                            }
                        }
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                    
                    // NOMAD ENTITY
                    else if(entity.type === 'NOMAD') {
                        if(entity.is_hostile) {
                            // Trigger bash for hostile encounter
                            if(this.player) this.player.bashTime = performance.now();
                            let damage = entity.damage;
                            this.pop = Math.max(0, this.pop - damage);
                            SoundFX.playHurt();
                            Controller.toast(`‚öîÔ∏è HOSTILE NOMAD! Ambush! -${damage} Population`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                        } else {
                            // Trigger bash for friendly greeting
                            if(this.player) this.player.bashTime = performance.now();
                            PROGRESSION.nomadsFound++;
                            this.nomadsFound++;
                            this.pop += entity.pop;
                            SoundFX.playCollect('population');
                            
                            // Update building populations when nomads join
                            if(typeof assignPopulationToResidential === 'function') {
                                assignPopulationToResidential(this);
                            }
                            
                            // Calculate total loot
                            let totalLoot = entity.loot.food + entity.loot.wood + entity.loot.metal + (entity.loot.stone || 0);
                            let currentInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - currentInventory;
                            
                            // Transfer what fits
                            let foodAdded = 0, woodAdded = 0, metalAdded = 0, stoneAdded = 0;
                            
                            if(spaceAvailable >= totalLoot) {
                                // All loot fits
                                this.inventory.food += entity.loot.food;
                                this.totalFoodCollected += entity.loot.food;
                                this.inventory.wood += entity.loot.wood;
                                this.inventory.metal += entity.loot.metal;
                                this.inventory.stone += entity.loot.stone || 0;
                                foodAdded = entity.loot.food;
                                woodAdded = entity.loot.wood;
                                metalAdded = entity.loot.metal;
                                stoneAdded = entity.loot.stone || 0;
                            } else if(spaceAvailable > 0) {
                                // Partial loot - prioritize food > wood > metal > stone
                                let remaining = spaceAvailable;
                                foodAdded = Math.min(entity.loot.food, remaining);
                                this.inventory.food += foodAdded;
                                this.totalFoodCollected += foodAdded;
                                remaining -= foodAdded;
                                
                                if(remaining > 0) {
                                    woodAdded = Math.min(entity.loot.wood, remaining);
                                    this.inventory.wood += woodAdded;
                                    remaining -= woodAdded;
                                }
                                if(remaining > 0) {
                                    metalAdded = Math.min(entity.loot.metal, remaining);
                                    this.inventory.metal += metalAdded;
                                    remaining -= metalAdded;
                                }
                                if(remaining > 0) {
                                    stoneAdded = Math.min(entity.loot.stone || 0, remaining);
                                    this.inventory.stone += stoneAdded;
                                }
                            }
                            
                            // Increase capacity (+100 per nomad)
                            this.inventory.capacity += 100;
                            
                            // Nomad shares local knowledge
                            this.exploreArea(newX, newY, 15);
                            
                            let lootMsg = spaceAvailable >= totalLoot 
                                ? `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S` 
                                : `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S (Inventory was full!)`;
                            Controller.toast(`üë§ OOGA BOOGA! Nomad joined! +${entity.pop} Pop, ${lootMsg}, Capacity: ${this.inventory.capacity}`);
                            
                            // LORE TRIGGER: First nomad!
                            if(!this.loreSeen) this.loreSeen = {};
                            if(!this.loreSeen.FIRST_NOMAD) {
                                this.loreSeen.FIRST_NOMAD = true;
                                Controller.showLoreEvent('FIRST_NOMAD');
                            }
                        }
                        tile.entity = null; // Remove entity
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                }
                
                // Camera follows player smoothly
                Controller.cam.x = this.player.x * CFG.TILE;
                Controller.cam.y = this.player.y * CFG.TILE;
                
                Controller.updateUI();
                
                return true; // Successfully moved
            },
            
            movePlayerToTile(targetX, targetY) {
                if(!this.player) return;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return;
                }

                if(targetX < 0 || targetX >= CFG.W || targetY < 0 || targetY >= CFG.H) return;
                
                // Check if clicking on an animal to attack it (works from adjacent or same tile)
                let animalIndex = this.animals.findIndex(a => a.x === targetX && a.y === targetY);
                if(animalIndex !== -1) {
                    // Animal attack is now handled by click (instant kill)
                    // Just pathfind to the location normally
                }
                
                let tile = this.tiles[targetX][targetY];
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) return;
                
                // Generate path to target
                this.pathQueue = this.findPath(this.player.x, this.player.y, targetX, targetY);
            },
            
            findPath(startX, startY, endX, endY) {
                // Simple A* pathfinding
                let openSet = [{x: startX, y: startY, g: 0, h: Math.abs(endX - startX) + Math.abs(endY - startY), parent: null}];
                let closedSet = new Set();
                
                while(openSet.length > 0) {
                    // Find node with lowest f score
                    openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                    let current = openSet.shift();
                    
                    if(current.x === endX && current.y === endY) {
                        // Reconstruct path
                        let path = [];
                        while(current.parent) {
                            path.unshift({x: current.x, y: current.y});
                            current = current.parent;
                        }
                        return path;
                    }
                    
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check neighbors
                    let directions = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                    for(let dir of directions) {
                        let nx = current.x + dir.x;
                        let ny = current.y + dir.y;
                        
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        if(closedSet.has(`${nx},${ny}`)) continue;
                        
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) continue;
                        
                        let g = current.g + 1;
                        let h = Math.abs(endX - nx) + Math.abs(endY - ny);
                        
                        let existing = openSet.find(n => n.x === nx && n.y === ny);
                        if(!existing) {
                            openSet.push({x: nx, y: ny, g: g, h: h, parent: current});
                        } else if(g < existing.g) {
                            existing.g = g;
                            existing.parent = current;
                        }
                    }
                    
                    // Limit search to prevent lag
                    if(closedSet.size > 1000) break;
                }
                
                // No path found, return empty
                return [];
            },
            
            processPath() {
                // Only move every 150ms for smooth visible walking animation
                let now = performance.now();
                if(now - this.lastMoveTime < 150) {
                    return;
                }
                
                if(this.pathQueue.length > 0) {
                    let next = this.pathQueue[0];
                    let dx = next.x - this.player.x;
                    let dy = next.y - this.player.y;
                    
                    if(Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                        let moved = this.movePlayer(dx, dy);
                        if(moved) {
                            this.pathQueue.shift();
                            this.lastMoveTime = now;
                        } else {
                            // Can't move (blocked), clear path and let AI recalculate
                            console.warn('AI: Path blocked, clearing queue');
                            this.pathQueue = [];
                            if(this.aiTarget) this.aiTarget = null;
                        }
                    } else {
                        // Path is invalid, clear it
                        console.warn('AI: Invalid path step, clearing queue');
                        this.pathQueue = [];
                    }
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // AI AUTOPLAY SYSTEM - Delegated to External Module
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // AI logic has been moved to js/ai.js for better organization
            // and easier debugging. This wrapper maintains compatibility.
            
            aiUpdate() {
                // Delegate to external AI module with safety check
                if(typeof AI !== 'undefined' && AI && typeof AI.update === 'function') {
                    AI.update(this);
                }
            },
            
            // Helper function for AI building attempts
            tryBuild(type, searchRadius) {
                for(let attempt = 0; attempt < 15; attempt++) {
                    let buildX = Math.floor(this.player.x + (Math.random() - 0.5) * searchRadius * 2);
                    let buildY = Math.floor(this.player.y + (Math.random() - 0.5) * searchRadius * 2);
                    buildX = Math.max(0, Math.min(CFG.W - 1, buildX));
                    buildY = Math.max(0, Math.min(CFG.H - 1, buildY));
                    
                    if(this.isValid(buildX, buildY, type)) {
                        this.build(buildX, buildY, type);
                        return true;
                    }
                }
                return false;
            },
            
            // === BUILDING EVOLUTION SYSTEM ===
            // Level 0 buildings evolve based on location desirability
            // Run every 60 frames (~1 second) to update building states
            updateBuildingEvolution() {
                try {
                    if(!this.evolutionFrameCounter) this.evolutionFrameCounter = 0;
                    this.evolutionFrameCounter++;
                    
                    // Only update every 300 frames (5 seconds at 60fps) - OPTIMIZED for performance
                    if(this.evolutionFrameCounter < 300) return;
                    this.evolutionFrameCounter = 0;
                    
                    // Don't run in nomad mode
                    if(this.gameState !== 'CITY') return;
                    
                    // Limit checks to avoid performance issues - REDUCED for better FPS
                    let checksThisFrame = 0;
                    const MAX_CHECKS_PER_FRAME = 20;
                    
                    // Iterate through ALL residential buildings (ALL LEVELS 0-4)
                    for(let x = 0; x < CFG.W && checksThisFrame < MAX_CHECKS_PER_FRAME; x++) {
                        for(let y = 0; y < CFG.H && checksThisFrame < MAX_CHECKS_PER_FRAME; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                checksThisFrame++;
                                
                                let bld = tile.building;
                                
                                // Calculate local desirability for this tile (pass building level)
                                let desirability = this.calculateTileDesirability(x, y, bld.level);
                                
                                // Store desirability for future reference
                                bld.desirability = desirability;
                                
                                // Determine variant based on building level
                                let oldVariant = bld.variant || 0;
                                let newVariant = 0;
                                
                                if(bld.level === 1) {
                                    // Level 1: Tree Shelter - Abandoned (0) ‚Üí Small Nest (1-5) ‚Üí Tree Platform (6-10) ‚Üí Sturdy Treehouse (11-15)
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned Nest
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Small Nest
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Tree Platform
                                    } else {
                                        newVariant = 3; // Sturdy Treehouse
                                    }
                                    
                                    // Level 1 population scaling (0-15 people)
                                    let newPopulation;
                                    if(newVariant === 0) {
                                        // Abandoned: 0 people
                                        newPopulation = 0;
                                    } else if(newVariant === 1) {
                                        // Small Nest: 1-5 people
                                        newPopulation = 1 + Math.floor((desirability - 0.1) / 0.3 * 4);
                                    } else if(newVariant === 2) {
                                        // Tree Platform: 6-10 people
                                        newPopulation = 6 + Math.floor((desirability - 0.4) / 0.3 * 4);
                                    } else {
                                        // Sturdy Treehouse: 11-15 people
                                        newPopulation = 11 + Math.floor((desirability - 0.7) / 0.3 * 4);
                                    }
                                    bld.population = Math.max(0, Math.min(15, newPopulation));
                                } else {
                                    // Levels 2-4: Use same 4-variant system
                                    // Variant 0: Abandoned (desirability < 0.1)
                                    // Variant 1: Low (desirability 0.1-0.4) - Base income
                                    // Variant 2: Medium (desirability 0.4-0.7) - Full bonus
                                    // Variant 3: High (desirability >= 0.7) - Enhanced bonus
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned state
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Low state
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Medium state
                                    } else {
                                        newVariant = 3; // High state
                                    }
                                }
                                
                                // Update variant and notify if changed
                                if(newVariant !== oldVariant) {
                                    tile.building.variant = newVariant;
                                    
                                    // Get variant name from BUILDING_LEVELS config
                                    let levelConfig = CFG.BUILDING_LEVELS[tile.building.level] || CFG.BUILDING_LEVELS[1];
                                    let variantName = 'Building';
                                    if(levelConfig.variants && levelConfig.variants[newVariant]) {
                                        variantName = levelConfig.variants[newVariant].name;
                                    }
                                    
                                    let icons = ['üï≥Ô∏è', 'üèöÔ∏è', 'üè†', 'üèòÔ∏è'];
                                    
                                    // Show notification for upgrades only (not downgrades to avoid spam)
                                    if(newVariant > oldVariant) {
                                        Controller.toast(`${icons[newVariant]} Upgraded to ${variantName}!`);
                                    }
                                    
                                    // Mark tile for redraw
                                    this.markDirty(x, y, 1);
                                }
                                
                                // Store desirability for future reference
                                tile.building.desirability = desirability;
                            }
                        }
                    }
                } catch(err) {
                    console.error('Evolution update error:', err);
                }
            },
            
            // Calculate desirability for a specific tile - LEVEL 1 SPECIAL CALCULATION
            // Level 1 uses different factors: water, dirt roads, commercial, industrial, berries
            calculateLevel1Desirability(x, y) {
                let score = 0.25; // Lower baseline for Level 1 (minimal bonuses philosophy)
                
                // Water proximity (+0.15 bonus)
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        let dist = Math.abs(dx) + Math.abs(dy);
                        if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                            waterDist = Math.min(waterDist, dist);
                            if(dist === 0) waterFound = true;
                        }
                    }
                }
                if(waterDist <= 3) score += 0.15;
                else if(waterDist <= 5) score += 0.08;
                
                // Dirt road adjacent (+0.10 bonus, but ONLY if roads are maintained!)
                // Roads need workers: 1 worker per 5 road tiles
                // If workforce shortage, road bonus is reduced proportionally
                let hasAdjacentRoad = false;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        // Check for road using tile.road property (not zone)
                        if(this.tiles[nx][ny].road) {
                            hasAdjacentRoad = true;
                            break;
                        }
                    }
                    if(hasAdjacentRoad) break;
                }
                if(hasAdjacentRoad) {
                    // Calculate road maintenance effectiveness
                    let roadMaintenance = 1.0; // 100% if fully staffed
                    if(this.workforce && this.workforce.roadsNeeded > 0) {
                        roadMaintenance = Math.min(1.0, this.workforce.roadWorkers / this.workforce.roadsNeeded);
                    }
                    score += 0.10 * roadMaintenance; // Road bonus scaled by maintenance
                }
                
                // Commercial nearby (+0.08 bonus within 8 tiles)
                let commercialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'COMMERCIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        commercialNearby = true;
                        break;
                    }
                }
                if(commercialNearby) score += 0.08;
                
                // Industrial proximity (+0.15 bonus within 8 tiles - primitive people want to live near butcher/hunter)
                let industrialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'INDUSTRIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        industrialNearby = true;
                        break;
                    }
                }
                if(industrialNearby) score += 0.15;
                
                // Berry tiles nearby (+0.20 bonus if any berries within 3 tiles)within 3 tiles)
                let berryCount = 0;
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'BERRY') berryCount++;
                    }
                }
                if(berryCount >= 1) score += 0.20;
                
                return Math.max(0, Math.min(1, score));
            },
            
            // Calculate desirability for a specific tile
            // Factors: Water proximity, Wells, Roads, Commercial, Industrial distance, Population density
            calculateTileDesirability(x, y, buildingLevel) {
                // Use Level 1 special calculation
                if(buildingLevel === 1) {
                    return this.calculateLevel1Desirability(x, y);
                }
                
                let score = 0.35; // BUFFED base score (was 0.3) to help reach higher tiers
                
                // === WATER PROXIMITY (Critical: +0.30 BUFFED) ===
                // OPTIMIZED: Reduced search area and added early exit
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            let tile = this.tiles[nx][ny];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                waterDist = Math.min(waterDist, dist);
                                if(dist === 0) waterFound = true; // Early exit if adjacent
                            }
                        }
                    }
                }
                // Closer water = better. 1 tile away = +0.30 (was +0.25), 5 tiles = +0.06
                if(waterDist <= 5) {
                    score += 0.30 * (1 - (waterDist / 6));
                }
                
                // === WELL PROXIMITY (Important: +0.25 BUFFED) ===
                // OPTIMIZED: Only check wells within reasonable range
                let nearestWell = 999;
                for(let well of this.blds) {
                    if(well.t !== 'WELL') continue;
                    let dist = Math.abs(x - well.x) + Math.abs(y - well.y);
                    if(dist > 8) continue; // Skip distant wells
                    nearestWell = Math.min(nearestWell, dist);
                    if(dist === 0) break; // Early exit if on well
                }
                // Well within 8 tiles is valuable: +0.25 (was +0.20)
                if(nearestWell <= 8) {
                    score += 0.25 * (1 - (nearestWell / 9));
                }
                
                // === ROAD CONNECTIVITY (Infrastructure: +0.20 BUFFED) ===
                // OPTIMIZED: Smaller search area with early exit
                let roadDist = 999;
                let roadFound = false;
                for(let dx = -2; dx <= 2 && !roadFound; dx++) {
                    for(let dy = -2; dy <= 2 && !roadFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].road) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                roadDist = Math.min(roadDist, dist);
                                if(dist === 0) roadFound = true;
                            }
                        }
                    }
                }
                if(roadDist <= 2) {
                    score += 0.20 * (1 - (roadDist / 3)); // Was +0.15
                }
                
                // === COMMERCIAL PROXIMITY (Convenience: +0.12) ===
                // OPTIMIZED: Skip if no commercial buildings exist
                let nearestCom = 999;
                for(let com of this.blds) {
                    if(com.t !== 'COM') continue;
                    let dist = Math.abs(x - com.x) + Math.abs(y - com.y);
                    if(dist > 10) continue; // Skip distant ones
                    nearestCom = Math.min(nearestCom, dist);
                    if(dist === 0) break;
                }
                // Commercial within 10 tiles is good
                if(nearestCom <= 10) {
                    score += 0.12 * (1 - (nearestCom / 11));
                }
                
                // === INDUSTRIAL DISTANCE (Pollution penalty: up to -0.20) ===
                // OPTIMIZED: Skip if no industrial buildings exist
                let nearestInd = 999;
                for(let ind of this.blds) {
                    if(ind.t !== 'IND') continue;
                    let dist = Math.abs(x - ind.x) + Math.abs(y - ind.y);
                    if(dist >= 15) continue; // Skip if too far to matter
                    nearestInd = Math.min(nearestInd, dist);
                }
                // Industrial within 3 tiles = severe penalty, 15+ tiles = no penalty
                if(nearestInd < 15) {
                    let penalty = nearestInd < 3 ? -0.20 : -0.20 * (1 - ((nearestInd - 3) / 12));
                    score += penalty;
                }
                
                // === POPULATION DENSITY (Clustering: +0.08) ===
                // OPTIMIZED: Smaller search radius (3 -> 2) and count limit
                let neighbors = 0;
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].zone === 'R') {
                                neighbors++;
                                if(neighbors > 10) break; // Early exit if overcrowded
                            }
                        }
                    }
                    if(neighbors > 10) break;
                }
                // Sweet spot: 2-6 neighbors. Too few = isolated, too many = crowded
                if(neighbors >= 2 && neighbors <= 6) {
                    score += 0.08;
                } else if(neighbors > 6) {
                    // Overcrowding penalty
                    score -= Math.min(0.10, (neighbors - 6) * 0.02);
                } else if(neighbors === 0) {
                    // Severe isolation penalty
                    score -= 0.15;
                }
                
                // === NATURAL FEATURES (Aesthetics: +0.05) ===
                // SIMPLIFIED: Just check immediate surroundings
                let trees = 0;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].tree) trees++;
                        }
                    }
                }
                score += Math.min(0.05, trees * 0.015);
                
                // Clamp between 0 and 1
                return Math.max(0, Math.min(1, score));
            },
            
            attackAnimal(animalIndex) {
                let animal = this.animals[animalIndex];
                animal.hits++;
                
                // Get animal config
                let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                
                if(animal.hits >= config.hitToKill) {
                    // Animal defeated!
                    
                    // HERD DANGER: Check if other animals are on same tile or adjacent
                    let nearbyAnimals = this.animals.filter((a, idx) => {
                        if(idx === animalIndex) return false; // Skip self
                        let dx = Math.abs(a.x - animal.x);
                        let dy = Math.abs(a.y - animal.y);
                        return dx <= 1 && dy <= 1; // Same tile or adjacent
                    });
                    
                    let isHerd = nearbyAnimals.length > 0;
                    let herdDamage = 0;
                    
                    if(isHerd && this.gameState === 'WANDER') {
                        // Herd attack - costs 1-3 population
                        herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                        this.pop = Math.max(0, this.pop - herdDamage);
                        
                        if(this.pop === 0) {
                            Controller.toast("üíÄ Your tribe has perished attacking a herd!");
                            this.animals.splice(animalIndex, 1);
                            Controller.updateUI();
                            return;
                        }
                    }
                    
                    // Calculate food reward (random for animals)
                    let foodReward;
                    if(Array.isArray(config.foodReward)) {
                        // Random range [min, max]
                        foodReward = config.foodReward[0] + Math.floor(Math.random() * (config.foodReward[1] - config.foodReward[0] + 1));
                    } else {
                        // Fixed value (wolf)
                        foodReward = config.foodReward;
                    }
                    
                    // Apply base population cost (wolf costs -1 Pop to kill)
                    let popCost = config.popCost || 0;
                    let popLostMsg = '';
                    if(popCost > 0 && this.pop > 0) {
                        this.pop = Math.max(0, this.pop - popCost);
                        popLostMsg = ` (-${popCost} Pop!)`;
                        
                        // Check for game over
                        if(this.pop === 0) {
                            Controller.showGameOver('HUNTING');
                            return;
                        }
                    }
                    
                    // Add herd damage to message
                    if(herdDamage > 0) {
                        popLostMsg += ` (Herd cost: ${herdDamage} pop)`;
                    }
                    
                    if(this.gameState === 'WANDER') {
                        // Check capacity
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        // Build message with herd context
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        
                        if(spaceAvailable >= foodReward) {
                            this.inventory.food += foodReward;
                            this.totalFoodCollected += foodReward;
                            SoundFX.playCollect('food');
                            Controller.toast(`üéØ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} üçñ`);
                        } else if(spaceAvailable > 0) {
                            this.inventory.food += spaceAvailable;
                            this.totalFoodCollected += spaceAvailable;
                            SoundFX.playCollect('food');
                            Controller.toast(`üéØ ${animalName} defeated!${popLostMsg} +${spaceAvailable}/${foodReward} Food${herdMsg}`);
                        } else {
                            Controller.toast(`üéØ ${animalName} defeated!${popLostMsg} Food lost - Inventory Full!${herdMsg}`);
                        }
                    } else {
                        // City mode - add to main food storage
                        this.food += foodReward;
                        SoundFX.playCollect('food');
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        Controller.toast(`üéØ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} üçñ`);
                    }
                    
                    this.animals.splice(animalIndex, 1);
                    
                    // LORE TRIGGERS: Track first kill and special animal kills
                    if(!this.loreSeen) this.loreSeen = {};
                    if(!this.loreSeen.FIRST_KILL) {
                        this.loreSeen.FIRST_KILL = true;
                        Controller.showLoreEvent('FIRST_KILL');
                    }
                    // Special lore for first turtle kill
                    if(animal.type === 'TURTLE' && !this.loreSeen.FIRST_TURTLE) {
                        this.loreSeen.FIRST_TURTLE = true;
                        Controller.showLoreEvent('FIRST_TURTLE');
                    }
                    
                    this.checkProgression();
                } else {
                    Controller.toast(`üí• Hit ${animalName.toLowerCase()}! (${animal.hits}/${config.hitToKill})`);
                }
                Controller.updateUI();
            },
            
            checkProgression() {
                let unlock = PROGRESSION.checkUnlock(this);
                if(unlock === 'settlement') {
                    Controller.toast("Settlement Unlocked! Explore to find water, then build Mud Huts! üè†");
                    Controller.showSettlementUI();
                    // Immediately check for industrial unlock too
                    this.checkProgression();
                } else if(unlock === 'industrial') {
                    Controller.toast("Hunting Grounds Unlocked! Cost: 1000 Food + 1000 Wood. üè≠");
                    Controller.showIndustrialUI();
                } else if(unlock === 'industrial_need_population') {
                    Controller.toast(`‚ö†Ô∏è Need ${CFG.PRODUCTION.INDUSTRIAL_POPULATION_REQUIREMENT} population to unlock Hunting Grounds!`);
                } else if(unlock === 'industrial_need_food') {
                    Controller.toast(`‚ö†Ô∏è Need ${CFG.PRODUCTION.INDUSTRIAL_UNLOCK_COST} food to unlock Hunting Grounds!`);
                }
            },
            
            settleHere() {
                console.log('settleHere() called!');
                console.log('gameState:', this.gameState);
                console.log('pop:', this.pop);
                console.log('inventory.food:', this.inventory.food);
                console.log('inventory.wood:', this.inventory.wood);
                
                // Record player action for AI learning
                if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                    QLearningAI.recordPlayerAction('SETTLE');
                }
                
                // Prevent settling if already in CITY mode
                if(this.gameState === 'CITY') {
                    Controller.toast("‚ö†Ô∏è Already settled!");
                    return;
                }
                
                // Get requirements from CFG (Master Design v40.0)
                const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                
                // Check requirements: Pop >= 2, Food >= 100, Wood >= 25
                if(this.pop < REQ.MIN_POP) {
                    Controller.toast(`‚ö†Ô∏è Need ${REQ.MIN_POP}+ population to settle! (${this.pop}/${REQ.MIN_POP} - find nomads)`);
                    return;
                }
                if(this.inventory.food < REQ.MIN_FOOD) {
                    Controller.toast(`‚ö†Ô∏è Need ${REQ.MIN_FOOD} food to settle! (${this.inventory.food}/${REQ.MIN_FOOD})`);
                    return;
                }
                if(this.inventory.wood < REQ.MIN_WOOD) {
                    Controller.toast(`‚ö†Ô∏è Need ${REQ.MIN_WOOD} wood to settle! (${this.inventory.wood}/${REQ.MIN_WOOD})`);
                    return;
                }
                
                // Check water proximity for BONUS (not required!)
                let px = this.player.x;
                let py = this.player.y;
                let waterDistance = Infinity;
                let waterFound = false;
                
                // Scan area for fresh water (bonus if nearby)
                for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                    for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                let dist = Math.abs(dx) + Math.abs(dy); // Manhattan distance
                                waterDistance = Math.min(waterDistance, dist);
                                waterFound = true;
                            }
                        }
                    }
                }
                
                // Water nearby is a BONUS, not a requirement
                if(waterFound && waterDistance <= REQ.WATER_DISTANCE) {
                    Controller.toast(`üíß Water nearby! (+Riverside bonus)`);
                }
                
                console.log('All requirements met! Starting settlement...');
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // RESOURCE LOCKING ON SETTLEMENT
                // Berry bush ‚Üí locks as Residential bonus
                // Tree/Forest ‚Üí locks as Commercial bonus  
                // Animal nearby ‚Üí locks as Industrial bonus
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let settleTile = this.tiles[px][py];
                this.lockedResources = {
                    residential: false,  // Berry locked
                    commercial: false,   // Tree locked
                    industrial: false    // Animal locked
                };
                
                // Check for berry on settlement tile
                if(settleTile.entity && settleTile.entity.type === 'BERRY') {
                    this.lockedResources.residential = true;
                    settleTile.entity.locked = true; // Mark as permanently locked
                    console.log('üçá Berry locked for Residential bonus!');
                }
                
                // Check for tree on settlement tile
                if(settleTile.tree || settleTile.type === 'FOREST') {
                    this.lockedResources.commercial = true;
                    settleTile.lockedTree = true; // Mark tree as locked
                    console.log('üå≤ Tree locked for Commercial bonus!');
                }
                
                // Check for animal adjacent to settlement (within 2 tiles)
                let foundAnimal = false;
                for(let dx = -2; dx <= 2 && !foundAnimal; dx++) {
                    for(let dy = -2; dy <= 2 && !foundAnimal; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            // Check animals array for nearby animal
                            for(let animal of this.animals) {
                                if(animal.x === x && animal.y === y) {
                                    this.lockedResources.industrial = true;
                                    animal.locked = true; // Mark animal as locked
                                    this.lockedAnimal = animal;
                                    foundAnimal = true;
                                    console.log('ü¶å Animal locked for Industrial bonus!');
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Scan 5x5 area for site traits (bonus features)
                let stoneCount = 0;
                let berryCount = 0;
                
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'STONE') stoneCount++;
                            if(tile.entity && tile.entity.type === 'BERRY') berryCount++;
                        }
                    }
                }
                
                // Determine site traits
                this.siteTraits = [];
                if(waterDistance <= 2) this.siteTraits.push('Riverside');
                if(stoneCount >= 3) this.siteTraits.push('Mineral Rich');
                if(berryCount >= 2) this.siteTraits.push('Fertile');
                if(waterDistance <= 2 && berryCount >= 2) this.siteTraits.push('Paradise');
                
                // Transition to CITY mode
                console.log('Transitioning to CITY mode...');
                this.gameState = 'CITY';
                console.log('gameState set to CITY');
                this.settlementPos = { x: px, y: py };
                
                // CONVERT wander wells to city wells - they persist into city mode!
                // Each wanderWell becomes a WELL building in blds array
                let convertedWells = 0;
                if(this.wanderWells && this.wanderWells.length > 0) {
                    for(let well of this.wanderWells) {
                        // Add as city building well
                        this.blds.push({ t: 'WELL', x: well.x, y: well.y, lvl: 1, efficiency: 1.0, age: 0 });
                        convertedWells++;
                    }
                    console.log(`Converted ${convertedWells} wander wells to city wells`);
                }
                this.wanderWells = [];
                console.log('Wander wells cleared after conversion to city mode');
                
                // Transfer inventory to main resources (no deduction - resources persist)
                this.food = this.inventory.food;
                this.wood = this.inventory.wood;
                this.metal = this.inventory.metal;
                this.stone = this.inventory.stone;
                console.log('Resources transferred:', {food: this.food, wood: this.wood, metal: this.metal, stone: this.stone});
                
                // POPULATION-BASED SETTLEMENT BONUSES
                // More nomads recruited = stronger start
                let popBonus = Math.floor((this.pop - 1) * 10); // Each nomad adds +10% bonus
                let gatheringMultiplier = 0.5 + (this.pop * 0.1); // 0.5 base + 0.1 per nomad (caps at reasonable levels)
                
                // Apply population bonus to starting resources
                if (popBonus > 0) {
                    let bonusFood = Math.floor(Number(this.food) * (popBonus / 100));
                    let bonusWood = Math.floor(Number(this.wood) * (popBonus / 100));
                    this.food = Number(this.food) + bonusFood;
                    this.wood = Number(this.wood) + bonusWood;
                    console.log(`Population bonus (${this.pop} people): +${bonusFood} food, +${bonusWood} wood`);
                }
                
                // Set gathering rate based on initial population
                this.gatheringMultiplier = Math.min(3.0, gatheringMultiplier); // Cap at 3x
                console.log(`Gathering rate: ${(this.gatheringMultiplier * 100).toFixed(0)}% (${this.pop} settlers)`);
                
                let traitText = this.siteTraits.length > 0 ? ` (${this.siteTraits.join(', ')})` : '';
                let bonusText = popBonus > 0 ? ` +${popBonus}% Resources!` : '';
                let gatherText = this.gatheringMultiplier > 1.0 ? ` Gathering: ${(this.gatheringMultiplier * 100).toFixed(0)}%` : '';
                let wellText = convertedWells > 0 ? ` üíß${convertedWells} wells transferred!` : '';
                
                // Build locked resources text
                let lockedText = '';
                if(this.lockedResources.residential || this.lockedResources.commercial || this.lockedResources.industrial) {
                    let locked = [];
                    if(this.lockedResources.residential) locked.push('üçá Berries‚ÜíResidential');
                    if(this.lockedResources.commercial) locked.push('üå≤ Trees‚ÜíCommercial');
                    if(this.lockedResources.industrial) locked.push('ü¶å Animals‚ÜíIndustrial');
                    lockedText = ` [Locked: ${locked.join(', ')}]`;
                }
                
                Controller.toast(`üèõÔ∏è Settlement Started!${traitText}${bonusText}${gatherText}${wellText}${lockedText}`);
                console.log('Calling Controller.showCityUI()...');
                
                // LORE TRIGGER: First settlement!
                Controller.showLoreEvent('FIRST_SETTLEMENT');
                
                // Force UI update
                setTimeout(() => {
                    console.log('Delayed showCityUI call...');
                    Controller.showCityUI();
                    // Always show and enable t-res after settlement
                    let tResBtn = document.getElementById('t-res');
                    if (tResBtn) {
                        tResBtn.style.display = 'inline-block';
                        tResBtn.disabled = false;
                        tResBtn.title = 'Build Residential';
                    }
                    Controller.updateUI();
                    console.log('Settlement complete!');
                    
                    // Check progression to unlock industrial immediately after settlement
                    this.checkProgression();
                }, 100);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // BUILD WANDER WELL (Level 0 only structure)
            // Cost: 25 food + 50 wood
            // Allows player to drink from well to reset thirst
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            buildWanderWell() {
                if(this.gameState !== 'WANDER') {
                    Controller.toast("‚ö†Ô∏è Can only build Water Pits while wandering!");
                    return false;
                }
                
                const WELL_COST = { food: 25, wood: 50 };
                
                // Check resources
                if(this.inventory.food < WELL_COST.food) {
                    Controller.toast(`‚ö†Ô∏è Need ${WELL_COST.food} food to dig a Water Pit! (${Math.floor(this.inventory.food)}/${WELL_COST.food})`);
                    return false;
                }
                if(this.inventory.wood < WELL_COST.wood) {
                    Controller.toast(`‚ö†Ô∏è Need ${WELL_COST.wood} wood to dig a Water Pit! (${Math.floor(this.inventory.wood)}/${WELL_COST.wood})`);
                    return false;
                }
                
                // Check if tile is buildable
                let px = this.player.x;
                let py = this.player.y;
                let tile = this.tiles[px][py];
                
                if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                    Controller.toast("‚ö†Ô∏è Can't build on water! You can drink here already.");
                    return false;
                }
                if(tile.type === 'STONE') {
                    Controller.toast("‚ö†Ô∏è Too rocky to dig here!");
                    return false;
                }
                
                // Check if well already exists at this location
                if(this.wanderWells.some(w => w.x === px && w.y === py)) {
                    Controller.toast("‚ö†Ô∏è There's already a Water Pit here!");
                    return false;
                }
                
                // Deduct resources
                this.inventory.food -= WELL_COST.food;
                this.inventory.wood -= WELL_COST.wood;
                
                // Create well
                this.wanderWells.push({ x: px, y: py });
                
                // Reset thirst immediately after building
                this.thirstCounter = 0;
                this.thirst = 100;
                
                // LORE TRIGGER: First well!
                if(this.wanderWells.length === 1) {
                    Controller.showLoreEvent('FIRST_WELL');
                }
                
                Controller.toast(`üï≥Ô∏è Built a Water Pit! (-${WELL_COST.food} food, -${WELL_COST.wood} wood) | You have ${this.wanderWells.length} well(s)`);
                Controller.updateUI();
                return true;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SMART BUILD WELL - Works in both WANDER and CITY modes
            // WANDER: Builds Water Pit at player location (25 food + 50 wood)
            // CITY: Sets tool to WELL for placement mode (20 food)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            smartBuildWell() {
                if(this.gameState === 'WANDER') {
                    // In WANDER mode, build a water pit at player location
                    this.buildWanderWell();
                } else {
                    // In CITY mode, use the placement tool
                    Controller.setTool('WELL');
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // DEBUG FUNCTIONS - For testing the game faster
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            debugAddPopulation(amount) {
                this.pop += amount;
                if(this.gameState === 'CITY') {
                    // In city mode, also increase housing cap so people don't leave
                    this.housingCap = Math.max(this.housingCap, this.pop + 100);
                }
                Controller.toast(`üêõ DEBUG: +${amount} population (now ${this.pop})`);
                Controller.updateUI();
            },
            
            debugAddResources(amount) {
                if(this.gameState === 'WANDER') {
                    // In WANDER mode, add to inventory
                    this.inventory.food += amount;
                    this.inventory.wood += amount;
                    this.inventory.metal += amount;
                    this.inventory.stone += amount;
                    this.inventory.capacity = Math.max(this.inventory.capacity, 
                        this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone + 100);
                    Controller.toast(`üêõ DEBUG: +${amount} to all inventory (WANDER)`);
                } else {
                    // In CITY mode, add to main resources
                    this.food += amount;
                    this.wood += amount;
                    this.metal += amount;
                    this.stone += amount;
                    this.res += amount; // Gold too
                    Controller.toast(`üêõ DEBUG: +${amount} to all resources (CITY)`);
                }
                Controller.updateUI();
            },
            
            isValid(gx, gy, tool) {
                // All zones are 1x1 per documentation (RES, COM, IND, ROAD, WELL, storage pits)
                let sz = 1;
                let szW = 1, szH = 1; // Width and Height for non-square buildings
                
                // Special buildings are 2x2
                if(tool === 'CHIEF' || tool === 'PALACE' || tool === 'GRANARY' || tool === 'BASKET' || tool === 'POTTERY' || tool === 'CLAN_CHIEF') {
                    sz = 2;
                    szW = 2;
                    szH = 2;
                }
                // DOCK is 3x2
                if(tool === 'DOCK') {
                    szW = 3;
                    szH = 2;
                    sz = Math.max(szW, szH);
                }
                
                if(gx<0 || gy<0 || gx+szW>CFG.W || gy+szH>CFG.H) return false;
                
                // Check for water, existing zones, roads, buildings - hard blocks
                for(let x=gx; x<gx+szW; x++) {
                    for(let y=gy; y<gy+szH; y++) { 
                        let tile = this.tiles[x][y];
                        let t = tile.type; 
                        if(t=='WATER'||t=='DEEP'||t=='RIVER'||t=='STONE') return false;
                        
                        // === NEW: Cannot build on unexplored tiles! ===
                        if(!tile.explored) {
                            Controller.toast('‚ö†Ô∏è Cannot build in fog - explore first!');
                            return false;
                        }
                        
                        // Stone deposits block most buildings (industrial can override)
                        if(tile.stoneDeposit && tool !== 'IND') return false;
                        
                        // Check for existing zone or building on tile (RES uses tile.zone system)
                        if(tile.zone || tile.building) return false;
                        
                        // Check for roads (can't build on roads)
                        if(tile.road) return false;
                    }
                }
                
                // Check for building overlap (COM/IND/WELL/storage pits use blds array)
                for(let b of this.blds) { 
                    // Get building size - check config first, then fallback to type-based sizes
                    let bConfig = CFG.BUILDING_DB && CFG.BUILDING_DB[b.t];
                    let bzW = 1, bzH = 1;
                    if(bConfig && bConfig.size) {
                        bzW = bConfig.size.w;
                        bzH = bConfig.size.h;
                    } else if(b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') {
                        bzW = 1; bzH = 1;
                    } else if(b.t === 'DOCK') {
                        bzW = 3; bzH = 2;
                    } else {
                        bzW = 2; bzH = 2;
                    }
                    if(gx<b.x+bzW && gx+szW>b.x && gy<b.y+bzH && gy+szH>b.y) return false; 
                }
                
                return true;
            },
            
            // Silent road placement for drag-to-build (no toast messages)
            placeRoadSilent(rx, ry) {
                // Bounds check
                if(rx < 0 || rx >= CFG.W || ry < 0 || ry >= CFG.H) return false;
                let tile = this.tiles[rx]?.[ry];
                if(!tile) return false;
                if (tile.type == 'WATER' || tile.type == 'DEEP' || tile.type == 'RIVER' || tile.type == 'STONE') return false;
                if (!tile.explored) return false;
                if (tile.stoneDeposit) return false;
                if (tile.road) return false; // Already has road
                
                // Check cost
                if(this.simcityMode && this.res < CFG.COST.ROAD) return false;
                else if(!this.simcityMode && this.food < CFG.COST.ROAD) return false;
                
                // Place the road
                tile.road = true; 
                tile.tree = false;
                if (tile.entity) tile.entity = null;
                if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(rx, ry);
                this.roadTileCount = (this.roadTileCount || 0) + 1;
                
                // Roads reveal fog of war (smaller radius than buildings)
                this.exploreArea(rx, ry, 2);
                
                // Record road action
                if(typeof recordBuildAction === 'function') recordBuildAction('ROAD', rx, ry);
                
                if(this.simcityMode) this.res -= CFG.COST.ROAD;
                else this.food -= CFG.COST.ROAD;
                
                this.recalc();
                return true;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SILENT ZONE PLACEMENT - For drag-to-paint highlighter tool
            // These allow painting zones quickly without toast spam
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Silent RES zone placement for drag-to-paint
            placeResSilent(gx, gy) {
                if(this.gameState !== 'CITY') return false;
                if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return false;
                let tile = this.tiles[gx]?.[gy];
                if(!tile) return false;
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(!tile.explored) return false;
                if(tile.zone || tile.building || tile.road) return false;
                
                let selectedLevel = Controller.selectedBuildingLevel || 1;
                let levelConfig = CFG.BUILDING_LEVELS[selectedLevel];
                if(!levelConfig) return false;
                
                // Calculate costs with elevation
                let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                let adjFoodCost = Math.ceil(levelConfig.food * elevCostMult);
                let adjWoodCost = Math.ceil((levelConfig.wood || 0) * elevCostMult);
                let adjStoneCost = Math.ceil((levelConfig.stone || 0) * elevCostMult);
                
                // Check resources
                if(this.food < adjFoodCost) return false;
                if(adjWoodCost > 0 && this.wood < adjWoodCost) return false;
                if(adjStoneCost > 0 && this.stone < adjStoneCost) return false;
                
                // Deduct resources
                this.food -= adjFoodCost;
                if(adjWoodCost > 0) this.wood -= adjWoodCost;
                if(adjStoneCost > 0) this.stone -= adjStoneCost;
                
                // Calculate zone bonus
                let zoneBonus = this.calculateZoneBonus(gx, gy, 'RES');
                
                // Place zone
                tile.zone = 'R';
                tile.building = {
                    level: selectedLevel,
                    growth: 0,
                    desirability: zoneBonus,
                    age: 0,
                    lastBirthYear: this.year,
                    pop: 0,
                    capacity: levelConfig.capacity,
                    variant: 1
                };
                tile.tree = false;
                
                if(typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                this.exploreArea(gx, gy, 3);
                this.markDirty(gx, gy, 1);
                this.recalc();
                return true;
            },
            
            // Silent COM zone placement for drag-to-paint
            placeComSilent(gx, gy) {
                if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return false;
                let tile = this.tiles[gx]?.[gy];
                if(!tile) return false;
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(!tile.explored) return false;
                if(tile.zone || tile.road) return false;
                
                // Check if already has building in blds array at this spot
                for(let b of this.blds) {
                    if(b.x === gx && b.y === gy) return false;
                }
                
                let selectedLevel = Controller.selectedCommercialLevel || 1;
                let buildingData = CFG.BUILDING_DB['COM_' + selectedLevel];
                if(!buildingData) return false;
                let levelCost = buildingData.cost;
                
                // Calculate costs with elevation
                let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                let adjFoodCost = Math.ceil(levelCost.food * elevCostMult);
                let adjWoodCost = Math.ceil(levelCost.wood * elevCostMult);
                let adjStoneCost = Math.ceil((levelCost.stone || 0) * elevCostMult);
                
                // Check resources
                if(this.food < adjFoodCost) return false;
                if(this.wood < adjWoodCost) return false;
                if(adjStoneCost > 0 && this.stone < adjStoneCost) return false;
                
                // Deduct resources
                this.food -= adjFoodCost;
                this.wood -= adjWoodCost;
                if(adjStoneCost > 0) this.stone -= adjStoneCost;
                
                // Calculate zone bonus
                let zoneBonus = this.calculateZoneBonus(gx, gy, 'COM');
                
                // Place building
                tile.tree = false;
                this.blds.push({ 
                    t: 'COM', 
                    x: gx, 
                    y: gy, 
                    lvl: selectedLevel, 
                    efficiency: zoneBonus,
                    age: 0,
                    variant: 1
                });
                
                if(typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                
                // Record action
                if(typeof recordBuildAction === 'function') recordBuildAction('COM', gx, gy);
                
                this.exploreArea(gx, gy, 3);
                this.recalc();
                return true;
            },
            
            // Silent IND zone placement for drag-to-paint
            placeIndSilent(gx, gy) {
                if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return false;
                let tile = this.tiles[gx]?.[gy];
                if(!tile) return false;
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(!tile.explored) return false;
                if(tile.zone || tile.road) return false;
                
                // Check if already has building in blds array at this spot
                for(let b of this.blds) {
                    if(b.x === gx && b.y === gy) return false;
                }
                
                let selectedLevel = Controller.selectedIndustrialLevel || 1;
                let levelConfig = CFG.INDUSTRIAL_LEVELS[selectedLevel];
                if(!levelConfig) return false;
                
                // Check if level is unlocked
                if(!PROGRESSION.unlockedIndustrialLevels.includes(selectedLevel)) return false;
                
                // Calculate costs with elevation
                let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                let adjFoodCost = Math.ceil(levelConfig.food * elevCostMult);
                let adjWoodCost = Math.ceil(levelConfig.wood * elevCostMult);
                let adjStoneCost = Math.ceil((levelConfig.stone || 0) * elevCostMult);
                let adjMetalCost = Math.ceil((levelConfig.metal || 0) * elevCostMult);
                
                // Check resources
                if(this.food < adjFoodCost) return false;
                if(this.wood < adjWoodCost) return false;
                if(adjStoneCost > 0 && this.stone < adjStoneCost) return false;
                if(adjMetalCost > 0 && this.metal < adjMetalCost) return false;
                
                // Deduct resources
                this.food -= adjFoodCost;
                this.wood -= adjWoodCost;
                if(adjStoneCost > 0) this.stone -= adjStoneCost;
                if(adjMetalCost > 0) this.metal -= adjMetalCost;
                
                // Check for stone deposit
                let hasStoneDeposit = tile.stoneDeposit ? true : false;
                // Cap metal value to prevent legacy/buggy deposits from giving millions
                let rawMetal = hasStoneDeposit ? tile.stoneDeposit.metal : 0;
                let totalMetal = Math.min(rawMetal, CFG.STONE_DEPOSITS.MAX_METAL);
                if(hasStoneDeposit) {
                    this.metal += totalMetal;
                    tile.stoneDeposit = null;
                }
                
                // Calculate zone bonus
                let zoneBonus = this.calculateZoneBonus(gx, gy, 'IND');
                
                // Place building
                tile.tree = false;
                this.blds.push({ 
                    t: 'IND', 
                    x: gx, 
                    y: gy, 
                    lvl: selectedLevel, 
                    efficiency: zoneBonus,
                    age: 0,
                    onDeposit: hasStoneDeposit,
                    desirability: 0.5,
                    variant: 1
                });
                
                if(typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                
                // Record action
                if(typeof recordBuildAction === 'function') recordBuildAction('IND', gx, gy);
                
                this.exploreArea(gx, gy, 3);
                this.recalc();
                return true;
            },
            
            // Silent WELL placement for drag-to-paint
            placeWellSilent(gx, gy) {
                if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return false;
                let tile = this.tiles[gx]?.[gy];
                if(!tile) return false;
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(!tile.explored) return false;
                if(tile.zone || tile.road || tile.building) return false;
                
                // Check if already has building at this spot
                for(let b of this.blds) {
                    if(b.x === gx && b.y === gy) return false;
                }
                
                // Check cost
                let cost = CFG.COST.WELL || 100;
                if(this.simcityMode && this.res < cost) return false;
                else if(!this.simcityMode && this.food < cost) return false;
                
                // Deduct cost
                if(this.simcityMode) this.res -= cost;
                else this.food -= cost;
                
                // Place the well
                this.blds.push({ t: 'WELL', x: gx, y: gy, lvl: 1, age: 0 });
                tile.tree = false;
                if(typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                
                // Record action
                if(typeof recordBuildAction === 'function') recordBuildAction('WELL', gx, gy);
                
                this.exploreArea(gx, gy, 3);
                return true;
            },
            
            // Silent DEMOLISH for drag-to-demolish (SimCity style area demolition)
            demolishSilent(gx, gy) {
                if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return false;
                let tile = this.tiles[gx]?.[gy];
                if(!tile) return false;
                
                let demolished = false;
                
                // Remove road
                if(tile.road) {
                    tile.road = false;
                    demolished = true;
                }
                
                // Remove zone
                if(tile.zone) {
                    tile.zone = null;
                    demolished = true;
                }
                
                // Remove building at this spot
                for(let i = this.blds.length - 1; i >= 0; i--) {
                    let b = this.blds[i];
                    let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                    if(gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) {
                        this.blds.splice(i, 1);
                        demolished = true;
                        break;
                    }
                }
                
                if(demolished && typeof Renderer !== 'undefined' && Renderer.addDust) {
                    Renderer.addDust(gx, gy);
                }
                
                return demolished;
            },
            
            build(t, gx, gy) {
                try {
                    console.log('build() called:', {tool: t, x: gx, y: gy});
                    
                    // Record player action for AI learning - NOW WITH POSITION!
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        let action = 'BUILD_' + (t === 'RES' ? 'RES' : t === 'IND' ? 'IND' : t === 'COM' ? 'COM' : t === 'WELL' ? 'WELL' : t === 'ROAD' ? 'ROAD' : 'OTHER');
                        QLearningAI.recordPlayerAction(action, gx, gy);
                    }
                    
                    // Record for Blueprint AI Watch Mode
                    if(typeof BlueprintAI !== 'undefined' && BlueprintAI.watchMode) {
                        BlueprintAI.recordPlayerBuild(t, gx, gy, this);
                    }
                    
                    // BULLDOZER: Remove zones or buildings
                    if(t === 'BULL') {
                    if(this.simcityMode && this.res < CFG.COST.BULL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < 1) return Controller.toast("Need Food");
                    
                    // Clear zone and building from tile
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        if(this.simcityMode) this.res -= CFG.COST.BULL;
                        else this.food -= 1;
                        Controller.toast("Zone Cleared");
                    }
                    // Check for buildings - COM/IND/WELL are 1x1, others are 2x2
                    else {
                        let hit = -1;
                        for (let i = 0; i < this.blds.length; i++) { 
                            let b = this.blds[i]; 
                            let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2; 
                            if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                                hit = i; 
                                break; 
                            } 
                        }
                        if (hit !== -1) { 
                            this.blds.splice(hit, 1); 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Demolished"); 
                        }
                        else if (this.tiles[gx][gy].road) { 
                            this.tiles[gx][gy].road = false; 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Road Removed"); 
                        }
                    }
                    this.recalc();
                    return;
                }
                
                // ROADS - supports diagonal placement by drawing lines between clicks
                if (t == 'ROAD') {
                    console.log('Road building - gx:', gx, 'gy:', gy, 'food:', this.food, 'lastRoadPos:', this.lastRoadPos);
                    
                    // Helper to place single road tile
                    const placeRoadTile = (rx, ry, showError = false) => {
                        // Bounds check
                        if(rx < 0 || rx >= CFG.W || ry < 0 || ry >= CFG.H) {
                            if(showError) Controller.toast("Out of bounds");
                            console.log('Road fail: out of bounds', rx, ry);
                            return false;
                        }
                        let tile = this.tiles[rx]?.[ry];
                        if(!tile) {
                            if(showError) Controller.toast("Invalid tile");
                            console.log('Road fail: invalid tile', rx, ry);
                            return false;
                        }
                        if (tile.type == 'WATER' || tile.type == 'DEEP' || tile.type == 'RIVER' || tile.type == 'STONE') {
                            if(showError) Controller.toast("Can't build on water/stone");
                            console.log('Road fail: water/stone', rx, ry, tile.type);
                            return false;
                        }
                        // === NEW: Cannot build road on unexplored tiles! ===
                        if (!tile.explored) {
                            if(showError) Controller.toast("‚ö†Ô∏è Cannot build in fog - explore first!");
                            console.log('Road fail: unexplored', rx, ry);
                            return false;
                        }
                        if (tile.stoneDeposit) {
                            if(showError) Controller.toast("Stone deposit blocking");
                            console.log('Road fail: stone deposit', rx, ry);
                            return false;
                        }
                        if (tile.road) {
                            if(showError) Controller.toast("Road already exists");
                            console.log('Road fail: already exists', rx, ry);
                            return false;
                        }
                        
                        // Check if we can afford it
                        if(this.simcityMode && this.res < CFG.COST.ROAD) {
                            if(showError) Controller.toast(`Need $${CFG.COST.ROAD} funds`);
                            console.log('Road fail: no funds');
                            return false;
                        }
                        else if(!this.simcityMode && this.food < CFG.COST.ROAD) {
                            if(showError) Controller.toast(`Need ${CFG.COST.ROAD} food`);
                            console.log('Road fail: no food', this.food, '<', CFG.COST.ROAD);
                            return false;
                        }
                        
                        console.log('Road SUCCESS at', rx, ry);
                        tile.road = true; 
                        tile.tree = false;
                        // Remove any entity (berry bush, etc) - roads destroy resources
                        if (tile.entity) {
                            tile.entity = null;
                        }
                        if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(rx, ry);
                        this.roadTileCount = (this.roadTileCount || 0) + 1;
                        
                        // Roads reveal fog of war (smaller radius than buildings)
                        this.exploreArea(rx, ry, 2);
                        
                        // Record road action
                        if(typeof recordBuildAction === 'function') recordBuildAction('ROAD', rx, ry);
                        
                        if(this.simcityMode) this.res -= CFG.COST.ROAD;
                        else this.food -= CFG.COST.ROAD;
                        return true;
                    };
                    
                    // Get tiles in a line between two points (Bresenham's algorithm)
                    const getLineTiles = (x0, y0, x1, y1) => {
                        let tiles = [];
                        let dx = Math.abs(x1 - x0);
                        let dy = Math.abs(y1 - y0);
                        let sx = x0 < x1 ? 1 : -1;
                        let sy = y0 < y1 ? 1 : -1;
                        let err = dx - dy;
                        let safety = 0;
                        let maxIter = 500;
                        
                        while (safety < maxIter) {
                            safety++;
                            tiles.push({x: x0, y: y0});
                            if (x0 === x1 && y0 === y1) break;
                            let e2 = 2 * err;
                            if (e2 > -dy) { err -= dy; x0 += sx; }
                            if (e2 < dx) { err += dx; y0 += sy; }
                        }
                        return tiles;
                    };
                    
                    // DIAGONAL ROADS: Hold shift + click to draw a line from last road
                    // Or just click to place single road
                    if (this.lastRoadPos && Controller.shiftHeld && (this.lastRoadPos.x !== gx || this.lastRoadPos.y !== gy)) {
                        // Draw diagonal line from last position to current
                        let lineTiles = getLineTiles(this.lastRoadPos.x, this.lastRoadPos.y, gx, gy);
                        let placed = 0;
                        let skipped = 0;
                        for (let t of lineTiles) {
                            if (t.x >= 0 && t.x < CFG.W && t.y >= 0 && t.y < CFG.H) {
                                let tile = this.tiles[t.x]?.[t.y];
                                // Skip tiles that already have roads (not an error)
                                if (tile && tile.road) {
                                    skipped++;
                                    continue;
                                }
                                if (placeRoadTile(t.x, t.y, false)) placed++;
                            }
                        }
                        if (placed > 0) {
                            Controller.toast(`üõ£Ô∏è Drew ${placed} road tiles!`);
                        } else if (skipped > 0) {
                            Controller.toast(`üõ£Ô∏è Road complete (${skipped} already paved)`);
                        } else {
                            Controller.toast("‚ö†Ô∏è Can't place roads there");
                        }
                    } else {
                        // Single click - place one road
                        if (placeRoadTile(gx, gy, true)) {
                            Controller.toast("üõ£Ô∏è Road placed! (Shift+click for diagonal)");
                        }
                    }
                    
                    // Remember this position for diagonal drawing
                    this.lastRoadPos = {x: gx, y: gy};
                    this.recalc();
                    return;
                }
                
                // WELLS (keep as instant building)
                if(t === 'WELL') {
                    if(this.simcityMode && this.res < CFG.COST.WELL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < CFG.COST.WELL) return Controller.toast("Need Food");
                    
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    this.tiles[gx][gy].tree = false;
                    this.blds.push({ t: 'WELL', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    if(this.simcityMode) this.res -= CFG.COST.WELL;
                    else this.food -= CFG.COST.WELL;
                    this.recalc();
                    return;
                }
                
                // CHIEF'S HUT (special 2x2 building with culture bonus)
                if(t === 'CHIEF') {
                    if(this.food < CFG.CHIEF_COST) return Controller.toast(`Need ${CFG.CHIEF_COST} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 2x2 area
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'CHIEF', x: gx, y: gy });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.CHIEF_COST;
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    Controller.toast("üèõÔ∏è First Chief's Hut built! +Culture Bonus in 50-tile radius");
                    this.recalc();
                    return;
                }
                
                // CLAN CHIEF'S HUT (milestone - unlocks L4-L6 buildings)
                if(t === 'CLAN_CHIEF') {
                    let config = CFG.BUILDING_DB['CLAN_CHIEF'];
                    if(!config) return Controller.toast("Building config not found");
                    
                    // Check if already built
                    if(this.hasClanChief) return Controller.toast("‚úÖ Clan Chief's Hut already built!");
                    
                    // Check population requirement
                    if(config.unlockReq && config.unlockReq.pop && this.pop < config.unlockReq.pop) {
                        return Controller.toast(`Need ${config.unlockReq.pop} Population`);
                    }
                    
                    // Check resources
                    if(this.food < config.cost.food) return Controller.toast(`Need ${Controller.formatNum(config.cost.food)} Food`);
                    if(this.wood < config.cost.wood) return Controller.toast(`Need ${Controller.formatNum(config.cost.wood)} Wood`);
                    if((this.gold || 0) < config.cost.gold) return Controller.toast(`Need ${config.cost.gold} Gold`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 2x2 area
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            if(this.tiles[x] && this.tiles[x][y]) {
                                this.tiles[x][y].tree = false;
                            }
                        }
                    }
                    
                    this.blds.push({ t: 'CLAN_CHIEF', x: gx, y: gy, lvl: 1 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resources
                    this.food -= config.cost.food;
                    this.wood -= config.cost.wood;
                    this.gold = (this.gold || 0) - config.cost.gold;
                    
                    // Set milestone flag
                    this.hasClanChief = true;
                    
                    this.exploreArea(gx, gy, 5);
                    Controller.toast("üèõÔ∏è Clan Chief's Hut built! Level 4-6 buildings now available!");
                    this.recalc();
                    return;
                }
                
                // FIRST DOCK (milestone - unlocks L7+ buildings)
                if(t === 'DOCK') {
                    let config = CFG.BUILDING_DB['DOCK'];
                    if(!config) return Controller.toast("Building config not found");
                    
                    // Check prerequisites
                    if(!this.hasClanChief) return Controller.toast("üîí Build Clan Chief's Hut first!");
                    
                    // Check if already built
                    if(this.hasDock) return Controller.toast("‚úÖ First Dock already built!");
                    
                    // Check resources
                    if(this.food < config.cost.food) return Controller.toast(`Need ${Controller.formatNum(config.cost.food)} Food`);
                    if(this.wood < config.cost.wood) return Controller.toast(`Need ${Controller.formatNum(config.cost.wood)} Wood`);
                    if((this.gold || 0) < config.cost.gold) return Controller.toast(`Need ${config.cost.gold} Gold`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 3x2 area
                    for(let x=gx; x<gx+3; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            if(this.tiles[x] && this.tiles[x][y]) {
                                this.tiles[x][y].tree = false;
                            }
                        }
                    }
                    
                    this.blds.push({ t: 'DOCK', x: gx, y: gy, lvl: 1 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resources
                    this.food -= config.cost.food;
                    this.wood -= config.cost.wood;
                    this.gold = (this.gold || 0) - config.cost.gold;
                    
                    // Set milestone flag
                    this.hasDock = true;
                    
                    this.exploreArea(gx, gy, 5);
                    Controller.toast("‚öì First Dock built! Level 7+ buildings now available!");
                    this.recalc();
                    return;
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // STORAGE PITS - REMOVED (use Monolithic Resource Pit instead)
                // Storage is now 1 million base, build Nuts Storage Reed House for 50 million
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const storagePitTypes = ['FOOD_PIT', 'WOOD_PIT', 'STONE_PIT', 'METAL_PIT'];
                if(storagePitTypes.includes(t)) {
                    return Controller.toast("‚ùå Storage Pits removed! You have 1M base storage. Build Monolithic Resource Pit for 50M!");
                }
                
                // STORAGE BUILDINGS (reduce food spoilage)
                if(t === 'BASKET') {
                    if(this.pop < CFG.BUILDINGS.BASKET.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.BASKET.cost) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'BASKET', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.BASKET.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`üß∫ Basket built! +${CFG.BUILDINGS.BASKET.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'POTTERY') {
                    if(this.pop < CFG.BUILDINGS.POTTERY.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.POTTERY.cost) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'POTTERY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.POTTERY.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`üè∫ Pottery built! +${CFG.BUILDINGS.POTTERY.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'GRANARY') {
                    // MONOLITHIC RESOURCE PIT - Costs 1M food + 1M wood
                    let granary = CFG.BUILDINGS.GRANARY;
                    if(this.pop < granary.reqPop) return Controller.toast(`Need ${Controller.formatNum(granary.reqPop)} Population`);
                    if(this.food < granary.food) return Controller.toast(`Need ${Controller.formatNum(granary.food)} Food`);
                    if(this.wood < granary.wood) return Controller.toast(`Need ${Controller.formatNum(granary.wood)} Wood`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'GRANARY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= granary.food;
                    this.wood -= granary.wood;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`üóø Monolithic Resource Pit built! +${Controller.formatNum(granary.cap)} storage | Rot reduced to 10%`);
                    this.recalc();
                    return;
                }
                
                if(t === 'PALACE') {
                    if(this.pop < CFG.BUILDINGS.PALACE.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.PALACE.cost) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'PALACE', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.PALACE.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`üè∞ Palace built! +${CFG.BUILDINGS.PALACE.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                // INDUSTRIAL BUILDING (1x1 - Hunting Ground, Hunting Pit, etc.)
                if(t === 'IND') {
                    // Get selected industrial level from Controller
                    let selectedLevel = Controller.selectedIndustrialLevel || 1;
                    let levelConfig = CFG.INDUSTRIAL_LEVELS[selectedLevel];
                    
                    if(!levelConfig) {
                        return Controller.toast("Invalid industrial level!");
                    }
                    
                    // Check if level is unlocked
                    if(!PROGRESSION.unlockedIndustrialLevels.includes(selectedLevel)) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(selectedLevel, this);
                        return Controller.toast(info.text);
                    }
                    
                    // Validate 1x1 spot first (needed for elevation check)
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    
                    // Calculate elevation cost multiplier (highland building costs more)
                    let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                    let elevCostInfo = this.getElevationCostInfo(gx, gy);
                    let adjFoodCost = Math.ceil(levelConfig.food * elevCostMult);
                    let adjWoodCost = Math.ceil(levelConfig.wood * elevCostMult);
                    let adjStoneCost = Math.ceil((levelConfig.stone || 0) * elevCostMult);
                    let adjMetalCost = Math.ceil((levelConfig.metal || 0) * elevCostMult);
                    
                    // Check resource costs (with elevation adjustment - cost shown but not reason)
                    if(this.food < adjFoodCost) return Controller.toast(`Need ${adjFoodCost} Food`);
                    if(this.wood < adjWoodCost) return Controller.toast(`Need ${adjWoodCost} Wood`);
                    if(adjStoneCost > 0 && this.stone < adjStoneCost) return Controller.toast(`Need ${adjStoneCost} Stone`);
                    if(adjMetalCost > 0 && this.metal < adjMetalCost) return Controller.toast(`Need ${adjMetalCost} Metal`);
                    
                    // Check for stone deposit bonus (single tile) - calculate BEFORE clearing
                    let hasStoneDeposit = tile.stoneDeposit ? true : false;
                    // Cap metal value to prevent legacy/buggy deposits from giving millions
                    let rawMetal = hasStoneDeposit ? tile.stoneDeposit.metal : 0;
                    let totalMetal = Math.min(rawMetal, CFG.STONE_DEPOSITS.MAX_METAL);
                    
                    // Validate tile type
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // Clear tree (but don't clear stoneDeposit yet - need metal value!)
                    tile.tree = false;
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'IND');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'IND');
                    
                    // Flood risk - kept internal, not shown to player (mystery mode)
                    // Player discovers flood dangers through gameplay, not warnings
                    
                    // Create 1x1 industrial building with level and variant support
                    this.blds.push({ 
                        t: 'IND', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0, 
                        onDeposit: hasStoneDeposit,
                        desirability: 0.5,  // Start at medium
                        variant: 1          // Start at Low variant
                    });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Record action
                    if(typeof recordBuildAction === 'function') recordBuildAction('IND', gx, gy);
                    
                    // Deduct costs (with elevation adjustment)
                    this.food -= adjFoodCost;
                    this.wood -= adjWoodCost;
                    if(adjStoneCost > 0) this.stone -= adjStoneCost;
                    if(adjMetalCost > 0) this.metal -= adjMetalCost;
                    
                    // Give metal bonus if built on deposits
                    if(hasStoneDeposit) {
                        this.metal += totalMetal;
                        tile.stoneDeposit = null; // Clear AFTER adding metal
                        Controller.toast(`‚õèÔ∏è ${levelConfig.name} on deposit! +${Controller.formatNum(totalMetal)} metal üåü`);
                    } else {
                        let indQuality = bonusInfo.total >= 1.2 ? 'üåü Great spot!' : bonusInfo.total >= 1.0 ? 'üëç Good location' : 'üìç Built';
                        Controller.toast(`üè≠ ${levelConfig.name} ${indQuality}`);
                    }
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.recalc();
                    return;
                }
                
                // COMMERCIAL (Level 1 = Pebble Trade Fire, Level 2 = Squirrel Trade Camp, Level 3 = Fire Meet Camp)
                if(t === 'COM') {
                    // Get selected commercial level (default to 1)
                    let selectedLevel = Controller.selectedCommercialLevel || 1;
                    
                    // Get building data from BUILDING_DB for proper cost lookup
                    let buildingData = CFG.BUILDING_DB['COM_' + selectedLevel];
                    if(!buildingData) {
                        return Controller.toast(`Commercial level ${selectedLevel} not found!`);
                    }
                    let levelCost = buildingData.cost;
                    
                    // Validate 1x1 spot first (needed for elevation check)
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    
                    // Calculate elevation cost multiplier (highland building costs more)
                    let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                    let elevCostInfo = this.getElevationCostInfo(gx, gy);
                    let adjFoodCost = Math.ceil(levelCost.food * elevCostMult);
                    let adjWoodCost = Math.ceil(levelCost.wood * elevCostMult);
                    let adjStoneCost = Math.ceil((levelCost.stone || 0) * elevCostMult);
                    
                    // Check resource costs (with elevation adjustment - cost shown but not reason)
                    if(this.food < adjFoodCost) {
                        return Controller.toast(`Need ${adjFoodCost} Food for ${buildingData.name}`);
                    }
                    if(this.wood < adjWoodCost) {
                        return Controller.toast(`Need ${adjWoodCost} Wood for ${buildingData.name}`);
                    }
                    if(adjStoneCost > 0 && this.stone < adjStoneCost) {
                        return Controller.toast(`Need ${adjStoneCost} Stone for ${buildingData.name}`);
                    }
                    
                    // Validate tile type
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // Clear tree if present (1x1)
                    tile.tree = false;
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'COM');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'COM');
                    
                    // Flood risk - kept internal, not shown to player (mystery mode)
                    // Player discovers flood dangers through gameplay, not warnings
                    
                    // Place 1x1 commercial zone
                    this.blds.push({ 
                        t: 'COM', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0,
                        variant: 1  // Start at Low activity
                    });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Record action
                    if(typeof recordBuildAction === 'function') recordBuildAction('COM', gx, gy);
                    
                    // Deduct resource costs (with elevation adjustment)
                    this.food -= adjFoodCost;
                    this.wood -= adjWoodCost;
                    if(adjStoneCost > 0) this.stone -= adjStoneCost;
                    
                    let costStr = `-${adjFoodCost} food, -${adjWoodCost} wood`;
                    if(adjStoneCost > 0) costStr += `, -${adjStoneCost} stone`;
                    // Simplified player-friendly message
                    let comQuality = bonusInfo.total >= 1.2 ? 'üåü Great spot!' : bonusInfo.total >= 1.0 ? 'üëç Good location' : 'üìç Built';
                    Controller.toast(`üè™ ${buildingData.name} ${comQuality}`);
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 3);
                    
                    this.recalc();
                    return;
                }
                
                // RESIDENTIAL ZONING (new zone-based system with level selection)
                if(t === 'RES') {
                    
                    // First check if we're in city mode
                    if(this.gameState !== 'CITY') {
                        return Controller.toast("‚ö†Ô∏è Must settle first! Click üèõÔ∏è button to settle.");
                    }
                    
                    if (!this.isValid(gx, gy, t)) {
                        // More detailed error message
                        let tile = this.tiles[gx][gy];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') {
                            return Controller.toast("‚ùå Can't build on water!");
                        }
                        if(tile.type === 'STONE') {
                            return Controller.toast("‚ùå Can't build on stone mountains!");
                        }
                        if(tile.zone || tile.building) {
                            return Controller.toast("‚ùå Tile already has a building!");
                        }
                        if(tile.road) {
                            return Controller.toast("‚ùå Can't build on roads!");
                        }
                        return Controller.toast("‚ùå Invalid Spot");
                    }
                    
                    // Get selected building level (default to highest unlocked level)
                    let selectedLevel = Controller.selectedBuildingLevel;
                    if(selectedLevel === undefined || selectedLevel === null) {
                        // Default to Level 1 if unlocked, otherwise Level 0
                        selectedLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    }
                    let levelConfig = CFG.BUILDING_LEVELS[selectedLevel];
                    
                    if(!levelConfig) {
                        return Controller.toast("‚ùå Invalid building level!");
                    }
                    
                    // Calculate elevation cost multiplier (highland building costs more)
                    let elevCostMult = this.getElevationCostMultiplier(gx, gy);
                    let elevCostInfo = this.getElevationCostInfo(gx, gy);
                    let adjFoodCost = Math.ceil(levelConfig.food * elevCostMult);
                    let adjWoodCost = Math.ceil((levelConfig.wood || 0) * elevCostMult);
                    let adjStoneCost = Math.ceil((levelConfig.stone || 0) * elevCostMult);
                    
                    // Check if player has required resources (with elevation adjustment - cost shown but not reason)
                    if(this.food < adjFoodCost) {
                        return Controller.toast(`Need ${adjFoodCost} Food for ${levelConfig.name}`);
                    }
                    if(adjWoodCost > 0 && this.wood < adjWoodCost) {
                        return Controller.toast(`Need ${adjWoodCost} Wood for ${levelConfig.name}`);
                    }
                    if(adjStoneCost > 0 && this.stone < adjStoneCost) {
                        return Controller.toast(`Need ${adjStoneCost} Stone for ${levelConfig.name}`);
                    }
                    
                    // Deduct resources (with elevation adjustment)
                    this.food = Number(this.food) - Number(adjFoodCost);
                                        if (isNaN(this.food)) this.food = 0;
                                        if (isNaN(this.food)) this.food = 0;
                                            if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                            if (isNaN(this.food)) this.food = 0;
                    if(adjWoodCost > 0) this.wood = Number(this.wood) - Number(adjWoodCost);
                    if(adjStoneCost > 0) this.stone = Number(this.stone) - Number(adjStoneCost);
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'RES');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'RES');
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // FLOOD RISK - Kept internal, not shown to player (mystery mode)
                    // Player discovers flood dangers through gameplay, not warnings
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Create zone with selected level
                    this.tiles[gx][gy].zone = 'R';
                    this.tiles[gx][gy].building = {
                        level: selectedLevel,
                        growth: 0,
                        desirability: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0,
                        lastBirthYear: this.year,
                        pop: 0,
                        capacity: levelConfig.capacity,
                        // Buildings start at variant 1 (Low) for visual variety
                        // Can evolve up/down based on desirability
                        variant: 1
                    };
                    this.tiles[gx][gy].tree = false;
                    
                    // Record action if preset recording is active
                    if(typeof recordBuildAction === 'function') recordBuildAction('RES', gx, gy);
                    
                    // Update building populations after creating residential
                    if(typeof assignPopulationToResidential === 'function') {
                        assignPopulationToResidential(this);
                    }
                    
                    // Auto-explore area around new zone for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.markDirty(gx, gy, 1); // Mark for redraw
                    
                    // Simplified player-friendly message (no technical stats)
                    let locationQuality = bonusInfo.total >= 1.2 ? 'üåü Great spot!' : bonusInfo.total >= 1.0 ? 'üëç Good location' : 'üìç Built';
                    Controller.toast(`üè† ${levelConfig.name} ${locationQuality}`);
                    
                    this.recalc();
                    return;
                }
                
                // DEMOLISH: Remove zones, buildings, or roads
                if(t === 'DEMOLISH') {
                    // Check if there's a road to demolish
                    if(this.tiles[gx][gy].road) {
                        this.tiles[gx][gy].road = false;
                        this.roadTileCount = Math.max(0, (this.roadTileCount || 0) - 1);
                        Controller.toast('üõ£Ô∏è Road demolished');
                        this.recalc();
                        return;
                    }
                    
                    // Check for buildings in blds array (WELL, COM, IND, CHIEF, etc.)
                    let bldHit = -1;
                    for (let i = 0; i < this.blds.length; i++) {
                        let b = this.blds[i];
                        // COM, IND, WELL are 1x1 per documentation
                        let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                        if (gx >= b.x && gx < b.x + bz && gy >= b.y && gy < b.y + bz) {
                            bldHit = i;
                            break;
                        }
                    }
                    if (bldHit !== -1) {
                        let removedBld = this.blds[bldHit];
                        this.blds.splice(bldHit, 1);
                        Controller.toast(`üî® ${removedBld.t} demolished`);
                        this.recalc();
                        return;
                    }
                    
                    // Check for zoned residential buildings
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        let bld = this.tiles[gx][gy].building;
                        
                        // FLAT 10% SALVAGE RATE for all building levels
                        if(bld && bld.level !== undefined) {
                            let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                            if(levelConfig) {
                                let refundRate = 0.10; // 10% refund for all levels
                                
                                let foodRefund = Math.floor(levelConfig.food * refundRate);
                                let woodRefund = Math.floor(levelConfig.wood * refundRate);
                                let stoneRefund = Math.floor(levelConfig.stone * refundRate);
                                
                                this.food += foodRefund;
                                this.wood += woodRefund;
                                this.stone += stoneRefund;
                                
                                if(foodRefund > 0 || woodRefund > 0 || stoneRefund > 0) {
                                    let refundText = [];
                                    if(foodRefund > 0) refundText.push(`${foodRefund} food`);
                                    if(woodRefund > 0) refundText.push(`${woodRefund} wood`);
                                    if(stoneRefund > 0) refundText.push(`${stoneRefund} stone`);
                                    Controller.toast(`‚ôªÔ∏è Salvaged 10%: ${refundText.join(', ')}`);
                                } else {
                                    Controller.toast(`üî® Demolished (no salvage value)`);
                                }
                            }
                        }
                        
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        this.markDirty(gx, gy, 1);
                        this.recalc();
                    } else {
                        Controller.toast("Nothing to demolish here");
                    }
                }
                } catch(err) {
                    console.error('Build error:', err);
                    Controller.toast('‚ùå Build error: ' + err.message);
                }
            },
            bull(gx, gy) {
                // Legacy function - now handled in build()
                // Kept for compatibility
                if (this.res < CFG.COST.BULL && this.simcityMode) return Controller.toast("Need Funds");
                if (this.food < 1 && !this.simcityMode) return Controller.toast("Need Food");
                
                // Check for zones first
                if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                    this.tiles[gx][gy].zone = null;
                    this.tiles[gx][gy].building = null;
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Zone Cleared");
                    this.recalc();
                    return;
                }
                
                // Check for buildings
                let hit = -1;
                for (let i = 0; i < this.blds.length; i++) { 
                    let b = this.blds[i]; 
                    // COM, IND, WELL are 1x1 per documentation
                    let sz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2; 
                    if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                        hit = i; 
                        break; 
                    } 
                }
                if (hit !== -1) { 
                    this.blds.splice(hit, 1); 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Demolished"); 
                }
                else if (this.tiles[gx][gy].road) { 
                    this.tiles[gx][gy].road = false; 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Road Removed"); 
                }
                this.recalc();
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SIMCITY SNES STYLE ZONING BONUS CALCULATOR
            // Build anywhere, but smart placement gets bonuses!
            // Returns a multiplier (0.3 to 2.5+) based on placement quality
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            calculateZoneBonus(gx, gy, zoneType) {
                let bonus = 1.0; // Base multiplier
                const B = CFG.ZONE_BONUSES;
                const tiles = this.tiles;
                
                // Helper: Count nearby tiles of a type
                const countNearby = (checkFn, range) => {
                    let count = 0;
                    for(let dx = -range; dx <= range; dx++) {
                        for(let dy = -range; dy <= range; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            let nx = gx + dx, ny = gy + dy;
                            if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                                if(checkFn(tiles[nx][ny], nx, ny)) count++;
                            }
                        }
                    }
                    return count;
                };
                
                // Helper: Check if any tile nearby matches
                const hasNearby = (checkFn, range) => countNearby(checkFn, range) > 0;
                
                // === ROAD ACCESS (critical for all zones) ===
                let roadCount = countNearby(t => t.road, 1);
                if(roadCount > 0) {
                    bonus += B.ROAD_ACCESS_BONUS;
                    // Extra bonus for road junctions (commercial loves these)
                    if(roadCount >= 3 && zoneType === 'COM') {
                        bonus += B.COM_ROAD_JUNCTION_BONUS;
                    }
                } else {
                    // Check if road is at least within 3 tiles
                    let hasRoadNearby = hasNearby(t => t.road, 3);
                    if(!hasRoadNearby) {
                        bonus -= B.NO_ROAD_PENALTY;
                    }
                }
                
                // === WATER PROXIMITY ===
                let hasWater = hasNearby(t => t.type === 'WATER' || t.type === 'RIVER', 3);
                if(hasWater) {
                    if(zoneType === 'RES') bonus += B.RES_WATER_BONUS;
                    else if(zoneType === 'IND') bonus += B.IND_WATER_BONUS;
                }
                
                // === WELL PROXIMITY ===
                let wellNearby = this.blds.some(b => {
                    if(b.t !== 'WELL') return false;
                    let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                    return dist <= 3;
                });
                if(wellNearby && zoneType === 'RES') {
                    bonus += B.RES_WELL_BONUS;
                }
                
                // === TREE/FOREST PROXIMITY ===
                let treeCount = countNearby(t => t.tree || t.type === 'FOREST', 2);
                if(treeCount > 0) {
                    if(zoneType === 'RES') bonus += B.RES_TREE_BONUS;
                    else if(zoneType === 'IND') bonus += B.IND_FOREST_BONUS * Math.min(treeCount / 3, 1);
                }
                
                // === STONE PROXIMITY (Industrial loves this) ===
                let stoneNearby = hasNearby(t => t.type === 'STONE' || t.stoneDeposit, 3);
                if(stoneNearby && zoneType === 'IND') {
                    bonus += B.IND_STONE_BONUS;
                }
                
                // === RESIDENTIAL BONUSES/PENALTIES ===
                if(zoneType === 'RES') {
                    // Clustering bonus
                    let resCount = countNearby(t => t.zone === 'R', 1);
                    bonus += resCount * B.RES_CLUSTER_BONUS;
                    
                    // Industrial penalty (pollution)
                    let indNearby = this.blds.some(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 2;
                    });
                    if(indNearby) bonus -= B.RES_INDUSTRIAL_PENALTY;
                }
                
                // === COMMERCIAL BONUSES/PENALTIES ===
                if(zoneType === 'COM') {
                    // Needs customers (residential)
                    let resNearby = countNearby(t => t.zone === 'R', 5);
                    if(resNearby >= 3) {
                        bonus += B.COM_RES_NEARBY_BONUS;
                    } else if(resNearby === 0) {
                        bonus -= B.COM_ISOLATION_PENALTY;
                    }
                    
                    // Industrial workers nearby
                    let indNearby = this.blds.some(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 5;
                    });
                    if(indNearby) bonus += B.COM_INDUSTRIAL_NEARBY;
                }
                
                // === INDUSTRIAL BONUSES/PENALTIES ===
                if(zoneType === 'IND') {
                    // Clustering bonus (industrial parks)
                    let indCount = this.blds.filter(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 2;
                    }).length;
                    bonus += indCount * B.IND_CLUSTER_BONUS;
                    
                    // Penalty if too close to residential
                    let resTooClose = countNearby(t => t.zone === 'R', 2);
                    if(resTooClose > 0) bonus -= B.IND_RES_NEARBY_PENALTY;
                }
                
                // === CHIEF'S HUT BONUS ===
                let chiefNearby = this.blds.some(b => {
                    if(b.t !== 'CHIEF') return false;
                    let dist = Math.sqrt(Math.pow(b.x - gx, 2) + Math.pow(b.y - gy, 2));
                    return dist <= B.CHIEF_CULTURE_RADIUS;
                });
                if(chiefNearby) bonus += B.CHIEF_BONUS;
                
                // === LOCKED RESOURCE BONUSES (from settlement) ===
                // Each person needs access to commercial/industrial zones
                // Locked resources provide permanent 25% bonus to their zone type
                if(this.lockedResources) {
                    if(zoneType === 'RES' && this.lockedResources.residential) {
                        bonus += 0.25; // +25% for having berries locked
                    }
                    if(zoneType === 'COM' && this.lockedResources.commercial) {
                        bonus += 0.25; // +25% for having trees locked
                    }
                    if(zoneType === 'IND' && this.lockedResources.industrial) {
                        bonus += 0.25; // +25% for having animals locked
                    }
                }
                
                // Clamp to reasonable range
                return Math.max(0.3, Math.min(2.5, bonus));
            },
            
            // Get a text description of zone bonuses for UI feedback
            getZoneBonusDescription(gx, gy, zoneType) {
                const B = CFG.ZONE_BONUSES;
                let bonuses = [];
                let penalties = [];
                
                // Road check
                let roadCount = 0;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = gx + dx, ny = gy + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].road) roadCount++;
                        }
                    }
                }
                if(roadCount > 0) bonuses.push('üõ£Ô∏è Road Access');
                else penalties.push('‚ùå No Road');
                
                // Water check
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let nx = gx + dx, ny = gy + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            let t = this.tiles[nx][ny].type;
                            if(t === 'WATER' || t === 'RIVER') {
                                bonuses.push('üíß Near Water');
                                dx = 99; dy = 99; // break out
                            }
                        }
                    }
                }
                
                let totalBonus = this.calculateZoneBonus(gx, gy, zoneType);
                let percentage = Math.round((totalBonus - 1) * 100);
                let prefix = percentage >= 0 ? '+' : '';
                
                return {
                    bonuses: bonuses,
                    penalties: penalties,
                    total: totalBonus,
                    text: `${prefix}${percentage}% Efficiency`
                };
            },
            
            upgradeBuilding(buildingIndex) {
                let b = this.blds[buildingIndex];
                if(!b || b.lvl >= 200) return Controller.toast("Max Level!");
                
                let cost = this.getUpgradeCost(b.lvl);
                
                // In SimCity mode, use funds; in survival mode, use food
                if(this.simcityMode) {
                    if(this.res < cost) return Controller.toast(`Need ${Math.floor(cost)} Funds`);
                    b.lvl++;
                    this.res -= cost;
                } else {
                    if(this.food < cost) return Controller.toast(`Need ${Math.floor(cost)} Food`);
                    b.lvl++;
                    this.food -= cost;
                }
                
                // Buildings in blds array (COM, IND, WELL, CHIEF) don't need special capacity updates
                // Zones handle their own capacity based on era level
                
                Controller.toast(`Upgraded to Level ${b.lvl}!`);
                this.recalc();
            },
            getUpgradeCost(currentLevel) {
                return Math.floor(CFG.UPGRADE.BASE_COST * Math.pow(CFG.UPGRADE.COST_MULTIPLIER, currentLevel - 1));
            },
            getBuildingProduction(building) {
                if(building.t === 'COM') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.COM_PRODUCTION_PER_LEVEL;
                } else if(building.t === 'IND') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.IND_PRODUCTION_PER_LEVEL;
                }
                return 0;
            },
            
            calculateDesirability(x, y, sz) {
                // Calculate desirability score for a location (0.5 to 3.0+)
                let score = 1.0;
                let neighborCount = 0;
                let hasTree = false;
                let hasWater = false;
                let hasChief = false;
                
                // Check neighbors (adjacent residential zones)
                for(let dx = -1; dx <= sz; dx++) {
                    for(let dy = -1; dy <= sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            // Check for zoned residential neighbors
                            let tile = this.tiles[checkX][checkY];
                            if(tile.zone === 'R') neighborCount++;
                            
                            // Check for trees/forest
                            if(tile.tree || tile.type === 'FOREST') hasTree = true;
                        }
                    }
                }
                
                // Check water proximity (within 3 tiles)
                for(let dx = -CFG.DESIRABILITY.WATER_RANGE; dx <= CFG.DESIRABILITY.WATER_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.WATER_RANGE; dy <= CFG.DESIRABILITY.WATER_RANGE + sz; dy++) {
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            let tile = this.tiles[checkX][checkY];
                            if(tile.type === 'WATER' || tile.type === 'RIVER') {
                                hasWater = true;
                            }
                        }
                    }
                }
                
                // Check Chief's Hut proximity (massive bonus within 50 tiles)
                let chiefHuts = this.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(x - chief.x, 2) + Math.pow(y - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChief = true;
                        break;
                    }
                }
                
                // Apply bonuses
                score += neighborCount * CFG.DESIRABILITY.NEIGHBOR_BONUS;
                if(hasTree) score += CFG.DESIRABILITY.TREE_BONUS;
                if(hasWater) score += CFG.DESIRABILITY.WATER_BONUS;
                if(hasChief) score *= CFG.CHIEF_BONUS;  // Multiplier for Chief bonus
                
                // Isolation penalty - check if any buildings within 2 tiles
                let isolated = true;
                for(let dx = -CFG.DESIRABILITY.ISOLATION_RANGE; dx <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.ISOLATION_RANGE; dy <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        
                        // Check for zoned tiles
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            if(this.tiles[checkX][checkY].zone) {
                                isolated = false;
                                break;
                            }
                        }
                        
                        // Check for 2x2 buildings
                        let nearBuilding = this.blds.find(b => 
                            checkX >= b.x && checkX < b.x + 2 &&
                            checkY >= b.y && checkY < b.y + 2
                        );
                        if(nearBuilding) {
                            isolated = false;
                            break;
                        }
                    }
                    if(!isolated) break;
                }
                
                if(isolated) score -= CFG.DESIRABILITY.ISOLATION_PENALTY;
                
                return Math.max(0.5, score);
            },
            recalc() {
                let wSup=50, jobs=0, housing=0, comJobs=0, indJobs=0;
                
                // Track peak population for game over screen
                if(this.pop > (this.peakPop || 0)) {
                    this.peakPop = this.pop;
                }
                
                // JIT HINT: Monomorphic array access pattern
                const tilesArray = this.tiles;
                const bldsArray = this.blds;
                const eraCount = CFG.ERAS.length;
                
                // Calculate zoned residential capacity AND average desirability
                let totalDesirability = 0;
                let zoneCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x]; // Cache array access
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Count neighboring residential zones for clustering bonus
                            let neighbors = 0;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    if(dx === 0 && dy === 0) continue;
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                                        if(tilesArray[nx][ny].zone === 'R') neighbors++;
                                    }
                                }
                            }
                            
                            // Growth penalty for isolated houses, bonus for grouped
                            // 0 neighbors = 0.3x (very slow), 1 = 0.5x, 2 = 0.8x, 3 = 1x, 4+ = 1.5x
                            let clusterMultiplier = 1.0;
                            if(neighbors === 0) clusterMultiplier = 0.3;
                            else if(neighbors === 1) clusterMultiplier = 0.5;
                            else if(neighbors === 2) clusterMultiplier = 0.8;
                            else if(neighbors === 3) clusterMultiplier = 1.0;
                            else clusterMultiplier = 1.5;
                            
                            // Use building level from BUILDING_LEVELS config
                            let buildingLevel = bld.level || 0;
                            let levelConfig = CFG.BUILDING_LEVELS[buildingLevel];
                            if(levelConfig) {
                                let baseCapacity = levelConfig.capacity;
                                
                                // Level 1 buildings always have 20 capacity (population varies 0-20 based on desirability)
                                // Housing capacity = max people that CAN live there
                                if(buildingLevel === 1) {
                                    housing += baseCapacity; // Always 20 for Level 1
                                } else {
                                    // Other levels use desirability multiplier
                                    let desirabilityBonus = Math.max(1.0, (bld.desirability || 1.0) * 1.5);
                                    let finalCapacity = Math.floor(baseCapacity * desirabilityBonus);
                                    housing += finalCapacity;
                                }
                                
                                totalDesirability += bld.desirability || 1.0;
                                zoneCount++;
                            }
                        }
                    }
                }
                
                this.blds.forEach(b => {
                    b.conn = false; 
                    // COM/IND/WELL are 1x1 per documentation, others are 2x2
                    let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                    
                    // Check road connection
                    for (let x=b.x-1; x<b.x+sz+1; x++) {
                        for (let y=b.y-1; y<b.y+sz+1; y++) { 
                            if (x>=0 && x<CFG.W && y>=0 && y<CFG.H && this.tiles[x][y].road) {
                                b.conn = true;
                            }
                        }
                    }
                    
                    // Calculate building efficiency (organic growth)
                    let eff = 1.0;
                    
                    // NON-RESIDENTIAL: Use efficiency system
                    if(!b.conn) {
                        eff *= CFG.EFFICIENCY.NO_ROAD_PENALTY;
                    }
                    
                    if(b.waterProximity) {
                        eff += b.waterProximity * CFG.EFFICIENCY.WATER_BONUS_MAX;
                    } else {
                        eff *= 0.7;
                    }
                    
                    if(b.t === 'IND' && b.forestProximity) {
                        eff += CFG.EFFICIENCY.FOREST_BONUS;
                    }
                    
                    if(b.age > 50 && !b.conn) {
                        eff *= Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, 1 - (b.age - 50) * CFG.EFFICIENCY.DECAY_RATE);
                    }
                    
                    b.efficiency = Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, Math.min(3.0, eff));
                    
                    // Apply efficiency to calculations
                    if (b.t=='WELL') {
                        wSup += Math.floor(200 * (1 + (b.lvl - 1) * 0.5) * b.efficiency);
                    } else if (b.t=='COM') {
                        comJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    } else if (b.t=='IND') {
                        indJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    }
                    
                    b.age++;
                });
                
                jobs = comJobs + indJobs;
                this.eff = (jobs>0) ? Math.min(1.0, this.pop/jobs) : 1.0;
                
                // CACHE housing capacity AND avg desirability to avoid recalculating 40k tiles every turn
                this.housingCap = housing;
                this.avgDesirability = zoneCount > 0 ? totalDesirability / zoneCount : 1.0;
                this.zoneCount = zoneCount;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // WORKFORCE CALCULATION - Assign workers to infrastructure
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                let comCount = this.blds.filter(b => b.t === 'COM').length;
                let indCount = this.blds.filter(b => b.t === 'IND').length;
                
                // Use cached road count (updated when roads placed/removed) - avoids 62,500 tile loop!
                let roadTileCount = this.roadTileCount || 0;
                
                // Calculate workforce needs (with null checks for early game)
                // Wells no longer need workers - they work automatically
                let roadsNeeded = Math.ceil(roadTileCount / 5) * (CFG.WORKFORCE && CFG.WORKFORCE.ROAD_WORKERS !== undefined ? CFG.WORKFORCE.ROAD_WORKERS : 1);
                let comNeeded = comCount * (CFG.WORKFORCE ? CFG.WORKFORCE.COMMERCIAL_WORKERS : 3);
                let totalNeeded = roadsNeeded + comNeeded;
                
                // Total workforce = residential population
                let totalWorkforce = this.pop;
                
                // Assign workers (priority: Roads > Commercial > Gathering)
                let remaining = totalWorkforce;
                
                let roadWorkers = Math.min(roadsNeeded, remaining);
                remaining -= roadWorkers;
                
                let comWorkers = Math.min(comNeeded, remaining);
                remaining -= comWorkers;
                
                let gatherers = remaining; // Everyone else gathers/hunts
                
                // Store workforce data
                this.workforce = {
                    total: totalWorkforce,
                    roadWorkers: roadWorkers,
                    comWorkers: comWorkers,
                    gatherers: gatherers,
                    roadsNeeded: roadsNeeded,
                    comNeeded: comNeeded,
                    shortage: totalNeeded - totalWorkforce
                };
                
                // Water calculation: all wells provide water automatically
                this.waterCap = wellCount * (CFG.WATER ? CFG.WATER.WELL_CAPACITY : 100);
                // WELLS ARE ALWAYS REQUIRED - 1 well per 100 people minimum
                let waterNeeded = Math.max(1, Math.ceil(this.pop / 100)); // At least 1 well always needed
                this.water = wellCount - waterNeeded; // Wells vs need
                
                // Store counts for UI
                this.wellCount = wellCount;
                this.roadTileCount = roadTileCount;
                this.housingCap = housing;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // NEEDS CALCULATION - Determine what people are missing
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                this.calculateNeeds();
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL UNLOCK CHECK - Unlock higher building levels based on population
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                PROGRESSION.updateUnlockedLevels(this);
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // POPULATION ASSIGNMENT - Distribute population to residential buildings
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(typeof assignPopulationToResidential === 'function') {
                    assignPopulationToResidential(this);
                }
                
                Controller.updateUI();
            },
            
            // Calculate needs satisfaction for all categories
            calculateNeeds() {
                let pop = this.pop || 0;
                if(pop === 0) {
                    this.needs.overall = 1.0;
                    return;
                }
                
                // HOUSING: Do we have enough homes?
                let housingNeed = pop;
                let housingHave = this.housingCap || 0;
                this.needs.housing = {
                    have: housingHave,
                    need: housingNeed,
                    satisfied: Math.min(1.0, housingHave / Math.max(1, housingNeed)),
                    shortage: Math.max(0, housingNeed - housingHave)
                };
                
                // WATER: Do we have enough wells?
                // In CITY mode: Always need at least 1 well, then 1 per 100 people
                let waterNeed = Math.max(1, Math.ceil(pop / 100)); // Always 1+ in settlement
                let waterHave = this.wellCount || 0;
                this.needs.water = {
                    have: waterHave,
                    need: waterNeed,
                    satisfied: Math.min(1.0, waterHave / Math.max(1, waterNeed)),
                    shortage: Math.max(0, waterNeed - waterHave)
                };
                
                // FOOD: Do we have food surplus?
                let foodConsumption = pop * (CFG.CONSTANTS ? CFG.CONSTANTS.FOOD_PER_PERSON : 0.2);
                let foodHave = this.food || 0;
                this.needs.food = {
                    have: foodHave,
                    need: foodConsumption * 10, // Need 10 years of food for full satisfaction
                    satisfied: Math.min(1.0, foodHave / Math.max(1, foodConsumption * 10)),
                    shortage: foodHave < foodConsumption ? Math.ceil(foodConsumption - foodHave) : 0
                };
                
                // JOBS: Do we have enough commercial/industrial?
                let jobsNeed = Math.ceil(pop * 0.5); // 50% of population wants jobs beyond gathering
                let jobsHave = 0;
                this.blds.forEach(b => {
                    if(b.t === 'COM') jobsHave += 20 * (b.lvl || 1);
                    if(b.t === 'IND') jobsHave += 30 * (b.lvl || 1);
                });
                this.needs.jobs = {
                    have: jobsHave,
                    need: jobsNeed,
                    satisfied: jobsNeed > 0 ? Math.min(1.0, jobsHave / jobsNeed) : 1.0,
                    shortage: Math.max(0, jobsNeed - jobsHave)
                };
                
                // PATHS: Do we have road coverage?
                let pathsNeed = Math.ceil(this.zoneCount * 2); // 2 road tiles per residential zone
                let pathsHave = this.roadTileCount || 0;
                this.needs.paths = {
                    have: pathsHave,
                    need: pathsNeed,
                    satisfied: pathsNeed > 0 ? Math.min(1.0, pathsHave / pathsNeed) : 1.0,
                    shortage: Math.max(0, pathsNeed - pathsHave)
                };
                
                // OVERALL SATISFACTION (weighted average)
                // Housing and Food are critical (weight 2), others weight 1
                let totalWeight = 8;
                this.needs.overall = (
                    this.needs.housing.satisfied * 2 +
                    this.needs.water.satisfied * 2 +
                    this.needs.food.satisfied * 2 +
                    this.needs.jobs.satisfied * 1 +
                    this.needs.paths.satisfied * 1
                ) / totalWeight;
            },
            
            // Generate yearly announcement about what people need
            generateNeedsAnnouncement() {
                if(!this.simcityMode && this.gameState !== 'CITY') return null;
                if(this.pop < 5) return null; // Don't spam for tiny settlements
                
                let missing = [];
                let icons = {
                    housing: 'üè†',
                    water: 'üíß',
                    food: 'üåæ',
                    jobs: 'üíº',
                    paths: 'üõ§Ô∏è'
                };
                
                // Check each need
                if(this.needs.housing.satisfied < 0.9) {
                    missing.push(`${icons.housing} Housing (${this.needs.housing.shortage} homeless)`);
                }
                if(this.needs.water.satisfied < 0.9) {
                    missing.push(`${icons.water} Wells (need ${this.needs.water.shortage} more)`);
                }
                if(this.needs.food.satisfied < 0.5) {
                    missing.push(`${icons.food} Food reserves low`);
                }
                if(this.needs.jobs.satisfied < 0.7 && this.pop > 20) {
                    missing.push(`${icons.jobs} Jobs (${this.needs.jobs.shortage} unemployed)`);
                }
                if(this.needs.paths.satisfied < 0.5 && this.zoneCount > 3) {
                    missing.push(`${icons.paths} Paths (${this.needs.paths.shortage} tiles needed)`);
                }
                
                if(missing.length === 0) {
                    // All needs met - prosperity message every 10 years
                    if(this.year % 10 === 0) {
                        return `‚ú® Year ${this.year}: Your people are prosperous! (${Math.floor(this.needs.overall * 100)}% satisfaction)`;
                    }
                    return null;
                }
                
                return `‚ö†Ô∏è Year ${this.year}: Your people need: ${missing.join(', ')}`;
            },
            
            // Calculate income based on population, desirability, and needs satisfaction
            calculateIncome() {
                let baseIncome = 0;
                let pop = this.pop || 0;
                
                // Base income per person (people generate value by existing)
                let incomePerPerson = 0.5; // Base income per person per year
                
                // Desirability multiplier (wealthy areas = more spending)
                let desirabilityMult = Math.max(0.5, Math.min(2.0, this.avgDesirability || 1.0));
                
                // Needs satisfaction multiplier (unhappy people = less productive)
                let satisfactionMult = Math.max(0.3, this.needs.overall || 1.0);
                
                // Population income (base economy)
                baseIncome = pop * incomePerPerson * desirabilityMult * satisfactionMult;
                
                // Commercial building income (boosted by population & satisfaction)
                this.blds.forEach(b => {
                    if(b.t === 'COM') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Commercial income scales with local population density
                        let popBonus = Math.min(2.0, 1.0 + (pop / 500)); // Up to 2x at 500 pop
                        baseIncome += buildingBase * b.efficiency * satisfactionMult * popBonus;
                    }
                    if(b.t === 'IND') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Industrial provides 50% income (rest is food production)
                        baseIncome += buildingBase * 0.5 * b.efficiency * satisfactionMult;
                    }
                });
                
                return Math.floor(baseIncome);
            },
            endTurn() {
                try {
                    // Record player action for AI learning
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        QLearningAI.recordPlayerAction('PASS_YEAR');
                    }
                    
                    this.year++;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // GEOLOGICAL WATER CYCLE - Check every 100 years
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if(CFG.ELEVATION_SYSTEM.ENABLED) {
                        this.updateGeologicalCycle();
                    }
                    
                    // CRITICAL: Recalculate workforce FIRST before any production/consumption
                    this.recalc();
                    
                    // Process player pathfinding
                    this.processPath();
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // NOTE: Level 0 buildings removed - Level 0 is WANDER epoch only
                // All building starts at Level 1 (Settlement) now
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 1 RESIDENTIAL UPKEEP & ABANDONED TIMER
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Upkeep is simple: 0.5 wood per building per year (very low)
                // Only abandoned buildings (5+ years empty) have higher upkeep
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let level1UpkeepTotal = 0;
                let level1Count = 0;
                let abandonedCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building && tile.building.level === 1) {
                            let bld = tile.building;
                            level1Count++;
                            
                            // Initialize empty years tracker if not exists
                            if(bld.emptyYears === undefined) bld.emptyYears = 0;
                            
                            // Check if building is abandoned (variant 0 AND empty for 5+ years)
                            let isAbandoned = bld.variant === 0 && bld.emptyYears >= 5;
                            
                            if(isAbandoned) {
                                // Abandoned: higher upkeep (1 wood)
                                level1UpkeepTotal += 1;
                            } else {
                                // Normal upkeep: 0.5 wood per building
                                level1UpkeepTotal += 0.5;
                                
                                // Track empty years for abandonment
                                let hasOccupancy = this.pop > 0; // Any population means buildings are in use
                                if(!hasOccupancy) {
                                    bld.emptyYears++;
                                } else {
                                    bld.emptyYears = 0;
                                }
                            }
                            
                            // Check for abandoned (5 years with 0 population in settlement)
                            if(bld.emptyYears >= 5 && bld.variant !== 0 && this.pop === 0) {
                                bld.variant = 0; // Force to Abandoned variant
                                abandonedCount++;
                                this.markDirty(x, y, 1);
                            }
                        }
                    }
                }
                
                // Round upkeep to nearest whole number
                level1UpkeepTotal = Math.ceil(level1UpkeepTotal);
                
                // Deduct wood upkeep (silently - only warn on shortage)
                if(level1UpkeepTotal > 0) {
                    if(this.wood >= level1UpkeepTotal) {
                        this.wood -= level1UpkeepTotal;
                    } else {
                        // Not enough wood
                        this.wood = 0;
                    }
                }
                
                if(abandonedCount > 0) {
                    Controller.toast(`üíÄ ${abandonedCount} settlement${abandonedCount > 1 ? 's' : ''} abandoned due to neglect!`);
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // WORKFORCE GATHERING - Unassigned workers gather/hunt food AND wood
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Workers not assigned to infrastructure (wells, roads, commercial)
                // automatically gather food AND wood. This is the main resource source before
                // Industrial zones are built in Epoch 2.
                // Scaled by gatheringMultiplier (based on initial settlement population)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(this.workforce && this.workforce.gatherers > 0 && CFG.WORKFORCE) {
                    let baseFood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5);
                    let gathererFood = baseFood * (this.gatheringMultiplier || 1.0);
                    this.food += gathererFood;
                    
                    // WOOD PRODUCTION: Gatherers also collect wood
                    // Using config rate, scaled by gathering multiplier
                    let baseWood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_WOOD_RATE || 3.0);
                    let gathererWood = baseWood * (this.gatheringMultiplier || 1.0);
                    this.wood += gathererWood;
                    
                    // STONE GATHERING: 25% of food rate - finding rocks while foraging
                    let baseStone = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5) * 0.25;
                    let gathererStone = baseStone * (this.gatheringMultiplier || 1.0);
                    this.stone = (this.stone || 0) + gathererStone;
                    
                    // METAL GATHERING: 5% of food rate - rare finds while foraging
                    let baseMetal = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5) * 0.05;
                    let gathererMetal = baseMetal * (this.gatheringMultiplier || 1.0);
                    this.metal = (this.metal || 0) + gathererMetal;
                    
                    // Warn if no gatherers due to infrastructure demand
                    if(this.workforce.shortage > 0) {
                        Controller.toast(`‚ö†Ô∏è Worker shortage! ${this.workforce.shortage} more needed. ${this.workforce.gatherers} gathering.`);
                    } else if(this.workforce.gatherers > 0 && this.pop < 20) {
                        // Show production details for early game
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`üåæ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood, +${gathererStone.toFixed(1)} stone${multiplierText}`);
                    } else if(this.workforce.gatherers > 10 && Math.random() < 0.2) {
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`üåæ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood, +${gathererStone.toFixed(1)} stone${multiplierText}`);
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // ROAD DECAY - Unmaintained roads decay over time
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // If not enough road workers, roads provide no desirability bonus
                if(this.workforce && this.workforce.roadWorkers < this.workforce.roadsNeeded) {
                    let unmaintainedRoads = Math.ceil((this.workforce.roadsNeeded - this.workforce.roadWorkers) * 5);
                    if(unmaintainedRoads > 10 && Math.random() < 0.3) {
                        Controller.toast(`‚ö†Ô∏è ${unmaintainedRoads} road tiles unmaintained! Desirability reduced.`);
                    }
                }
                
                // AUTO-EVOLUTION: Update all zoned buildings
                const tilesArray = this.tiles;
                const popTotal = this.pop;
                const growthThreshold = CFG.GROWTH_THRESHOLD;
                const decayThreshold = CFG.DECAY_THRESHOLD;
                
                // Use cached housing capacity from recalc() - don't recalculate 40k tiles!
                let housingCap = this.housingCap || 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x];
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Age the zone (only every 10 years to slow progression)
                            if(!bld.age) bld.age = 0;
                            if(!bld.lastBirthYear) bld.lastBirthYear = this.year;
                            if(this.year % 10 === 0) bld.age++;
                            
                            // Calculate desirability
                            bld.desirability = this.calculateDesirability(x, y, 1);
                            
                            // NATURAL POPULATION BOOM: Every 10 years, zones generate bonus population
                            let yearsSinceBirth = this.year - bld.lastBirthYear;
                            if(yearsSinceBirth >= 10 && bld.desirability >= 1.0) {
                                // Calculate boom size: 1-2 base, +1 for high desirability, +1 for high level
                                let boomSize = 1 + Math.floor(Math.random() * 2);
                                if(bld.desirability >= 1.5) boomSize++;
                                if(bld.level >= 4) boomSize++;
                                
                                this.pop += boomSize;
                                bld.lastBirthYear = this.year;
                                
                                // Update building populations after population boom
                                if(typeof assignPopulationToResidential === 'function') {
                                    assignPopulationToResidential(this);
                                }
                                
                                if(Math.random() < 0.3) { // Only show some messages to avoid spam
                                    Controller.toast(`üë∂ Population boom! +${boomSize} from established settlement`);
                                }
                            }
                            
                            // NOTE: maxLevel no longer used - building LEVEL only changes via player action
                            // Variant state (appearance) changes automatically based on desirability
                            
                            // Growth rate based on desirability - CHANGES VARIANT STATE, NOT LEVEL
                            // Level (zone tier) only changes when player builds/bulldozes
                            // Variant (0=Abandoned, 1=Low, 2=Medium, 3=High) changes based on desirability
                            if(!bld.variant) bld.variant = 1; // Default to Low variant
                            if(!bld.growth) bld.growth = 0;
                            
                            // Determine target variant based on desirability
                            let targetVariant = 1; // Default Low
                            if(bld.desirability < 0.1) targetVariant = 0; // Abandoned
                            else if(bld.desirability < 0.4) targetVariant = 1; // Low
                            else if(bld.desirability < 0.7) targetVariant = 2; // Medium
                            else targetVariant = 3; // High
                            
                            // Gradually move toward target variant
                            if(bld.variant < targetVariant) {
                                // Growing: desirability supports higher variant
                                let growthSpeed = 0.02; // Base (50 years to upgrade)
                                if(bld.desirability >= 1.0) growthSpeed = 0.04; // Faster (25 years)
                                if(bld.desirability >= 1.5) growthSpeed = 0.08; // Even faster (12.5 years)
                                if(bld.desirability >= 2.0) growthSpeed = 0.15; // Fast (6-7 years)
                                
                                bld.growth += growthSpeed;
                                
                                // Gathering logic: increase food production at medium/high variants
                                if(bld.variant >= 2) {
                                    let gatherBonus = 1.0;
                                    if(bld.variant === 2) gatherBonus = 1.25; // Medium
                                    if(bld.variant >= 3) gatherBonus = 1.5; // High
                                    this.food += gatherBonus;
                                }
                                
                                if(bld.growth >= 1.0) {
                                    bld.variant = Math.min(bld.variant + 1, 3); // Max variant is 3
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`üè† Building upgraded to ${variantName}!`);
                                        }
                                    }
                                }
                            } else if(bld.variant > targetVariant && bld.variant > 0) {
                                // Decaying: desirability doesn't support current variant
                                bld.growth -= 0.05;
                                if(bld.growth <= -1.0) {
                                    bld.variant = Math.max(bld.variant - 1, 0); // Min variant is 0
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`üìâ Building declined to ${variantName}`);
                                        }
                                    }
                                }
                            }
                            
                            // NOTE: Buildings player PAID FOR are not downgraded.
                            // The maxLevel only limits natural GROWTH, not existing buildings.
                            // This prevents frustration from losing expensive buildings.
                        }
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // OVERCROWDING PENALTY SYSTEM
                // Buildings can hold +5 extra people (overflowCapacity) but if
                // overcrowded for more than 1 year, they start losing population
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let overcrowdingDeaths = 0;
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            let buildingLevel = bld.level || 1;
                            let levelConfig = CFG.BUILDING_LEVELS[buildingLevel];
                            
                            if(levelConfig) {
                                let capacity = levelConfig.capacity;
                                let overflowCapacity = levelConfig.overflowCapacity || (capacity + 5);
                                let currentPop = bld.pop || 0;
                                
                                // Initialize overcrowdedYears tracker
                                if(bld.overcrowdedYears === undefined) bld.overcrowdedYears = 0;
                                
                                // Check if building is overcrowded (above normal capacity)
                                if(currentPop > capacity) {
                                    bld.overcrowdedYears++;
                                    
                                    // If overcrowded for more than 1 year, start losing population
                                    if(bld.overcrowdedYears > 1) {
                                        // Lose 1-2 people per year from disease/stress
                                        let deaths = 1 + Math.floor(Math.random() * 2);
                                        deaths = Math.min(deaths, currentPop - capacity); // Don't reduce below capacity
                                        
                                        if(deaths > 0) {
                                            this.pop = Math.max(0, this.pop - deaths);
                                            overcrowdingDeaths += deaths;
                                        }
                                    }
                                } else {
                                    // Not overcrowded, reset timer
                                    bld.overcrowdedYears = 0;
                                }
                            }
                        }
                    }
                }
                
                if(overcrowdingDeaths > 0) {
                    Controller.toast(`üíÄ OVERCROWDING! ${overcrowdingDeaths} people died from cramped conditions!`);
                    // Re-assign population after deaths
                    if(typeof assignPopulationToResidential === 'function') {
                        assignPopulationToResidential(this);
                    }
                    // Check for game over
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LIFESPAN SYSTEM
                // Base lifespan: 20 years (Low density/variant 1)
                // Medium density (variant 2): +5% = 21 years
                // High density (variant 3): +10% = 22 years
                // Higher quality buildings = longer lives due to better conditions
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let totalPopInBuildings = 0;
                let weightedLifespan = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            let pop = bld.pop || 0;
                            if(pop > 0) {
                                // Base lifespan is 20 years
                                let baseLifespan = 20;
                                
                                // Variant bonus: 0=abandoned (no bonus), 1=low (+0), 2=medium (+5%), 3=high (+10%)
                                let variant = bld.variant || 1;
                                let lifespanBonus = 0;
                                if(variant === 2) lifespanBonus = 0.05; // +5% = 21 years
                                else if(variant >= 3) lifespanBonus = 0.10; // +10% = 22 years
                                
                                let lifespan = baseLifespan * (1 + lifespanBonus);
                                
                                totalPopInBuildings += pop;
                                weightedLifespan += pop * lifespan;
                            }
                        }
                    }
                }
                
                // Calculate natural deaths from old age
                if(totalPopInBuildings > 0 && this.pop > 0) {
                    let avgLifespan = weightedLifespan / totalPopInBuildings;
                    
                    // Each year, 1/lifespan of the population dies of old age
                    // e.g., with 20 year lifespan, ~5% die per year (1/20 = 0.05)
                    let expectedDeaths = this.pop / avgLifespan;
                    
                    // Add some randomness (50% to 150% of expected)
                    let randomFactor = 0.5 + Math.random();
                    let naturalDeaths = Math.floor(expectedDeaths * randomFactor);
                    
                    // Cap at current population
                    naturalDeaths = Math.max(0, Math.min(naturalDeaths, this.pop));
                    
                    if(naturalDeaths > 0) {
                        this.pop -= naturalDeaths;
                        
                        // Only show message occasionally to avoid spam
                        if(Math.random() < 0.2 || naturalDeaths > 5) {
                            Controller.toast(`‚ö∞Ô∏è ${naturalDeaths} died of old age. Avg lifespan: ${avgLifespan.toFixed(1)} years`);
                        }
                        
                        // Re-assign population after deaths
                        if(typeof assignPopulationToResidential === 'function') {
                            assignPopulationToResidential(this);
                        }
                        
                        // Check for game over - attribute to flood if that was the cause
                        if(this.pop <= 0) {
                            Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                            return;
                        }
                    }
                }
                
                // SIMCITY MODE - Modern city management
                if(this.simcityMode) {
                    // Use cached values from recalc() - PERFORMANCE FIX (no 40k tile iteration!)
                    let housingCap = this.housingCap || 0;
                    let avgDesirability = this.avgDesirability || 1.0;
                    let zoneCount = this.zoneCount || 0;
                    let jobs = 0;
                    let foodProduction = 0;
                    
                    // Calculate jobs and food from 2x2 buildings
                    this.blds.forEach(b => {
                        if(b.t === 'COM') jobs += Math.floor(100 * b.lvl * b.efficiency);
                        else if(b.t === 'IND') {
                            jobs += Math.floor(100 * b.lvl * b.efficiency);
                            foodProduction += Math.floor(50 * b.lvl * b.efficiency); // Industry still produces food
                        }
                    });
                    
                    // Food remains relevant - population health
                    // Wealthier areas (high desirability) consume more food per person
                    
                    let foodNeeded = this.pop * CFG.PRODUCTION.SIMCITY_FOOD_PER_PERSON * (avgDesirability > 1.5 ? CFG.DESIRABILITY.WEALTH_FOOD_MULTIPLIER : 1.0);
                    this.food += foodProduction;
                    this.food -= foodNeeded;
                    
                    // Starvation - population shrinks without food
                    if(this.food < 0) {
                        let starvation = Math.ceil(Math.abs(this.food) * CFG.PRODUCTION.STARVATION_RATE);
                        this.pop -= starvation;
                        this.pop = Math.max(0, this.pop);
                        this.food = 0;
                        Controller.toast(`‚ö†Ô∏è ${starvation} people starved! Need more Industrial!`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    
                    // WATER SYSTEM: Wells are critical for survival
                    // Each well supports 100 people. No wells = death after 1 year
                    // Insufficient wells = population dies off from dehydration
                    let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                    let waterCapacity = wellCount * 100; // Each well supports 100 people
                    
                    if(wellCount === 0 && this.pop > 0) {
                        // NO WELLS AT ALL - instant death after 1 year
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // Die after 1 year with no wells
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(wellCount > 0 && this.pop > waterCapacity) {
                        // NOT ENOUGH WELLS - only people WITHOUT water die (not everyone)
                        let peopleWithoutWater = this.pop - waterCapacity;
                        let dehydrationDeaths = Math.ceil(peopleWithoutWater * 0.20); // 20% of those without water
                        this.pop -= dehydrationDeaths;
                        this.pop = Math.max(1, this.pop);
                        
                        if(dehydrationDeaths > 0) {
                            Controller.toast(`üíß Water shortage! ${dehydrationDeaths} died. Have ${wellCount} wells (${waterCapacity} capacity), pop: ${this.pop}`);
                        }
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                        this.yearsWithoutWell = 0;
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Population growth based on balance (see-saw)
                    let targetPop = Math.min(housingCap, jobs);
                    if(this.pop < targetPop && this.food > foodNeeded * 2) {
                        let growth = Math.floor((targetPop - this.pop) * CFG.PRODUCTION.SIMCITY_POPULATION_GROWTH_RATE);
                        this.pop += Math.max(1, growth);
                        this.pop = Math.min(this.pop, targetPop);
                    } else if(this.pop > housingCap) {
                        // BRUTAL OVERPOPULATION - homeless people are a massive drain
                        let homeless = this.pop - housingCap;
                        
                        // DISEASE: 25% of homeless die every year from overcrowding, disease, crime
                        let deaths = Math.ceil(homeless * 0.25);
                        this.pop -= deaths;
                        
                        // Economic collapse from chaos - 20% loss
                        let econLoss = Math.ceil(this.res * 0.20);
                        this.res = Math.max(0, this.res - econLoss);
                        
                        // Food waste and theft
                        let foodLoss = Math.ceil(this.food * 0.15);
                        this.food = Math.max(0, this.food - foodLoss);
                        
                        if(deaths > 10) {
                            Controller.toast(`‚ò†Ô∏è OVERCROWDING! ${deaths} homeless died! $${econLoss} economic collapse!`);
                        }
                    }
                    
                    // Income from buildings (NOW INTERDEPENDENT!)
                    // Uses new calculateIncome() which factors in population, desirability, and needs
                    let incR = this.calculateIncome();
                    
                    let maint = this.blds.length * 2;
                    this.res = Math.max(0, this.res + incR - maint);
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    this.recalc();
                    Controller.updateUI();
                    return;
                }
                
                // EPOCH 0 (Paleolithic) - BRUTAL SURVIVAL ECONOMY
                if(this.age === 0) {
                    // --- BRUTAL ECONOMY ---
                    
                    // 1. FOOD SPOILAGE (The Rot)
                    // Base capacity is 1 MILLION - no pit needed until Monolithic Resource Pit
                    let storageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let woodStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let stoneStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let metalStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    
                    // Check for Monolithic Resource Pit (reduces rot to 10% max)
                    let hasMonolithicPit = false;
                    
                    this.blds.forEach(b => {
                        // Old storage buildings (all add to food)
                        if(b.t === 'BASKET') storageCap += CFG.BUILDINGS.BASKET.cap;
                        if(b.t === 'POTTERY') storageCap += CFG.BUILDINGS.POTTERY.cap;
                        if(b.t === 'GRANARY') {
                            storageCap += CFG.BUILDINGS.GRANARY.cap;
                            hasMonolithicPit = true; // Monolithic Resource Pit built!
                        }
                        if(b.t === 'PALACE') storageCap += CFG.BUILDINGS.PALACE.cap;
                    });
                    
                    // Determine rot rate (normal 20% or reduced 10% with Nuts Storage Reed House)
                    let rotRate = hasMonolithicPit ? CFG.BUILDINGS.GRANARY.rotReduction : CFG.CONSTANTS.BASE_SPOILAGE;

                    // If you have more food than storage, it rots
                    if(this.food > storageCap) {
                        let rot = Math.floor((this.food - storageCap) * rotRate);
                        this.food = Math.max(0, this.food - rot);
                        if(rot > 100 && Math.random() < 0.3) {
                            let msg = hasMonolithicPit ? `üçÇ ${rot} food rotted! (10% rate with Nuts Storage Reed House)` : `üçÇ ${rot} food rotted! Need storage buildings!`;
                            Controller.toast(msg);
                        }
                    }
                    
                    // Wood rot (10% rate - same as Nuts Storage Reed House reduces food to)
                    if(this.wood > woodStorageCap) {
                        let rot = Math.floor((this.wood - woodStorageCap) * 0.10);
                        this.wood = Math.max(0, this.wood - rot);
                        if(rot > 50 && Math.random() < 0.2) {
                            Controller.toast(`ü™µ ${rot} wood rotted!`);
                        }
                    }
                    
                    // Stone doesn't rot but can be "lost" at very high amounts (5% rate)
                    if(this.stone > stoneStorageCap) {
                        let lost = Math.floor((this.stone - stoneStorageCap) * 0.05);
                        this.stone = Math.max(0, this.stone - lost);
                        if(lost > 20 && Math.random() < 0.1) {
                            Controller.toast(`ü™® ${lost} stone scattered!`);
                        }
                    }
                    
                    // Metal rusts slowly (3% rate)
                    if(this.metal > metalStorageCap) {
                        let rust = Math.floor((this.metal - metalStorageCap) * 0.03);
                        this.metal = Math.max(0, this.metal - rust);
                        if(rust > 10 && Math.random() < 0.1) {
                            Controller.toast(`‚öôÔ∏è ${rust} metal rusted! Build Metal Pit!`);
                        }
                    }
                    
                    // 2. PRODUCTION & CONSUMPTION
                    let housingCap = this.housingCap || 0;
                    // Only count homeless if there ARE residential buildings - nomads don't need housing
                    // This prevents plague from triggering in early game before any buildings exist
                    let hasResBuildings = housingCap > 0;
                    let homeless = hasResBuildings ? Math.max(0, this.pop - housingCap) : 0;
                    let housed = this.pop - homeless;
                    
                    // Calculate average zone level for food production scaling
                    let totalLevel = 0;
                    let zoneCount = 0;
                    for(let x = 0; x < CFG.W; x++) {
                        for(let y = 0; y < CFG.H; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                let buildingLevel = tile.building.level || 1;
                                totalLevel += buildingLevel;
                                // Use level-specific capacity from BUILDING_LEVELS config
                                let levelConfig = CFG.BUILDING_LEVELS[buildingLevel - 1] || CFG.BUILDING_LEVELS[0];
                                zoneCount++;
                            }
                        }
                    }
                    let avgLevel = zoneCount > 0 ? totalLevel / zoneCount : 1;
                    
                    // Food production scales with civilization level (better tools, farming, etc.)
                    // Level 1: 1.0x, Level 3: 1.5x, Level 5: 2.0x, Level 8: 3.0x
                    let techMultiplier = 1.0 + (avgLevel - 1) * 0.3;
                    
                    // Food consumption scales FASTER than production (luxury goods, waste)
                    // Level 1: 1.0x, Level 3: 2.0x, Level 5: 3.5x, Level 8: 6.0x
                    let consumptionMultiplier = 1.0 + (avgLevel - 1) * 0.7;
                    
                    // ONLY HOUSED PEOPLE PRODUCE FOOD
                    let gathered = housed * CFG.PRODUCTION.PERSON_HUNTS * CFG.CONSTANTS.BASE_PROD * techMultiplier;
                    
                    // EVERYONE EATS, consumption scales faster than production
                    let housedConsumption = housed * CFG.CONSTANTS.FOOD_PER_PERSON * consumptionMultiplier;
                    let homelessConsumption = homeless * CFG.CONSTANTS.FOOD_PER_PERSON * 2.0; // Homeless eat DOUBLE
                    let eaten = housedConsumption + homelessConsumption;
                    
                    // Add hunting grounds production
                    let industrialCount = 0;
                    this.blds.forEach(b => {
                        if(b.t === 'IND' && PROGRESSION.stage >= 2 && b.forestProximity) {
                            // Check if built on STONE tiles (quarry mode)
                            let isQuarry = false;
                            let stoneMined = 0;
                            let metalExtracted = 0;
                            
                            for(let dx = 0; dx < 2; dx++) {
                                for(let dy = 0; dy < 2; dy++) {
                                    let tile = this.tiles[b.x + dx]?.[b.y + dy];
                                    if(tile && tile.type === 'STONE' && tile.resource && tile.resource.amount > 0) {
                                        isQuarry = true;
                                        // Mine stone from deposit
                                        let mineAmount = Math.min(100, tile.resource.amount);
                                        tile.resource.amount -= mineAmount;
                                        stoneMined += mineAmount;
                                        metalExtracted += mineAmount * tile.resource.metal_yield;
                                        
                                        // Notify when deposit depleted
                                        if(tile.resource.amount <= 0) {
                                            Controller.toast(`‚õèÔ∏è Quarry stone deposit depleted!`);
                                        }
                                    }
                                }
                            }
                            
                            if(isQuarry) {
                                // Quarry mode: mine stone and extract metal
                                this.stone += stoneMined;
                                this.metal += metalExtracted;
                            } else {
                                // Hunting grounds mode: produce food
                                gathered += CFG.PRODUCTION.INDUSTRIAL_FOOD_PER_TURN;
                            }
                            industrialCount++;
                        }
                    });
                    
                    this.food += gathered;
                    this.food -= eaten;
                    
                    // 3. BRUTAL OVERPOPULATION (Disease, starvation, crime)
                    if(homeless > 0 && this.pop > 0) {
                        let overcrowdingPct = homeless / this.pop; // 0.0 to 1.0
                        
                        // 1. CRIME & THEFT (Immediate Resource Drain)
                        // Desperate people steal food. 
                        // You lose 10% of your TOTAL stockpile per year.
                        let stolenFood = Math.ceil(this.food * 0.10); 
                        this.food = Math.max(0, this.food - stolenFood);

                        // 2. EXPOSURE (Constant Death)
                        // Living without shelter kills 15% of the homeless every turn.
                        let exposureDeaths = Math.ceil(homeless * 0.15);
                        this.pop -= exposureDeaths;

                        // 3. THE PLAGUE (The Civilization Killer)
                        // The chance of outbreak = 2x % of population that is homeless.
                        // If 20% are homeless, you have a 40% chance of Plague every turn.
                        if(Math.random() < (overcrowdingPct * 2)) {
                             // Plague kills 30% of EVERYONE (housed and homeless)
                             let plagueDeaths = Math.ceil(this.pop * 0.30);
                             this.pop -= plagueDeaths;
                             
                             // Economic Crash
                             let lostFunds = Math.ceil(this.res * 0.50);
                             this.res -= lostFunds;

                             Controller.toast(`‚ò†Ô∏è PLAGUE OUTBREAK! ${plagueDeaths} dead! Economy Collapsed!`);
                        } else {
                             // ALWAYS show overcrowding warning when homeless exist
                             Controller.toast(`üèöÔ∏è OVERCROWDED! ${homeless} homeless: -${exposureDeaths} died, -${stolenFood} food stolen!`);
                        }
                    }
                    
                    // 4. CHECK CAPACITY - use cached value from recalc() for PERFORMANCE
                    housingCap = this.housingCap || 0;
                    
                    // 4. STARVATION (THE DEATH SPIRAL)
                    if(this.food < 0) {
                        this.food = 0;
                        let deaths = Math.ceil(this.pop * CFG.CONSTANTS.STARVATION_DEATH);
                        this.pop = Math.max(0, this.pop - deaths);
                        Controller.toast(`üíÄ FAMINE! ${deaths} people starved to death!`);
                    }
                    
                    // 5. WATER SHORTAGE - POPULATION ALWAYS DEPENDS ON FRESH WATER
                    // Calculate how many wells are needed - at least 1 well always required!
                    let wellsNeeded = Math.max(1, Math.ceil(this.pop / 100)); // 1 well per 100 people, minimum 1
                    let totalWellCount = this.blds.filter(b => b.t === 'WELL').length;
                    
                    // Track years without ANY wells
                    if(totalWellCount === 0 && this.pop > 0) {
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // After 1 year with NO wells at all = instant death
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Check if we have enough wells
                    let wellShortage = Math.max(0, wellsNeeded - totalWellCount);
                    
                    if(wellShortage > 0 && totalWellCount > 0) {
                        // Has wells but not enough - only people WITHOUT water die
                        // Each well supports 100 people, so calculate how many lack water
                        let waterCapacity = totalWellCount * 100;
                        let peopleWithoutWater = Math.max(0, this.pop - waterCapacity);
                        
                        // Only 20% of those without water die each year (gives time to build more)
                        let waterDeaths = Math.ceil(peopleWithoutWater * 0.20);
                        this.pop = Math.max(1, this.pop - waterDeaths);
                        
                        if(waterDeaths > 0) {
                            Controller.toast(`üíß Water shortage! ${waterDeaths} died. Have ${totalWellCount} wells (${waterCapacity} capacity), need ${wellsNeeded} for ${this.pop} people.`);
                        }
                        
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(totalWellCount > 0 && Math.random() < 0.05) {
                        // Rare reminder that water is fine
                        Controller.toast(`üíß Water OK: ${totalWellCount} wells serving ${this.pop} people.`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    
                    // 5. GROWTH LOGIC (Only if surplus exists AND under capacity)
                    else if(this.food > eaten * 1.5 && this.pop < housingCap) {
                        // Slow, realistic growth - 5% per year if well-fed
                        let growth = Math.max(1, Math.ceil(this.pop * 0.05));
                        this.pop = Math.min(this.pop + growth, housingCap);
                        if(growth > 1 && Math.random() < 0.3) {
                            Controller.toast(`üë∂ ${growth} new tribe members born!`);
                        }
                    }
                    
                    // 6. CAPACITY WARNINGS
                    let industrialCapacity = industrialCount * CFG.PRODUCTION.INDUSTRIAL_SUPPORTS_POPULATION;
                    if(this.pop > industrialCapacity && industrialCount > 0) {
                        Controller.toast(`‚ö†Ô∏è Need more Hunting Grounds! (${industrialCount} supports ${industrialCapacity} pop)`);
                    }
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    // Check for industrial unlock
                    this.checkProgression();
                }
                
                // FINAL GAME OVER CHECK - Catch any edge cases where pop reaches 0
                if(this.pop <= 0) {
                    Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                    return;
                }
                
                this.recalc();
                Controller.updateUI();
                } catch(error) {
                    console.error('Error in endTurn:', error);
                    Controller.toast('Error processing turn!');
                }
            },
            toggleOrdinance() {
                if (this.ordinance) return;
                if (this.res < CFG.COST.ORD) return Controller.toast("Need Funds");
                this.res -= CFG.COST.ORD; this.ordinance = true; this.ordEnd = this.year + 20;
                Controller.toast("Act Enacted"); Controller.updateUI();
            }
        };

        const Controller = {
            cam: { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM }, 
            mx: 0, my: 0, tool: 'PAN', drag: false, last: {x:0, y:0},
            selectedBuildingLevel: 1, // Default to Level 1 Settlement (first buildable level)
            shiftHeld: false, // Track shift key for diagonal road drawing
            showElevation: false, // Toggle elevation overlay view (V key)
            
            // Format numbers with K/M/B/T/Q/Qi suffixes (up to Quintillion)
            formatNum(num) {
                if(num >= 1000000000000000000) return (num/1000000000000000000).toFixed(1) + 'Qi'; // Quintillion
                if(num >= 1000000000000000) return (num/1000000000000000).toFixed(1) + 'Q'; // Quadrillion
                if(num >= 1000000000000) return (num/1000000000000).toFixed(1) + 'T'; // Trillion
                if(num >= 1000000000) return (num/1000000000).toFixed(1) + 'B'; // Billion
                if(num >= 1000000) return (num/1000000).toFixed(1) + 'M'; // Million
                if(num >= 1000) return (num/1000).toFixed(1) + 'K'; // Thousand
                return Math.floor(num).toString();
            },
            
            init() {
                // Capture console logs to technical log
                this.captureConsoleLogs();
                
                try {
                    console.log('Initializing Renderer...');
                    Renderer.init(); 
                    Renderer.initTinyPeople(); // Initialize tiny people system
                    console.log('Initializing Game...');
                    Game.init(123);
                    console.log('Game initialized successfully');
                    // DELAY RENDER TO PREVENT 0-WIDTH BUG
                    setTimeout(() => {
                        console.log('Starting render loop...');
                        Renderer.resize();
                        let c = Renderer.cvs;
                        
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        // SPACEBAR PAN MODE - Hold space + left click to pan camera
                        // Much easier than middle click!
                        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                        this.spaceHeld = false;
                        window.addEventListener('keydown', (e) => {
                            if(e.code === 'Space' && !e.repeat && !Game.gameOver) {
                                this.spaceHeld = true;
                                document.body.style.cursor = 'grab';
                                e.preventDefault();
                            }
                        });
                        window.addEventListener('keyup', (e) => {
                            if(e.code === 'Space') {
                                this.spaceHeld = false;
                                if(!this.drag) document.body.style.cursor = 'default';
                            }
                        });
                        
                        // Keyboard controls for player movement (always available)
                        window.onkeydown = (e) => {
                            // BLOCK ALL GAME INPUTS WHEN GAME IS OVER
                            // Check both the flag and the visible screen
                            if(Game.gameOver) {
                                e.preventDefault();
                                return;
                            }
                            let gameoverScreen = document.getElementById('gameover-screen');
                            if(gameoverScreen && gameoverScreen.style.display !== 'none') {
                                // Only allow Tab and Enter for UI navigation on death screen
                                if(e.key !== 'Tab' && e.key !== 'Enter') {
                                    e.preventDefault();
                                    return;
                                }
                                return;
                            }
                            
                            // Track shift key for diagonal road drawing
                            if(e.key === 'Shift') Controller.shiftHeld = true;
                            
                            // DEBUG: Press 'B' to test build residential at player position
                            if(e.key === 'b' || e.key === 'B') {
                                if(Game.gameState === 'CITY' && Game.player) {
                                    console.log('=== DEBUG BUILD TEST ===');
                                    console.log('Attempting to build at player position:', Game.player.x, Game.player.y);
                                    console.log('Current tool:', this.tool);
                                    console.log('Selected level:', this.selectedBuildingLevel);
                                    Game.build('RES', Game.player.x, Game.player.y);
                                    e.preventDefault();
                                    return;
                                }
                            }
                            
                            // Settle shortcut (only in WANDER mode)
                            if((e.key === 'Enter' || e.key === ' ') && Game.gameState === 'WANDER') { 
                                Game.settleHere(); 
                                e.preventDefault(); 
                                return;
                            }
                            
                            if(e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') { Game.movePlayer(0, -1); e.preventDefault(); }
                            else if(e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') { Game.movePlayer(0, 1); e.preventDefault(); }
                            else if(e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') { Game.movePlayer(-1, 0); e.preventDefault(); }
                            else if(e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') { Game.movePlayer(1, 0); e.preventDefault(); }
                            // Diagonals
                            else if(e.key === 'q' || e.key === 'Q') { Game.movePlayer(-1, -1); e.preventDefault(); }
                            else if(e.key === 'e' || e.key === 'E') { Game.movePlayer(1, -1); e.preventDefault(); }
                            else if(e.key === 'z' || e.key === 'Z') { Game.movePlayer(-1, 1); e.preventDefault(); }
                            else if(e.key === 'c' || e.key === 'C') { Game.movePlayer(1, 1); e.preventDefault(); }
                            
                            // ELEVATION VIEW TOGGLE (V key) - DISABLED FOR MYSTERY MODE
                            // Elevation data is now hidden from player until water network is connected
                            else if(false && (e.key === 'v' || e.key === 'V')) { // DISABLED
                                if(Game.vm === 'ELEVATION') {
                                    // Return to normal view
                                    Game.vm = 'NORMAL';
                                    Controller.showElevation = false;
                                    let btn = document.getElementById('btn-view');
                                    if(btn) { btn.innerText = 'üëÅÔ∏è'; btn.title = 'Normal View'; }
                                    Controller.toast(`üó∫Ô∏è Elevation view OFF`, 2000);
                                } else {
                                    // Switch to elevation view
                                    Game.vm = 'ELEVATION';
                                    Controller.showElevation = true;
                                    let btn = document.getElementById('btn-view');
                                    if(btn) { btn.innerText = 'üó∫Ô∏è'; btn.title = 'Elevation View (Flood Risk)'; }
                                    const seaLvl = Game.geology ? Game.geology.currentSeaLevel.toFixed(1) : '?';
                                    Controller.toast(`üó∫Ô∏è ELEVATION VIEW ON - Sea Level: ${seaLvl} | üü• Danger üü® Warning üü© Safe`, 3000);
                                }
                                e.preventDefault();
                            }
                        };
                        
                        // Track shift key release for diagonal road drawing
                        window.onkeyup = (e) => {
                            if(e.key === 'Shift') Controller.shiftHeld = false;
                        };
                        
                        c.onmousedown=e=>{ 
                            // Check if click is on a UI element - don't build behind menus!
                            if(e.target !== c) {
                                return; // Click was on a UI element, not the canvas
                            }
                            
                            // Check if any menu panels are open - don't click through them
                            const menuPanels = ['building-menu-panel', 'industrial-menu-panel', 'commercial-menu-panel', 'storage-menu-panel', 'special-menu-panel', 'road-menu-panel', 'milestone-menu-panel'];
                            for(let panelId of menuPanels) {
                                let panel = document.getElementById(panelId);
                                if(panel && panel.style.display !== 'none' && panel.style.display !== '') {
                                    // A menu is open - check if click is within viewport area covered by menu
                                    let rect = panel.getBoundingClientRect();
                                    if(e.clientX >= rect.left && e.clientX <= rect.right && 
                                       e.clientY >= rect.top && e.clientY <= rect.bottom) {
                                        return; // Click is on the menu, don't process
                                    }
                                }
                            }
                            
                            // Left click: build if tool selected, otherwise move/attack
                            if (e.button==0) {
                                console.log('Mouse down - Tool:', this.tool, 'Position:', this.mx, this.my);
                                if(this.tool !== 'NONE' && this.tool !== 'PAN') {
                                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                    // HIGHLIGHTER MODE: Drag-to-paint for ROAD, RES, COM, IND
                                    // Paint zones like a highlighter - click and drag!
                                    // Falls back to normal click() if silent placement fails
                                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                    const dragTools = ['ROAD', 'RES', 'COM', 'IND', 'WELL', 'DEMOLISH'];
                                    if(dragTools.includes(this.tool)) {
                                        // Try silent placement first
                                        let placed = false;
                                        
                                        if(this.tool === 'ROAD') {
                                            placed = Game.placeRoadSilent(this.mx, this.my);
                                        } else if(this.tool === 'RES') {
                                            placed = Game.placeResSilent(this.mx, this.my);
                                        } else if(this.tool === 'COM') {
                                            placed = Game.placeComSilent(this.mx, this.my);
                                        } else if(this.tool === 'IND') {
                                            placed = Game.placeIndSilent(this.mx, this.my);
                                        } else if(this.tool === 'WELL') {
                                            placed = Game.placeWellSilent(this.mx, this.my);
                                        } else if(this.tool === 'DEMOLISH') {
                                            placed = Game.demolishSilent(this.mx, this.my);
                                        }
                                        
                                        if(placed) {
                                            // Silent placement worked - enable drag mode
                                            this.zoneDrag = true;
                                            this.zoneDragTool = this.tool;
                                            this.zoneDragBuilt = new Set();
                                            this.zoneDragCount = 1;
                                            let key = this.mx + ',' + this.my;
                                            this.zoneDragBuilt.add(key);
                                            this.lastDragPos = {x: this.mx, y: this.my}; // Track starting position for line drawing
                                            document.body.style.cursor = 'crosshair'; // SimCity-style cursor
                                            return;
                                        } else {
                                            // Silent placement failed - fall back to normal click()
                                            // This handles auto-settle, error messages, etc.
                                            console.log('Silent placement failed, falling back to click()');
                                            this.click();
                                            return;
                                        }
                                    }
                                    // Building mode - available once settled
                                    console.log('Building mode detected, calling click()');
                                    this.click();
                                } else {
                                    // Click to move player or attack animals (works in both WANDER and CITY modes)
                                    if(Game.player) {
                                        // Check if clicking on an animal - instant kill
                                        let animalIndex = Game.animals.findIndex(a => a.x === this.mx && a.y === this.my);
                                        if(animalIndex !== -1) {
                                            // Trigger bash animation
                                            if(Game.player) Game.player.bashTime = performance.now();
                                            
                                            // Move to animal position
                                            Game.movePlayerToTile(this.mx, this.my);
                                            
                                            let animal = Game.animals[animalIndex];
                                            let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                                            let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                                            
                                            // HERD DANGER: Check if other animals are on same tile or adjacent
                                            let nearbyAnimals = Game.animals.filter((a, idx) => {
                                                if(idx === animalIndex) return false; // Skip self
                                                let dx = Math.abs(a.x - animal.x);
                                                let dy = Math.abs(a.y - animal.y);
                                                return dx <= 1 && dy <= 1; // Same tile or adjacent
                                            });
                                            
                                            let isHerd = nearbyAnimals.length > 0;
                                            let herdDamage = 0;
                                            
                                            if(isHerd && Game.gameState === 'WANDER') {
                                                // Herd attack - costs 1-3 population
                                                herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                                                Game.pop = Math.max(0, Game.pop - herdDamage);
                                                Controller.toast(`‚ö†Ô∏è Attacked by herd! Lost ${herdDamage} population! (${Game.pop} remaining)`);
                                                
                                                if(Game.pop === 0) {
                                                    Controller.toast("üíÄ Your tribe has perished!");
                                                    // Game over logic could go here
                                                    Controller.updateUI();
                                                    return;
                                                }
                                            }
                                            
                                            if(Game.gameState === 'WANDER') {
                                                let totalInventory = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                                                let spaceAvailable = Game.inventory.capacity - totalInventory;
                                                
                                                // Build message with herd context
                                                let herdMsg = isHerd ? ` (Herd cost: ${herdDamage} pop)` : ' (Safe hunt!)';
                                                
                                                if(spaceAvailable >= config.foodReward) {
                                                    Game.inventory.food += config.foodReward;
                                                    Game.totalFoodCollected += config.foodReward;
                                                    Controller.toast(`üéØ ${animalName} killed! +${config.foodReward} Food${herdMsg} üçñ`);
                                                } else if(spaceAvailable > 0) {
                                                    Game.inventory.food += spaceAvailable;
                                                    Game.totalFoodCollected += spaceAvailable;
                                                    Controller.toast(`üéØ ${animalName} killed! +${spaceAvailable}/${config.foodReward} Food${herdMsg}`);
                                                } else {
                                                    Controller.toast(`üéØ ${animalName} killed! Food lost - Inventory Full!${herdMsg}`);
                                                }
                                            } else {
                                                Game.food += config.foodReward;
                                                Controller.toast(`üéØ ${animalName} killed! +${config.foodReward} Food üçñ`);
                                            }
                                            
                                            Game.animals.splice(animalIndex, 1);
                                            Game.checkProgression();
                                            Controller.updateUI();
                                        } else {
                                            // Normal movement
                                            Game.movePlayerToTile(this.mx, this.my);
                                        }
                                    }
                                }
                            }
                            // Middle click, right click, OR spacebar+left click: pan camera
                            else if(e.button==1 || e.button==2 || (e.button==0 && this.spaceHeld)) {
                                this.drag=true; 
                                this.last={x:e.clientX, y:e.clientY}; 
                                document.body.style.cursor='grabbing';
                            }
                        };
                        window.onmouseup=()=>{ 
                            this.drag=false; 
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            // HIGHLIGHTER SUMMARY: Show what was painted when drag ends
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            if(this.zoneDrag && this.zoneDragCount > 0) {
                                const toolEmoji = {
                                    'ROAD': 'üõ£Ô∏è',
                                    'RES': 'üè†',
                                    'COM': 'üè™',
                                    'IND': 'üè≠'
                                };
                                const toolName = {
                                    'ROAD': 'road',
                                    'RES': 'residential',
                                    'COM': 'commercial',
                                    'IND': 'industrial'
                                };
                                let emoji = toolEmoji[this.zoneDragTool] || 'üî®';
                                let name = toolName[this.zoneDragTool] || 'zone';
                                
                                if(this.zoneDragCount === 1) {
                                    Controller.toast(`${emoji} ${name.charAt(0).toUpperCase() + name.slice(1)} placed! (Drag to paint more)`);
                                } else {
                                    Controller.toast(`${emoji} Painted ${this.zoneDragCount} ${name} tiles!`);
                                }
                            }
                            this.zoneDrag = false;
                            this.zoneDragTool = null;
                            this.lastDragPos = null; // Clear last drag position
                            this.dragStartPos = null; // Clear start position for line snapping
                            this.zoneDragCount = 0;
                            this.zoneDragBuilt = null; // Clear the painted tile set
                            this.roadDrag=false; // Legacy compatibility
                            this.roadDragCount = 0;
                            document.body.style.cursor='default'; 
                        };
                        window.onmousemove=e=>{
                            if (this.drag) {
                                this.cam.x -= (e.clientX-this.last.x)/this.cam.z; this.cam.y -= (e.clientY-this.last.y)/this.cam.z;
                                this.cam.x = Math.max(0, Math.min(6400, this.cam.x)); this.cam.y = Math.max(0, Math.min(6400, this.cam.y));
                                this.last={x:e.clientX, y:e.clientY};
                            }
                            let r=c.getBoundingClientRect();
                            let wx=(e.clientX-r.left-Renderer.w/2)/this.cam.z+this.cam.x; let wy=(e.clientY-r.top-Renderer.h/2)/this.cam.z+this.cam.y;
                            this.mx=Math.floor(wx/CFG.TILE); this.my=Math.floor(wy/CFG.TILE);
                            document.getElementById('debug').innerText=`Pos: ${this.mx}, ${this.my}`;
                            
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            // SIMCITY-STYLE PAINT MODE: Paint zones as you drag the mouse
                            // IMPROVED: For roads, snap to straight lines (H, V, or 45¬∞ diagonal)
                            // Other zones use Bresenham for smooth painting
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            if(this.zoneDrag && this.zoneDragTool) {
                                if(!this.zoneDragBuilt) this.zoneDragBuilt = new Set();
                                if(!this.dragStartPos) this.dragStartPos = {x: this.mx, y: this.my};
                                
                                // If we have a last position, draw a line to fill gaps (SimCity style)
                                let tilesToPaint = [];
                                if(this.lastDragPos && (this.lastDragPos.x !== this.mx || this.lastDragPos.y !== this.my)) {
                                    let x0 = this.lastDragPos.x, y0 = this.lastDragPos.y;
                                    let x1 = this.mx, y1 = this.my;
                                    let dx = Math.abs(x1 - x0);
                                    let dy = Math.abs(y1 - y0);
                                    // For ROADS and WELL: STRICT straight lines only (H, V, or exact 45¬∞)
                                    if((this.zoneDragTool === 'ROAD' || this.zoneDragTool === 'WELL') && this.dragStartPos) {
                                        let startX = this.dragStartPos.x;
                                        let startY = this.dragStartPos.y;
                                        let totalDx = Math.abs(this.mx - startX);
                                        let totalDy = Math.abs(this.my - startY);
                                        let snapX = this.mx, snapY = this.my;
                                        
                                        // STRICT: Only 3 directions allowed
                                        // Horizontal if Y movement is less than 25% of X movement
                                        // Vertical if X movement is less than 25% of Y movement
                                        // Diagonal otherwise (locked to 45¬∞)
                                        if(totalDy < totalDx * 0.25) {
                                            // Horizontal line - lock Y to start
                                            snapY = startY;
                                        } else if(totalDx < totalDy * 0.25) {
                                            // Vertical line - lock X to start
                                            snapX = startX;
                                        } else {
                                            // Diagonal - force exact 45 degrees
                                            let diagDist = Math.min(totalDx, totalDy);
                                            let signX = this.mx >= startX ? 1 : -1;
                                            let signY = this.my >= startY ? 1 : -1;
                                            snapX = startX + diagDist * signX;
                                            snapY = startY + diagDist * signY;
                                        }
                                        x1 = snapX;
                                        y1 = snapY;
                                        dx = Math.abs(x1 - x0);
                                        dy = Math.abs(y1 - y0);
                                    }
                                    let sx = x0 < x1 ? 1 : -1;
                                    let sy = y0 < y1 ? 1 : -1;
                                    let err = dx - dy;
                                    let safety = 0;
                                    let maxIter = 500; // Safety limit to prevent infinite loops
                                    while (safety < maxIter) {
                                        safety++;
                                        tilesToPaint.push({x: x0, y: y0});
                                        if (x0 === x1 && y0 === y1) break;
                                        let e2 = 2 * err;
                                        if (e2 > -dy) { err -= dy; x0 += sx; }
                                        if (e2 < dx) { err += dx; y0 += sy; }
                                    }
                                } else {
                                    tilesToPaint.push({x: this.mx, y: this.my});
                                }
                                
                                // Paint all tiles in the line
                                for(let tile of tilesToPaint) {
                                    let key = tile.x + ',' + tile.y;
                                    if(!this.zoneDragBuilt.has(key)) {
                                        let placed = false;
                                        
                                        if(this.zoneDragTool === 'ROAD') {
                                            placed = Game.placeRoadSilent(tile.x, tile.y);
                                        } else if(this.zoneDragTool === 'RES') {
                                            placed = Game.placeResSilent(tile.x, tile.y);
                                        } else if(this.zoneDragTool === 'COM') {
                                            placed = Game.placeComSilent(tile.x, tile.y);
                                        } else if(this.zoneDragTool === 'IND') {
                                            placed = Game.placeIndSilent(tile.x, tile.y);
                                        } else if(this.zoneDragTool === 'WELL') {
                                            placed = Game.placeWellSilent(tile.x, tile.y);
                                        } else if(this.zoneDragTool === 'DEMOLISH') {
                                            placed = Game.demolishSilent(tile.x, tile.y);
                                        }
                                        
                                        if(placed) {
                                            this.zoneDragCount = (this.zoneDragCount || 0) + 1;
                                        }
                                        this.zoneDragBuilt.add(key);
                                    }
                                }
                                
                                // Update last position for next mousemove
                                this.lastDragPos = {x: this.mx, y: this.my};
                            }
                        };
                        c.onwheel=e=>{ e.preventDefault(); let f=e.deltaY<0?CFG.ZOOM.STEP:1/CFG.ZOOM.STEP; this.cam.z=Math.max(CFG.ZOOM.MIN, Math.min(CFG.ZOOM.MAX, this.cam.z*f)); this._dirty=true; }, {passive:false};
                        
                        // PERFORMANCE: Frame timing for 30 FPS cap (saves CPU/battery)
                        let lastFrameTime = 0;
                        const TARGET_FPS = 30;
                        const FRAME_TIME = 1000 / TARGET_FPS;
                        let frameCount = 0;
                        
                        const loop=(timestamp)=> { 
                            // PERFORMANCE: Skip frames to maintain 30 FPS cap
                            const elapsed = timestamp - lastFrameTime;
                            if(elapsed < FRAME_TIME) {
                                requestAnimationFrame(loop);
                                return;
                            }
                            lastFrameTime = timestamp - (elapsed % FRAME_TIME);
                            frameCount++;
                            
                            try {
                                // Process player pathfinding automatically
                                if(Game.pathQueue && Game.pathQueue.length > 0) {
                                    Game.processPath();
                                }
                                
                                // AI autoplay (throttled - every 2nd frame)
                                if(frameCount % 2 === 0) {
                                    Game.aiUpdate();
                                }
                                
                                // Update building evolution states (every 30 frames = ~1 second at 30fps)
                                if(frameCount % 30 === 0) {
                                    Game.updateBuildingEvolution();
                                }
                                
                                // Render
                                Renderer.draw(this.cam);
                            } catch(err) {
                                console.error('Game loop error:', err);
                                // Continue running even if there's an error
                            }
                            requestAnimationFrame(loop); 
                        }; 
                        console.log('Starting animation loop...');
                        loop();
                    }, 200);
                } catch(e){
                    console.error('Initialization error:', e);
                    Controller.toast('ERROR: ' + e.message);
                }
            },
            click() {
                let gx=this.mx, gy=this.my;
                console.log('Click handler - Tool:', this.tool, 'Position:', gx, gy);
                if (this.tool!='NONE' && this.tool!='PAN') {
                    // Auto-settle UX: If trying to build Residential while still in WANDER, attempt to settle
                    if (this.tool === 'RES' && typeof Game !== 'undefined' && Game.gameState !== 'CITY') {
                        console.log('Attempting auto-settle before building RES...');
                        Controller.toast('üèõÔ∏è Settling so you can build...');
                        if (typeof Game.settleHere === 'function') {
                            Game.settleHere();
                            // If settlement succeeded, proceed to build
                            if (Game.gameState === 'CITY') {
                                console.log('Auto-settle succeeded, placing RES');
                                Game.build(this.tool, gx, gy);
                            } else {
                                console.log('Auto-settle failed due to requirements');
                                Controller.toast('‚ö†Ô∏è Settle first: Need water nearby + basic resources');
                            }
                            return;
                        }
                    }
                    console.log('Calling Game.build with:', this.tool, gx, gy);
                    Game.build(this.tool, gx, gy);
                } else {
                    console.log('Tool is NONE or PAN, not building');
                }
            },
            setTool(t) { 
                // Check if button is disabled
                let btnId = 't-' + t.toLowerCase();
                let btn = document.getElementById(btnId);
                if(btn && btn.disabled) {
                    Controller.toast(btn.title || 'üîí This building is locked');
                    return;
                }
                
                // Reset diagonal road tracking when switching tools
                if(t !== 'ROAD' && typeof Game !== 'undefined') {
                    Game.lastRoadPos = null;
                }
                
                this.tool=t; 
                document.querySelectorAll('.build-btn').forEach(b => b.classList.remove('active')); 
                let b=document.getElementById('b-'+t.toLowerCase()); 
                if(b) b.classList.add('active'); 
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // BUILDING PREVIEW DRAWER - Beautiful miniature icons for UI menus
            // These look EXTRA nice - better than in-game buildings!
            // Now supports 4 VARIANT STATES per level for population-based visuals
            // Variant 0 = Abandoned, 1 = Low, 2 = Medium, 3 = High
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Draw beautiful residential preview with VARIANT support
            drawBuildingPreview(canvas, level, variant = 3) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const T = Math.min(w, h) * 0.85;
                const cx = w / 2;
                const cy = h / 2;
                
                // Clear canvas
                ctx.clearRect(0, 0, w, h);
                
                // Background depends on variant (abandoned = darker/desolate)
                const isAbandoned = variant === 0;
                const bgGrad = ctx.createRadialGradient(cx, cy*0.7, 0, cx, cy, T*0.7);
                if(isAbandoned) {
                    bgGrad.addColorStop(0, '#4A5A3B');
                    bgGrad.addColorStop(0.7, '#3A4A2A');
                    bgGrad.addColorStop(1, '#2D3B1A');
                } else {
                    bgGrad.addColorStop(0, '#6B9B4B');
                    bgGrad.addColorStop(0.7, '#4A7A2A');
                    bgGrad.addColorStop(1, '#3D6B22');
                }
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                // Add subtle grass texture (less for abandoned)
                ctx.fillStyle = isAbandoned ? 'rgba(40, 50, 30, 0.3)' : 'rgba(60, 90, 40, 0.3)';
                for(let i = 0; i < (isAbandoned ? 4 : 8); i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random()*w, Math.random()*h, T*0.02, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 1: TREE SHELTER - 4 states from Abandoned Nest to Sturdy Treehouse
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(level === 1) {
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê ABANDONED NEST - Broken, empty tree with fallen nest ‚ïê‚ïê‚ïê
                        // Dead/dying tree trunk - grayish, cracked
                        const trunkGrad = ctx.createLinearGradient(cx - T*0.15, 0, cx + T*0.1, 0);
                        trunkGrad.addColorStop(0, '#3A3A35');
                        trunkGrad.addColorStop(0.5, '#4A4A42');
                        trunkGrad.addColorStop(1, '#3A3A35');
                        ctx.fillStyle = trunkGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.12, cy + T*0.4);
                        ctx.quadraticCurveTo(cx - T*0.18, cy, cx - T*0.08, cy - T*0.1);
                        ctx.quadraticCurveTo(cx + T*0.08, cy - T*0.15, cx + T*0.1, cy + T*0.4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Dead branches - bare, broken
                        ctx.strokeStyle = '#4A4540';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.05, cy - T*0.08);
                        ctx.lineTo(cx - T*0.22, cy - T*0.2);
                        ctx.moveTo(cx + T*0.03, cy - T*0.12);
                        ctx.lineTo(cx + T*0.18, cy - T*0.25);
                        ctx.lineTo(cx + T*0.15, cy - T*0.3); // Broken tip
                        ctx.stroke();
                        
                        // Fallen nest debris on ground
                        ctx.fillStyle = '#5A4A30';
                        ctx.beginPath();
                        ctx.ellipse(cx - T*0.15, cy + T*0.32, T*0.12, T*0.06, 0.2, 0, Math.PI*2);
                        ctx.fill();
                        // Scattered twigs
                        ctx.strokeStyle = '#6B5A40';
                        ctx.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.25 + i*T*0.08, cy + T*0.28);
                            ctx.lineTo(cx - T*0.22 + i*T*0.07, cy + T*0.38);
                            ctx.stroke();
                        }
                        
                        // X mark to show abandoned
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.25);
                        ctx.lineTo(cx + T*0.25, cy + T*0.15);
                        ctx.moveTo(cx + T*0.25, cy - T*0.25);
                        ctx.lineTo(cx - T*0.25, cy + T*0.15);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SMALL NEST - Simple bird-like nest, sparse tree ‚ïê‚ïê‚ïê
                        // Young tree trunk
                        const trunkGrad = ctx.createLinearGradient(cx - T*0.1, 0, cx + T*0.1, 0);
                        trunkGrad.addColorStop(0, '#4A3520');
                        trunkGrad.addColorStop(0.5, '#5A4528');
                        trunkGrad.addColorStop(1, '#4A3520');
                        ctx.fillStyle = trunkGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.08, cy + T*0.4);
                        ctx.lineTo(cx - T*0.06, cy - T*0.05);
                        ctx.lineTo(cx + T*0.06, cy - T*0.08);
                        ctx.lineTo(cx + T*0.08, cy + T*0.4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Small branches
                        ctx.strokeStyle = '#5A4528';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - T*0.05);
                        ctx.lineTo(cx - T*0.15, cy - T*0.15);
                        ctx.moveTo(cx, cy - T*0.08);
                        ctx.lineTo(cx + T*0.12, cy - T*0.18);
                        ctx.stroke();
                        
                        // Sparse leaves
                        ctx.fillStyle = '#3A6A25';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.12, cy - T*0.18, T*0.08, 0, Math.PI*2);
                        ctx.arc(cx + T*0.1, cy - T*0.22, T*0.07, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Simple small nest - just twigs
                        ctx.fillStyle = '#7A6040';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.05, T*0.1, T*0.06, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Nest texture
                        ctx.strokeStyle = '#5A4530';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(cx, cy + T*0.05, T*0.06, 0, Math.PI*2);
                        ctx.stroke();
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê TREE PLATFORM - Sturdy platform with small shelter frame ‚ïê‚ïê‚ïê
                        // Healthy tree trunk
                        const trunkGrad = ctx.createLinearGradient(cx - T*0.12, 0, cx + T*0.1, 0);
                        trunkGrad.addColorStop(0, '#3D2817');
                        trunkGrad.addColorStop(0.5, '#5A3D25');
                        trunkGrad.addColorStop(1, '#3D2817');
                        ctx.fillStyle = trunkGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.1, cy + T*0.4);
                        ctx.quadraticCurveTo(cx - T*0.15, cy, cx - T*0.08, cy - T*0.1);
                        ctx.quadraticCurveTo(cx + T*0.08, cy - T*0.15, cx + T*0.1, cy + T*0.4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Leafy canopy
                        ctx.fillStyle = '#2E5E1A';
                        ctx.beginPath();
                        ctx.arc(cx, cy - T*0.22, T*0.2, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#3D7A25';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.08, cy - T*0.18, T*0.12, 0, Math.PI*2);
                        ctx.arc(cx + T*0.08, cy - T*0.2, T*0.1, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Platform - solid wooden base
                        ctx.fillStyle = '#8B6914';
                        ctx.fillRect(cx - T*0.18, cy - T*0.02, T*0.36, T*0.08);
                        // Platform supports
                        ctx.fillStyle = '#6B4E0A';
                        ctx.fillRect(cx - T*0.16, cy + T*0.06, T*0.04, T*0.1);
                        ctx.fillRect(cx + T*0.12, cy + T*0.06, T*0.04, T*0.1);
                        
                        // Simple shelter frame (A-frame poles)
                        ctx.strokeStyle = '#5C4A3D';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.12, cy - T*0.02);
                        ctx.lineTo(cx, cy - T*0.15);
                        ctx.lineTo(cx + T*0.12, cy - T*0.02);
                        ctx.stroke();
                        
                        // Rope ladder
                        ctx.strokeStyle = '#A08060';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.2, cy + T*0.06);
                        ctx.lineTo(cx + T*0.25, cy + T*0.35);
                        ctx.moveTo(cx + T*0.22, cy + T*0.06);
                        ctx.lineTo(cx + T*0.27, cy + T*0.35);
                        ctx.stroke();
                        // Rungs
                        for(let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx + T*0.2 + i*T*0.015, cy + T*0.12 + i*T*0.08);
                            ctx.lineTo(cx + T*0.22 + i*T*0.015, cy + T*0.12 + i*T*0.08);
                            ctx.stroke();
                        }
                        
                    } else {
                        // ‚ïê‚ïê‚ïê STURDY TREEHOUSE (variant 3) - Full featured tree home ‚ïê‚ïê‚ïê
                        // Massive ancient tree trunk with texture
                        const trunkGrad = ctx.createLinearGradient(cx - T*0.15, 0, cx + T*0.1, 0);
                        trunkGrad.addColorStop(0, '#3D2817');
                        trunkGrad.addColorStop(0.5, '#5A3D25');
                        trunkGrad.addColorStop(1, '#3D2817');
                        ctx.fillStyle = trunkGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.14, cy + T*0.4);
                        ctx.quadraticCurveTo(cx - T*0.2, cy, cx - T*0.1, cy - T*0.12);
                        ctx.quadraticCurveTo(cx + T*0.1, cy - T*0.18, cx + T*0.12, cy + T*0.4);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Bark texture lines
                        ctx.strokeStyle = '#2E1A0A';
                        ctx.lineWidth = 1;
                        for(let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.08 + i*T*0.04, cy + T*0.35);
                            ctx.quadraticCurveTo(cx - T*0.1 + i*T*0.05, cy + T*0.1, cx - T*0.06 + i*T*0.03, cy - T*0.05);
                            ctx.stroke();
                        }
                        
                        // Lush multi-layered canopy
                        const canopyColors = ['#1E4D0F', '#2E5E1A', '#3D7A25', '#4A8A30'];
                        canopyColors.forEach((color, i) => {
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(cx + (i-1.5)*T*0.08, cy - T*0.18 - i*T*0.03, T*0.28 - i*T*0.03, 0, Math.PI*2);
                            ctx.fill();
                        });
                        
                        // Hanging vines
                        ctx.strokeStyle = '#2E5E1A';
                        ctx.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.2 + i*T*0.15, cy - T*0.25);
                            ctx.quadraticCurveTo(cx - T*0.22 + i*T*0.15, cy + T*0.1, cx - T*0.18 + i*T*0.12, cy + T*0.2);
                            ctx.stroke();
                        }
                        
                        // Woven platform/nest with detail
                        ctx.fillStyle = '#8B6914';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy - T*0.05, T*0.2, T*0.12, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Weave pattern
                        ctx.strokeStyle = '#6B4E0A';
                        ctx.lineWidth = 1;
                        for(let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.18 + i*T*0.1, cy - T*0.12);
                            ctx.lineTo(cx - T*0.15 + i*T*0.1, cy + T*0.05);
                            ctx.stroke();
                        }
                        
                        // Full shelter with thatched roof
                        ctx.fillStyle = '#C4A035';
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - T*0.22);
                        ctx.lineTo(cx - T*0.12, cy - T*0.05);
                        ctx.lineTo(cx + T*0.12, cy - T*0.05);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Warm glow from inside
                        ctx.fillStyle = 'rgba(255, 180, 100, 0.6)';
                        ctx.beginPath();
                        ctx.arc(cx, cy - T*0.08, T*0.04, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 2: GROUND PIT - 4 states from Collapsed Pit to Covered Pit Dwelling
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                } else if(level === 2) {
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê COLLAPSED PIT - Caved in, unusable ‚ïê‚ïê‚ïê
                        // Ground with cracks
                        ctx.fillStyle = '#4D4030';
                        ctx.fillRect(0, cy + T*0.1, w, h);
                        
                        // Collapsed pit - irregular, filled with dirt
                        const pitGrad = ctx.createRadialGradient(cx, cy + T*0.15, 0, cx, cy + T*0.15, T*0.3);
                        pitGrad.addColorStop(0, '#3A2E20');
                        pitGrad.addColorStop(0.5, '#4A3D30');
                        pitGrad.addColorStop(1, '#5D4E3D');
                        ctx.fillStyle = pitGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.15, T*0.28, T*0.18, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Rubble and debris
                        ctx.fillStyle = '#6A5A4A';
                        for(let i = 0; i < 6; i++) {
                            ctx.beginPath();
                            ctx.arc(cx - T*0.15 + i*T*0.06, cy + T*0.12 + (i%2)*T*0.05, T*0.04, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Broken support poles sticking out
                        ctx.strokeStyle = '#5A4A3D';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.12, cy + T*0.1);
                        ctx.lineTo(cx - T*0.18, cy - T*0.1);
                        ctx.moveTo(cx + T*0.08, cy + T*0.15);
                        ctx.lineTo(cx + T*0.15, cy - T*0.05);
                        ctx.stroke();
                        
                        // X mark
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.15);
                        ctx.lineTo(cx + T*0.25, cy + T*0.25);
                        ctx.moveTo(cx + T*0.25, cy - T*0.15);
                        ctx.lineTo(cx - T*0.25, cy + T*0.25);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SHALLOW SCRAPE - Basic depression, barely functional ‚ïê‚ïê‚ïê
                        ctx.fillStyle = '#5D4E37';
                        ctx.fillRect(0, cy + T*0.15, w, h);
                        
                        // Shallow pit - small, simple
                        const pitGrad = ctx.createRadialGradient(cx, cy + T*0.18, 0, cx, cy + T*0.18, T*0.22);
                        pitGrad.addColorStop(0, '#3A2A1A');
                        pitGrad.addColorStop(0.7, '#4A3A28');
                        pitGrad.addColorStop(1, '#5D4E37');
                        ctx.fillStyle = pitGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.18, T*0.22, T*0.12, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Few leaves for bedding
                        ctx.fillStyle = '#8B7355';
                        for(let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.ellipse(cx - T*0.08 + i*T*0.08, cy + T*0.18, T*0.04, T*0.02, i*0.3, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Single leaning stick for wind break
                        ctx.strokeStyle = '#5C4A3D';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.15, cy + T*0.25);
                        ctx.lineTo(cx - T*0.08, cy - T*0.1);
                        ctx.stroke();
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê DUG PIT - Proper pit with some amenities ‚ïê‚ïê‚ïê
                        ctx.fillStyle = '#5D4E37';
                        ctx.fillRect(0, cy + T*0.15, w, h);
                        
                        // Deeper pit with defined edges
                        const pitGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy + T*0.1, T*0.32);
                        pitGrad.addColorStop(0, '#2A1A0A');
                        pitGrad.addColorStop(0.6, '#3D2817');
                        pitGrad.addColorStop(1, '#4A3520');
                        ctx.fillStyle = pitGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.1, T*0.32, T*0.2, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Straw bedding
                        ctx.fillStyle = '#C4A035';
                        for(let i = 0; i < 5; i++) {
                            ctx.save();
                            ctx.translate(cx - T*0.15 + i*T*0.06, cy + T*0.1);
                            ctx.rotate((i - 2) * 0.15);
                            ctx.fillRect(0, 0, T*0.04, T*0.08);
                            ctx.restore();
                        }
                        
                        // Two support poles
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.2, cy + T*0.05);
                        ctx.lineTo(cx - T*0.2, cy - T*0.2);
                        ctx.moveTo(cx + T*0.2, cy + T*0.05);
                        ctx.lineTo(cx + T*0.2, cy - T*0.2);
                        ctx.stroke();
                        
                        // Small fire
                        const fireGrad = ctx.createRadialGradient(cx, cy + T*0.22, 0, cx, cy + T*0.22, T*0.06);
                        fireGrad.addColorStop(0, '#FFD93D');
                        fireGrad.addColorStop(0.5, '#FF6B35');
                        fireGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = fireGrad;
                        ctx.beginPath();
                        ctx.arc(cx, cy + T*0.22, T*0.06, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else {
                        // ‚ïê‚ïê‚ïê COVERED PIT DWELLING (variant 3) - Full featured ‚ïê‚ïê‚ïê
                        // Ground level with depth
                        ctx.fillStyle = '#5D4E37';
                        ctx.fillRect(0, cy + T*0.15, w, h);
                        
                        // Dug pit with shadow
                        const pitGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy + T*0.1, T*0.35);
                        pitGrad.addColorStop(0, '#2A1A0A');
                        pitGrad.addColorStop(0.7, '#3D2817');
                        pitGrad.addColorStop(1, '#4A3520');
                        ctx.fillStyle = pitGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.1, T*0.35, T*0.22, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Straw/reed bedding with texture
                        ctx.fillStyle = '#C4A035';
                        for(let i = 0; i < 7; i++) {
                            ctx.save();
                            ctx.translate(cx - T*0.22 + i*T*0.07, cy + T*0.08);
                            ctx.rotate((i - 3) * 0.1);
                            ctx.fillRect(0, 0, T*0.05, T*0.1);
                            ctx.restore();
                        }
                        
                        // Drying rack with poles
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.3);
                        ctx.lineTo(cx - T*0.25, cy - T*0.05);
                        ctx.moveTo(cx + T*0.25, cy - T*0.3);
                        ctx.lineTo(cx + T*0.25, cy - T*0.05);
                        ctx.stroke();
                        // Cross bar
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.28, cy - T*0.22);
                        ctx.lineTo(cx + T*0.28, cy - T*0.22);
                        ctx.stroke();
                        
                        // Hanging meat strips with drip detail
                        ctx.fillStyle = '#8B2500';
                        ctx.fillRect(cx - T*0.18, cy - T*0.2, T*0.08, T*0.14);
                        ctx.fillRect(cx - T*0.05, cy - T*0.2, T*0.08, T*0.12);
                        ctx.fillRect(cx + T*0.1, cy - T*0.2, T*0.07, T*0.13);
                        // Fat drips
                        ctx.fillStyle = '#FFE4B5';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.14, cy - T*0.05, T*0.015, 0, Math.PI*2);
                        ctx.arc(cx + T*0.13, cy - T*0.06, T*0.012, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Warm fire
                        const fireGrad = ctx.createRadialGradient(cx, cy + T*0.28, 0, cx, cy + T*0.28, T*0.1);
                        fireGrad.addColorStop(0, '#FFD93D');
                        fireGrad.addColorStop(0.5, '#FF6B35');
                        fireGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = fireGrad;
                        ctx.beginPath();
                        ctx.arc(cx, cy + T*0.28, T*0.1, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 3: GROUND CAVE - 4 states from Collapsed Cave to Cave Complex
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                } else if(level === 3) {
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê COLLAPSED CAVE - Rubble pile, blocked entrance ‚ïê‚ïê‚ïê
                        // Dark rocky mound
                        const moundGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy, T*0.5);
                        moundGrad.addColorStop(0, '#4A4540');
                        moundGrad.addColorStop(1, '#3A3530');
                        ctx.fillStyle = moundGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.45, cy + T*0.32);
                        ctx.quadraticCurveTo(cx - T*0.3, cy - T*0.15, cx, cy - T*0.22);
                        ctx.quadraticCurveTo(cx + T*0.3, cy - T*0.15, cx + T*0.45, cy + T*0.32);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Rubble/boulder pile blocking entrance
                        ctx.fillStyle = '#5A5550';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.1, cy + T*0.15, T*0.1, 0, Math.PI*2);
                        ctx.arc(cx + T*0.05, cy + T*0.1, T*0.12, 0, Math.PI*2);
                        ctx.arc(cx, cy + T*0.22, T*0.08, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Cracks in rock
                        ctx.strokeStyle = '#2A2520';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.15, cy - T*0.1);
                        ctx.lineTo(cx - T*0.1, cy + T*0.05);
                        ctx.moveTo(cx + T*0.1, cy - T*0.05);
                        ctx.lineTo(cx + T*0.2, cy + T*0.1);
                        ctx.stroke();
                        
                        // X mark
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.2);
                        ctx.lineTo(cx + T*0.25, cy + T*0.2);
                        ctx.moveTo(cx + T*0.25, cy - T*0.2);
                        ctx.lineTo(cx - T*0.25, cy + T*0.2);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SMALL CAVE - Simple rock overhang, basic shelter ‚ïê‚ïê‚ïê
                        // Small rocky outcrop
                        const moundGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy, T*0.4);
                        moundGrad.addColorStop(0, '#5D5550');
                        moundGrad.addColorStop(1, '#4A4540');
                        ctx.fillStyle = moundGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.35, cy + T*0.32);
                        ctx.quadraticCurveTo(cx - T*0.25, cy - T*0.1, cx, cy - T*0.18);
                        ctx.quadraticCurveTo(cx + T*0.25, cy - T*0.1, cx + T*0.35, cy + T*0.32);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Small dark opening
                        ctx.fillStyle = '#1A1510';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.15, T*0.08, T*0.1, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Few stones around entrance
                        ctx.fillStyle = '#6A6560';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.12, cy + T*0.25, T*0.04, 0, Math.PI*2);
                        ctx.arc(cx + T*0.1, cy + T*0.28, T*0.03, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê DEEP CAVE - Larger cave with basic improvements ‚ïê‚ïê‚ïê
                        // Larger rock formation
                        const moundGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy, T*0.45);
                        moundGrad.addColorStop(0, '#5D5045');
                        moundGrad.addColorStop(1, '#4A4035');
                        ctx.fillStyle = moundGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.4, cy + T*0.32);
                        ctx.quadraticCurveTo(cx - T*0.32, cy - T*0.2, cx, cy - T*0.28);
                        ctx.quadraticCurveTo(cx + T*0.32, cy - T*0.2, cx + T*0.4, cy + T*0.32);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Grass on top
                        ctx.fillStyle = '#4A7A2A';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy - T*0.22, T*0.12, T*0.06, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Larger entrance
                        ctx.fillStyle = '#0A0505';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.12, T*0.1, T*0.13, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Glow from inside (fire)
                        const glowGrad = ctx.createRadialGradient(cx, cy + T*0.18, 0, cx, cy + T*0.12, T*0.1);
                        glowGrad.addColorStop(0, 'rgba(255, 120, 40, 0.6)');
                        glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.15, T*0.08, T*0.1, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Stone windbreak at entrance
                        ctx.fillStyle = '#6B6B6B';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.12, cy + T*0.2, T*0.05, 0, Math.PI*2);
                        ctx.arc(cx + T*0.12, cy + T*0.2, T*0.05, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else {
                        // ‚ïê‚ïê‚ïê CAVE COMPLEX (variant 3) - Full hobbit-style dwelling ‚ïê‚ïê‚ïê
                        // Rich earth mound with grass
                        const moundGrad = ctx.createRadialGradient(cx, cy + T*0.1, 0, cx, cy, T*0.5);
                        moundGrad.addColorStop(0, '#5D4E37');
                        moundGrad.addColorStop(1, '#4A3D2A');
                        ctx.fillStyle = moundGrad;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.45, cy + T*0.32);
                        ctx.quadraticCurveTo(cx - T*0.35, cy - T*0.28, cx, cy - T*0.35);
                        ctx.quadraticCurveTo(cx + T*0.35, cy - T*0.28, cx + T*0.45, cy + T*0.32);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Grass patches on mound
                        ctx.fillStyle = '#4A7A2A';
                        ctx.beginPath();
                        ctx.ellipse(cx - T*0.1, cy - T*0.22, T*0.15, T*0.08, -0.2, 0, Math.PI*2);
                        ctx.ellipse(cx + T*0.15, cy - T*0.18, T*0.12, T*0.07, 0.3, 0, Math.PI*2);
                        ctx.ellipse(cx, cy - T*0.28, T*0.18, T*0.1, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                        // Stone-framed entrance
                        ctx.fillStyle = '#6B6B6B';
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.2, cy + T*0.25);
                        ctx.lineTo(cx - T*0.18, cy - T*0.02);
                        ctx.quadraticCurveTo(cx, cy - T*0.12, cx + T*0.18, cy - T*0.02);
                        ctx.lineTo(cx + T*0.2, cy + T*0.25);
                        ctx.lineTo(cx + T*0.15, cy + T*0.25);
                        ctx.lineTo(cx + T*0.13, cy + T*0.02);
                        ctx.quadraticCurveTo(cx, cy - T*0.05, cx - T*0.13, cy + T*0.02);
                        ctx.lineTo(cx - T*0.15, cy + T*0.25);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Dark entrance
                        ctx.fillStyle = '#0A0505';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.12, T*0.12, T*0.15, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Warm fire glow from inside
                        const glowGrad = ctx.createRadialGradient(cx, cy + T*0.18, 0, cx, cy + T*0.1, T*0.15);
                        glowGrad.addColorStop(0, 'rgba(255, 150, 50, 0.8)');
                        glowGrad.addColorStop(0.5, 'rgba(255, 100, 30, 0.4)');
                        glowGrad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctx.fillStyle = glowGrad;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + T*0.15, T*0.1, T*0.12, 0, 0, Math.PI);
                        ctx.fill();
                        
                        // Stone chimney with smoke
                        ctx.fillStyle = '#5A5A5A';
                        ctx.fillRect(cx + T*0.18, cy - T*0.4, T*0.1, T*0.25);
                        // Smoke puffs
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.23, cy - T*0.45, T*0.04, 0, Math.PI*2);
                        ctx.arc(cx + T*0.2, cy - T*0.52, T*0.03, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 4: TIPI VILLAGE - 4 states from Abandoned Tipis to Full Village
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                } else if(level === 4) {
                    // Helper to draw a tipi
                    const drawTipi = (tx, ty, size, decorated, collapsed = false) => {
                        if(collapsed) {
                            // Collapsed tipi - fallen poles
                            ctx.strokeStyle = '#5C4A3D';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(tx - size*0.2, ty + size*0.2);
                            ctx.lineTo(tx + size*0.15, ty - size*0.1);
                            ctx.moveTo(tx - size*0.1, ty + size*0.22);
                            ctx.lineTo(tx + size*0.2, ty);
                            ctx.stroke();
                            // Torn hide
                            ctx.fillStyle = '#8A7A68';
                            ctx.beginPath();
                            ctx.ellipse(tx, ty + size*0.1, size*0.15, size*0.08, 0.3, 0, Math.PI*2);
                            ctx.fill();
                            return;
                        }
                        
                        // Tipi body with gradient
                        const tipiGrad = ctx.createLinearGradient(tx - size*0.3, ty, tx + size*0.3, ty);
                        tipiGrad.addColorStop(0, '#C4B498');
                        tipiGrad.addColorStop(0.5, '#E8DCC8');
                        tipiGrad.addColorStop(1, '#C4B498');
                        ctx.fillStyle = tipiGrad;
                        ctx.beginPath();
                        ctx.moveTo(tx, ty - size*0.55);
                        ctx.lineTo(tx - size*0.32, ty + size*0.3);
                        ctx.lineTo(tx + size*0.32, ty + size*0.3);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Poles sticking out top
                        ctx.strokeStyle = '#5C4A3D';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(tx - size*0.05, ty - size*0.5);
                        ctx.lineTo(tx - size*0.12, ty - size*0.7);
                        ctx.moveTo(tx + size*0.05, ty - size*0.5);
                        ctx.lineTo(tx + size*0.12, ty - size*0.7);
                        ctx.stroke();
                        
                        // Decorative bands
                        if(decorated) {
                            ctx.strokeStyle = '#8B4513';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(tx - size*0.22, ty + size*0.1);
                            ctx.lineTo(tx + size*0.22, ty + size*0.1);
                            ctx.stroke();
                            ctx.fillStyle = '#8B4513';
                            ctx.beginPath();
                            ctx.arc(tx, ty - size*0.1, size*0.04, 0, Math.PI*2);
                            ctx.fill();
                        }
                        
                        // Door flap
                        ctx.fillStyle = '#1A0F05';
                        ctx.beginPath();
                        ctx.ellipse(tx, ty + size*0.15, size*0.08, size*0.12, 0, 0, Math.PI*2);
                        ctx.fill();
                    };
                    
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê ABANDONED TIPIS - Collapsed, scattered ‚ïê‚ïê‚ïê
                        drawTipi(cx - T*0.15, cy + T*0.05, T*0.45, false, true);
                        drawTipi(cx + T*0.2, cy + T*0.1, T*0.4, false, true);
                        // X mark
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.2);
                        ctx.lineTo(cx + T*0.25, cy + T*0.2);
                        ctx.moveTo(cx + T*0.25, cy - T*0.2);
                        ctx.lineTo(cx - T*0.25, cy + T*0.2);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SMALL CAMP - Single tipi, minimal setup ‚ïê‚ïê‚ïê
                        drawTipi(cx, cy + T*0.08, T*0.5, false);
                        // Small fire pit (cold)
                        ctx.fillStyle = '#4A4040';
                        ctx.beginPath();
                        ctx.ellipse(cx + T*0.2, cy + T*0.28, T*0.05, T*0.03, 0, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê TIPI CIRCLE - Two tipis with fire ‚ïê‚ïê‚ïê
                        drawTipi(cx - T*0.15, cy + T*0.05, T*0.48, true);
                        drawTipi(cx + T*0.18, cy + T*0.1, T*0.42, false);
                        // Active campfire
                        ctx.fillStyle = '#FF6B35';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.02, cy + T*0.3, T*0.04, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#FFD93D';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.02, cy + T*0.28, T*0.025, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else {
                        // ‚ïê‚ïê‚ïê TIPI VILLAGE (variant 3) - Full village ‚ïê‚ïê‚ïê
                        drawTipi(cx - T*0.18, cy + T*0.05, T*0.55, true);
                        drawTipi(cx + T*0.22, cy + T*0.1, T*0.5, true);
                        // Large campfire
                        ctx.fillStyle = '#FF6B35';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.02, cy + T*0.3, T*0.05, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#FFD93D';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.02, cy + T*0.28, T*0.03, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 5: LONGHOUSE - 4 states from Ruined to Clan Longhouse
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                } else if(level === 5) {
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê RUINED LONGHOUSE - Collapsed structure ‚ïê‚ïê‚ïê
                        // Fallen walls
                        ctx.fillStyle = '#4A3A2D';
                        ctx.fillRect(cx - T*0.3, cy + T*0.1, T*0.5, T*0.15);
                        // Collapsed roof debris
                        ctx.fillStyle = '#8A7A55';
                        for(let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.ellipse(cx - T*0.2 + i*T*0.1, cy + T*0.05, T*0.06, T*0.03, i*0.2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Broken frame
                        ctx.strokeStyle = '#5C4A3D';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy + T*0.1);
                        ctx.lineTo(cx - T*0.2, cy - T*0.1);
                        ctx.moveTo(cx + T*0.15, cy + T*0.1);
                        ctx.lineTo(cx + T*0.2, cy - T*0.05);
                        ctx.stroke();
                        // X mark
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.3, cy - T*0.15);
                        ctx.lineTo(cx + T*0.3, cy + T*0.2);
                        ctx.moveTo(cx + T*0.3, cy - T*0.15);
                        ctx.lineTo(cx - T*0.3, cy + T*0.2);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SMALL LONGHOUSE - Basic structure ‚ïê‚ïê‚ïê
                        ctx.fillStyle = '#5C3A1D';
                        ctx.fillRect(cx - T*0.25, cy + T*0.02, T*0.5, T*0.28);
                        // Simple roof
                        ctx.fillStyle = '#8B7355';
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.28, cy + T*0.02);
                        ctx.lineTo(cx, cy - T*0.15);
                        ctx.lineTo(cx + T*0.28, cy + T*0.02);
                        ctx.closePath();
                        ctx.fill();
                        // Simple door
                        ctx.fillStyle = '#1A0F05';
                        ctx.fillRect(cx - T*0.05, cy + T*0.15, T*0.1, T*0.15);
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê FAMILY LONGHOUSE - Better built ‚ïê‚ïê‚ïê
                        const wallGrad = ctx.createLinearGradient(cx - T*0.32, 0, cx + T*0.32, 0);
                        wallGrad.addColorStop(0, '#5C3A1D');
                        wallGrad.addColorStop(0.5, '#6B4828');
                        wallGrad.addColorStop(1, '#5C3A1D');
                        ctx.fillStyle = wallGrad;
                        ctx.fillRect(cx - T*0.32, cy, T*0.64, T*0.3);
                        // Barrel roof
                        ctx.fillStyle = '#C4A035';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, T*0.34, T*0.18, 0, Math.PI, Math.PI*2);
                        ctx.fill();
                        // Door
                        ctx.fillStyle = '#1A0F05';
                        ctx.fillRect(cx - T*0.06, cy + T*0.1, T*0.12, T*0.18);
                        // Smoke hole
                        ctx.fillStyle = 'rgba(180, 180, 180, 0.4)';
                        ctx.beginPath();
                        ctx.arc(cx, cy - T*0.15, T*0.02, 0, Math.PI*2);
                        ctx.fill();
                        
                    } else {
                        // ‚ïê‚ïê‚ïê CLAN LONGHOUSE (variant 3) - Full featured ‚ïê‚ïê‚ïê
                        const wallGrad = ctx.createLinearGradient(cx - T*0.38, 0, cx + T*0.38, 0);
                        wallGrad.addColorStop(0, '#5C3A1D');
                        wallGrad.addColorStop(0.3, '#7B5030');
                        wallGrad.addColorStop(0.7, '#7B5030');
                        wallGrad.addColorStop(1, '#5C3A1D');
                        ctx.fillStyle = wallGrad;
                        ctx.fillRect(cx - T*0.38, cy - T*0.02, T*0.76, T*0.35);
                        // Barrel roof with thatch
                        ctx.fillStyle = '#C4A035';
                        ctx.beginPath();
                        ctx.ellipse(cx, cy - T*0.02, T*0.4, T*0.22, 0, Math.PI, Math.PI*2);
                        ctx.fill();
                        // Thatch lines
                        ctx.strokeStyle = '#8B7355';
                        ctx.lineWidth = 1;
                        for(let i = 0; i < 6; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.35 + i*T*0.14, cy - T*0.02);
                            ctx.quadraticCurveTo(cx - T*0.35 + i*T*0.14, cy - T*0.18, cx - T*0.3 + i*T*0.12, cy - T*0.02);
                            ctx.stroke();
                        }
                        // Log texture
                        ctx.strokeStyle = '#3E2E1E';
                        for(let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.36, cy + T*0.02 + i*T*0.065);
                            ctx.lineTo(cx + T*0.36, cy + T*0.02 + i*T*0.065);
                            ctx.stroke();
                        }
                        // Entrance
                        ctx.fillStyle = '#1A0F05';
                        ctx.fillRect(cx - T*0.08, cy + T*0.1, T*0.16, T*0.23);
                        ctx.fillStyle = '#8B6914';
                        ctx.fillRect(cx - T*0.06, cy + T*0.12, T*0.12, T*0.08);
                        // Smoke holes
                        ctx.fillStyle = 'rgba(180, 180, 180, 0.5)';
                        ctx.beginPath();
                        ctx.arc(cx - T*0.15, cy - T*0.2, T*0.02, 0, Math.PI*2);
                        ctx.arc(cx + T*0.15, cy - T*0.2, T*0.02, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LEVEL 6: LOG COMPOUND - 4 states from Abandoned to Grand Compound
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                } else if(level === 6) {
                    if(variant === 0) {
                        // ‚ïê‚ïê‚ïê ABANDONED COMPOUND - Ruins ‚ïê‚ïê‚ïê
                        // Collapsed main building
                        ctx.fillStyle = '#4A3A2D';
                        ctx.fillRect(cx - T*0.25, cy + T*0.05, T*0.35, T*0.2);
                        // Debris
                        ctx.fillStyle = '#5A4A3D';
                        for(let i = 0; i < 6; i++) {
                            ctx.beginPath();
                            ctx.arc(cx - T*0.2 + i*T*0.08, cy + T*0.02, T*0.04, 0, Math.PI*2);
                            ctx.fill();
                        }
                        // Broken fence posts
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.35 + i*T*0.12, cy + T*0.25);
                            ctx.lineTo(cx - T*0.33 + i*T*0.12, cy + T*0.15 + i*T*0.02);
                            ctx.stroke();
                        }
                        // X mark
                        ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.3, cy - T*0.15);
                        ctx.lineTo(cx + T*0.3, cy + T*0.2);
                        ctx.moveTo(cx + T*0.3, cy - T*0.15);
                        ctx.lineTo(cx - T*0.3, cy + T*0.2);
                        ctx.stroke();
                        
                    } else if(variant === 1) {
                        // ‚ïê‚ïê‚ïê SMALL COMPOUND - Single building with fence ‚ïê‚ïê‚ïê
                        ctx.fillStyle = '#5C3A1D';
                        ctx.fillRect(cx - T*0.2, cy - T*0.02, T*0.35, T*0.25);
                        // Roof
                        ctx.fillStyle = '#4A2E15';
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25, cy - T*0.02);
                        ctx.lineTo(cx - T*0.02, cy - T*0.2);
                        ctx.lineTo(cx + T*0.2, cy - T*0.02);
                        ctx.closePath();
                        ctx.fill();
                        // Partial fence
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.35 + i*T*0.08, cy + T*0.25);
                            ctx.lineTo(cx - T*0.35 + i*T*0.08, cy + T*0.32);
                            ctx.stroke();
                        }
                        
                    } else if(variant === 2) {
                        // ‚ïê‚ïê‚ïê GROWING COMPOUND - Two buildings ‚ïê‚ïê‚ïê
                        // Main building
                        ctx.fillStyle = '#5C3A1D';
                        ctx.fillRect(cx - T*0.28, cy - T*0.05, T*0.4, T*0.28);
                        ctx.fillStyle = '#4A2E15';
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.32, cy - T*0.05);
                        ctx.lineTo(cx - T*0.08, cy - T*0.25);
                        ctx.lineTo(cx + T*0.16, cy - T*0.05);
                        ctx.closePath();
                        ctx.fill();
                        // Secondary building
                        ctx.fillStyle = '#6B4423';
                        ctx.fillRect(cx + T*0.1, cy + T*0.08, T*0.2, T*0.15);
                        ctx.fillStyle = '#5C3A1D';
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.08, cy + T*0.08);
                        ctx.lineTo(cx + T*0.2, cy - T*0.02);
                        ctx.lineTo(cx + T*0.32, cy + T*0.08);
                        ctx.closePath();
                        ctx.fill();
                        // Fence
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 2;
                        for(let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.38 + i*T*0.08, cy + T*0.25);
                            ctx.lineTo(cx - T*0.38 + i*T*0.08, cy + T*0.32);
                            ctx.stroke();
                        }
                        
                    } else {
                        // ‚ïê‚ïê‚ïê GRAND LOG COMPOUND (variant 3) - Full village ‚ïê‚ïê‚ïê
                        // Main longhouse
                        ctx.fillStyle = '#5C3A1D';
                        ctx.fillRect(cx - T*0.32, cy - T*0.08, T*0.48, T*0.32);
                        ctx.fillStyle = '#4A2E15';
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.38, cy - T*0.08);
                        ctx.lineTo(cx - T*0.08, cy - T*0.35);
                        ctx.lineTo(cx + T*0.22, cy - T*0.08);
                        ctx.closePath();
                        ctx.fill();
                        // Secondary building
                        ctx.fillStyle = '#6B4423';
                        ctx.fillRect(cx + T*0.12, cy + T*0.05, T*0.25, T*0.22);
                        ctx.fillStyle = '#5C3A1D';
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.1, cy + T*0.05);
                        ctx.lineTo(cx + T*0.24, cy - T*0.08);
                        ctx.lineTo(cx + T*0.38, cy + T*0.05);
                        ctx.closePath();
                        ctx.fill();
                        // Totem pole
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(cx + T*0.35, cy - T*0.22, T*0.08, T*0.5);
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.39, cy - T*0.12, T*0.05, 0, Math.PI*2);
                        ctx.fill();
                        ctx.fillStyle = '#E53935';
                        ctx.beginPath();
                        ctx.arc(cx + T*0.39, cy + T*0.02, T*0.04, 0, Math.PI*2);
                        ctx.fill();
                        // Palisade fence
                        ctx.strokeStyle = '#4A3728';
                        ctx.lineWidth = 2;
                        for(let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(cx - T*0.4 + i*T*0.08, cy + T*0.28);
                            ctx.lineTo(cx - T*0.4 + i*T*0.08, cy + T*0.35);
                            ctx.stroke();
                        }
                    }
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // INDUSTRIAL BUILDING PREVIEW - Beautiful hunting/gathering icons
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            drawIndustrialPreview(canvas, level) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const T = Math.min(w, h) * 0.85;
                const cx = w / 2;
                const cy = h / 2;
                
                // Clear with nature background
                ctx.clearRect(0, 0, w, h);
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, T*0.6);
                bgGrad.addColorStop(0, '#4A7A3A');
                bgGrad.addColorStop(1, '#3D6B2F');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                if(level === 1) {
                    // ‚ïê‚ïê‚ïê HUNTING GROUND - Spear and animal tracks ‚ïê‚ïê‚ïê
                    // Animal tracks
                    ctx.fillStyle = '#3A5A2A';
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.ellipse(cx - T*0.2 + i*T*0.15, cy + T*0.2 - i*T*0.05, T*0.04, T*0.03, 0.3, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Standing spear with feathers
                    ctx.strokeStyle = '#5C4A3D';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy + T*0.35);
                    ctx.lineTo(cx, cy - T*0.3);
                    ctx.stroke();
                    
                    // Spear tip (obsidian)
                    ctx.fillStyle = '#2A2A35';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - T*0.45);
                    ctx.lineTo(cx - T*0.06, cy - T*0.28);
                    ctx.lineTo(cx + T*0.06, cy - T*0.28);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Feathers
                    ctx.fillStyle = '#E53935';
                    ctx.beginPath();
                    ctx.ellipse(cx - T*0.04, cy - T*0.2, T*0.02, T*0.08, -0.3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#FFC107';
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.04, cy - T*0.18, T*0.02, T*0.07, 0.3, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Deer silhouette in background
                    ctx.fillStyle = 'rgba(90, 70, 50, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.25, cy + T*0.05, T*0.12, T*0.08, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Antlers
                    ctx.strokeStyle = 'rgba(90, 70, 50, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.3, cy - T*0.02);
                    ctx.lineTo(cx + T*0.35, cy - T*0.12);
                    ctx.moveTo(cx + T*0.32, cy - T*0.08);
                    ctx.lineTo(cx + T*0.38, cy - T*0.06);
                    ctx.stroke();
                    
                } else if(level === 2) {
                    // ‚ïê‚ïê‚ïê LUMBER CAMP - Axe and wood pile ‚ïê‚ïê‚ïê
                    // Wood pile
                    ctx.fillStyle = '#8B5A2B';
                    for(let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.ellipse(cx - T*0.15 + i*T*0.1, cy + T*0.2, T*0.05, T*0.12, 0.1*i, 0, Math.PI*2);
                        ctx.fill();
                    }
                    // Log rings
                    ctx.strokeStyle = '#6B4423';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.arc(cx - T*0.15 + i*T*0.1, cy + T*0.08, T*0.04, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Stone axe
                    ctx.fillStyle = '#5C4A3D';
                    ctx.fillRect(cx - T*0.02, cy - T*0.3, T*0.04, T*0.35);
                    // Axe head
                    ctx.fillStyle = '#6B6B6B';
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.02, cy - T*0.25);
                    ctx.lineTo(cx + T*0.18, cy - T*0.2);
                    ctx.lineTo(cx + T*0.18, cy - T*0.1);
                    ctx.lineTo(cx + T*0.02, cy - T*0.05);
                    ctx.closePath();
                    ctx.fill();
                    // Axe shine
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.04, cy - T*0.22);
                    ctx.lineTo(cx + T*0.12, cy - T*0.18);
                    ctx.lineTo(cx + T*0.12, cy - T*0.14);
                    ctx.lineTo(cx + T*0.04, cy - T*0.18);
                    ctx.fill();
                    
                } else if(level === 3) {
                    // ‚ïê‚ïê‚ïê STONE QUARRY - Pickaxe and rocks ‚ïê‚ïê‚ïê
                    // Rock pile
                    ctx.fillStyle = '#7A7A7A';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.3, cy + T*0.25);
                    ctx.lineTo(cx - T*0.15, cy + T*0.05);
                    ctx.lineTo(cx + T*0.05, cy + T*0.1);
                    ctx.lineTo(cx + T*0.2, cy + T*0.25);
                    ctx.closePath();
                    ctx.fill();
                    // Rock highlights
                    ctx.fillStyle = '#9A9A9A';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.1, cy + T*0.15);
                    ctx.lineTo(cx - T*0.05, cy + T*0.05);
                    ctx.lineTo(cx + T*0.08, cy + T*0.12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stone pickaxe
                    ctx.fillStyle = '#5C4A3D';
                    ctx.save();
                    ctx.translate(cx, cy - T*0.1);
                    ctx.rotate(-0.5);
                    ctx.fillRect(-T*0.02, -T*0.2, T*0.04, T*0.4);
                    ctx.restore();
                    // Pickaxe head
                    ctx.fillStyle = '#5A5A5A';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.18, cy - T*0.2);
                    ctx.lineTo(cx - T*0.05, cy - T*0.28);
                    ctx.lineTo(cx + T*0.08, cy - T*0.2);
                    ctx.lineTo(cx - T*0.05, cy - T*0.15);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if(level === 4) {
                    // ‚ïê‚ïê‚ïê MINING SHAFT - Mine entrance with cart ‚ïê‚ïê‚ïê
                    // Hill/mound
                    ctx.fillStyle = '#5D4E37';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.4, cy + T*0.3);
                    ctx.quadraticCurveTo(cx, cy - T*0.2, cx + T*0.4, cy + T*0.3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Mine entrance
                    ctx.fillStyle = '#1A1A1A';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.15, cy + T*0.25);
                    ctx.lineTo(cx - T*0.12, cy);
                    ctx.lineTo(cx + T*0.12, cy);
                    ctx.lineTo(cx + T*0.15, cy + T*0.25);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Wooden support beams
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.17, cy - T*0.02, T*0.06, T*0.27);
                    ctx.fillRect(cx + T*0.11, cy - T*0.02, T*0.06, T*0.27);
                    ctx.fillRect(cx - T*0.18, cy - T*0.06, T*0.36, T*0.06);
                    
                    // Ore cart
                    ctx.fillStyle = '#4A4A4A';
                    ctx.fillRect(cx - T*0.08, cy + T*0.18, T*0.16, T*0.08);
                    // Wheels
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(cx - T*0.05, cy + T*0.28, T*0.03, 0, Math.PI*2);
                    ctx.arc(cx + T*0.05, cy + T*0.28, T*0.03, 0, Math.PI*2);
                    ctx.fill();
                    // Gold in cart
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(cx, cy + T*0.16, T*0.04, Math.PI, Math.PI*2);
                    ctx.fill();
                    
                } else if(level === 5) {
                    // ‚ïê‚ïê‚ïê FISHING VILLAGE - Hut with fishing nets ‚ïê‚ïê‚ïê
                    // Water
                    ctx.fillStyle = '#2E7D9B';
                    ctx.fillRect(0, cy + T*0.1, w, h);
                    
                    // Dock
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.08, cy + T*0.05, T*0.16, T*0.25);
                    
                    // Fishing hut
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(cx - T*0.2, cy - T*0.1, T*0.25, T*0.2);
                    // Straw roof
                    ctx.fillStyle = '#C4A035';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.25, cy - T*0.1);
                    ctx.lineTo(cx - T*0.08, cy - T*0.3);
                    ctx.lineTo(cx + T*0.1, cy - T*0.1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Fishing net
                    ctx.strokeStyle = '#A89070';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.15, cy - T*0.15);
                    ctx.lineTo(cx + T*0.35, cy + T*0.1);
                    ctx.lineTo(cx + T*0.15, cy + T*0.15);
                    ctx.stroke();
                    // Net pattern
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.18 + i*T*0.06, cy - T*0.1 + i*T*0.08);
                        ctx.lineTo(cx + T*0.18 + i*T*0.06, cy + T*0.1);
                        ctx.stroke();
                    }
                    
                    // Fish
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.25, cy + T*0.2, T*0.06, T*0.03, 0.2, 0, Math.PI*2);
                    ctx.fill();
                    
                } else if(level === 6) {
                    // ‚ïê‚ïê‚ïê FORGE - Anvil and flames ‚ïê‚ïê‚ïê
                    // Stone base
                    ctx.fillStyle = '#5A5A5A';
                    ctx.fillRect(cx - T*0.3, cy + T*0.1, T*0.6, T*0.2);
                    
                    // Forge fire pit
                    ctx.fillStyle = '#1A1A1A';
                    ctx.beginPath();
                    ctx.ellipse(cx - T*0.1, cy + T*0.05, T*0.15, T*0.1, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Flames
                    const flames = ['#FF6B35', '#FF8C42', '#FFD93D'];
                    flames.forEach((color, i) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.1, cy + T*0.05);
                        ctx.quadraticCurveTo(cx - T*0.15 + i*T*0.05, cy - T*0.15 - i*T*0.05, cx - T*0.1 + i*T*0.03, cy - T*0.25 + i*T*0.08);
                        ctx.quadraticCurveTo(cx - T*0.05 + i*T*0.02, cy - T*0.1, cx - T*0.1, cy + T*0.05);
                        ctx.fill();
                    });
                    
                    // Anvil
                    ctx.fillStyle = '#3A3A3A';
                    ctx.fillRect(cx + T*0.1, cy - T*0.05, T*0.15, T*0.15);
                    ctx.fillRect(cx + T*0.05, cy - T*0.1, T*0.25, T*0.06);
                    // Anvil shine
                    ctx.fillStyle = '#5A5A5A';
                    ctx.fillRect(cx + T*0.08, cy - T*0.08, T*0.08, T*0.02);
                    
                    // Hammer
                    ctx.fillStyle = '#5C4A3D';
                    ctx.save();
                    ctx.translate(cx + T*0.25, cy - T*0.2);
                    ctx.rotate(0.5);
                    ctx.fillRect(-T*0.02, -T*0.15, T*0.04, T*0.2);
                    ctx.fillStyle = '#4A4A4A';
                    ctx.fillRect(-T*0.05, -T*0.18, T*0.1, T*0.06);
                    ctx.restore();
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // COMMERCIAL BUILDING PREVIEW - Beautiful trading posts
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            drawCommercialPreview(canvas, level) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const T = Math.min(w, h) * 0.85;
                const cx = w / 2;
                const cy = h / 2;
                
                // Clear with market ground
                ctx.clearRect(0, 0, w, h);
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, T*0.6);
                bgGrad.addColorStop(0, '#8B7355');
                bgGrad.addColorStop(1, '#6B5344');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                if(level === 1) {
                    // ‚ïê‚ïê‚ïê PEBBLE TRADE FIRE - Campfire with trading goods ‚ïê‚ïê‚ïê
                    // Fire pit ring
                    ctx.strokeStyle = '#5A5A5A';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(cx, cy + T*0.05, T*0.2, 0, Math.PI*2);
                    ctx.stroke();
                    
                    // Campfire logs
                    ctx.fillStyle = '#5C4A3D';
                    ctx.save();
                    ctx.translate(cx, cy + T*0.05);
                    for(let i = 0; i < 3; i++) {
                        ctx.rotate(Math.PI*2/3);
                        ctx.fillRect(-T*0.03, -T*0.02, T*0.2, T*0.04);
                    }
                    ctx.restore();
                    
                    // Fire
                    ctx.fillStyle = '#FF6B35';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - T*0.25);
                    ctx.quadraticCurveTo(cx - T*0.12, cy - T*0.1, cx - T*0.08, cy + T*0.08);
                    ctx.quadraticCurveTo(cx, cy, cx + T*0.08, cy + T*0.08);
                    ctx.quadraticCurveTo(cx + T*0.12, cy - T*0.1, cx, cy - T*0.25);
                    ctx.fill();
                    ctx.fillStyle = '#FFD93D';
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - T*0.15);
                    ctx.quadraticCurveTo(cx - T*0.06, cy - T*0.05, cx - T*0.04, cy + T*0.05);
                    ctx.quadraticCurveTo(cx, cy, cx + T*0.04, cy + T*0.05);
                    ctx.quadraticCurveTo(cx + T*0.06, cy - T*0.05, cx, cy - T*0.15);
                    ctx.fill();
                    
                    // Trading items (pebbles/shells)
                    ctx.fillStyle = '#87CEEB';
                    ctx.beginPath();
                    ctx.arc(cx - T*0.28, cy - T*0.1, T*0.04, 0, Math.PI*2);
                    ctx.arc(cx + T*0.28, cy + T*0.1, T*0.04, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(cx - T*0.25, cy + T*0.2, T*0.03, 0, Math.PI*2);
                    ctx.arc(cx + T*0.3, cy - T*0.05, T*0.03, 0, Math.PI*2);
                    ctx.fill();
                    
                } else if(level === 2) {
                    // ‚ïê‚ïê‚ïê BARTER POST - Wooden stall with goods ‚ïê‚ïê‚ïê
                    // Counter/table
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.3, cy, T*0.6, T*0.08);
                    ctx.fillRect(cx - T*0.28, cy + T*0.08, T*0.06, T*0.2);
                    ctx.fillRect(cx + T*0.22, cy + T*0.08, T*0.06, T*0.2);
                    
                    // Awning
                    ctx.fillStyle = '#C4A035';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.35, cy - T*0.1);
                    ctx.lineTo(cx, cy - T*0.3);
                    ctx.lineTo(cx + T*0.35, cy - T*0.1);
                    ctx.lineTo(cx + T*0.35, cy);
                    ctx.lineTo(cx - T*0.35, cy);
                    ctx.closePath();
                    ctx.fill();
                    // Awning stripes
                    ctx.fillStyle = '#A08025';
                    for(let i = 0; i < 3; i++) {
                        ctx.fillRect(cx - T*0.3 + i*T*0.22, cy - T*0.08 - i*T*0.03, T*0.08, cy + T*0.05);
                    }
                    
                    // Goods on counter
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx - T*0.2, cy - T*0.08, T*0.1, T*0.08);
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(cx + T*0.1, cy - T*0.04, T*0.05, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.arc(cx - T*0.05, cy - T*0.05, T*0.04, 0, Math.PI*2);
                    ctx.fill();
                    
                } else if(level === 3) {
                    // ‚ïê‚ïê‚ïê TRADING HUT - Small shop building ‚ïê‚ïê‚ïê
                    // Building
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(cx - T*0.25, cy - T*0.05, T*0.5, T*0.3);
                    
                    // Roof
                    ctx.fillStyle = '#5C4A3D';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.32, cy - T*0.05);
                    ctx.lineTo(cx, cy - T*0.35);
                    ctx.lineTo(cx + T*0.32, cy - T*0.05);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Door
                    ctx.fillStyle = '#4A3728';
                    ctx.fillRect(cx - T*0.08, cy + T*0.05, T*0.16, T*0.2);
                    
                    // Window
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(cx + T*0.12, cy, T*0.08, T*0.08);
                    ctx.strokeStyle = '#4A3728';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cx + T*0.12, cy, T*0.08, T*0.08);
                    
                    // Sign
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.35, cy - T*0.12, T*0.12, T*0.08);
                    ctx.fillStyle = '#FFD700';
                    ctx.font = `${T*0.06}px Arial`;
                    ctx.fillText('$', cx - T*0.32, cy - T*0.06);
                    
                } else if(level === 4) {
                    // ‚ïê‚ïê‚ïê MARKETPLACE - Multiple stalls ‚ïê‚ïê‚ïê
                    // Ground pattern
                    ctx.fillStyle = '#7A6A5A';
                    ctx.fillRect(cx - T*0.35, cy + T*0.15, T*0.7, T*0.15);
                    
                    // Stall 1
                    ctx.fillStyle = '#C4A035';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.35, cy + T*0.1);
                    ctx.lineTo(cx - T*0.2, cy - T*0.15);
                    ctx.lineTo(cx - T*0.05, cy + T*0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.32, cy + T*0.1, T*0.24, T*0.06);
                    
                    // Stall 2
                    ctx.fillStyle = '#E57373';
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.05, cy + T*0.1);
                    ctx.lineTo(cx + T*0.2, cy - T*0.15);
                    ctx.lineTo(cx + T*0.35, cy + T*0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx + T*0.08, cy + T*0.1, T*0.24, T*0.06);
                    
                    // Center fountain/well
                    ctx.fillStyle = '#5A5A5A';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + T*0.05, T*0.1, T*0.06, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#4FC3F7';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + T*0.03, T*0.07, T*0.04, 0, 0, Math.PI*2);
                    ctx.fill();
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SPECIAL BUILDING PREVIEW - Unique landmark buildings
            // Professional quality artwork for app store release
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            drawSpecialPreview(canvas, buildingId) {
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const T = Math.min(w, h) * 0.85;
                const cx = w / 2;
                const cy = h / 2;
                
                // Clear with rich earthy background gradient
                ctx.clearRect(0, 0, w, h);
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, T*0.7);
                bgGrad.addColorStop(0, '#4A4535');
                bgGrad.addColorStop(0.7, '#3A352A');
                bgGrad.addColorStop(1, '#2A251F');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);
                
                // Ground texture
                ctx.fillStyle = '#3D3528';
                ctx.fillRect(0, cy + T*0.25, w, h);
                
                if(buildingId === 'CHIEF' || buildingId === 'CLAN_CHIEF') {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CLAN CHIEF'S HUT - Grand tribal ceremonial longhouse
                    // Impressive wooden structure with golden decorations
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Ground shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + T*0.28, T*0.42, T*0.08, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Stone foundation platform with texture
                    const foundGrad = ctx.createLinearGradient(cx - T*0.38, cy + T*0.15, cx + T*0.38, cy + T*0.25);
                    foundGrad.addColorStop(0, '#6A6A5A');
                    foundGrad.addColorStop(0.5, '#7A7A6A');
                    foundGrad.addColorStop(1, '#5A5A4A');
                    ctx.fillStyle = foundGrad;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.42, cy + T*0.25);
                    ctx.lineTo(cx - T*0.38, cy + T*0.15);
                    ctx.lineTo(cx + T*0.38, cy + T*0.15);
                    ctx.lineTo(cx + T*0.42, cy + T*0.25);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#4A4A3A';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Main wooden structure with rich wood grain
                    const wallGrad = ctx.createLinearGradient(cx - T*0.32, 0, cx + T*0.32, 0);
                    wallGrad.addColorStop(0, '#5C3D1E');
                    wallGrad.addColorStop(0.3, '#7B5432');
                    wallGrad.addColorStop(0.5, '#8B6442');
                    wallGrad.addColorStop(0.7, '#7B5432');
                    wallGrad.addColorStop(1, '#5C3D1E');
                    ctx.fillStyle = wallGrad;
                    ctx.fillRect(cx - T*0.32, cy - T*0.1, T*0.64, T*0.28);
                    
                    // Horizontal log lines for texture
                    ctx.strokeStyle = '#4A2D12';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.31, cy - T*0.08 + i*T*0.07);
                        ctx.lineTo(cx + T*0.31, cy - T*0.08 + i*T*0.07);
                        ctx.stroke();
                    }
                    
                    // Grand thatched roof with layers
                    const roofGrad = ctx.createLinearGradient(cx, cy - T*0.45, cx, cy - T*0.08);
                    roofGrad.addColorStop(0, '#D4B878');
                    roofGrad.addColorStop(0.3, '#C4A868');
                    roofGrad.addColorStop(0.6, '#B49858');
                    roofGrad.addColorStop(1, '#A48848');
                    ctx.fillStyle = roofGrad;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.45, cy - T*0.08);
                    ctx.lineTo(cx, cy - T*0.45);
                    ctx.lineTo(cx + T*0.45, cy - T*0.08);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Roof thatch lines
                    ctx.strokeStyle = '#8B7748';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 8; i++) {
                        let t = i / 8;
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.42 + t*T*0.42, cy - T*0.1 - t*T*0.35);
                        ctx.lineTo(cx - T*0.42 + t*T*0.42 + T*0.1, cy - T*0.1 - t*T*0.35 + T*0.05);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.42 - t*T*0.42, cy - T*0.1 - t*T*0.35);
                        ctx.lineTo(cx + T*0.42 - t*T*0.42 - T*0.1, cy - T*0.1 - t*T*0.35 + T*0.05);
                        ctx.stroke();
                    }
                    
                    // Golden roof trim
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.42, cy - T*0.08);
                    ctx.lineTo(cx, cy - T*0.42);
                    ctx.lineTo(cx + T*0.42, cy - T*0.08);
                    ctx.stroke();
                    
                    // Ornate arched doorway
                    ctx.fillStyle = '#2A1808';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.12, cy + T*0.15);
                    ctx.lineTo(cx - T*0.12, cy + T*0.0);
                    ctx.quadraticCurveTo(cx, cy - T*0.1, cx + T*0.12, cy + T*0.0);
                    ctx.lineTo(cx + T*0.12, cy + T*0.15);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Door frame gold trim
                    ctx.strokeStyle = '#D4A030';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.12, cy + T*0.15);
                    ctx.lineTo(cx - T*0.12, cy + T*0.0);
                    ctx.quadraticCurveTo(cx, cy - T*0.1, cx + T*0.12, cy + T*0.0);
                    ctx.lineTo(cx + T*0.12, cy + T*0.15);
                    ctx.stroke();
                    
                    // Golden crown emblem on roof peak
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.1, cy - T*0.28);
                    ctx.lineTo(cx - T*0.08, cy - T*0.38);
                    ctx.lineTo(cx - T*0.03, cy - T*0.32);
                    ctx.lineTo(cx, cy - T*0.42);
                    ctx.lineTo(cx + T*0.03, cy - T*0.32);
                    ctx.lineTo(cx + T*0.08, cy - T*0.38);
                    ctx.lineTo(cx + T*0.1, cy - T*0.28);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Decorative wooden pillars
                    ctx.fillStyle = '#6B4423';
                    ctx.fillRect(cx - T*0.34, cy - T*0.08, T*0.05, T*0.23);
                    ctx.fillRect(cx + T*0.29, cy - T*0.08, T*0.05, T*0.23);
                    
                    // Golden pillar bands
                    ctx.fillStyle = '#D4A030';
                    ctx.fillRect(cx - T*0.34, cy - T*0.02, T*0.05, T*0.02);
                    ctx.fillRect(cx - T*0.34, cy + T*0.08, T*0.05, T*0.02);
                    ctx.fillRect(cx + T*0.29, cy - T*0.02, T*0.05, T*0.02);
                    ctx.fillRect(cx + T*0.29, cy + T*0.08, T*0.05, T*0.02);
                    
                } else if(buildingId === 'DOCK') {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // FIRST DOCK - Beautiful waterfront pier with boat
                    // Scenic dock with reflective water and detailed boat
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Sky gradient at top
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, cy);
                    skyGrad.addColorStop(0, '#4A6B8A');
                    skyGrad.addColorStop(1, '#6A8BAA');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, w, cy);
                    
                    // Water with beautiful gradient
                    const waterGrad = ctx.createLinearGradient(0, cy - T*0.1, 0, h);
                    waterGrad.addColorStop(0, '#3A7CA5');
                    waterGrad.addColorStop(0.3, '#2E6D94');
                    waterGrad.addColorStop(0.6, '#256083');
                    waterGrad.addColorStop(1, '#1D5070');
                    ctx.fillStyle = waterGrad;
                    ctx.fillRect(0, cy - T*0.1, w, h);
                    
                    // Water ripples and reflections
                    ctx.strokeStyle = 'rgba(100, 180, 220, 0.4)';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, cy + T*0.05 + i*T*0.08);
                        ctx.quadraticCurveTo(w*0.25, cy + T*0.02 + i*T*0.08, w*0.5, cy + T*0.06 + i*T*0.08);
                        ctx.quadraticCurveTo(w*0.75, cy + T*0.1 + i*T*0.08, w, cy + T*0.04 + i*T*0.08);
                        ctx.stroke();
                    }
                    
                    // Dock shadow on water
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(cx - T*0.4, cy + T*0.1, T*0.35, T*0.35);
                    
                    // Main dock warehouse building
                    const dockGrad = ctx.createLinearGradient(cx - T*0.4, cy - T*0.25, cx - T*0.1, cy + T*0.1);
                    dockGrad.addColorStop(0, '#7B5A3D');
                    dockGrad.addColorStop(0.5, '#6B4A2D');
                    dockGrad.addColorStop(1, '#5B3A1D');
                    ctx.fillStyle = dockGrad;
                    ctx.fillRect(cx - T*0.4, cy - T*0.2, T*0.35, T*0.3);
                    
                    // Warehouse roof
                    ctx.fillStyle = '#8B7355';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.45, cy - T*0.2);
                    ctx.lineTo(cx - T*0.22, cy - T*0.38);
                    ctx.lineTo(cx, cy - T*0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Warehouse door
                    ctx.fillStyle = '#3A2515';
                    ctx.fillRect(cx - T*0.3, cy - T*0.05, T*0.12, T*0.15);
                    ctx.strokeStyle = '#D4A030';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(cx - T*0.3, cy - T*0.05, T*0.12, T*0.15);
                    
                    // Wooden pier extending into water
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(cx - T*0.05, cy - T*0.02, T*0.5, T*0.1);
                    
                    // Pier plank lines
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 10; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.02 + i*T*0.05, cy - T*0.02);
                        ctx.lineTo(cx - T*0.02 + i*T*0.05, cy + T*0.08);
                        ctx.stroke();
                    }
                    
                    // Pier support posts going into water
                    ctx.fillStyle = '#5C4A3D';
                    ctx.fillRect(cx + T*0.05, cy + T*0.08, T*0.04, T*0.18);
                    ctx.fillRect(cx + T*0.2, cy + T*0.08, T*0.04, T*0.18);
                    ctx.fillRect(cx + T*0.35, cy + T*0.08, T*0.04, T*0.18);
                    
                    // Beautiful wooden boat
                    ctx.fillStyle = '#6D4C41';
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.08, cy + T*0.2);
                    ctx.quadraticCurveTo(cx + T*0.2, cy + T*0.32, cx + T*0.38, cy + T*0.2);
                    ctx.lineTo(cx + T*0.35, cy + T*0.14);
                    ctx.lineTo(cx + T*0.11, cy + T*0.14);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#4A3628';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Boat details - seats
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(cx + T*0.15, cy + T*0.16, T*0.12, T*0.02);
                    
                    // Boat mast
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.23, cy + T*0.18);
                    ctx.lineTo(cx + T*0.23, cy - T*0.08);
                    ctx.stroke();
                    
                    // Sail
                    ctx.fillStyle = '#F5F5DC';
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.24, cy - T*0.06);
                    ctx.quadraticCurveTo(cx + T*0.35, cy + T*0.02, cx + T*0.24, cy + T*0.12);
                    ctx.lineTo(cx + T*0.24, cy - T*0.06);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#DDD';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Mooring rope
                    ctx.strokeStyle = '#D7CCC8';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.4, cy + T*0.04);
                    ctx.lineTo(cx + T*0.12, cy + T*0.15);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Golden anchor emblem on warehouse
                    ctx.fillStyle = '#FFD700';
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(cx - T*0.22, cy - T*0.28, T*0.04, Math.PI, 0);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.22, cy - T*0.24);
                    ctx.lineTo(cx - T*0.22, cy - T*0.12);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.28, cy - T*0.14);
                    ctx.quadraticCurveTo(cx - T*0.22, cy - T*0.08, cx - T*0.16, cy - T*0.14);
                    ctx.stroke();
                    
                    // Crates and barrels on dock
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(cx + T*0.0, cy - T*0.0, T*0.06, T*0.06);
                    ctx.fillStyle = '#A0826D';
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.12, cy + T*0.02, T*0.035, T*0.05, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                } else if(buildingId === 'GRANARY') {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // NUTS STORAGE REED HOUSE - Traditional reed hut for nuts
                    // Raised platform with woven reed walls and thatched roof
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Ground with grass texture
                    ctx.fillStyle = '#4A5D3A';
                    ctx.fillRect(0, cy + T*0.15, w, h);
                    
                    // Ground shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + T*0.32, T*0.4, T*0.1, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Raised wooden platform/stilts
                    ctx.fillStyle = '#6B4423';
                    // Platform supports
                    ctx.fillRect(cx - T*0.28, cy + T*0.1, T*0.05, T*0.2);
                    ctx.fillRect(cx + T*0.23, cy + T*0.1, T*0.05, T*0.2);
                    ctx.fillRect(cx - T*0.03, cy + T*0.1, T*0.05, T*0.2);
                    
                    // Platform floor
                    ctx.fillStyle = '#7B5433';
                    ctx.fillRect(cx - T*0.32, cy + T*0.08, T*0.64, T*0.06);
                    
                    // Main reed house structure - woven texture
                    const reedGrad = ctx.createLinearGradient(cx - T*0.28, 0, cx + T*0.28, 0);
                    reedGrad.addColorStop(0, '#C4A060');
                    reedGrad.addColorStop(0.2, '#D4B070');
                    reedGrad.addColorStop(0.4, '#C4A060');
                    reedGrad.addColorStop(0.6, '#D4B070');
                    reedGrad.addColorStop(0.8, '#C4A060');
                    reedGrad.addColorStop(1, '#B49050');
                    ctx.fillStyle = reedGrad;
                    ctx.fillRect(cx - T*0.28, cy - T*0.15, T*0.56, T*0.25);
                    
                    // Woven reed pattern - horizontal
                    ctx.strokeStyle = '#A08040';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.27, cy - T*0.13 + i*T*0.04);
                        ctx.lineTo(cx + T*0.27, cy - T*0.13 + i*T*0.04);
                        ctx.stroke();
                    }
                    // Vertical weave pattern
                    for(let i = 0; i < 10; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.25 + i*T*0.055, cy - T*0.15);
                        ctx.lineTo(cx - T*0.25 + i*T*0.055, cy + T*0.1);
                        ctx.stroke();
                    }
                    
                    // Thatched roof - layered for depth
                    const roofGrad = ctx.createLinearGradient(cx, cy - T*0.42, cx, cy - T*0.12);
                    roofGrad.addColorStop(0, '#A08050');
                    roofGrad.addColorStop(0.4, '#B09060');
                    roofGrad.addColorStop(0.7, '#C0A070');
                    roofGrad.addColorStop(1, '#D0B080');
                    ctx.fillStyle = roofGrad;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.38, cy - T*0.12);
                    ctx.lineTo(cx, cy - T*0.42);
                    ctx.lineTo(cx + T*0.38, cy - T*0.12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Roof thatch texture lines
                    ctx.strokeStyle = '#907040';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 12; i++) {
                        let t = i / 12;
                        // Left side
                        ctx.beginPath();
                        ctx.moveTo(cx - T*0.35 + t*T*0.35, cy - T*0.14 - t*T*0.26);
                        ctx.lineTo(cx - T*0.35 + t*T*0.35 + T*0.06, cy - T*0.14 - t*T*0.26 + T*0.08);
                        ctx.stroke();
                        // Right side
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.35 - t*T*0.35, cy - T*0.14 - t*T*0.26);
                        ctx.lineTo(cx + T*0.35 - t*T*0.35 - T*0.06, cy - T*0.14 - t*T*0.26 + T*0.08);
                        ctx.stroke();
                    }
                    
                    // Small entrance opening
                    ctx.fillStyle = '#4A3520';
                    ctx.beginPath();
                    ctx.arc(cx, cy + T*0.02, T*0.08, Math.PI, 0);
                    ctx.lineTo(cx + T*0.08, cy + T*0.08);
                    ctx.lineTo(cx - T*0.08, cy + T*0.08);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Nut/acorn emblem
                    ctx.fillStyle = '#8B5A2B';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - T*0.26, T*0.06, T*0.08, 0, 0, Math.PI*2);
                    ctx.fill();
                    // Acorn cap
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy - T*0.32, T*0.07, T*0.03, 0, 0, Math.PI);
                    ctx.fill();
                    // Cap stem
                    ctx.fillStyle = '#4A3520';
                    ctx.fillRect(cx - T*0.01, cy - T*0.36, T*0.02, T*0.03);
                    
                    // Small ladder on side
                    ctx.strokeStyle = '#5B3A1D';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.2, cy + T*0.08);
                    ctx.lineTo(cx + T*0.28, cy + T*0.28);
                    ctx.moveTo(cx + T*0.24, cy + T*0.08);
                    ctx.lineTo(cx + T*0.32, cy + T*0.28);
                    ctx.stroke();
                    // Ladder rungs
                    ctx.lineWidth = 1.5;
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(cx + T*0.21 + i*T*0.02, cy + T*0.12 + i*T*0.06);
                        ctx.lineTo(cx + T*0.27 + i*T*0.02, cy + T*0.12 + i*T*0.06);
                        ctx.stroke();
                    }
                    
                    // Basket of nuts near entrance
                    ctx.fillStyle = '#A08050';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.2, cy + T*0.12);
                    ctx.quadraticCurveTo(cx - T*0.18, cy + T*0.06, cx - T*0.12, cy + T*0.06);
                    ctx.quadraticCurveTo(cx - T*0.1, cy + T*0.12, cx - T*0.12, cy + T*0.12);
                    ctx.closePath();
                    ctx.fill();
                    // Nuts in basket
                    ctx.fillStyle = '#8B5A2B';
                    ctx.beginPath();
                    ctx.arc(cx - T*0.16, cy + T*0.07, T*0.02, 0, Math.PI*2);
                    ctx.arc(cx - T*0.14, cy + T*0.08, T*0.015, 0, Math.PI*2);
                    ctx.fill();
                    
                } else if(buildingId === 'MONUMENT') {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // STONE MONUMENT - Majestic moai-style statue
                    // Ancient carved stone with mystical glow
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Mystical sky background
                    const skyGrad = ctx.createLinearGradient(0, 0, 0, h);
                    skyGrad.addColorStop(0, '#3A3545');
                    skyGrad.addColorStop(0.5, '#4A4555');
                    skyGrad.addColorStop(1, '#3A3028');
                    ctx.fillStyle = skyGrad;
                    ctx.fillRect(0, 0, w, h);
                    
                    // Stars/sparkles
                    ctx.fillStyle = '#FFD700';
                    for(let i = 0; i < 8; i++) {
                        let sx = T*0.2 + Math.random()*T*0.6 + (w-T)/2;
                        let sy = T*0.1 + Math.random()*T*0.3;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 1, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Ground
                    ctx.fillStyle = '#3D3528';
                    ctx.fillRect(0, cy + T*0.2, w, h);
                    
                    // Mystical glow behind statue
                    const glowGrad = ctx.createRadialGradient(cx, cy - T*0.1, 0, cx, cy - T*0.1, T*0.5);
                    glowGrad.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    glowGrad.addColorStop(0.5, 'rgba(255, 180, 0, 0.15)');
                    glowGrad.addColorStop(1, 'rgba(255, 150, 0, 0)');
                    ctx.fillStyle = glowGrad;
                    ctx.fillRect(0, 0, w, h);
                    
                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.4)';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy + T*0.28, T*0.25, T*0.08, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Stone platform base
                    const baseGrad = ctx.createLinearGradient(cx - T*0.22, cy + T*0.2, cx + T*0.22, cy + T*0.28);
                    baseGrad.addColorStop(0, '#5A5A5A');
                    baseGrad.addColorStop(0.5, '#6A6A6A');
                    baseGrad.addColorStop(1, '#4A4A4A');
                    ctx.fillStyle = baseGrad;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.25, cy + T*0.28);
                    ctx.lineTo(cx - T*0.22, cy + T*0.18);
                    ctx.lineTo(cx + T*0.22, cy + T*0.18);
                    ctx.lineTo(cx + T*0.25, cy + T*0.28);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Main stone body with gradient
                    const stoneGrad = ctx.createLinearGradient(cx - T*0.15, 0, cx + T*0.15, 0);
                    stoneGrad.addColorStop(0, '#6A6A6A');
                    stoneGrad.addColorStop(0.3, '#8A8A8A');
                    stoneGrad.addColorStop(0.5, '#9A9A9A');
                    stoneGrad.addColorStop(0.7, '#8A8A8A');
                    stoneGrad.addColorStop(1, '#6A6A6A');
                    ctx.fillStyle = stoneGrad;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.14, cy + T*0.18);
                    ctx.lineTo(cx - T*0.17, cy - T*0.05);
                    ctx.quadraticCurveTo(cx - T*0.2, cy - T*0.35, cx, cy - T*0.42);
                    ctx.quadraticCurveTo(cx + T*0.2, cy - T*0.35, cx + T*0.17, cy - T*0.05);
                    ctx.lineTo(cx + T*0.14, cy + T*0.18);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stone texture cracks
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.08, cy - T*0.25);
                    ctx.lineTo(cx - T*0.05, cy - T*0.15);
                    ctx.lineTo(cx - T*0.1, cy + T*0.05);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cx + T*0.06, cy - T*0.2);
                    ctx.lineTo(cx + T*0.08, cy - T*0.05);
                    ctx.stroke();
                    
                    // Face features - deep carved look
                    // Eye sockets
                    ctx.fillStyle = '#4A4A4A';
                    ctx.beginPath();
                    ctx.ellipse(cx - T*0.065, cy - T*0.2, T*0.035, T*0.045, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.065, cy - T*0.2, T*0.035, T*0.045, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Glowing eyes
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.ellipse(cx - T*0.065, cy - T*0.2, T*0.02, T*0.025, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.065, cy - T*0.2, T*0.02, T*0.025, 0, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Prominent nose
                    ctx.fillStyle = '#7A7A7A';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.025, cy - T*0.15);
                    ctx.lineTo(cx, cy - T*0.12);
                    ctx.lineTo(cx + T*0.025, cy - T*0.15);
                    ctx.lineTo(cx + T*0.03, cy - T*0.02);
                    ctx.lineTo(cx - T*0.03, cy - T*0.02);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stern mouth
                    ctx.fillStyle = '#5A5A5A';
                    ctx.fillRect(cx - T*0.06, cy + T*0.04, T*0.12, T*0.025);
                    
                    // Golden crown/headdress
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.moveTo(cx - T*0.12, cy - T*0.32);
                    ctx.quadraticCurveTo(cx, cy - T*0.48, cx + T*0.12, cy - T*0.32);
                    ctx.lineTo(cx + T*0.08, cy - T*0.35);
                    ctx.quadraticCurveTo(cx, cy - T*0.42, cx - T*0.08, cy - T*0.35);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Ear decorations
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.ellipse(cx - T*0.17, cy - T*0.1, T*0.02, T*0.04, 0.2, 0, Math.PI*2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cx + T*0.17, cy - T*0.1, T*0.02, T*0.04, -0.2, 0, Math.PI*2);
                    ctx.fill();
                }
            },
            
            openBuildingMenu() {
                console.log('=== openBuildingMenu called ===');
                // Set default selection to Level 1 (first buildable level)
                if(this.selectedBuildingLevel === undefined || this.selectedBuildingLevel === 0) {
                    this.selectedBuildingLevel = 1;
                }
                
                // Dynamically generate building cards from BUILDING_DB
                let grid = document.getElementById('building-level-grid');
                grid.innerHTML = '';
                
                // Video/image media files for residential buildings (in Media folder)
                // Level 1 = Tree Shelter, Level 2 = Ground Pit, Level 3 = Ground Cave
                // Level 4 = Tipi Village, Level 5 = Log LongHouse, Level 6 = Old Growth Log Compound
                const buildingMedia = {
                    1: { video: 'Media/Tree Shelter Video.mp4', image: 'Media/Tree Shelter.jpg', name: 'Tree Shelter' },
                    2: { video: 'Media/Ground Pit Video.mp4', image: 'Media/Ground Pit.jpg', name: 'Ground Pit' },
                    3: { video: 'Media/Ground Cave Video.mp4', image: 'Media/Ground Cave.jpg', name: 'Ground Cave' },
                    4: { video: null, image: 'Media/Tipi Village.jpg', name: 'Tipi Village' },
                    5: { video: null, image: 'Media/Log LongHouse.jpg', name: 'Log LongHouse' },
                    6: { video: null, image: 'Media/Old Growth Log Compound.jpg', name: 'Old Growth Log Compound' }
                };
                
                let buildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedLevels.includes(levelNum);
                    let isSelected = this.selectedBuildingLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'üè†';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectBuildingLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    
                    // Show unlock requirements if locked
                    let unlockText = '';
                    if(!isUnlocked && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(Controller.formatNum(req.pop) + ' pop');
                        if(req.buildings) {
                            parts.push(req.buildings.count + 'x ' + req.buildings.type + ' L' + req.buildings.level);
                        }
                        unlockText = 'üîí ' + parts.join(' + ');
                        costText = unlockText;
                    }
                    
                    // Use video preview if available for this level
                    let mediaHTML = '';
                    if(buildingMedia[levelNum]) {
                        let media = buildingMedia[levelNum];
                        let mediaId = 'media-res-' + levelNum;
                        if(media.video) {
                            // Has video - show image with video on hover
                            mediaHTML = `
                                <div class="building-media-container" style="position:relative;width:200px;height:200px;">
                                    <img src="${media.image}" alt="${media.name}" 
                                         class="building-preview-img"
                                         style="width:200px;height:200px;object-fit:cover;border-radius:10px;border:3px solid rgba(76,175,80,0.6);box-shadow:0 4px 15px rgba(0,0,0,0.4);position:absolute;top:0;left:0;z-index:2;transition:opacity 0.3s ease;">
                                    <video id="${mediaId}" loop muted playsinline 
                                           style="width:200px;height:200px;object-fit:cover;border-radius:10px;border:3px solid rgba(76,175,80,0.6);box-shadow:0 4px 15px rgba(0,0,0,0.4);position:absolute;top:0;left:0;z-index:1;"
                                           poster="${media.image}">
                                        <source src="${media.video}" type="video/mp4">
                                    </video>
                                </div>
                            `;
                        } else {
                            // Image only - no video
                            mediaHTML = `
                                <div class="building-media-container" style="position:relative;width:200px;height:200px;">
                                    <img src="${media.image}" alt="${media.name}" 
                                         style="width:200px;height:200px;object-fit:cover;border-radius:10px;border:3px solid rgba(76,175,80,0.6);box-shadow:0 4px 15px rgba(0,0,0,0.4);">
                                </div>
                            `;
                        }
                    } else {
                        // Fall back to canvas preview for levels without media
                        mediaHTML = `<canvas id="preview-res-${levelNum}" width="60" height="60" style="border-radius:4px;"></canvas>`;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${mediaHTML}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                    
                    // Add hover events for video playback (show image by default, play video on hover)
                    if(buildingMedia[levelNum]) {
                        let mediaContainer = card.querySelector('.building-media-container');
                        let img = card.querySelector('.building-preview-img');
                        let video = card.querySelector('video');
                        
                        if(mediaContainer && img && video) {
                            mediaContainer.addEventListener('mouseenter', function() {
                                img.style.opacity = '0';
                                video.play().catch(e => console.log('Video play error:', e));
                            });
                            mediaContainer.addEventListener('mouseleave', function() {
                                img.style.opacity = '1';
                                video.pause();
                                video.currentTime = 0;
                            });
                        }
                    }
                    
                    // Draw the building preview on the canvas (only for levels without video)
                    if(!buildingMedia[levelNum]) {
                        let previewCanvas = document.getElementById('preview-res-' + levelNum);
                        if(previewCanvas) {
                            this.drawBuildingPreview(previewCanvas, levelNum, 3);
                        }
                    }
                }
                
                document.getElementById('building-menu-panel').style.display = 'block';
            },
            closeBuildingMenu() {
                document.getElementById('building-menu-panel').style.display = 'none';
            },
            
            // Industrial menu functions
            openIndustrialMenu() {
                console.log('=== openIndustrialMenu called ===');
                // Set default selection to Level 1
                if(this.selectedIndustrialLevel === undefined || this.selectedIndustrialLevel === 0) {
                    this.selectedIndustrialLevel = 1;
                }
                
                // Dynamically generate industrial cards from BUILDING_DB
                let grid = document.getElementById('industrial-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('INDUSTRIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedIndustrialLevels.includes(levelNum);
                    let isSelected = this.selectedIndustrialLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'üè≠';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-ind-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectIndustrialLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    if(!isUnlocked) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(levelNum, Game);
                        costText = info.text;
                    }
                    
                    // Create card with canvas preview - player-friendly stats
                    let workText = building.capacity <= 5 ? '‚öíÔ∏è Small workshop' : 
                                   building.capacity <= 10 ? '‚öíÔ∏è Workshop' :
                                   building.capacity <= 20 ? 'üè≠ Factory' : 'üèóÔ∏è Large factory';
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon"><canvas id="preview-ind-${levelNum}" width="60" height="60" style="border-radius:4px;"></canvas></div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">${workText}</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                    
                    // Draw industrial preview
                    let previewCanvas = document.getElementById('preview-ind-' + levelNum);
                    if(previewCanvas) {
                        this.drawIndustrialPreview(previewCanvas, levelNum);
                    }
                }
                
                document.getElementById('industrial-menu-panel').style.display = 'block';
            },
            closeIndustrialMenu() {
                document.getElementById('industrial-menu-panel').style.display = 'none';
            },
            selectIndustrialLevel(level) {
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.selectedIndustrialLevel = level;
                
                // Update card styling
                document.querySelectorAll('#industrial-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                let card = document.getElementById('card-ind-level-' + level);
                if(card) card.classList.add('selected');
                
                Controller.toast(`Selected: ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            confirmIndustrialSelection() {
                let level = this.selectedIndustrialLevel || 1;
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.closeIndustrialMenu();
                this.setTool('IND');
                Controller.toast(`üè≠ Click to place ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // COMMERCIAL MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedCommercialLevel: 1,
            
            openCommercialMenu() {
                console.log('=== openCommercialMenu called ===');
                // Set default selection to Level 1
                if(this.selectedCommercialLevel === undefined || this.selectedCommercialLevel === 0) {
                    this.selectedCommercialLevel = 1;
                }
                
                // Video/image media files for commercial buildings
                const commercialMedia = {
                    1: { video: null, image: 'Media/Pebble Trade Fire.jpg', name: 'Pebble Trade Fire' },
                    2: { video: null, image: 'Media/Squirrel Trade Camp.jpg', name: 'Squirrel Trade Camp' }
                };
                
                // Dynamically generate commercial cards from BUILDING_DB
                let grid = document.getElementById('commercial-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('COMMERCIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(levelNum) : (levelNum === 1);
                    let isSelected = this.selectedCommercialLevel === levelNum;
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-com-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectCommercialLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    if(!isUnlocked) {
                        costText = 'üîí Locked';
                    }
                    
                    // Use media image if available for this level
                    let mediaHTML = '';
                    if(commercialMedia[levelNum]) {
                        let media = commercialMedia[levelNum];
                        mediaHTML = `
                            <div class="building-media-container" style="position:relative;width:200px;height:200px;">
                                <img src="${media.image}" alt="${media.name}" 
                                     style="width:200px;height:200px;object-fit:cover;border-radius:10px;border:3px solid rgba(74,158,255,0.6);box-shadow:0 4px 15px rgba(0,0,0,0.4);">
                            </div>
                        `;
                    } else {
                        mediaHTML = `<canvas id="preview-com-${levelNum}" width="60" height="60" style="border-radius:4px;"></canvas>`;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${mediaHTML}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">Cap: ${building.capacity} workers</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                    
                    // Draw commercial preview (only if no media image)
                    if(!commercialMedia[levelNum]) {
                        let previewCanvas = document.getElementById('preview-com-' + levelNum);
                        if(previewCanvas) {
                            this.drawCommercialPreview(previewCanvas, levelNum);
                        }
                    }
                }
                
                document.getElementById('commercial-menu-panel').style.display = 'block';
            },
            closeCommercialMenu() {
                document.getElementById('commercial-menu-panel').style.display = 'none';
            },
            selectCommercialLevel(level) {
                let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(level) : (level === 1);
                if(!isUnlocked) {
                    Controller.toast('üîí Locked! Build more residential first.');
                    return;
                }
                this.selectedCommercialLevel = level;
                
                // Update card styling
                document.querySelectorAll('#commercial-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                let card = document.getElementById('card-com-level-' + level);
                if(card) {
                    card.classList.add('selected');
                }
                
                let building = CFG.getBuilding('COM_' + level);
                Controller.toast(`Selected: ${building ? building.name : 'Commercial L' + level}`);
            },
            confirmCommercialSelection() {
                let level = this.selectedCommercialLevel || 1;
                let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(level) : (level === 1);
                if(!isUnlocked) {
                    Controller.toast('üîí Locked! Build more residential first.');
                    return;
                }
                this.closeCommercialMenu();
                this.setTool('COM');
                let building = CFG.getBuilding('COM_' + level);
                Controller.toast(`üè™ Click to place ${building ? building.name : 'Commercial'}`);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // WELL MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedWellType: 'WELL',
            showElevation: false,
            
            toggleElevation() {
                this.showElevation = !this.showElevation;
                Controller.toast(this.showElevation ? 'üóª Elevation overlay ON' : 'üóª Elevation overlay OFF');
            },
            
            openWellMenu() {
                let existing = document.getElementById('well-menu-popup');
                if(existing) existing.remove();
                
                let menu = document.createElement('div');
                menu.id = 'well-menu-popup';
                menu.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:2000;padding:20px;background:#2E251B;border:2px solid #8B6914;border-radius:8px;min-width:280px;';
                menu.innerHTML = `
                    <button onclick="this.parentElement.remove()" style="position:absolute;top:5px;right:10px;background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">√ó</button>
                    <h2 style="color:#F5E6C8;margin:0 0 15px 0;text-align:center;">üíß Wells</h2>
                    <div style="display:flex;flex-direction:column;gap:10px;">
                        <button id="well-normal-btn" class="btn" style="padding:12px 15px;text-align:left;">
                            <strong>üíß Normal Well</strong><br>
                            <span style='font-size:11px;opacity:0.8;'>Cost: 50 food | Supports 50 pop</span>
                        </button>
                        <button id="well-mega-btn" class="btn" style="padding:12px 15px;text-align:left;">
                            <strong>üíßüíß Mega Well</strong><br>
                            <span style='font-size:11px;opacity:0.8;'>Cost: 100k food, 100k wood, 10k stone | 1000 pop</span>
                        </button>
                    </div>
                    <div style="text-align:center;margin-top:15px;">
                        <button onclick="this.parentElement.parentElement.remove()" class="btn" style="padding:8px 25px;">Cancel</button>
                    </div>
                `;
                document.body.appendChild(menu);
                
                document.getElementById('well-normal-btn').onclick = function() {
                    Controller.selectedWellType = 'WELL';
                    Controller.setTool('WELL');
                    Controller.toast('üíß Well tool - click or drag to place');
                    menu.remove();
                };
                document.getElementById('well-mega-btn').onclick = function() {
                    Controller.selectedWellType = 'MEGA_WELL';
                    Controller.setTool('MEGA_WELL');
                    Controller.toast('üíßüíß Mega Well tool - click to place');
                    menu.remove();
                };
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // STORAGE MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedStoragePit: 'FOOD_PIT',
            
            openStorageMenu() {
                console.log('=== openStorageMenu called ===');
                this.selectedStoragePit = 'FOOD_PIT';
                
                // Dynamically generate storage pit cards
                let grid = document.getElementById('storage-level-grid');
                grid.innerHTML = '';
                
                const pits = CFG.STORAGE_PITS;
                const pitKeys = ['FOOD_PIT', 'WOOD_PIT', 'STONE_PIT', 'METAL_PIT'];
                const resourceColors = {
                    'FOOD_PIT': '#4CAF50',
                    'WOOD_PIT': '#8B4513',
                    'STONE_PIT': '#808080',
                    'METAL_PIT': '#FFD700'
                };
                
                for(let key of pitKeys) {
                    let pit = pits[key];
                    let isSelected = this.selectedStoragePit === key;
                    let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!canAfford ? ' level-locked' : '');
                    card.id = 'card-storage-' + key;
                    card.style.cssText = 'background:#2a2a4a; border:2px solid ' + (isSelected ? resourceColors[key] : '#444') + '; border-radius:8px; padding:15px; cursor:pointer; text-align:center;';
                    card.onclick = () => this.selectStoragePit(key);
                    
                    let costText = `${Controller.formatNum(pit.food)} üçñ + ${Controller.formatNum(pit.wood)} ü™µ + ${pit.stone} ü™®`;
                    
                    card.innerHTML = `
                        <div style="font-size:36px;">${pit.icon}</div>
                        <div style="font-size:14px; font-weight:bold; color:${resourceColors[key]};">${pit.desc}</div>
                        <div style="font-size:12px; color:#4CAF50; margin:5px 0;">+${Controller.formatNum(pit.cap)} ${pit.resource} storage</div>
                        <div style="font-size:10px; color:${canAfford ? '#888' : '#f44336'};">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('storage-menu-panel').style.display = 'block';
            },
            closeStorageMenu() {
                document.getElementById('storage-menu-panel').style.display = 'none';
            },
            selectStoragePit(pitKey) {
                let pit = CFG.STORAGE_PITS[pitKey];
                let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                
                if(!canAfford) {
                    Controller.toast(`‚ùå Need ${Controller.formatNum(pit.food)} food, ${Controller.formatNum(pit.wood)} wood, ${pit.stone} stone`);
                    return;
                }
                
                this.selectedStoragePit = pitKey;
                
                // Update card styling
                const resourceColors = {
                    'FOOD_PIT': '#4CAF50',
                    'WOOD_PIT': '#8B4513',
                    'STONE_PIT': '#808080',
                    'METAL_PIT': '#FFD700'
                };
                
                document.querySelectorAll('#storage-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-storage-' + pitKey);
                if(card) {
                    card.classList.add('selected');
                    card.style.borderColor = resourceColors[pitKey];
                }
                
                Controller.toast(`Selected: ${pit.desc}`);
            },
            confirmStorageSelection() {
                let pitKey = this.selectedStoragePit || 'FOOD_PIT';
                let pit = CFG.STORAGE_PITS[pitKey];
                
                let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                if(!canAfford) {
                    Controller.toast(`‚ùå Need ${Controller.formatNum(pit.food)} food, ${Controller.formatNum(pit.wood)} wood, ${pit.stone} stone`);
                    return;
                }
                
                this.closeStorageMenu();
                this.setTool(pitKey);
                Controller.toast(`üï≥Ô∏è Click to place ${pit.desc}`);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // SPECIAL BUILDINGS MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedSpecialBuilding: 'CHIEF',
            
            openSpecialMenu() {
                console.log('=== openSpecialMenu called ===');
                this.selectedSpecialBuilding = 'CHIEF';
                
                // Dynamically generate special building cards
                let grid = document.getElementById('special-level-grid');
                grid.innerHTML = '';
                
                // Define special buildings with their requirements
                const specialBuildings = [
                    {
                        id: 'CHIEF',
                        name: "First Chief's Hut",
                        icon: 'üèõÔ∏è',
                        desc: '+50% bonus to all buildings within radius',
                        cost: { food: CFG.CHIEF_COST || 10000, wood: 0 },
                        unlockReq: { hasCommercial: true },
                        unlockText: 'Build a Pebble Trade Fire first'
                    },
                    {
                        id: 'DOCK',
                        name: 'First Dock',
                        icon: '‚öì',
                        desc: '+5% output when connected to water',
                        cost: { food: 10000, wood: 100000 },
                        unlockReq: { pop: 500 },
                        unlockText: 'Need 500 population'
                    },
                    {
                        id: 'GRANARY',
                        name: 'Nuts Storage Reed House',
                        icon: 'üå∞',
                        desc: 'Reduces food decay by 50%',
                        cost: { food: 5000, wood: 5000 },
                        unlockReq: { pop: 100 },
                        unlockText: 'Need 100 population'
                    },
                    {
                        id: 'MONUMENT',
                        name: 'Stone Monument',
                        icon: 'üóø',
                        desc: '+100% population happiness',
                        cost: { food: 25000, wood: 10000, stone: 5000 },
                        unlockReq: { pop: 1000 },
                        unlockText: 'Need 1000 population'
                    }
                ];
                
                for(let building of specialBuildings) {
                    let isSelected = this.selectedSpecialBuilding === building.id;
                    let canAfford = Game.food >= building.cost.food && Game.wood >= (building.cost.wood || 0);
                    
                    // Check unlock requirements
                    let isUnlocked = true;
                    let unlockReason = '';
                    if(building.unlockReq.hasCommercial) {
                        let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                        isUnlocked = comCount > 0;
                        unlockReason = building.unlockText;
                    }
                    if(building.unlockReq.pop) {
                        isUnlocked = (Game.pop || 0) >= building.unlockReq.pop;
                        unlockReason = building.unlockText;
                    }
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked || !canAfford ? ' level-locked' : '');
                    card.id = 'card-special-' + building.id;
                    card.onclick = () => this.selectSpecialBuilding(building.id);
                    
                    let costText = `${Controller.formatNum(building.cost.food)} üçñ`;
                    if(building.cost.wood) costText += ` + ${Controller.formatNum(building.cost.wood)} ü™µ`;
                    if(building.cost.stone) costText += ` + ${Controller.formatNum(building.cost.stone)} ü™®`;
                    
                    let statusText = !isUnlocked ? `üîí ${unlockReason}` : (!canAfford ? '‚ùå Cannot afford' : '‚úÖ Available');
                    let statusColor = !isUnlocked ? '#888' : (!canAfford ? '#f44336' : '#4CAF50');
                    
                    card.innerHTML = `
                        <div class="level-icon"><canvas id="preview-special-${building.id}" width="60" height="60" style="border-radius:4px;"></canvas></div>
                        <div class="level-name" style="color:#FFD700;">${building.name}</div>
                        <div class="level-stats">${building.desc}</div>
                        <div class="level-cost">${costText}</div>
                        <div style="font-size:9px; color:${statusColor}; margin-top:3px;">${statusText}</div>
                    `;
                    grid.appendChild(card);
                    
                    // Draw special preview
                    let previewCanvas = document.getElementById('preview-special-' + building.id);
                    if(previewCanvas) {
                        this.drawSpecialPreview(previewCanvas, building.id);
                    }
                }
                
                document.getElementById('special-menu-panel').style.display = 'block';
            },
            closeSpecialMenu() {
                document.getElementById('special-menu-panel').style.display = 'none';
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // MILESTONE BUILDINGS MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedMilestoneBuilding: 'CLAN_CHIEF',
            
            openMilestoneMenu() {
                console.log('=== openMilestoneMenu called ===');
                this.selectedMilestoneBuilding = 'CLAN_CHIEF';
                
                // Update resource displays
                let metalEl = document.getElementById('milestone-metal-display');
                let goldEl = document.getElementById('milestone-gold-display');
                if(metalEl) metalEl.textContent = Controller.formatNum((Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0));
                if(goldEl) goldEl.textContent = Game.gold || 0;
                
                // Dynamically generate milestone building cards
                let grid = document.getElementById('milestone-level-grid');
                grid.innerHTML = '';
                
                const milestoneBuildings = [
                    {
                        id: 'CLAN_CHIEF',
                        name: "Clan Chief's Hut",
                        icon: 'üèõÔ∏è',
                        desc: 'Unlocks Level 4-6 buildings. The seat of power for your clan.',
                        cost: { food: 100000, wood: 100000, gold: 1 },
                        size: '2x2',
                        unlocked: !Game.hasClanChief,
                        built: Game.hasClanChief,
                        requires: 'Pop 500+'
                    },
                    {
                        id: 'DOCK',
                        name: 'First Dock',
                        icon: '‚öì',
                        desc: 'Unlocks Level 7+ buildings. The first dock for river trade.',
                        cost: { food: 500000, wood: 500000, gold: 5 },
                        size: '3x2',
                        unlocked: Game.hasClanChief && !Game.hasDock,
                        built: Game.hasDock,
                        requires: 'Clan Chief\'s Hut'
                    }
                ];
                
                for(let building of milestoneBuildings) {
                    let isSelected = this.selectedMilestoneBuilding === building.id;
                    let canAfford = Game.food >= building.cost.food && 
                                   Game.wood >= building.cost.wood && 
                                   (Game.gold || 0) >= building.cost.gold;
                    
                    let card = document.createElement('div');
                    let statusClass = building.built ? 'level-locked' : (!building.unlocked ? 'level-locked' : (isSelected ? ' selected' : ''));
                    card.className = 'level-card ' + statusClass;
                    card.id = 'card-milestone-' + building.id;
                    if(!building.built && building.unlocked) {
                        card.onclick = () => this.selectMilestoneBuilding(building.id);
                    }
                    
                    let costText = `${Controller.formatNum(building.cost.food)} üçñ + ${Controller.formatNum(building.cost.wood)} ü™µ + ${building.cost.gold} üí∞`;
                    
                    let statusText = building.built ? '‚úÖ Already Built' : 
                                    (!building.unlocked ? 'üîí ' + building.requires : 
                                    (!canAfford ? '‚ùå Cannot afford' : '‚úÖ Available'));
                    let statusColor = building.built ? '#4CAF50' : (!building.unlocked ? '#888' : (!canAfford ? '#f44336' : '#4CAF50'));
                    
                    card.innerHTML = `
                        <div class="level-icon"><canvas id="preview-milestone-${building.id}" width="60" height="60" style="border-radius:4px;"></canvas></div>
                        <div class="level-name" style="color:#FFD700;">${building.name}</div>
                        <div class="level-stats">Size: ${building.size}</div>
                        <div style="font-size:10px; color:#aaa; margin:3px 0;">${building.desc}</div>
                        <div class="level-cost">${costText}</div>
                        <div style="font-size:9px; color:${statusColor}; margin-top:3px;">${statusText}</div>
                    `;
                    grid.appendChild(card);
                    
                    // Draw milestone preview (reuse special preview for chief-like buildings)
                    let previewCanvas = document.getElementById('preview-milestone-' + building.id);
                    if(previewCanvas) {
                        this.drawSpecialPreview(previewCanvas, building.id);
                    }
                }
                
                document.getElementById('milestone-menu-panel').style.display = 'block';
            },
            closeMilestoneMenu() {
                document.getElementById('milestone-menu-panel').style.display = 'none';
            },
            selectMilestoneBuilding(buildingId) {
                this.selectedMilestoneBuilding = buildingId;
                
                // Update card styling
                document.querySelectorAll('#milestone-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                let card = document.getElementById('card-milestone-' + buildingId);
                if(card && !card.classList.contains('level-locked')) {
                    card.classList.add('selected');
                }
            },
            confirmMilestoneSelection() {
                let buildingId = this.selectedMilestoneBuilding;
                let config = CFG.BUILDING_DB[buildingId];
                
                if(!config) {
                    Controller.toast('‚ùå Invalid building selection');
                    return;
                }
                
                // Check if already built
                if(buildingId === 'CLAN_CHIEF' && Game.hasClanChief) {
                    Controller.toast('‚úÖ Clan Chief\'s Hut already built!');
                    return;
                }
                if(buildingId === 'DOCK' && Game.hasDock) {
                    Controller.toast('‚úÖ First Dock already built!');
                    return;
                }
                
                // Check prerequisites
                if(buildingId === 'DOCK' && !Game.hasClanChief) {
                    Controller.toast('üîí Build Clan Chief\'s Hut first!');
                    return;
                }
                
                // Check resources
                let cost = config.cost;
                if(Game.food < cost.food) {
                    Controller.toast(`‚ùå Need ${Controller.formatNum(cost.food)} food (have ${Controller.formatNum(Game.food)})`);
                    return;
                }
                if(Game.wood < cost.wood) {
                    Controller.toast(`‚ùå Need ${Controller.formatNum(cost.wood)} wood (have ${Controller.formatNum(Game.wood)})`);
                    return;
                }
                if((Game.gold || 0) < cost.gold) {
                    Controller.toast(`‚ùå Need ${cost.gold} gold (have ${Game.gold || 0})`);
                    return;
                }
                
                this.closeMilestoneMenu();
                this.setTool(buildingId);
                Controller.toast(`üèõÔ∏è Click to place ${config.name}`);
            },
            exchangeGold() {
                let metalNeeded = CFG.GOLD_EXCHANGE_RATE || 5000;
                let totalMetal = (Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0);
                
                if(totalMetal < metalNeeded) {
                    Controller.toast(`‚ùå Need ${Controller.formatNum(metalNeeded)} metal to exchange (have ${Controller.formatNum(totalMetal)})`);
                    return;
                }
                
                // Deduct from pocket first, then main inventory
                let remaining = metalNeeded;
                if(Game.pocket && Game.pocket.metal > 0) {
                    let fromPocket = Math.min(Game.pocket.metal, remaining);
                    Game.pocket.metal -= fromPocket;
                    remaining -= fromPocket;
                }
                if(remaining > 0) {
                    Game.metal = (Game.metal || 0) - remaining;
                }
                
                Game.gold = (Game.gold || 0) + 1;
                
                Controller.toast(`üí∞ Exchanged ${Controller.formatNum(metalNeeded)} metal for 1 gold! Total gold: ${Game.gold}`);
                
                // Update displays if milestone menu is open
                let metalEl = document.getElementById('milestone-metal-display');
                let goldEl = document.getElementById('milestone-gold-display');
                if(metalEl) metalEl.textContent = Controller.formatNum((Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0));
                if(goldEl) goldEl.textContent = Game.gold || 0;
                
                // Refresh the menu if open
                if(document.getElementById('milestone-menu-panel').style.display !== 'none') {
                    this.openMilestoneMenu();
                }
            },
            
            selectSpecialBuilding(buildingId) {
                this.selectedSpecialBuilding = buildingId;
                
                // Update card styling
                document.querySelectorAll('#special-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-special-' + buildingId);
                if(card) {
                    card.classList.add('selected');
                    card.style.borderColor = '#FFD700';
                }
            },
            confirmSpecialSelection() {
                let buildingId = this.selectedSpecialBuilding || 'CHIEF';
                
                // Check unlock requirements
                if(buildingId === 'CHIEF') {
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    if(comCount === 0) {
                        Controller.toast('üîí Build a Pebble Trade Fire (commercial) first!');
                        return;
                    }
                    if(Game.food < (CFG.CHIEF_COST || 10000)) {
                        Controller.toast(`‚ùå Need ${Controller.formatNum(CFG.CHIEF_COST || 10000)} food`);
                        return;
                    }
                }
                
                this.closeSpecialMenu();
                this.setTool(buildingId);
                Controller.toast(`‚≠ê Click to place special building`);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ROADS MENU FUNCTIONS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            selectedRoadLevel: 1,
            
            openRoadMenu() {
                console.log('=== openRoadMenu called ===');
                this.selectedRoadLevel = 1;
                this.updateRoadUnlocks();
                document.getElementById('road-menu-panel').style.display = 'block';
            },
            closeRoadMenu() {
                document.getElementById('road-menu-panel').style.display = 'none';
            },
            updateRoadUnlocks() {
                // Only Path (level 1) is unlocked for now
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) {
                        card.classList.remove('selected');
                        if(i === 1) {
                            card.classList.remove('level-locked');
                        } else {
                            card.classList.add('level-locked');
                        }
                    }
                }
                let card1 = document.getElementById('card-road-1');
                if(card1) card1.classList.add('selected');
            },
            selectRoadLevel(level) {
                if(level !== 1) {
                    Controller.toast('üîí Locked! Only Path is available.');
                    return;
                }
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) card.classList.remove('selected');
                }
                let card = document.getElementById('card-road-' + level);
                if(card) card.classList.add('selected');
                this.selectedRoadLevel = level;
                Controller.toast('Selected: Path');
            },
            confirmRoadSelection() {
                this.closeRoadMenu();
                this.setTool('ROAD');
                Controller.toast('üõ£Ô∏è Click to place Path ($5)');
            },
            
            updateNeedsWarning() {
                // Only show in SimCity mode and if population is reasonable
                if(!Game.simcityMode || Game.pop < 5) {
                    document.getElementById('needs-warning-panel').style.display = 'none';
                    return;
                }
                
                let panel = document.getElementById('needs-warning-panel');
                let needsList = document.getElementById('needs-list');
                let satisfactionBar = document.getElementById('satisfaction-bar');
                
                let warnings = [];
                let colors = {
                    housing: '#FF6B6B',     // Red
                    water: '#4ECDC4',       // Teal
                    food: '#FFD93D',        // Yellow
                    jobs: '#6BCF7F',        // Green
                    paths: '#A78BFA'        // Purple
                };
                
                // Check each need
                if(Game.needs.housing.satisfied < 0.5) {
                    warnings.push(`üè† Housing CRITICAL (${Game.needs.housing.shortage} homeless)`);
                } else if(Game.needs.housing.satisfied < 0.8) {
                    warnings.push(`üè† Housing needed (${Game.needs.housing.shortage} shortage)`);
                }
                
                if(Game.needs.water.satisfied < 0.5 && Game.pop >= 10) {
                    warnings.push(`üíß Water CRITICAL (need ${Game.needs.water.shortage} wells)`);
                } else if(Game.needs.water.satisfied < 0.8 && Game.pop >= 10) {
                    warnings.push(`üíß Water needed (${Game.needs.water.shortage} wells)`);
                }
                
                if(Game.needs.food.satisfied < 0.3) {
                    warnings.push(`üåæ Food CRITICAL - reserves low!`);
                } else if(Game.needs.food.satisfied < 0.6) {
                    warnings.push(`üåæ Food low - build industry`);
                }
                
                if(Game.needs.jobs.satisfied < 0.7 && Game.pop > 20) {
                    warnings.push(`üíº Jobs needed (${Game.needs.jobs.shortage} unemployed)`);
                }
                
                if(Game.needs.paths.satisfied < 0.5 && Game.zoneCount > 3) {
                    warnings.push(`üõ§Ô∏è Paths needed (${Game.needs.paths.shortage} tiles)`);
                }
                
                // If no warnings, show satisfaction message
                if(warnings.length === 0) {
                    needsList.innerHTML = `<span style="color: #6BCF7F;">‚úì All needs met!</span>`;
                    panel.style.border = '2px solid #6BCF7F';
                    panel.style.boxShadow = '0 8px 25px rgba(107,207,127,0.3)';
                } else {
                    needsList.innerHTML = warnings.map(w => `<div>‚Ä¢ ${w}</div>`).join('');
                    panel.style.border = '2px solid #FF6B6B';
                    panel.style.boxShadow = '0 8px 25px rgba(255,107,107,0.3)';
                }
                
                // Update satisfaction bar
                let satisfaction = Game.needs.overall || 1.0;
                let satPercent = Math.floor(satisfaction * 100);
                satisfactionBar.style.width = (satisfaction * 100) + '%';
                satisfactionBar.textContent = satPercent + '%';
                
                // Color code the bar
                if(satisfaction >= 0.8) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #6BCF7F 0%, #4CAF50 100%)';
                } else if(satisfaction >= 0.5) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FFD93D 0%, #FFA726 100%)';
                } else {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FF6B6B 0%, #C62828 100%)';
                }
                
                panel.style.display = 'block';
            },
            updateBuildingUnlocks() {
                let pop = Game.pop;
                
                // Level 0 removed - WANDER epoch only, no building placement
                
                // Level 1 (Pit) - Always unlocked (first buildable level)
                let card1 = document.getElementById('card-level-1');
                card1.classList.remove('level-locked');
                card1.querySelector('.level-cost').textContent = 'Cost: 100 Food + 100 Wood';
                
                // Level 2 (Leather Tent) - Unlock at 50 pop
                let card2 = document.getElementById('card-level-2');
                if(pop >= 50) {
                    card2.classList.remove('level-locked');
                    card2.querySelector('.level-cost').textContent = 'Cost: 300 Food + 300 Wood';
                } else {
                    card2.classList.add('level-locked');
                    card2.querySelector('.level-cost').textContent = 'üîí Unlock at 50 Population';
                }
                
                // Level 3 (Mud Brick) - Unlock at 200 pop
                let card3 = document.getElementById('card-level-3');
                if(pop >= 200) {
                    card3.classList.remove('level-locked');
                    card3.querySelector('.level-cost').textContent = 'Cost: 900 Food + 900 Wood';
                } else {
                    card3.classList.add('level-locked');
                    card3.querySelector('.level-cost').textContent = 'üîí Unlock at 200 Population';
                }
                
                // Level 4 (Stone House) - Unlock at 500 pop
                let card4 = document.getElementById('card-level-4');
                if(pop >= 500) {
                    card4.classList.remove('level-locked');
                    card4.querySelector('.level-cost').textContent = 'Cost: 300 Food + 50 Wood + 100 Stone';
                } else {
                    card4.classList.add('level-locked');
                    card4.querySelector('.level-cost').textContent = 'üîí Unlock at 500 Population';
                }
                
                // Auto-select highest unlocked level
                let highestUnlocked = 0;
                if(pop >= 500) highestUnlocked = 4;
                else if(pop >= 200) highestUnlocked = 3;
                else if(pop >= 50) highestUnlocked = 2;
                else if(pop >= 10) highestUnlocked = 1;
                
                // If current selection is locked, switch to highest unlocked
                if(this.selectedBuildingLevel > highestUnlocked) {
                    this.selectBuildingLevel(highestUnlocked);
                }
            },
            selectBuildingLevel(level) {
                // Check if this level is locked
                let card = document.getElementById('card-level-' + level);
                if(!card) {
                    console.error('Card not found for level:', level);
                    return;
                }
                if(card.classList.contains('level-locked')) {
                    // Get actual unlock requirements from BUILDING_DB
                    let building = CFG.BUILDING_DB['RES_' + level];
                    if(building && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(`${Controller.formatNum(req.pop)} population`);
                        if(req.buildings) {
                            parts.push(`${req.buildings.count}x ${req.buildings.type} L${req.buildings.level}`);
                        }
                        Controller.toast(`üîí Locked! Need: ${parts.join(' + ')}`);
                    } else {
                        Controller.toast(`üîí This level is locked`);
                    }
                    return;
                }
                
                // Remove selected class from all cards (only levels 1-4 exist)
                for(let i = 1; i <= 4; i++) {
                    let c = document.getElementById('card-level-' + i);
                    if(c) c.classList.remove('selected');
                }
                // Add selected class to chosen card
                card.classList.add('selected');
                this.selectedBuildingLevel = level;
            },
            confirmBuildingSelection() {
                let levelConfig = CFG.BUILDING_LEVELS[this.selectedBuildingLevel];
                console.log('confirmBuildingSelection: Level', this.selectedBuildingLevel, 'Config:', levelConfig);
                this.closeBuildingMenu();
                this.tool = 'RES';
                console.log('Tool set to RES, current tool value:', this.tool);
                
                // Highlight the residential button to show it's active
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                let resBtn = document.getElementById('t-res');
                if(resBtn) {
                    resBtn.classList.add('active');
                    console.log('Residential button activated, tool set to RES');
                } else {
                    console.error('t-res button not found!');
                }
                
                Controller.toast(`Ready to build: ${levelConfig.name} (Capacity: ${levelConfig.capacity})`);
                
                // TEST: Try to build immediately at player position as a test
                if(Game.player) {
                    console.log('TEST: Attempting to build at player position:', Game.player.x, Game.player.y);
                }
            },
            setBuildingLevel(level) {
                this.selectedBuildingLevel = level;
                let levelConfig = CFG.BUILDING_LEVELS[level];
                Controller.toast(`Selected: ${levelConfig.name} (Cap: ${levelConfig.capacity})`);
            },
            toggleView() { 
                // Cycle through view modes: NORMAL -> DESIRABILITY -> BIRDSEYE -> POL -> NORMAL
                // ELEVATION mode removed for mystery gameplay - player discovers flood risk through disasters
                let modes = ['NORMAL', 'DESIRABILITY', 'BIRDSEYE', 'POL'];
                let currentIndex = modes.indexOf(Game.vm);
                Game.vm = modes[(currentIndex + 1) % modes.length];
                
                // Elevation overlay stays disabled for mystery mode
                Controller.showElevation = false;
                
                let btn = document.getElementById('btn-view');
                let icons = { 'NORMAL': 'üëÅÔ∏è', 'DESIRABILITY': 'üî•', 'BIRDSEYE': 'üé®', 'POL': '‚ò¢Ô∏è' };
                let titles = { 'NORMAL': 'Normal View', 'DESIRABILITY': 'Desirability Heatmap', 'BIRDSEYE': 'Birds Eye View (No UI)', 'POL': 'Pollution View' };
                btn.innerText = icons[Game.vm];
                btn.title = titles[Game.vm];
                
                Controller.toast(`View: ${titles[Game.vm]}`);
            },
            toggleAI() {
                // Use external AI module's toggle function
                let enabled = AI.toggle();
                
                // Update game state for compatibility
                Game.aiEnabled = enabled;
                
                // Update UI
                let btn = document.getElementById('btn-ai');
                btn.innerText = 'ü§ñ';
                btn.title = enabled ? 'AI Autoplay: ON' : 'Toggle AI Autoplay';
                btn.style.background = enabled ? '#4CAF50' : '';
                Controller.toast(enabled ? 'ü§ñ AI Autoplay Enabled' : 'ü§ñ AI Autoplay Disabled');
            },
            toggleBuildPanel() {
                let sidebar = document.getElementById('sidebar');
                if(sidebar.style.display === 'none' || sidebar.style.display === '') {
                    sidebar.style.display = 'block';
                    document.getElementById('btn-build').style.background = '#4CAF50';
                } else {
                    sidebar.style.display = 'none';
                    document.getElementById('btn-build').style.background = '#444';
                }
            },
            showCityUI() {
                console.log('=== showCityUI START ===');
                console.log('Game.gameState:', Game.gameState);
                
                // Force CITY mode
                Game.gameState = 'CITY';
                console.log('Forced gameState to CITY');
                
                // Hide wander mode buttons
                try {
                    let settleBtn = document.getElementById('btn-settle');
                    if(settleBtn) {
                        settleBtn.style.display = 'none';
                        console.log('Hid settlement button');
                    }
                } catch(e) {
                    console.error('Error hiding settlement button:', e);
                }
                
                // Show build tools
                console.log('Showing build tools...');
                try {
                    let elements = {
                        't-road': document.getElementById('t-road'),
                        't-well': document.getElementById('t-well'),
                        't-demolish': document.getElementById('t-demolish'),
                        't-res': document.getElementById('t-res'),
                        't-com': document.getElementById('t-com'),
                        't-ind': document.getElementById('t-ind'),
                        't-chief': document.getElementById('t-chief'),
                        't-basket': document.getElementById('t-basket'),
                        't-pottery': document.getElementById('t-pottery'),
                        't-granary': document.getElementById('t-granary'),
                        't-palace': document.getElementById('t-palace'),
                        'sep1': document.getElementById('sep1'),
                        'sep2': document.getElementById('sep2'),
                        'btn-turn': document.getElementById('btn-turn'),
                        'btn-view': document.getElementById('btn-view')
                    };
                    for(let id in elements) {
                        if(elements[id]) {
                            elements[id].style.display = 'inline-block';
                            // Special: always enable t-res in city mode
                            if(id === 't-res') {
                                elements[id].disabled = false;
                                elements[id].style.display = 'inline-block';
                                elements[id].title = 'Build Residential';
                            }
                            console.log('Showed:', id);
                        } else {
                            console.error('Element not found:', id);
                        }
                    }
                } catch(e) {
                    console.error('Error showing build tools:', e);
                }
                
                console.log('Build tools shown');
                
                // Initialize building level selector (default to highest unlocked level)
                if(Controller.selectedBuildingLevel === undefined) {
                    Controller.selectedBuildingLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    console.log('Set default building level to', Controller.selectedBuildingLevel);
                }
                
                console.log('Checking progression locks...');
                
                // Check progression and disable locked buildings
                // Industrial is unlocked at stage 2 (after settlement triggers stage 1 ‚Üí 2 transition)
                let industrialUnlocked = PROGRESSION.stage >= 2;
                let simcityUnlocked = Game.simcityMode;
                
                // Commercial (Pebble Trade Fire) - unlocked after first residential zone at epoch 1
                let btnCom = document.getElementById('t-com');
                if(btnCom) {
                    btnCom.disabled = false; // Always available in city mode
                    btnCom.title = 'Build Pebble Trade Fire to unlock commerce';
                }
                
                // Industrial (Hunting Ground) - always available in city mode (after settlement)
                let btnInd = document.getElementById('t-ind');
                if(btnInd) {
                    // In CITY mode, industrial is always unlocked
                    btnInd.disabled = false;
                    btnInd.title = 'Build hunting ground (1000 food + 1000 wood)';
                }
                
                // Chief's Hut - requires simcity mode
                let btnChief = document.getElementById('t-chief');
                if(btnChief) {
                    if(!simcityUnlocked) {
                        btnChief.disabled = true;
                        btnChief.title = `üîí LOCKED: Build Pebble Trade Fire first (${CFG.PRODUCTION.SIMCITY_MODE_UNLOCK_COST} food)`;
                    } else {
                        btnChief.disabled = false;
                        btnChief.title = "First Chief's Hut (10,000 food)";
                    }
                }
                
                // Storage buildings - require simcity mode
                let btnBasket = document.getElementById('t-basket');
                let btnPottery = document.getElementById('t-pottery');
                let btnGranary = document.getElementById('t-granary');
                let btnPalace = document.getElementById('t-palace');
                
                if(!simcityUnlocked) {
                    if(btnBasket) { btnBasket.disabled = true; btnBasket.title = `üîí LOCKED: Build Pebble Trade Fire first`; }
                    if(btnPottery) { btnPottery.disabled = true; btnPottery.title = `üîí LOCKED: Build Pebble Trade Fire first`; }
                    if(btnGranary) { btnGranary.disabled = true; btnGranary.title = `üîí LOCKED: Build Pebble Trade Fire first`; }
                    if(btnPalace) { btnPalace.disabled = true; btnPalace.title = `üîí LOCKED: Build Pebble Trade Fire first`; }
                } else {
                    if(btnBasket) { btnBasket.disabled = false; btnBasket.title = 'Basket (500 food) - +25 storage'; }
                    if(btnPottery) { btnPottery.disabled = false; btnPottery.title = 'Pottery (5,000 food) - +100 storage'; }
                    if(btnGranary) { btnGranary.disabled = false; btnGranary.title = 'Granary (50,000 food) - +500 storage'; }
                    if(btnPalace) { btnPalace.disabled = false; btnPalace.title = 'Palace (250,000 food) - +2,500 storage'; }
                }
                
                // Show city stats
                document.getElementById('stat-year').style.display = 'flex';
                document.getElementById('stat-water').style.display = 'flex';
                document.getElementById('stat-funds').style.display = 'flex';
                
                // Show camera control arrows (if they exist)
                let camUp = document.getElementById('cam-up');
                let camDown = document.getElementById('cam-down');
                let camLeft = document.getElementById('cam-left');
                let camRight = document.getElementById('cam-right');
                if (camUp) camUp.style.display = 'block';
                if (camDown) camDown.style.display = 'block';
                if (camLeft) camLeft.style.display = 'block';
                if (camRight) camRight.style.display = 'block';
                
                console.log('showCityUI() complete');
                
                // Visual confirmation
                setTimeout(() => {
                    Controller.toast('üèóÔ∏è City Build Mode Active! Click Residential to start building.');
                }, 200);
            },
            formatNumber(num) {
                // Use the same formatter as formatNum for consistency
                return this.formatNum(num);
            },
            updateUI() {
                // Show population differently in WANDER vs CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}`;
                } else {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}/${this.formatNumber(Game.housingCap)}`;
                }
                                document.getElementById('v-res').innerText = this.formatNumber(Math.floor(Game.gold || 0));
                
                // Show inventory food in WANDER mode, regular food in CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-food').innerText = `${this.formatNumber(Math.floor(Game.inventory.food))}/${this.formatNumber(Game.inventory.capacity)}`;
                    document.getElementById('v-wood').innerText = this.formatNumber(Math.floor(Game.inventory.wood));
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show inventory metal/stone (from active collection) + pocket (passive finds)
                    let wanderMetal = Math.floor(Game.inventory.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let wanderStone = Math.floor(Game.inventory.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    document.getElementById('v-metal').innerText = this.formatNumber(wanderMetal);
                    document.getElementById('v-stone').innerText = this.formatNumber(wanderStone);
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    // Show total inventory
                    let totalInv = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                    document.getElementById('v-inventory').innerText = `${this.formatNumber(Math.floor(totalInv))}/${this.formatNumber(Game.inventory.capacity)}`;
                    document.getElementById('stat-inventory').style.display = 'flex';
                    
                    // Show thirst indicator in WANDER mode
                    document.getElementById('stat-thirst').style.display = 'flex';
                    let thirstEl = document.getElementById('v-thirst');
                    let thirst = Game.thirst || 100;
                    thirstEl.innerText = thirst;
                    // Color code thirst level
                    if(thirst > 50) thirstEl.style.color = '#29B6F6'; // Blue - good
                    else if(thirst > 25) thirstEl.style.color = '#FFA726'; // Orange - warning
                    else thirstEl.style.color = '#E53935'; // Red - critical
                    
                    // Show wander wells count
                    document.getElementById('stat-wander-wells').style.display = 'flex';
                    document.getElementById('v-wander-wells').innerText = (Game.wanderWells ? Game.wanderWells.length : 0);
                } else {
                    document.getElementById('v-food').innerText = this.formatNumber(Math.floor(Game.food));
                    // Show wood in CITY mode (needed for upkeep)
                    document.getElementById('v-wood').innerText = this.formatNumber(Math.floor(Game.wood));
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show metal and stone (from inventory + pocket)
                    let totalMetal = Math.floor(Game.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let totalStone = Math.floor(Game.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    
                    document.getElementById('v-metal').innerText = this.formatNumber(totalMetal);
                    document.getElementById('v-stone').innerText = this.formatNumber(totalStone);
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    document.getElementById('stat-inventory').style.display = 'none';
                    document.getElementById('stat-thirst').style.display = 'none'; // Hide thirst in CITY mode
                    
                    // Hide wander wells stat in CITY mode
                    document.getElementById('stat-wander-wells').style.display = 'none';
                }

                let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                let comCount = Game.blds.filter(b => b.t === 'COM').length;
                let indCount = Game.blds.filter(b => b.t === 'IND').length;
                
                // Update water display: percentage of capacity used
                let totalWells = Game.wellCount || wellCount;
                let waterCapacity = totalWells * 100; // Each well supports 100 people
                let waterUsed = Math.min(Game.pop, waterCapacity);
                let waterPercent = waterCapacity > 0 ? Math.round((waterUsed / waterCapacity) * 100) : 0;
                let waterStatus = `üíß ${waterPercent}% capacity`;
                if(waterCapacity === 0) waterStatus = `‚ö†Ô∏è No wells!`;
                else if(Game.pop > waterCapacity) waterStatus = `üî¥ OVER CAPACITY! (${Game.pop}/${waterCapacity})`;
                else if(waterPercent > 80) waterStatus = `üü° ${waterPercent}% capacity`;
                else waterStatus = `üü¢ ${waterPercent}% capacity`;
                document.getElementById('v-wat').innerText = waterStatus;
                
                // Update wells meter (new detailed view)
                if(Game.gameState === 'CITY') {
                    let wellsNeeded = Math.max(1, Math.ceil(Game.pop / 100)); // 1 well per 100 people
                    let wellsWithBuffer = wellsNeeded + 2; // +2 buffer recommended
                    let wellsEl = document.getElementById('v-wells');
                    let wellsStatEl = document.getElementById('stat-wells');
                    if(wellsEl && wellsStatEl) {
                        wellsStatEl.style.display = 'flex';
                        // Show wells: how many built and capacity usage
                        let wellsStatus = '';
                        let capacityUsed = totalWells > 0 ? Math.round((Game.pop / (totalWells * 100)) * 100) : 0;
                        
                        if(totalWells >= wellsNeeded) {
                            // Enough wells - show capacity usage
                            wellsStatus = `üü¢ ${totalWells} wells (${capacityUsed}% capacity)`;
                        } else if(totalWells > 0) {
                            // Not enough wells - DANGER!
                            let shortage = wellsNeeded - totalWells;
                            wellsStatus = `üî¥ ${totalWells} wells - Need ${shortage} more!`;
                        } else {
                            wellsStatus = `‚ö†Ô∏è NO WELLS! Need ${wellsNeeded}`;
                        }
                        wellsEl.innerText = wellsStatus;
                    }
                } else {
                    let wellsStatEl = document.getElementById('stat-wells');
                    if(wellsStatEl) wellsStatEl.style.display = 'none';
                }
                
                document.getElementById('v-nomad').innerText = Game.nomadsFound;
                document.getElementById('v-year').innerText = Game.year;
                
                // Update geological period display (if enabled)
                if(CFG.ELEVATION_SYSTEM.ENABLED && Game.geology) {
                    let geoEl = document.getElementById('v-geology');
                    if(geoEl) {
                        let seaIcon = Game.geology.currentSeaLevel > 3 ? 'üåä' : 
                                     Game.geology.currentSeaLevel < 3 ? '‚ùÑÔ∏è' : 'üåç';
                        geoEl.innerText = `${seaIcon} ${Game.geology.currentPeriodName}`;
                        document.getElementById('stat-geology').style.display = 'flex';
                    }
                }
                
                // Update workforce display (only in CITY mode)
                if(Game.gameState === 'CITY' && Game.workforce) {
                    let wf = Game.workforce;
                    let workforceEl = document.getElementById('v-workforce');
                    if(workforceEl) {
                        let status = `üë∑ ${wf.gatherers} gathering`;
                        if(wf.shortage > 0) {
                            status = `‚ö†Ô∏è ${wf.shortage} workers short! ${wf.gatherers} gathering`;
                        }
                        workforceEl.innerText = status;
                        document.getElementById('stat-workforce').style.display = 'flex';
                    }
                } else {
                    let workforceEl = document.getElementById('stat-workforce');
                    if(workforceEl) workforceEl.style.display = 'none';
                }
                
                // Update health display - HIDE in Epoch 0 (population IS health)
                // Health display removed - player health is now tied to population
                
                // Dynamic contextual guidance based on game state
                if(PROGRESSION.stage === 0) {
                    // Exploration phase - keep it open-ended
                    document.getElementById('v-epoch').innerText = `üåç EXPLORING THE WORLD`;
                } else if(PROGRESSION.stage === 1) {
                    // Settlement phase - simple status
                    document.getElementById('v-epoch').innerText = `üèïÔ∏è BUILDING SETTLEMENT`;
                } else if(PROGRESSION.stage === 2 && Game.age === 0) {
                    // Paleolithic - simple status
                    document.getElementById('v-epoch').innerText = `üèπ PALEOLITHIC AGE`;
                } else {
                    // Advanced ages - just show current age
                    let ageName = AGES[Game.age].n;
                    document.getElementById('v-epoch').innerText = `‚öîÔ∏è ${ageName.toUpperCase()} AGE`;
                }
                
                // UPDATE NEEDS WARNING PANEL
                this.updateNeedsWarning();
                
                // Update RCI demand meters (SimCity-style interdependent balance)
                if(Game.gameState === 'CITY') {
                    document.getElementById('rci-meters').style.display = 'block';
                    
                    // Use centralized RCI calculation (shared with AI)
                    let rci = Game.calculateRCIDemand();
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    
                    // Update the visual bars
                    let rBar = document.getElementById('r-bar-fill');
                    let cBar = document.getElementById('c-bar-fill');
                    let iBar = document.getElementById('i-bar-fill');
                    
                    if(rBar) rBar.style.height = rci.r + '%';
                    if(cBar) cBar.style.height = rci.c + '%';
                    if(iBar) iBar.style.height = rci.i + '%';
                    
                    // Update tooltip with counts
                    let tooltip = document.getElementById('rci-tooltip');
                    if(tooltip) {
                        tooltip.innerText = `R:${resCount} C:${comCount} I:${indCount}`;
                    }
                }
                // RCI meters always visible now (moved to left side of dashboard)
            },
            currentLogView: 'player',
            captureConsoleLogs() {
                // Store original console methods
                const originalLog = console.log;
                const originalError = console.error;
                const originalWarn = console.warn;
                const originalInfo = console.info;
                
                // Initialize technical log if needed
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Override console.log
                console.log = function(...args) {
                    originalLog.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [LOG] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.error - Enhanced with auto-toast for critical errors
                console.error = function(...args) {
                    originalError.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [ERROR] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                    
                    // AUTO-ALERT: Flash toast RED immediately on any error
                    // This ensures testers/AI notice when something breaks
                    if(typeof Controller !== 'undefined' && Controller.toast) {
                        Controller.toast(`‚ö†Ô∏è ERROR: ${msg.substring(0, 80)}...`, true);
                    }
                    
                    // Optional: Auto-open log modal on critical errors (uncomment to enable)
                    // if(typeof Controller !== 'undefined' && Controller.showLog) {
                    //     Controller.showLog();
                    //     Controller.switchLog('technical');
                    // }
                };
                
                // Override console.warn
                console.warn = function(...args) {
                    originalWarn.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [WARN] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.info
                console.info = function(...args) {
                    originalInfo.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [INFO] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
            },
            toast(m, isError = false) { 
                let t = document.getElementById('toast'); 
                t.innerText = m; 
                t.style.opacity = 1; 
                if(isError) t.style.background = '#F44336';
                else t.style.background = 'rgba(0,0,0,0.85)';
                setTimeout(() => t.style.opacity = 0, 2000); 
                
                // Initialize logs if needed
                if(!Game.playerLog) Game.playerLog = [];
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Add to player log (user-friendly messages)
                let timestamp = `[Y${Game.year || 0}]`;
                Game.playerLog.push(`${timestamp} ${m}`);
                if(Game.playerLog.length > 200) Game.playerLog.shift();
                
                // Add to technical log with more detail
                let techTimestamp = new Date().toLocaleTimeString();
                Game.technicalLog.push(`[${techTimestamp}] ${m}`);
                if(Game.technicalLog.length > 500) Game.technicalLog.shift();
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // LORE SYSTEM - Story Mode with Cartoon Illustrations
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            toggleLore() {
                Game.loreEnabled = !Game.loreEnabled;
                let btn = document.getElementById('btn-lore');
                if(Game.loreEnabled) {
                    btn.classList.add('active');
                    this.toast('üìñ Lore Mode ON - Story events will appear!');
                    // Show intro lore if this is a fresh game
                    if(!Game.loreSeen.GAME_START && Game.year === 0) {
                        this.showLoreEvent('GAME_START');
                    }
                } else {
                    btn.classList.remove('active');
                    this.toast('üìñ Lore Mode OFF');
                }
            },
            
            showLoreEvent(eventId) {
                // Only show if lore is enabled and not already seen
                if(!Game.loreEnabled) return;
                if(Game.loreSeen[eventId]) return;
                
                // Mark as seen
                Game.loreSeen[eventId] = true;
                
                // Get event data
                let event = CFG.LORE_EVENTS[eventId];
                if(!event) {
                    console.warn('Lore event not found:', eventId);
                    return;
                }
                
                // Update popup content
                document.getElementById('lore-title').textContent = event.title;
                document.getElementById('lore-text').textContent = event.text;
                
                // Draw illustration
                this.drawLoreIllustration(event.illustration);
                
                // Show popup
                document.getElementById('lore-popup-overlay').style.display = 'block';
                document.getElementById('lore-popup').style.display = 'block';
            },
            
            closeLorePopup() {
                document.getElementById('lore-popup-overlay').style.display = 'none';
                document.getElementById('lore-popup').style.display = 'none';
            },
            
            drawLoreIllustration(type) {
                let canvas = document.getElementById('lore-canvas');
                let c = canvas.getContext('2d');
                let w = canvas.width;
                let h = canvas.height;
                
                // Clear canvas
                c.clearRect(0, 0, w, h);
                
                // Draw based on illustration type (Pokemon/cartoon style)
                switch(type) {
                    case 'wanderer':
                        this.drawWandererScene(c, w, h);
                        break;
                    case 'well':
                        this.drawWellScene(c, w, h);
                        break;
                    case 'hut':
                        this.drawHutScene(c, w, h);
                        break;
                    case 'hunting':
                        this.drawHuntingScene(c, w, h);
                        break;
                    case 'road':
                        this.drawRoadScene(c, w, h);
                        break;
                    case 'hunt_success':
                        this.drawHuntSuccessScene(c, w, h);
                        break;
                    case 'settlement':
                        this.drawSettlementScene(c, w, h);
                        break;
                    case 'storage':
                        this.drawStorageScene(c, w, h);
                        break;
                    case 'trading':
                        this.drawTradingScene(c, w, h);
                        break;
                    case 'nomad':
                        this.drawNomadScene(c, w, h);
                        break;
                    case 'turtle':
                        this.drawTurtleScene(c, w, h);
                        break;
                    case 'flood':
                        this.drawFloodScene(c, w, h);
                        break;
                    case 'berry':
                        this.drawBerryScene(c, w, h);
                        break;
                    default:
                        this.drawDefaultScene(c, w, h);
                }
            },
            
            // Helper function for drawing cartoon-style characters
            drawCartoonPerson(c, x, y, scale, facing) {
                // Facing: 1 = right, -1 = left
                let s = scale || 1;
                let f = facing || 1;
                
                // Body (fur clothes)
                c.fillStyle = '#8B6914';
                c.beginPath();
                c.ellipse(x, y + 15*s, 12*s, 18*s, 0, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#5D4E37';
                c.lineWidth = 2;
                c.stroke();
                
                // Head
                c.fillStyle = '#E8C4A0';
                c.beginPath();
                c.arc(x, y - 10*s, 14*s, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#B8947A';
                c.stroke();
                
                // Hair (messy)
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.ellipse(x, y - 20*s, 12*s, 8*s, 0, 0, Math.PI*2);
                c.fill();
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.arc(x + (i-2)*5*s, y - 24*s, 4*s, 0, Math.PI*2);
                    c.fill();
                }
                
                // Eyes (big cartoon eyes)
                c.fillStyle = '#fff';
                c.beginPath();
                c.ellipse(x - 5*s*f, y - 12*s, 4*s, 5*s, 0, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(x + 3*s*f, y - 12*s, 4*s, 5*s, 0, 0, Math.PI*2);
                c.fill();
                
                // Pupils
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(x - 4*s*f, y - 12*s, 2*s, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.arc(x + 4*s*f, y - 12*s, 2*s, 0, Math.PI*2);
                c.fill();
                
                // Smile
                c.strokeStyle = '#6B4A3A';
                c.lineWidth = 2;
                c.beginPath();
                c.arc(x, y - 5*s, 6*s, 0.2, Math.PI - 0.2);
                c.stroke();
            },
            
            // Scene drawing functions
            drawWandererScene(c, w, h) {
                // Sky gradient (sunset)
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#FF7F50');
                skyGrad.addColorStop(0.4, '#FFD700');
                skyGrad.addColorStop(0.7, '#87CEEB');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Sun
                c.fillStyle = '#FFE135';
                c.beginPath();
                c.arc(w - 80, 50, 35, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#FFA500';
                c.lineWidth = 4;
                c.stroke();
                
                // Rolling hills
                c.fillStyle = '#7CB342';
                c.beginPath();
                c.moveTo(0, h);
                c.quadraticCurveTo(100, h - 80, 200, h - 40);
                c.quadraticCurveTo(350, h - 100, w, h - 50);
                c.lineTo(w, h);
                c.fill();
                
                // Grass tufts
                c.fillStyle = '#558B2F';
                for(let i = 0; i < 15; i++) {
                    let gx = Math.random() * w;
                    let gy = h - 30 - Math.random() * 40;
                    c.beginPath();
                    c.moveTo(gx, gy);
                    c.lineTo(gx - 3, gy + 10);
                    c.lineTo(gx + 3, gy + 10);
                    c.fill();
                }
                
                // Wanderer walking toward horizon
                this.drawCartoonPerson(c, w/2 - 30, h - 60, 1.2, 1);
                
                // Walking stick
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 - 5, h - 80);
                c.lineTo(w/2 + 10, h - 25);
                c.stroke();
            },
            
            drawWellScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#8B7355';
                c.fillRect(0, h - 60, w, 60);
                
                // Well structure
                c.fillStyle = '#696969';
                c.fillRect(w/2 - 40, h - 100, 80, 50);
                
                // Well opening
                c.fillStyle = '#1a1a2e';
                c.beginPath();
                c.ellipse(w/2, h - 100, 30, 12, 0, 0, Math.PI*2);
                c.fill();
                
                // Water splash!
                c.fillStyle = '#4FC3F7';
                for(let i = 0; i < 8; i++) {
                    let sx = w/2 + (Math.random() - 0.5) * 40;
                    let sy = h - 110 - Math.random() * 30;
                    c.beginPath();
                    c.ellipse(sx, sy, 4, 6, Math.random(), 0, Math.PI*2);
                    c.fill();
                }
                
                // Happy caveman
                this.drawCartoonPerson(c, w/2 + 80, h - 80, 1.3, -1);
                
                // Surprised expression (raised eyebrows - draw over)
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.ellipse(w/2 + 75, h - 108, 8, 3, -0.3, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(w/2 + 88, h - 106, 8, 3, 0.3, 0, Math.PI*2);
                c.fill();
            },
            
            drawHutScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Hut (cute round structure)
                // Main body
                c.fillStyle = '#DEB887';
                c.beginPath();
                c.arc(w/2, h - 60, 60, Math.PI, 0);
                c.fill();
                
                // Door
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.arc(w/2, h - 55, 20, Math.PI, 0);
                c.fill();
                
                // Straw roof
                c.fillStyle = '#DAA520';
                c.beginPath();
                c.moveTo(w/2 - 70, h - 60);
                c.lineTo(w/2, h - 120);
                c.lineTo(w/2 + 70, h - 60);
                c.fill();
                
                // Roof texture
                c.strokeStyle = '#B8860B';
                c.lineWidth = 2;
                for(let i = 0; i < 7; i++) {
                    c.beginPath();
                    c.moveTo(w/2 - 50 + i*15, h - 60);
                    c.lineTo(w/2, h - 115);
                    c.stroke();
                }
                
                // Proud caveman
                this.drawCartoonPerson(c, w/2 + 100, h - 80, 1.2, -1);
                
                // Smoke from invisible fire inside
                c.fillStyle = 'rgba(200, 200, 200, 0.5)';
                for(let i = 0; i < 4; i++) {
                    c.beginPath();
                    c.arc(w/2 + 5, h - 130 - i*20, 8 + i*3, 0, Math.PI*2);
                    c.fill();
                }
            },
            
            drawHuntingScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Forest background
                c.fillStyle = '#228B22';
                for(let i = 0; i < 5; i++) {
                    let tx = i * 120;
                    c.beginPath();
                    c.moveTo(tx, h - 50);
                    c.lineTo(tx + 40, h - 140);
                    c.lineTo(tx + 80, h - 50);
                    c.fill();
                }
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 50, w, 50);
                
                // Deer (cute style)
                let dx = w/2 - 60;
                let dy = h - 70;
                c.fillStyle = '#D4A76A';
                c.beginPath();
                c.ellipse(dx, dy, 35, 20, 0, 0, Math.PI*2);
                c.fill();
                // Head
                c.beginPath();
                c.ellipse(dx + 40, dy - 10, 15, 12, 0.3, 0, Math.PI*2);
                c.fill();
                // Eye
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(dx + 45, dy - 13, 3, 0, Math.PI*2);
                c.fill();
                // Antlers
                c.strokeStyle = '#8B4513';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(dx + 38, dy - 22);
                c.lineTo(dx + 30, dy - 40);
                c.moveTo(dx + 32, dy - 30);
                c.lineTo(dx + 22, dy - 35);
                c.stroke();
                c.beginPath();
                c.moveTo(dx + 45, dy - 22);
                c.lineTo(dx + 55, dy - 40);
                c.moveTo(dx + 52, dy - 30);
                c.lineTo(dx + 62, dy - 35);
                c.stroke();
                // Legs
                c.fillStyle = '#C49A6C';
                c.fillRect(dx - 20, dy + 10, 8, 25);
                c.fillRect(dx + 15, dy + 10, 8, 25);
                
                // Hiding hunter
                this.drawCartoonPerson(c, 100, h - 70, 1, 1);
                // Spear
                c.strokeStyle = '#5D4037';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(110, h - 90);
                c.lineTo(180, h - 110);
                c.stroke();
                // Spear tip
                c.fillStyle = '#808080';
                c.beginPath();
                c.moveTo(180, h - 115);
                c.lineTo(190, h - 110);
                c.lineTo(180, h - 105);
                c.fill();
            },
            
            drawRoadScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Grass
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 80, w, 80);
                
                // Dirt road
                c.fillStyle = '#C4A76C';
                c.beginPath();
                c.moveTo(0, h - 30);
                c.quadraticCurveTo(w/2, h - 60, w, h - 30);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Road texture (stones)
                c.fillStyle = '#A08050';
                for(let i = 0; i < 15; i++) {
                    let rx = Math.random() * w;
                    let ry = h - 10 - Math.random() * 20;
                    c.beginPath();
                    c.ellipse(rx, ry, 5, 3, Math.random(), 0, Math.PI*2);
                    c.fill();
                }
                
                // Happy caveman pointing at road
                this.drawCartoonPerson(c, w/2, h - 90, 1.3, 1);
                
                // Pointing arm
                c.strokeStyle = '#E8C4A0';
                c.lineWidth = 8;
                c.beginPath();
                c.moveTo(w/2 + 10, h - 90);
                c.lineTo(w/2 + 50, h - 70);
                c.stroke();
            },
            
            drawHuntSuccessScene(c, w, h) {
                // Dramatic red/orange sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#8B0000');
                skyGrad.addColorStop(0.5, '#FF4500');
                skyGrad.addColorStop(1, '#FFD700');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#6B8E23';
                c.fillRect(0, h - 60, w, 60);
                
                // Victorious hunter
                this.drawCartoonPerson(c, w/2, h - 80, 1.5, 1);
                
                // Raised spear
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 + 20, h - 70);
                c.lineTo(w/2 + 40, h - 150);
                c.stroke();
                c.fillStyle = '#808080';
                c.beginPath();
                c.moveTo(w/2 + 35, h - 155);
                c.lineTo(w/2 + 45, h - 145);
                c.lineTo(w/2 + 35, h - 135);
                c.fill();
                
                // Meat on ground
                c.fillStyle = '#8B0000';
                c.beginPath();
                c.ellipse(w/2 - 60, h - 40, 25, 15, 0.2, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#5D0000';
                c.lineWidth = 2;
                c.stroke();
                
                // Victory sparkles
                c.fillStyle = '#FFD700';
                for(let i = 0; i < 8; i++) {
                    let sx = w/2 + Math.cos(i*0.8) * 80;
                    let sy = h - 120 + Math.sin(i*1.2) * 40;
                    c.beginPath();
                    c.moveTo(sx, sy - 8);
                    c.lineTo(sx + 3, sy);
                    c.lineTo(sx, sy + 8);
                    c.lineTo(sx - 3, sy);
                    c.fill();
                }
            },
            
            drawSettlementScene(c, w, h) {
                // Bright sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 70, w, 70);
                
                // Multiple huts
                for(let i = 0; i < 3; i++) {
                    let hx = 80 + i * 150;
                    c.fillStyle = '#DEB887';
                    c.beginPath();
                    c.arc(hx, h - 50, 35, Math.PI, 0);
                    c.fill();
                    c.fillStyle = '#DAA520';
                    c.beginPath();
                    c.moveTo(hx - 45, h - 50);
                    c.lineTo(hx, h - 90);
                    c.lineTo(hx + 45, h - 50);
                    c.fill();
                }
                
                // Proud founder in center
                this.drawCartoonPerson(c, w/2, h - 100, 1.4, 1);
                
                // Flag/banner
                c.fillStyle = '#8B0000';
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 + 30, h - 140);
                c.lineTo(w/2 + 30, h - 80);
                c.stroke();
                c.beginPath();
                c.moveTo(w/2 + 30, h - 140);
                c.lineTo(w/2 + 70, h - 130);
                c.lineTo(w/2 + 30, h - 120);
                c.fill();
            },
            
            drawStorageScene(c, w, h) {
                // Underground view
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h/2);
                c.fillStyle = '#8B7355';
                c.fillRect(0, h/2, w, h/2);
                
                // Pit
                c.fillStyle = '#5D4037';
                c.beginPath();
                c.moveTo(w/2 - 60, h/2);
                c.lineTo(w/2 - 40, h - 40);
                c.lineTo(w/2 + 40, h - 40);
                c.lineTo(w/2 + 60, h/2);
                c.fill();
                
                // Food in pit
                c.fillStyle = '#FF6347';
                c.beginPath();
                c.arc(w/2 - 15, h - 60, 12, 0, Math.PI*2);
                c.fill();
                c.fillStyle = '#FFD700';
                c.beginPath();
                c.ellipse(w/2 + 10, h - 55, 15, 10, 0.3, 0, Math.PI*2);
                c.fill();
                
                // Person looking down proudly
                this.drawCartoonPerson(c, w/2 + 100, h/2 - 30, 1.2, -1);
            },
            
            drawTradingScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Two people facing each other
                this.drawCartoonPerson(c, w/2 - 60, h - 80, 1.2, 1);
                this.drawCartoonPerson(c, w/2 + 60, h - 80, 1.2, -1);
                
                // Trading items floating between them
                c.fillStyle = '#4FC3F7';
                c.beginPath();
                c.arc(w/2 - 20, h - 100, 10, 0, Math.PI*2); // Fish
                c.fill();
                c.fillStyle = '#FF6B6B';
                c.beginPath();
                c.arc(w/2 + 20, h - 100, 8, 0, Math.PI*2); // Berry
                c.fill();
                
                // Trade arrows
                c.strokeStyle = '#FFD700';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(w/2 - 30, h - 90);
                c.lineTo(w/2, h - 85);
                c.stroke();
                c.beginPath();
                c.moveTo(w/2 + 30, h - 110);
                c.lineTo(w/2, h - 115);
                c.stroke();
            },
            
            drawNomadScene(c, w, h) {
                // Misty sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#708090');
                skyGrad.addColorStop(1, '#B0C4DE');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#6B8E23';
                c.fillRect(0, h - 60, w, 60);
                
                // Mist
                c.fillStyle = 'rgba(200, 200, 200, 0.3)';
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.ellipse(i * 120, h - 50, 80, 30, 0, 0, Math.PI*2);
                    c.fill();
                }
                
                // Our protagonist
                this.drawCartoonPerson(c, w/2 - 80, h - 80, 1.2, 1);
                
                // Mysterious stranger emerging from mist
                this.drawCartoonPerson(c, w/2 + 80, h - 80, 1.2, -1);
                
                // Raised hand (peace gesture)
                c.fillStyle = '#E8C4A0';
                c.beginPath();
                c.moveTo(w/2 + 50, h - 110);
                c.lineTo(w/2 + 45, h - 130);
                c.lineTo(w/2 + 55, h - 130);
                c.lineTo(w/2 + 60, h - 110);
                c.fill();
            },
            
            drawTurtleScene(c, w, h) {
                // Beach scene
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ocean
                c.fillStyle = '#4FC3F7';
                c.fillRect(0, h - 40, w, 40);
                
                // Sand
                c.fillStyle = '#F4D03F';
                c.beginPath();
                c.moveTo(0, h - 40);
                c.quadraticCurveTo(w/2, h - 80, w, h - 40);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Turtle (cute cartoon style)
                let tx = w/2 - 40;
                let ty = h - 80;
                // Shell
                c.fillStyle = '#4A7A4A';
                c.beginPath();
                c.ellipse(tx, ty, 30, 20, 0, 0, Math.PI*2);
                c.fill();
                // Shell pattern
                c.strokeStyle = '#3D6B3D';
                c.lineWidth = 2;
                c.beginPath();
                c.arc(tx, ty, 15, 0, Math.PI*2);
                c.stroke();
                // Head
                c.fillStyle = '#6B8E6B';
                c.beginPath();
                c.ellipse(tx + 35, ty - 5, 12, 10, 0.3, 0, Math.PI*2);
                c.fill();
                // Eye
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(tx + 40, ty - 8, 3, 0, Math.PI*2);
                c.fill();
                // Flippers
                c.fillStyle = '#6B8E6B';
                c.beginPath();
                c.ellipse(tx - 20, ty + 15, 15, 6, -0.5, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(tx + 20, ty + 15, 15, 6, 0.5, 0, Math.PI*2);
                c.fill();
                
                // Confused hunter
                this.drawCartoonPerson(c, w/2 + 80, h - 90, 1.2, -1);
                // Question mark
                c.fillStyle = '#FFD700';
                c.font = 'bold 30px Arial';
                c.fillText('?', w/2 + 90, h - 130);
            },
            
            drawFloodScene(c, w, h) {
                // Stormy sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#2F4F4F');
                skyGrad.addColorStop(1, '#4682B4');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Rising water
                c.fillStyle = '#1E90FF';
                c.fillRect(0, h - 100, w, 100);
                
                // Waves
                c.fillStyle = '#4169E1';
                c.beginPath();
                c.moveTo(0, h - 100);
                for(let i = 0; i < 10; i++) {
                    c.quadraticCurveTo(i*60 + 30, h - 120, i*60 + 60, h - 100);
                }
                c.lineTo(w, h - 100);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Small hut on hill (safe)
                c.fillStyle = '#6B8E23';
                c.beginPath();
                c.ellipse(w - 100, h - 110, 60, 30, 0, Math.PI, 0);
                c.fill();
                c.fillStyle = '#DEB887';
                c.beginPath();
                c.arc(w - 100, h - 120, 25, Math.PI, 0);
                c.fill();
                
                // Worried person looking at water
                this.drawCartoonPerson(c, w - 100, h - 150, 1, -1);
                
                // Rain
                c.strokeStyle = 'rgba(200, 200, 255, 0.5)';
                c.lineWidth = 1;
                for(let i = 0; i < 30; i++) {
                    let rx = Math.random() * w;
                    let ry = Math.random() * (h - 100);
                    c.beginPath();
                    c.moveTo(rx, ry);
                    c.lineTo(rx - 5, ry + 15);
                    c.stroke();
                }
            },
            
            drawBerryScene(c, w, h) {
                // Forest scene
                c.fillStyle = '#228B22';
                c.fillRect(0, 0, w, h);
                
                // Lighter ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Berry bush
                c.fillStyle = '#2E7D32';
                c.beginPath();
                c.arc(w/2 - 50, h - 80, 50, 0, Math.PI*2);
                c.fill();
                
                // Berries (red and juicy)
                c.fillStyle = '#DC143C';
                for(let i = 0; i < 12; i++) {
                    let bx = w/2 - 50 + (Math.random() - 0.5) * 70;
                    let by = h - 80 + (Math.random() - 0.5) * 50;
                    c.beginPath();
                    c.arc(bx, by, 6, 0, Math.PI*2);
                    c.fill();
                    // Shine
                    c.fillStyle = 'rgba(255,255,255,0.5)';
                    c.beginPath();
                    c.arc(bx - 2, by - 2, 2, 0, Math.PI*2);
                    c.fill();
                    c.fillStyle = '#DC143C';
                }
                
                // Hungry person reaching
                this.drawCartoonPerson(c, w/2 + 60, h - 80, 1.2, -1);
                // Reaching arm
                c.strokeStyle = '#E8C4A0';
                c.lineWidth = 8;
                c.beginPath();
                c.moveTo(w/2 + 45, h - 80);
                c.lineTo(w/2, h - 70);
                c.stroke();
                
                // Drool? Maybe just a happy expression
            },
            
            drawDefaultScene(c, w, h) {
                // Generic stone age scene
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                this.drawCartoonPerson(c, w/2, h - 80, 1.3, 1);
            },
            switchLog(type) {
                this.currentLogView = type;
                let playerBtn = document.getElementById('btn-player-log');
                let techBtn = document.getElementById('btn-technical-log');
                
                if(type === 'player') {
                    playerBtn.style.background = '#4CAF50';
                    playerBtn.style.fontWeight = 'bold';
                    techBtn.style.background = '#333';
                    techBtn.style.fontWeight = 'normal';
                } else {
                    playerBtn.style.background = '#333';
                    playerBtn.style.fontWeight = 'normal';
                    techBtn.style.background = '#4CAF50';
                    techBtn.style.fontWeight = 'bold';
                }
                
                this.updateLogDisplay();
            },
            updateLogDisplay() {
                let content = document.getElementById('log-content');
                if(this.currentLogView === 'player') {
                    if(!Game.playerLog || Game.playerLog.length === 0) {
                        content.innerText = 'No player events logged yet.';
                    } else {
                        content.innerText = Game.playerLog.join('\n');
                    }
                } else {
                    if(!Game.technicalLog || Game.technicalLog.length === 0) {
                        content.innerText = 'No technical events logged yet.';
                    } else {
                        content.innerText = Game.technicalLog.join('\n');
                    }
                }
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
            },
            copyLog() {
                let content = document.getElementById('log-content');
                let text = content.innerText;
                
                navigator.clipboard.writeText(text).then(() => {
                    this.toast('üìã Log copied to clipboard!');
                }).catch(err => {
                    // Fallback for older browsers
                    let textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        this.toast('üìã Log copied to clipboard!');
                    } catch(err) {
                        this.toast('‚ùå Failed to copy log', true);
                    }
                    document.body.removeChild(textarea);
                });
            },
            showLog() {
                this.updateLogDisplay();
                document.getElementById('log-modal').style.display = 'flex';
            },
            hideLog() {
                document.getElementById('log-modal').style.display = 'none';
            },
            reset() {
                try {
                    console.log('Resetting game...');
                    // Set camera and tool
                    this.cam = { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM };
                    this.tool = 'PAN';
                    // Reset progression
                    PROGRESSION.reset();
                    // Reset game state
                    if (typeof Game === 'object') {
                        Game.gameState = 'WANDER';
                        Game.simcityMode = false;
                        Game.gatheringMultiplier = 1.0;
                        Game.age = 0;
                        Game.pop = 4;
                        Game.food = 0;
                        Game.wood = 0;
                        Game.metal = 0;
                        Game.stone = 0;
                        Game.res = 0;
                        Game.year = 0;
                        Game.nomadsFound = 0;
                        Game.totalFoodCollected = 0;
                        Game.housingCap = 0;
                        Game.blds = [];
                        Game.animals = [];
                        Game.pathQueue = [];
                        Game.player = null;
                        Game.inventory = { food: 0, wood: 0, metal: 0, stone: 0, capacity: CFG.INVENTORY.BACKPACK_BASE };
                        Game.pocket = { metal: 0, stone: 0 };
                    }
                    // Re-initialize game
                    Game.init(Math.floor(Math.random() * 999999));
                    // Hide all city building buttons (with null checks)
                    const hideElement = (id) => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = 'none';
                    };
                    const showElement = (id, display = 'inline-block') => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = display;
                    };
                    hideElement('t-res');
                    hideElement('t-com');
                    hideElement('t-ind');
                    hideElement('t-road');
                    hideElement('t-well');
                    hideElement('t-chief');
                    hideElement('t-basket');
                    hideElement('t-pottery');
                    hideElement('t-granary');
                    hideElement('t-palace');
                    hideElement('t-demolish');
                    hideElement('sep1');
                    hideElement('sep2');
                    hideElement('btn-turn');
                    hideElement('btn-view');
                    hideElement('t-bull');
                    hideElement('stat-funds');
                    hideElement('stat-water');
                    hideElement('stat-nomad');
                    hideElement('stat-year');
                    hideElement('stat-workforce');
                    hideElement('cam-up');
                    hideElement('cam-down');
                    hideElement('cam-left');
                    hideElement('cam-right');
                    hideElement('building-menu-panel');
                    // RCI meters always visible now
                    // Show wander mode buttons
                    showElement('btn-settle');
                    this.updateUI();
                    console.log('Game reset complete!');
                } catch(err) {
                    console.error('Reset error:', err);
                    // Force page reload as fallback
                    location.reload();
                }
            },
            
            showStatsMenu() {
                try {
                    this.updateStatsMenu();
                    let menu = document.getElementById('stats-menu');
                    let overlay = document.getElementById('stats-overlay');
                    if(menu && overlay) {
                        menu.style.display = 'block';
                        overlay.style.display = 'block';
                    } else {
                        console.error('Stats menu elements not found!', {menu, overlay});
                        this.toast('‚ùå Stats menu not available', true);
                    }
                } catch(e) {
                    console.error('Error showing stats menu:', e);
                    this.toast('‚ùå Error opening stats', true);
                }
            },
            
            hideStatsMenu() {
                document.getElementById('stats-menu').style.display = 'none';
                document.getElementById('stats-overlay').style.display = 'none';
            },
            
            updateStatsMenu() {
                let html = '';
                
                // Time & Progress Stats
                html += '<div style="margin-bottom:10px;"><strong style="color:#81C784;">‚è±Ô∏è Progress</strong></div>';
                html += `<div>Year: ${Game.year || 0}</div>`;
                html += `<div>Turns Played: ${Game.turn || 0}</div>`;
                html += `<div>Game Mode: ${Game.gameState}</div>`;
                
                // Population Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#FF7043;">üë• Population</strong></div>';
                    html += `<div>Total Population: ${this.formatNumber(Game.pop)}</div>`;
                    html += `<div>Population Capacity: ${this.formatNumber(Game.popCap)}</div>`;
                    
                    let resBuildings = Game.blds.filter(b => b.t === 'RES');
                    let avgLevel = resBuildings.length > 0 ? (resBuildings.reduce((sum, b) => sum + b.lvl, 0) / resBuildings.length).toFixed(1) : 0;
                    html += `<div>Residential Buildings: ${resBuildings.length}</div>`;
                    html += `<div>Average Res Level: ${avgLevel}</div>`;
                }
                
                // Resource Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#4CAF50;">üåæ Resources</strong></div>';
                html += `<div>Food Collected: ${this.formatNumber(Game.totalFoodCollected)}</div>`;
                if(Game.gameState === 'WANDER') {
                    html += `<div>Nomads Found: ${Game.nomadsFound || 0}</div>`;
                    html += `<div>Inventory Used: ${Math.floor((Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone))}/${Game.inventory.capacity}</div>`;
                }
                
                // Building Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#2196F3;">üèóÔ∏è Buildings</strong></div>';
                    let resCount = Game.blds.filter(b => b.t === 'RES').length;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                    
                    html += `<div>Residential: ${resCount}</div>`;
                    html += `<div>Commercial: ${comCount}</div>`;
                    html += `<div>Industrial: ${indCount}</div>`;
                    html += `<div>Wells: ${wellCount}</div>`;
                    html += `<div>Total Buildings: ${Game.blds.length}</div>`;
                }
                
                // Unlocks Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#9C27B0;">üîì Progress</strong></div>';
                html += `<div>Unlocked Res Levels: ${PROGRESSION.unlockedLevels.length}</div>`;
                html += `<div>Highest Unlocked: Level ${Math.max(...PROGRESSION.unlockedLevels, 0)}</div>`;
                
                document.getElementById('stats-content').innerHTML = html;
            },
            saveMap() {
                let saveData = {
                    version: '28.0',
                    game: {
                        tiles: Game.tiles,
                        blds: Game.blds,
                        res: Game.res,
                        food: Game.food,
                        water: Game.water,
                        pop: Game.pop,
                        year: Game.year,
                        age: Game.age,
                        player: Game.player,
                        wolves: Game.wolves,
                        nomadsFound: Game.nomadsFound
                    },
                    progression: {
                        stage: PROGRESSION.stage,
                        nomadsFound: PROGRESSION.nomadsFound,
                        settlementYear: PROGRESSION.settlementYear
                    },
                    camera: {
                        x: this.cam.x,
                        y: this.cam.y,
                        z: this.cam.z
                    }
                };
                let d = JSON.stringify(saveData);
                let blob = new Blob([d], {type: 'application/json'});
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a'); a.href = url; a.download = 'citgame_save.json'; a.click();
                this.toast('Game Saved!');
            },
            loadMap() { document.getElementById('file-input').click(); },
            
            zoomIn() {
                this.cam.z = Math.min(CFG.ZOOM.MAX, this.cam.z * CFG.ZOOM.STEP);
            },
            
            zoomOut() {
                this.cam.z = Math.max(CFG.ZOOM.MIN, this.cam.z / CFG.ZOOM.STEP);
            },
            
            moveCameraUp() {
                this.cam.y -= CFG.TILE * 5;
            },
            
            moveCameraDown() {
                this.cam.y += CFG.TILE * 5;
            },
            
            moveCameraLeft() {
                this.cam.x -= CFG.TILE * 5;
            },
            
            moveCameraRight() {
                this.cam.x += CFG.TILE * 5;
            },
            
            showSettlementUI() {
                // Show building tools (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-road'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-well'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-res'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-com'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep1'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-funds'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-water'); if(el) el.style.display = 'flex';
                el = document.getElementById('btn-turn'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-year'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-nomad'); if(el) el.style.display = 'flex';
                console.log('Settlement UI shown - Pass Turn button should be visible');
                this.updateUI();
            },
            
            showIndustrialUI() {
                // Enable Industrial/Hunting Ground button (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-ind'); 
                if(el) { el.style.display = 'inline-block'; el.disabled = false; el.title = 'Build hunting ground'; }
                el = document.getElementById('t-basket'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-pottery'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-granary'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-palace'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-chief'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-demolish'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep2'); if(el) el.style.display = 'inline-block';
                console.log('Industrial UI shown - Industrial button should be visible');
                this.updateUI();
            },
            
                showSimCityUI() {
                // Enable all storage and special buildings (with null checks)
                let btnChief = document.getElementById('t-chief');
                if (btnChief) {
                    btnChief.disabled = false;
                    btnChief.title = "Chief's Hut (10,000 food)";
                }
                
                let btnBasket = document.getElementById('t-basket');
                if (btnBasket) {
                    btnBasket.disabled = false;
                    btnBasket.title = 'Basket (500 food) - +25 storage';
                }
                
                let btnPottery = document.getElementById('t-pottery');
                if (btnPottery) {
                    btnPottery.disabled = false;
                    btnPottery.title = 'Pottery (5,000 food) - +100 storage';
                }
                
                let btnGranary = document.getElementById('t-granary');
                if (btnGranary) {
                    btnGranary.disabled = false;
                    btnGranary.title = 'Granary (50,000 food) - +500 storage';
                }
                
                let btnPalace = document.getElementById('t-palace');
                if (btnPalace) {
                    btnPalace.disabled = false;
                    btnPalace.title = 'Palace (250,000 food) - +2,500 storage';
                }
                
                // Show all building tools when SimCity mode unlocks
                let elem;
                elem = document.getElementById('t-res'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-com'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-ind'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-chief'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-road'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-well'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-bull'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep1'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep2'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('stat-funds'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-water'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-year'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('btn-view'); if (elem) elem.style.display = 'inline-block';
                
                // Update button texts for SimCity mode
                let tRes = document.getElementById('t-res'); if (tRes) tRes.innerHTML = 'üè† Residence ($50)';
                let tCom = document.getElementById('t-com'); if (tCom) tCom.innerHTML = 'üè¢ Commercial ($75)';
                let tInd = document.getElementById('t-ind'); if (tInd) tInd.innerHTML = 'üè≠ Industrial ($500)';
                
                this.updateUI();
            }
        };

        // Game Over overlay helpers - Newspaper Article Style
        Controller.showGameOver = function(reason) {
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // STOP ALL AI SYSTEMS IMMEDIATELY - Prevents death screen hopping!
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            Game.aiEnabled = false;
            if(typeof AI !== 'undefined' && AI.enabled) {
                AI.enabled = false;
            }
            if(typeof BlueprintAI !== 'undefined') {
                BlueprintAI.stopWatching();
                BlueprintAI.enabled = false;
            }
            if(typeof QLearningAI !== 'undefined') {
                if(QLearningAI.isTraining) QLearningAI.stopTraining();
                if(QLearningAI.isWatching) QLearningAI.stopWatching();
            }
            // Set game state to prevent any further actions
            Game.gameOver = true;
            
            var panel = document.getElementById('gameover-screen');
            var dateEl = document.getElementById('newspaper-date');
            var headline = document.getElementById('newspaper-headline');
            var subheadline = document.getElementById('newspaper-subheadline');
            var body = document.getElementById('newspaper-body');
            var stats = document.getElementById('newspaper-stats');
            
            // Get today's date formatted
            var today = new Date();
            var months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            var dateStr = months[today.getMonth()] + ' ' + today.getDate() + ', ' + today.getFullYear();
            if(dateEl) dateEl.textContent = dateStr;
            
            // Gather game state - use peakPop for stats since current pop is often 0 at game over
            var pop = Game.peakPop || Game.pop || 0;
            var food = Math.floor(Game.food || (Game.inventory ? Game.inventory.food : 0) || 0);
            var wood = Math.floor(Game.wood || (Game.inventory ? Game.inventory.wood : 0) || 0);
            var gameState = Game.gameState || 'WANDER';
            var year = Game.year || 0;
            
            // Check if player ever established a settlement (had buildings beyond starter or high population)
            var hadSettlement = (Game.blds && Game.blds.length > 0) || pop > 10 || gameState === 'CITY';
            
            // Level 0 (WANDER) - Archaeological discovery article (only if never settled)
            if(!hadSettlement || reason === 'HUNTING') {
                var fossilCount = Math.max(1, pop);
                var siteAge = '2.' + Math.floor(Math.random()*9) + ' million';
                // Vary headlines
                var headlines = [
                    'Ancient Hominid Remains Discovered in Remote Valley',
                    'Fossilized Hunter-Gatherers Unearthed at Excavation Site',
                    'Pre-Historic Human Ancestors Found After ' + siteAge + ' Years',
                    'Archaeological Team Uncovers Early Human Settlement Attempt',
                    'Nomadic Tribe Fossils Reveal Harsh Prehistoric Reality'
                ];
                // Vary based on population
                var popDesc;
                if(fossilCount === 1) popDesc = 'a solitary individual';
                else if(fossilCount <= 3) popDesc = 'a small family group of ' + fossilCount;
                else if(fossilCount <= 10) popDesc = 'a band of ' + fossilCount + ' individuals';
                else if(fossilCount <= 50) popDesc = 'a tribe of ' + fossilCount + ' members';
                else popDesc = 'a large clan numbering ' + fossilCount + ' individuals';
                // Food context
                var foodContext;
                if(food <= 0) foodContext = 'with no food stores remaining, suggesting starvation';
                else if(food < 20) foodContext = 'with only ' + food + ' units of preserved food nearby‚Äîbarely enough for survival';
                else if(food < 100) foodContext = 'alongside ' + food + ' units of stored provisions';
                else foodContext = 'with substantial food reserves of ' + food + ' units, indicating capable foragers';
                // Wood/tools context
                var woodContext;
                if(wood <= 0) woodContext = 'No wooden implements were recovered';
                else if(wood < 10) woodContext = 'A few crude wooden tools (' + wood + ' pieces) were found';
                else if(wood < 50) woodContext = 'Evidence of ' + wood + ' wooden implements suggests basic tool use';
                else woodContext = 'An impressive cache of ' + wood + ' wooden items indicates advanced craftsmanship';
                // Death cause context
                var deathCause;
                if(reason === 'HUNTING') {
                    deathCause = 'Skeletal trauma patterns suggest the group perished during a hunting expedition gone wrong. Large animal bones nearby indicate a dangerous prey encounter.';
                } else if(reason === 'THIRST') {
                    deathCause = 'Analysis of the bone structure reveals severe dehydration. The group appears to have wandered too far from water sources during a prolonged drought, unable to find rivers or lakes in time.';
                } else if(food <= 0) {
                    deathCause = 'The absence of food remains and evidence of malnutrition in the bones suggests this group succumbed to starvation during a harsh season.';
                } else {
                    deathCause = 'The circumstances of their demise remain unclear, though the harsh environment of the Pleistocene era claimed countless such groups.';
                }
                // Professor names for article quote
                var professors = [
                    'Sarah Chen', 'Michael Oduya', 'Elena Vasquez', 'James Thornton',
                    'Fatima Al-Hassan', 'Robert Kimura', 'Catherine Dubois', 'Henrik Larsson',
                    'Priya Nair', 'Luca Romano', 'Ava M√ºller', 'Santiago Perez',
                    'Yara Haddad', 'Wei Zhang', 'Nina Petrova', 'Omar Farouk',
                    'Isabella Rossi', 'Jonas Berg', 'Maya Singh', 'Lucas Silva'
                ];
                var prof = professors[Math.floor(Math.random()*professors.length)];
                
                // Draw fossil illustration
                var canvas = document.getElementById('fossil-illustration');
                if(canvas && canvas.getContext) {
                    var ctx = canvas.getContext('2d');
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    
                    // Background dirt/sediment texture
                    ctx.fillStyle = '#D4C4A8';
                    ctx.fillRect(0,0,280,140);
                    for(var i=0; i<50; i++) {
                        ctx.fillStyle = ['#C9B896','#BFA97E','#E0D4BC','#A89878'][Math.floor(Math.random()*4)];
                        ctx.beginPath();
                        ctx.arc(Math.random()*280, Math.random()*140, Math.random()*8+2, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Randomize which bones to show (20+ variations)
                    var variant = Math.floor(Math.random()*20);
                    var boneColor = '#F5F0E0';
                    var boneShade = '#D8D0BC';
                    var crackColor = '#A09080';
                    
                    // Draw partial skull (most variants)
                    if(variant !== 5 && variant !== 12) {
                        var skullX = 40 + (variant % 3) * 10;
                        var skullY = 50 + (variant % 2) * 15;
                        // Skull dome
                        ctx.beginPath();
                        ctx.ellipse(skullX, skullY, 28, 22, 0.2, 0, Math.PI * 1.8);
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Eye socket
                        ctx.beginPath();
                        ctx.ellipse(skullX + 8, skullY + 8, 7, 9, 0.1, 0, 2*Math.PI);
                        ctx.fillStyle = '#B0A090';
                        ctx.fill();
                        // Cracks
                        ctx.strokeStyle = crackColor;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(skullX - 10, skullY - 5);
                        ctx.lineTo(skullX + 5, skullY + 3);
                        ctx.lineTo(skullX + 2, skullY + 15);
                        ctx.stroke();
                    }
                    
                    // Draw spine/vertebrae
                    if(variant % 3 !== 2) {
                        var spineX = 100 + (variant % 4) * 8;
                        for(var v = 0; v < 5 + (variant % 3); v++) {
                            ctx.beginPath();
                            ctx.ellipse(spineX + v * 14, 75 + Math.sin(v)*5, 8, 6, 0.3, 0, 2*Math.PI);
                            ctx.fillStyle = boneColor;
                            ctx.fill();
                            ctx.strokeStyle = boneShade;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Draw ribs
                    if(variant % 4 !== 3) {
                        var ribX = 120 + (variant % 3) * 15;
                        var ribY = 35;
                        ctx.strokeStyle = boneColor;
                        ctx.lineWidth = 4;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw femur/leg bone
                    if(variant % 2 === 0) {
                        var femurX = 200 + (variant % 5) * 8;
                        var femurY = 30 + (variant % 3) * 10;
                        ctx.save();
                        ctx.translate(femurX, femurY);
                        ctx.rotate(0.4 + (variant % 4) * 0.2);
                        // Shaft
                        ctx.fillStyle = boneColor;
                        ctx.fillRect(-5, 0, 10, 70);
                        // Joint ends
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 12, 10, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(0, 70, 10, 8, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(-5, 0, 10, 70);
                        ctx.restore();
                    }
                    
                    // Draw hand bones (scattered)
                    if(variant > 7) {
                        var handX = 230 + (variant % 4) * 10;
                        var handY = 90 - (variant % 3) * 15;
                        for(var f = 0; f < 4; f++) {
                            ctx.fillStyle = boneColor;
                            ctx.save();
                            ctx.translate(handX + f * 8, handY);
                            ctx.rotate(-0.2 + f * 0.15);
                            ctx.fillRect(-2, 0, 4, 18);
                            ctx.beginPath();
                            ctx.arc(0, 0, 4, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    
                    // Draw pelvis fragment
                    if(variant % 5 === 0 || variant > 15) {
                        var pelvisX = 180;
                        var pelvisY = 100;
                        ctx.beginPath();
                        ctx.moveTo(pelvisX, pelvisY);
                        ctx.quadraticCurveTo(pelvisX + 30, pelvisY - 20, pelvisX + 50, pelvisY + 5);
                        ctx.quadraticCurveTo(pelvisX + 35, pelvisY + 15, pelvisX + 10, pelvisY + 10);
                        ctx.closePath();
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.stroke();
                    }
                    
                    // Add some scattered small bone fragments
                    for(var b = 0; b < 3 + (variant % 4); b++) {
                        ctx.fillStyle = boneColor;
                        ctx.beginPath();
                        var fx = 50 + Math.random() * 200;
                        var fy = 100 + Math.random() * 30;
                        ctx.ellipse(fx, fy, 4 + Math.random()*6, 3 + Math.random()*4, Math.random()*Math.PI, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Caption label
                    ctx.fillStyle = '#443322';
                    ctx.font = 'italic 10px Georgia';
                    ctx.fillText('Fig. 1: Excavation site photograph', 10, 132);
                }
                if(headline) headline.textContent = headlines[Math.floor(Math.random()*headlines.length)];
                if(subheadline) subheadline.textContent = 'Researchers document ' + popDesc + ' who never established permanent settlement';
                if(body) body.innerHTML = '<p><strong>EAST AFRICAN RIFT VALLEY</strong> ‚Äî An international team of paleoanthropologists has announced the discovery of ' + popDesc + ' dating back approximately ' + siteAge + ' years.</p>' +
                    '<p>The remains were found ' + foodContext + '. ' + woodContext + ', providing valuable insight into early human material culture.</p>' +
                    '<p>"These ancestors never made the crucial transition to permanent settlement," noted Professor ' + prof + ', lead researcher on the excavation. "They represent the countless groups who wandered but never found the right conditions to establish lasting communities."</p>' +
                    '<p>' + deathCause + '</p>' +
                    '<p>This discovery adds to our understanding of the tremendous challenges faced by early <strong>hominids</strong>, where survival was never guaranteed and most lineages ended without descendants.</p>';
                if(stats) stats.innerHTML = '<strong>üìã EXCAVATION DATA:</strong><br>' +
                    '‚Ä¢ Fossils recovered: ' + fossilCount + '<br>' +
                    '‚Ä¢ Food remains: ' + food + ' units<br>' +
                    '‚Ä¢ Wooden artifacts: ' + wood + ' pieces<br>' +
                    '‚Ä¢ Site age: ~' + siteAge + ' years<br>' +
                    '‚Ä¢ Settlement status: <span style="color:#8B0000;">Never established</span>';
            }
            // Level 1+ (CITY) - Historical collapse article
            else {
                // Count buildings by type AND level
                var resBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='RES';}) : [];
                var comBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='COM';}) : [];
                var indBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='IND';}) : [];
                var wellCount = Game.blds ? Game.blds.filter(function(b){return b.t==='WELL';}).length : 0;
                var roadCount = Game.blds ? Game.blds.filter(function(b){return b.t==='ROAD';}).length : 0;
                
                var resCount = resBlds.length;
                var comCount = comBlds.length;
                var indCount = indBlds.length;
                var totalZones = resCount + comCount + indCount;
                
                // Get descriptive names for building types
                var getResDescription = function(blds) {
                    if(blds.length === 0) return 'no residential structures';
                    // Most buildings will be level 1 (Pit Class) early game
                    var names = [];
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    if(lvl1 > 0) names.push(lvl1 + ' Pit dwelling' + (lvl1 > 1 ? 's' : '') + ' (simple straw-lined earth pits where families huddled for warmth)');
                    if(lvl2 > 0) names.push(lvl2 + ' Grubenh√§user (semi-subterranean pit houses with basic roofing)');
                    return names.join(', ') || blds.length + ' residential structures';
                };
                
                var getComDescription = function(blds) {
                    if(blds.length === 0) return 'no commercial areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var lvl3 = blds.filter(function(b){ return (b.level || 1) === 3; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Pebble Trade Fire' + (lvl1 > 1 ? 's' : '') + ' (primitive trade spots where pebbles were exchanged)');
                    if(lvl2 > 0) names.push(lvl2 + ' Squirrel Trade Camp' + (lvl2 > 1 ? 's' : '') + ' (fur trading camps with squirrel pelts)');
                    if(lvl3 > 0) names.push(lvl3 + ' Fire Meet Camp' + (lvl3 > 1 ? 's' : '') + ' (communal gathering places for fire meetings)');
                    return names.join(', ') || blds.length + ' commercial areas';
                };
                
                var getIndDescription = function(blds) {
                    if(blds.length === 0) return 'no food production areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : '') + ' (designated areas where hunters tracked and trapped wild game)');
                    if(lvl2 > 0) names.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : '') + ' (deep pits dug to trap larger prey)');
                    return names.join(', ') || blds.length + ' hunting areas';
                };
                
                // Short versions for stats
                var getResShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Pit' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Grubenhaus' + (lvl2 > 1 ? 'er' : ''));
                    return parts.join(', ');
                };
                
                var getComShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var lvl3 = blds.filter(function(b){ return (b.level || 1) === 3; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Pebble Fire' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Squirrel Camp' + (lvl2 > 1 ? 's' : ''));
                    if(lvl3 > 0) parts.push(lvl3 + ' Fire Meet' + (lvl3 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                var getIndShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                // Water needs calculation (1 well per 100 population)
                var wellsNeeded = Math.max(1, Math.ceil(pop / 100));
                
                // Settlement size description
                var sizeDesc;
                if(pop <= 20) sizeDesc = 'a tiny hamlet';
                else if(pop <= 100) sizeDesc = 'a small village';
                else if(pop <= 500) sizeDesc = 'a growing settlement';
                else if(pop <= 2000) sizeDesc = 'a thriving community';
                else sizeDesc = 'a substantial town';
                
                // Failure analysis
                var failureReason;
                if(reason === 'NO_WATER') {
                    failureReason = 'Skeletal analysis reveals catastrophic dehydration as the primary cause of death. The settlement existed for over two years without any permanent water infrastructure‚Äîa fatal oversight. Bone analysis shows progressive signs of water stress, malnutrition, and ultimately mass mortality during what appears to have been a severe drought season.';
                } else if(food <= 0) {
                    failureReason = 'Archaeological evidence strongly suggests famine as the primary cause of collapse. Grain stores were found completely empty, and skeletal remains show signs of severe malnutrition.';
                } else if(wellCount === 0 && pop > 50) {
                    failureReason = 'The absence of any water infrastructure proved fatal. Without wells, the growing population could not sustain itself through dry seasons.';
                } else if(indCount === 0 && pop > 30) {
                    failureReason = 'No hunting grounds or food production facilities were established. The settlement relied entirely on foraged food, an unsustainable strategy for a permanent community.';
                } else {
                    failureReason = 'Poor resource management and inadequate planning appear to have doomed this early settlement. Early humans who succeeded were those who learned to think ahead.';
                }
                
                var headlines2 = [
                    'Ancient Settlement Collapse Reveals Harsh Lessons of Early Civilization',
                    'Failed Neolithic Village Discovered: "They Didn\'t Plan Ahead"',
                    'Archaeologists Uncover Tragic End of ' + sizeDesc.charAt(0).toUpperCase() + sizeDesc.slice(1),
                    'Early Human Settlement Found Abandoned After Apparent Collapse',
                    '"Planning Was Everything": Ruins Tell Story of Prehistoric Failure'
                ];
                
                if(reason === 'NO_WATER') {
                    headlines2 = [
                        'Mass Dehydration Wiped Out Ancient Settlement, Study Confirms',
                        'No Wells, No Water, No Survivors: Prehistoric Village\'s Fatal Flaw',
                        'Settlement Died of Thirst: "Water Was Everything," Say Archaeologists',
                        'Archaeological Evidence Shows Entire Community Perished From Lack of Water',
                        'Two Years Without Wells Proved Fatal for Early Human Settlement'
                    ];
                }
                
                // FLOOD DEATH - New catastrophic ending
                if(reason === 'FLOOD') {
                    var drowned = Game.geology ? Game.geology.populationDrowned || pop : pop;
                    var periodName = Game.geology ? Game.geology.currentPeriodName : 'Unknown Climate Shift';
                    headlines2 = [
                        'Rising Seas Swallowed Ancient Settlement Whole',
                        'Climate Catastrophe: Entire Village Lost to Flooding',
                        '"The Waters Came Too Fast": Flood Erased Early Civilization',
                        'Geological Shift Drowned Prehistoric Community',
                        periodName + ' Floods Claimed Settlement Without Warning'
                    ];
                    failureReason = 'Geological records indicate a catastrophic flooding event during the ' + periodName + '. Rising sea levels, driven by melting glaciers or tectonic shifts, overwhelmed the low-lying settlement. ' + drowned + ' inhabitants perished as waters rose faster than they could escape. The lesson for future settlements: always build on high ground.';
                }
                
                if(headline) headline.textContent = headlines2[Math.floor(Math.random()*headlines2.length)];
                if(subheadline) subheadline.textContent = 'Excavation of ' + sizeDesc + ' (' + pop + ' inhabitants) shows why early humans needed foresight to survive';
                
                // Build descriptive body text
                var resDesc = getResDescription(resBlds);
                var comDesc = getComDescription(comBlds);
                var indDesc = getIndDescription(indBlds);
                
                if(body) body.innerHTML = '<p><strong>FERTILE CRESCENT REGION</strong> ‚Äî Researchers have completed their analysis of ' + sizeDesc + ' that housed approximately ' + pop + ' people before its sudden collapse in Year ' + year + ' of the settlement\'s existence.</p>' +
                    '<p>The excavation revealed ' + resDesc + '. ' + (comCount > 0 ? 'For trade and social gatherings, the community had established ' + comDesc + '. ' : 'No evidence of organized trade or social gathering spots was found. ') + (indCount > 0 ? 'Food was procured through ' + indDesc + '.' : 'Remarkably, no organized food production was ever established‚Äîthe settlement relied entirely on opportunistic foraging.') + '</p>' +
                    '<p>' + (wellCount > 0 ? 'Water infrastructure consisted of ' + wellCount + ' well' + (wellCount > 1 ? 's' : '') + '. A settlement of this size required ' + wellsNeeded + ' functioning wells.' : 'Notably, no permanent water infrastructure was ever constructed‚Äîa critical oversight that may have contributed to the settlement\'s demise.') + '</p>' +
                    '<p>' + failureReason + '</p>' +
                    '<p>"The difference between the groups that survived and those that perished often came down to planning," explained Dr. ' + ['Henrik Larsson','Fatima Al-Hassan','Robert Kimura','Catherine Dubois'][Math.floor(Math.random()*4)] + '. "Those who thought seasons ahead, who built reserves, who prepared for hardship‚Äîthey became our ancestors. The others... became archaeology."</p>' +
                    '<p>This settlement joins thousands of similar failed attempts across the prehistoric world, each a testament to the razor-thin margin between survival and extinction that defined early human existence.</p>';
                    
                if(stats) stats.innerHTML = '<strong>üìã SETTLEMENT SURVEY:</strong><br>' +
                    '‚Ä¢ Peak population: ' + pop + '<br>' +
                    '‚Ä¢ Years survived: ' + year + '<br>' +
                    '‚Ä¢ Dwellings: ' + (getResShort(resBlds) || 'None') + '<br>' +
                    '‚Ä¢ Trade spots: ' + (getComShort(comBlds) || 'None') + '<br>' +
                    '‚Ä¢ Food production: ' + (getIndShort(indBlds) || 'None') + '<br>' +
                    '‚Ä¢ Water wells: ' + wellCount + ' built / ' + wellsNeeded + ' needed<br>' +
                    '‚Ä¢ Food at collapse: ' + food + ' units<br>' +
                    (reason === 'NO_WATER' ? '‚Ä¢ Years without water: ' + (Game.yearsWithoutWell || 2) + '<br>' : '') +
                    (reason === 'FLOOD' ? '‚Ä¢ Sea level: ' + (Game.geology ? Math.floor(Game.geology.currentSeaLevel) : '?') + '/10<br>' : '') +
                    (reason === 'FLOOD' ? '‚Ä¢ Climate period: ' + (Game.geology ? Game.geology.currentPeriodName : 'Unknown') + '<br>' : '') +
                    '‚Ä¢ Verdict: <span style="color:#8B0000;">' + (reason === 'FLOOD' ? 'Death by flooding' : reason === 'NO_WATER' ? 'Death by dehydration' : 'Insufficient planning') + '</span>';
            }
            
            if (panel) panel.style.display = 'flex';
        };

        document.addEventListener('DOMContentLoaded', function() {
            var btn = document.getElementById('btn-newgame');
            if (btn) {
                // Keep the confirmation modal - don't override!
                btn.onclick = function() {
                    window.startNewGame(); // This shows the confirmation modal
                };
            }
            
        });
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PATCH: Integrate Pass Year button updates with Controller lifecycle
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        (function() {
            // Patch window.startNewGame to update Pass Year buttons
            var origStartNewGame = window.startNewGame;
            window.startNewGame = function() {
                if (origStartNewGame) origStartNewGame();
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.updateUI to update Pass Year buttons
            var origUpdateUI = Controller.updateUI;
            Controller.updateUI = function() {
                if (origUpdateUI) origUpdateUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showSettlementUI to update Pass Year buttons
            var origShowSettlementUI = Controller.showSettlementUI;
            Controller.showSettlementUI = function() {
                if (origShowSettlementUI) origShowSettlementUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showCityUI to update Pass Year buttons  
            if (Controller.showCityUI) {
                var origShowCityUI = Controller.showCityUI;
                Controller.showCityUI = function() {
                    if (origShowCityUI) origShowCityUI.call(this);
                    if (typeof updatePassYearButton === 'function') updatePassYearButton();
                };
            }
        })();
        
        document.getElementById('file-input').onchange=e=>{ 
            let r=new FileReader(); 
            r.onload=ev=>{ 
                try {
                    let saveData=JSON.parse(ev.target.result);
                    if(saveData.version && saveData.game) {
                        Object.assign(Game, saveData.game);
                        Object.assign(PROGRESSION, saveData.progression);
                        Controller.cam = saveData.camera;
                        
                        // Restore UI state based on progression
                        if(PROGRESSION.stage >= 1) {
                            Controller.showSettlementUI();
                        }
                        
                        Game.recalc();
                        Controller.updateUI();
                        Controller.toast("Game Loaded!");
                    } else {
                        Controller.toast("Invalid save file!");
                    }
                } catch(err) {
                    Controller.toast("Failed to load!");
                    console.error(err);
                }
            }; 
            r.readAsText(e.target.files[0]); 
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // Q-LEARNING AI - Learns to play the game through reinforcement learning
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        var QLearningAI = {
            // Hyperparameters (TUNED FOR FASTER LEARNING)
            learningRate: 0.25,     // How quickly we update Q-values (was 0.1)
            discountFactor: 0.9,    // How much we value future rewards (was 0.95, lower = focus on immediate)
            explorationRate: 0.8,   // Start with 80% exploration (was 1.0, faster to exploit)
            explorationDecay: 0.98, // Decay exploration each episode (was 0.995, much faster decay)
            minExploration: 0.1,    // Minimum exploration rate (was 0.05, keep some exploration)
            
            // Q-table: state -> action -> value
            qTable: {},
            maxQTableSize: 50000, // Limit Q-table to prevent memory explosion
            
            // Training stats
            episode: 0,
            totalReward: 0,
            episodeRewards: [],
            bestScore: 0,
            gamesPlayed: 0,
            isTraining: false,
            trainingSpeed: 10, // 1 = normal, 10 = fast, 100 = ultra fast (default matches dropdown)
            isResetting: false, // Prevent multiple simultaneous resets
            lastExploredCount: 0,
            
            // === LEARNING ANALYTICS ===
            citiesBuilt: 0,         // Times AI successfully settled
            bestPopulation: 0,      // Highest population reached
            bestSurvivalYears: 0,   // Longest city survival
            balancedCities: 0,      // Cities with all 3 zone types balanced
            smartSettlements: 0,    // Settlements near resources (animals/berries)
            rewardHistory: [],      // Last 20 episode rewards for graph
            episodeStartSnapshotTaken: false,
            episodeStartPop: 0,
            episodeStartRes: 0,
            episodeStartStage: 0,
            episodeStartYear: 0,
            progressMade: false,
            lastExpansionRadius: 0,
            lastQuadrantCount: 0,
            lastStageAwarded: 0,
            lastLevelUnlockAward: 1,
            
            // === CURRICULUM LEARNING ===
            // Phase 1: Learn to survive WANDER (drink water, gather food)
            // Phase 2: Learn to settle successfully
            // Phase 3: Learn to build balanced cities
            learningPhase: 1,       // Current curriculum phase
            phase1Threshold: 10,    // Settle 10 times to move to phase 2
            phase2Threshold: 5,     // Build 5 balanced cities to move to phase 3
            
            // === IMITATION LEARNING (Watch & Learn from Player) ===
            isWatching: false,          // Is AI watching player?
            playerDemonstrations: [],    // Records of player actions
            watchStartState: null,       // State when watching started
            
            // === EXPLORATION TEST MODE ===
            explorationTestMode: false,  // Is exploration test active?
            exploreStats: {
                tilesVisited: new Set(),    // Set of "x,y" strings for visited tiles
                totalTiles: 0,              // Total explorable tiles on map
                resourcesCollected: 0,      // Total resources picked up
                berriesCollected: 0,
                woodCollected: 0,
                nomadsRecruited: 0,
                animalsHunted: 0,
                deaths: 0,                  // Total deaths during test
                totalSteps: 0,              // Steps taken across all runs
                stepsThisRun: 0,            // Steps in current run
                runsCompleted: 0,           // Number of exploration runs
                deathLocations: [],         // Array of {x, y, cause, steps}
                dangerZones: {},            // "x,y" -> death count
                startTime: null
            },
            
            // Actions the AI can take (includes Level 2-6 buildings!)
            actions: [
                'SETTLE', 'WANDER', 
                'BUILD_RES', 'BUILD_RES_L2', 'BUILD_RES_L3', 'BUILD_RES_L4', 'BUILD_RES_L5', 'BUILD_RES_L6',
                'BUILD_WELL', 'PASS_YEAR', 
                'BUILD_IND', 'BUILD_IND_L2', 'BUILD_IND_L3', 'BUILD_IND_L4', 'BUILD_IND_L5', 'BUILD_IND_L6',
                'BUILD_COM', 'BUILD_COM_L2', 'BUILD_COM_L3', 'BUILD_COM_L4', 'BUILD_COM_L5', 'BUILD_COM_L6',
                'BUILD_ROAD', 'WAIT', 'BUILD_CLAN_CHIEF', 'BUILD_DOCK', 'EXCHANGE_GOLD'
            ],
            macroPlaybooks: [
                {
                    id: 'early_twin_res',
                    name: 'Twin Huts Opener',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 }
                    ]
                },
                {
                    id: 'water_buffer',
                    name: 'Water Buffer Start',
                    steps: [
                        { action: 'BUILD_WELL' },
                        { action: 'BUILD_RES', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2, requirePop: 12 },
                        { action: 'BUILD_COM', waitYears: 1, minYear: 3, requireDemand: 'C' }
                    ]
                },
                {
                    id: 'wood_stack',
                    name: 'Wood Stockpile First',
                    steps: [
                        { action: 'PASS_YEAR', waitYears: 1 },
                        { action: 'PASS_YEAR', waitYears: 1 },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 2 }
                    ]
                },
                {
                    id: 'double_well_after50',
                    name: 'Double Wells After 50 Pop',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2, requirePop: 20 },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_COM', waitYears: 1, minYear: 6 }
                    ]
                },
                {
                    id: 'twin_roads_kickoff',
                    name: 'Twin Roads Kickoff',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_COM', waitYears: 1 }
                    ]
                },
                {
                    id: 'demand_cycle',
                    name: 'Demand Cycle Builder',
                    steps: [
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 }
                    ]
                },
                {
                    id: 'homeless_cover',
                    name: 'Homeless Cover Plan',
                    steps: [
                        { action: 'BUILD_RES', requireHousingNearFull: true },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', requireHousingNearFull: true, waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', requireHomeless: 1, waitYears: 2 }
                    ]
                },
                {
                    id: 'worker_gate',
                    name: 'Worker Gatekeeper',
                    steps: [
                        { action: 'BUILD_ROAD', requireWorkerShortage: false },
                        { action: 'BUILD_WELL', requireWorkerShortage: false, waitYears: 1 },
                        { action: 'BUILD_RES', requireWorkerShortage: true, waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_COM', waitYears: 1 }
                    ]
                },
                {
                    id: 'satisfaction_ladder',
                    name: 'Satisfaction Ladder',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 1 },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 2 },
                        { action: 'BUILD_COM', requireDemand: 'C', waitYears: 1 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'food_ratio_guard',
                    name: 'Food Ratio Guard',
                    steps: [
                        { action: 'BUILD_COM', requireFoodPerPop: 5, waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 1 },
                        { action: 'BUILD_COM', requireFoodPerPop: 4, waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'yearly_cycle',
                    name: 'Yearly Cycle Plan',
                    steps: [
                        { action: 'BUILD_RES', minYear: 1 },
                        { action: 'BUILD_ROAD', minYear: 2 },
                        { action: 'BUILD_WELL', minYear: 3 },
                        { action: 'BUILD_RES', minYear: 4 },
                        { action: 'BUILD_COM', minYear: 5 },
                        { action: 'BUILD_ROAD', minYear: 6 }
                    ]
                },
                {
                    id: 'double_res_pulse',
                    name: 'Double Residential Pulse',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_RES', waitYears: 3 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 3 }
                    ]
                },
                {
                    id: 'tutorial_clone',
                    name: 'Tutorial Clone',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'PASS_YEAR', waitYears: 7 },
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_COM' },
                        { action: 'BUILD_ROAD' }
                    ]
                },
                {
                    id: 'builder_merchant_split',
                    name: 'Builder Merchant Split',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_COM', minYear: 8, waitYears: 1 },
                        { action: 'BUILD_COM', minYear: 10, waitYears: 1 }
                    ]
                },
                {
                    id: 'industrial_threshold',
                    name: 'Industrial Threshold',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_COM', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_IND', requirePop: 25, requireFood: 1000, requireWood: 1000, waitYears: 5 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'rain_balance',
                    name: 'Rain Balance',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_COM', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 2, requireNeeds: ['water'] },
                        { action: 'BUILD_DEMAND', waitYears: 1 }
                    ]
                },
                {
                    id: 'panic_flow',
                    name: 'Panic Flow',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 1 }
                    ]
                },
                {
                    id: 'balanced_pairing',
                    name: 'Balanced Pairing',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 1 }
                    ]
                },
                {
                    id: 'road_grid_first',
                    name: 'Road Grid First',
                    steps: [
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_COM', waitYears: 2 }
                    ]
                },
                {
                    id: 'scout_stall',
                    name: 'Scout And Stall',
                    steps: [
                        { action: 'PASS_YEAR', waitYears: 1, maxYear: 2 },
                        { action: 'PASS_YEAR', waitYears: 1, maxYear: 3 },
                        { action: 'BUILD_DEMAND', waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                }
            ],
            activeMacroTactic: null,
            macroStepIndex: 0,
            macroWaitUntilYear: 0,
            macroRotationIndex: 0,
            
            assignMacroTactic: function(advance = false) {
                if(!this.macroPlaybooks || this.macroPlaybooks.length === 0) {
                    this.activeMacroTactic = null;
                    return;
                }
                
                // Initialize tactic stats if needed
                if(!this.tacticStats) this.tacticStats = {};
                for(let pb of this.macroPlaybooks) {
                    if(!this.tacticStats[pb.id]) {
                        this.tacticStats[pb.id] = { attempts: 0, successes: 0, totalYears: 0, maxPop: 0, avgScore: 0 };
                    }
                }
                
                // Smart tactic selection: favor successful tactics, but still explore
                let candidates = this.macroPlaybooks.slice();
                if(Math.random() < 0.7 && this.episode > 10) { // 70% chance to pick strategically after 10 episodes
                    // Sort by success rate + average score
                    candidates.sort((a, b) => {
                        let statsA = this.tacticStats[a.id] || { attempts: 0, avgScore: 0 };
                        let statsB = this.tacticStats[b.id] || { attempts: 0, avgScore: 0 };
                        let scoreA = statsA.attempts > 0 ? (statsA.successes / statsA.attempts * 100 + statsA.avgScore) : 50;
                        let scoreB = statsB.attempts > 0 ? (statsB.successes / statsB.attempts * 100 + statsB.avgScore) : 50;
                        return scoreB - scoreA;
                    });
                    // Pick from top 5 with weighted random
                    let topN = candidates.slice(0, Math.min(5, candidates.length));
                    let weights = topN.map((_, i) => Math.pow(0.6, i));
                    let totalWeight = weights.reduce((a, b) => a + b, 0);
                    let r = Math.random() * totalWeight;
                    let cumulative = 0;
                    for(let i = 0; i < topN.length; i++) {
                        cumulative += weights[i];
                        if(r <= cumulative) {
                            this.activeMacroTactic = topN[i];
                            break;
                        }
                    }
                } else {
                    // Random exploration
                    if(advance || this.macroRotationIndex === undefined) {
                        this.macroRotationIndex = Math.floor(Math.random() * candidates.length);
                    }
                    this.activeMacroTactic = candidates[this.macroRotationIndex];
                }
                
                this.macroStepIndex = 0;
                this.macroWaitUntilYear = 0;
                
                if(this.activeMacroTactic) {
                    this.tacticStats[this.activeMacroTactic.id].attempts++;
                    let stats = this.tacticStats[this.activeMacroTactic.id];
                    let successRate = stats.attempts > 0 ? Math.round(stats.successes / stats.attempts * 100) : 0;
                    this.log(`üìò Tactic: ${this.activeMacroTactic.name} (${successRate}% success, ${stats.attempts} tries)`);
                }
            },

            getMacroAction: function(context) {
                if(!this.activeMacroTactic || !context || Game.gameState !== 'CITY') return null;
                if(this.macroStepIndex >= this.activeMacroTactic.steps.length) return null;
                if(this.macroWaitUntilYear && (Game.year || 0) < this.macroWaitUntilYear) return null;
                let step = this.activeMacroTactic.steps[this.macroStepIndex];
                if(!this.macroConditionsMet(step, context)) return null;
                let resolvedAction = this.resolveMacroAction(step, context);
                if(!resolvedAction) return null;
                if(!this.canAffordMacroAction(resolvedAction, context)) return null;
                this.log(`üìò Macro ${this.activeMacroTactic.name}: ${resolvedAction}`);
                this.macroStepIndex++;
                this.macroWaitUntilYear = (Game.year || 0) + (step.waitYears || 0);
                if(this.macroStepIndex >= this.activeMacroTactic.steps.length) {
                    this.log(`üìó Macro ${this.activeMacroTactic.name} complete.`);
                    this.activeMacroTactic = null;
                }
                return resolvedAction;
            },

            macroConditionsMet: function(step, context) {
                if(!step) return false;
                if(step.minYear !== undefined && context.year < step.minYear) return false;
                if(step.maxYear !== undefined && context.year > step.maxYear) return false;
                if(step.requirePop !== undefined && context.pop < step.requirePop) return false;
                if(step.requireDemand && context.highestDemand !== step.requireDemand) return false;
                if(step.requireNeeds) {
                    for(let need of step.requireNeeds) {
                        if(need === 'water' && !context.needsWater) return false;
                        if(need === 'food' && !context.needsFood) return false;
                        if(need === 'housing' && !context.needsHousing) return false;
                    }
                }
                if(step.requireHousingNearFull && !context.housingNearFull) return false;
                if(step.requireHomeless && context.homeless < step.requireHomeless) return false;
                if(step.requireWorkerShortage === true && !context.workerShortage) return false;
                if(step.requireWorkerShortage === false && context.workerShortage) return false;
                if(step.requireFood && context.food < step.requireFood) return false;
                if(step.requireWood && context.wood < step.requireWood) return false;
                if(step.requireFoodPerPop && (context.pop === 0 || (context.food / Math.max(1, context.pop)) < step.requireFoodPerPop)) return false;
                return true;
            },

            resolveMacroAction: function(step, context) {
                if(!step) return null;
                if(step.action === 'BUILD_DEMAND') {
                    if(context.highestDemand === 'R') return 'BUILD_RES';
                    if(context.highestDemand === 'C') return 'BUILD_COM';
                    return 'BUILD_IND';
                }
                return step.action;
            },

            canAffordMacroAction: function(action, context) {
                switch(action) {
                    case 'BUILD_RES':
                        return context.food >= context.resCost.food && context.wood >= context.resCost.wood;
                    case 'BUILD_COM':
                        return context.food >= context.comCost.food && context.wood >= context.comCost.wood;
                    case 'BUILD_IND':
                        return context.food >= context.indCost.food && context.wood >= context.indCost.wood;
                    case 'BUILD_WELL':
                        return context.food >= context.wellCost;
                    case 'BUILD_ROAD':
                        return context.food >= context.roadCost;
                    case 'PASS_YEAR':
                        return true;
                    default:
                        return true;
                }
            },

            // Get discretized state representation
            getState: function() {
                // Track population in WANDER mode too! AI needs to know nomad count
                if(!Game) return 'WANDER_P0';

                let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                let highestUnlock = 1;
                if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                    highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                }
                let civLevel = Game.civLevel || Game.level || 1;

                let pop = Game.pop || 0;
                let popBucket = Math.min(10, Math.floor(pop / 5)); // 0-10 (tracks 0-50 nomads in groups of 5)
                
                if(Game.gameState === 'WANDER') {
                    // Include food and wood status for settling decisions
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    let foodOK = food >= 100 ? 1 : 0;
                    let woodOK = wood >= 25 ? 1 : 0;
                    return `WANDER_S${stage}_LV${highestUnlock}_P${popBucket}_F${foodOK}_W${woodOK}`;
                }
                
                // CITY mode - detailed state
                let foodBucket = Math.min(5, Math.floor((Game.food || 0) / 100)); // 0-5
                let woodBucket = Math.min(5, Math.floor((Game.wood || 0) / 50)); // 0-5
                let wellCount = Math.min(3, Game.wellCount || 0); // 0-3
                let resCount = Math.min(5, Game.zoneCount || 0); // Use zoneCount for residential
                let indCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0);
                let comCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0);
                let roadCount = Math.min(5, Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0);
                let hasWaterCrisis = (Game.wellCount === 0 && Game.pop > 5) ? 1 : 0;
                let hasFoodCrisis = (Game.food < Game.pop * 2) ? 1 : 0;
                let expansion = this.getCityExpansionStats();
                let expansionBucket = Math.min(9, Math.floor(expansion.radius / 5));
                let roadFrontBucket = Math.min(9, Math.floor(expansion.roadFrontier / 5));
                let quadrantBucket = Math.min(4, expansion.quadrants || 0);

                return `S${stage}LV${highestUnlock}CV${Math.min(9, Math.floor(civLevel))}P${popBucket}F${foodBucket}W${woodBucket}WL${wellCount}R${resCount}I${indCount}C${comCount}RD${roadCount}WC${hasWaterCrisis}FC${hasFoodCrisis}EX${expansionBucket}RF${roadFrontBucket}Q${quadrantBucket}`;
            },

            // Count explored tiles around player (small radius for cheap signal)
            localExploredCount: function(radius = 3) {
                if(!Game || !Game.player || !Game.tiles) return 0;
                let cx = Game.player.x, cy = Game.player.y;
                let count = 0;
                for(let x = cx - radius; x <= cx + radius; x++) {
                    for(let y = cy - radius; y <= cy + radius; y++) {
                        if(x>=0 && y>=0 && x < Game.tiles.length && y < Game.tiles[0].length) {
                            let t = Game.tiles[x][y];
                            if(t && t.explored) count++;
                        }
                    }
                }
                return count;
            },

            getCityExpansionStats: function() {
                if(!Game || !Game.blds || Game.blds.length === 0) {
                    return { radius: 0, roadFrontier: 0, quadrants: 0 };
                }

                let origin = Game.settlementPos || this.aiSettlementPos;
                if(!origin) {
                    if(Game.player) origin = { x: Game.player.x, y: Game.player.y };
                    else {
                        let first = Game.blds[0];
                        origin = { x: (first && first.x) || 0, y: (first && first.y) || 0 };
                    }
                }

                let maxDist = 0;
                let roadFrontier = 0;
                let quadrants = new Set();

                for(let b of Game.blds) {
                    if(b.x === undefined || b.y === undefined) continue;
                    let dx = b.x - origin.x;
                    let dy = b.y - origin.y;
                    let manhattan = Math.abs(dx) + Math.abs(dy);
                    if(manhattan > maxDist) maxDist = manhattan;
                    if(b.t === 'ROAD' && manhattan > roadFrontier) roadFrontier = manhattan;
                    if(manhattan > 0) {
                        let quad;
                        if(dx >= 0 && dy >= 0) quad = 'SE';
                        else if(dx >= 0 && dy < 0) quad = 'NE';
                        else if(dx < 0 && dy >= 0) quad = 'SW';
                        else quad = 'NW';
                        quadrants.add(quad);
                    }
                }

                return { radius: maxDist, roadFrontier, quadrants: quadrants.size };
            },
            
            // Check if player is near water (for settlement)
            checkNearWater: function() {
                if(!Game || !Game.player || !Game.tiles) return false;
                const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                let px = Game.player.x, py = Game.player.y;
                for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                    for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                        let x = px + dx, y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = Game.tiles[x][y];
                            if(tile && (tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP')) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            },
            
            // Find nearest water source for WANDER mode seeking
            findNearestWater: function() {
                if(!Game || !Game.player || !Game.tiles) return null;
                let px = Game.player.x, py = Game.player.y;
                let bestDist = Infinity, bestPos = null;
                for(let radius = 1; radius <= 20; radius++) {
                    for(let dx = -radius; dx <= radius; dx++) {
                        for(let dy = -radius; dy <= radius; dy++) {
                            if(Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
                            let x = px + dx, y = py + dy;
                            if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                let tile = Game.tiles[x][y];
                                if(tile && tile.explored && (tile.type === 'WATER' || tile.type === 'RIVER')) {
                                    let dist = Math.abs(dx) + Math.abs(dy);
                                    if(dist < bestDist) {
                                        bestDist = dist;
                                        bestPos = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    if(bestPos) break;
                }
                return bestPos;
            },
            
            // Track death cause for learning
            recordDeath: function(cause) {
                this.lastDeathCause = cause;
                this.consecutiveDeaths = (this.consecutiveDeaths || 0) + 1;
                this.deathCauses = this.deathCauses || {};
                this.deathCauses[cause] = (this.deathCauses[cause] || 0) + 1;
                
                // Track tactic failure
                if(this.activeMacroTactic && this.tacticStats) {
                    // Don't count as success
                    this.log(`‚ùå Tactic ${this.activeMacroTactic.name} failed: ${cause}`);
                }
            },
            
            // Track successful episode for tactic learning
            recordSuccess: function(pop, year) {
                if(this.activeMacroTactic && this.tacticStats) {
                    let stats = this.tacticStats[this.activeMacroTactic.id];
                    if(stats) {
                        if(year >= 5 && pop >= 10) { // Count as success if survived 5 years with 10+ pop
                            stats.successes++;
                        }
                        stats.totalYears += year;
                        stats.maxPop = Math.max(stats.maxPop, pop);
                        stats.avgScore = stats.attempts > 0 ? 
                            Math.round((stats.totalYears / stats.attempts) * 10 + stats.maxPop) : 0;
                    }
                }
                this.consecutiveDeaths = 0; // Reset streak on good run
            },
            
            // Get population-tier based strategy advice
            getPopTierStrategy: function(pop) {
                // Returns strategic guidance based on city population tier
                if(pop < 10) {
                    return {
                        tier: 'startup',
                        priority: 'survival',
                        waterRatio: 0.15, // water wells per pop
                        comRatio: 0.2,    // commercial per residential
                        indThreshold: 999, // don't build industrial yet
                        roadsPer: 3,      // roads per total buildings
                        expandRate: 0,    // don't expand yet
                        hint: 'Focus on first residential and well'
                    };
                } else if(pop < 25) {
                    return {
                        tier: 'growth',
                        priority: 'population',
                        waterRatio: 0.12,
                        comRatio: 0.25,
                        indThreshold: 200, // can consider industrial
                        roadsPer: 2.5,
                        expandRate: 1,    // expand slowly
                        hint: 'Build residential, add commercial for production'
                    };
                } else if(pop < 50) {
                    return {
                        tier: 'expansion',
                        priority: 'diversity',
                        waterRatio: 0.1,
                        comRatio: 0.33,
                        indThreshold: 100, // should have industrial
                        roadsPer: 2,
                        expandRate: 2,    // expand moderately
                        hint: 'Balance RCI, push road frontier'
                    };
                } else if(pop < 100) {
                    return {
                        tier: 'city',
                        priority: 'efficiency',
                        waterRatio: 0.08,
                        comRatio: 0.4,
                        indThreshold: 50,
                        roadsPer: 1.5,
                        expandRate: 3,    // expand aggressively
                        hint: 'Maximize industrial, expand into new quadrants'
                    };
                } else {
                    return {
                        tier: 'metropolis',
                        priority: 'dominance',
                        waterRatio: 0.06,
                        comRatio: 0.5,
                        indThreshold: 25,
                        roadsPer: 1,
                        expandRate: 5,    // expand very aggressively
                        hint: 'Fill all quadrants, reach Level 3+'
                    };
                }
            },
            
            // Analyze what's blocking progress and suggest fixes
            diagnoseBlocker: function() {
                if(!Game || Game.gameState !== 'CITY') return null;
                
                let pop = Game.pop || 0;
                let food = Game.food || 0;
                let wood = Game.wood || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.blds ? Game.blds.filter(b => b.t === 'RES').length : 0;
                let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                let waterCap = wellCount * 100;
                let housingCap = resCount * 10;
                
                let blockers = [];
                
                // Check water
                if(pop > waterCap * 0.8) {
                    blockers.push({ issue: 'water', severity: pop > waterCap ? 'critical' : 'warning', fix: 'BUILD_WELL' });
                }
                
                // Check housing
                if(pop >= housingCap - 2) {
                    blockers.push({ issue: 'housing', severity: pop >= housingCap ? 'critical' : 'warning', fix: 'BUILD_RES' });
                }
                
                // Check food production
                if(food < pop * 5) {
                    blockers.push({ issue: 'food', severity: food < pop * 2 ? 'critical' : 'warning', fix: 'BUILD_COM' });
                }
                
                // Check wood production
                if(wood < 50 && comCount > 0) {
                    blockers.push({ issue: 'wood', severity: 'warning', fix: 'BUILD_COM' });
                }
                
                // Check industrial readiness
                if(indCount === 0 && pop >= 25 && resCount >= 4 && comCount >= 1) {
                    blockers.push({ issue: 'no-industrial', severity: 'opportunity', fix: 'BUILD_IND' });
                }
                
                // Check expansion
                let expansion = this.getCityExpansionStats();
                if(expansion.quadrants < 2 && pop >= 30) {
                    blockers.push({ issue: 'cramped', severity: 'opportunity', fix: 'BUILD_ROAD' });
                }
                
                return blockers.length > 0 ? blockers : null;
            },
            
            // Get Q-value for state-action pair
            getQ: function(state, action) {
                if(!this.qTable[state]) this.qTable[state] = {};
                if(this.qTable[state][action] === undefined) this.qTable[state][action] = 0;
                return this.qTable[state][action];
            },
            
            // Update Q-value
            updateQ: function(state, action, reward, nextState) {
                let currentQ = this.getQ(state, action);
                let maxNextQ = Math.max(...this.actions.map(a => this.getQ(nextState, a)));
                let newQ = currentQ + this.learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
                
                // Limit Q-table size to prevent memory explosion
                let stateCount = Object.keys(this.qTable).length;
                if(stateCount >= this.maxQTableSize) {
                    // Remove oldest/lowest-value states
                    this.pruneQTable();
                }
                
                if(!this.qTable[state]) this.qTable[state] = {};
                this.qTable[state][action] = newQ;
            },
            
            // Prune Q-table to prevent memory explosion
            pruneQTable: function() {
                let states = Object.keys(this.qTable);
                if(states.length < this.maxQTableSize * 0.9) return;
                
                // Calculate average Q-value per state
                let stateScores = states.map(s => {
                    let actions = this.qTable[s];
                    let values = Object.values(actions);
                    let maxQ = values.length > 0 ? Math.max(...values) : 0;
                    return { state: s, score: maxQ };
                });
                
                // Sort by score (lowest first) and remove bottom 20%
                stateScores.sort((a, b) => a.score - b.score);
                let removeCount = Math.floor(states.length * 0.2);
                for(let i = 0; i < removeCount; i++) {
                    delete this.qTable[stateScores[i].state];
                }
                console.log(`[AI] Pruned Q-table: removed ${removeCount} low-value states`);
            },
            
            // Choose action using epsilon-greedy policy - POPULATION MAXIMIZER
            // NOW PRIORITIZES PLAYBOOKS FROM WATCHING PLAYER!
            chooseAction: function(state) {
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PRIORITY 0: Replay mode - follow best run exactly
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(this.useReplayMode) {
                    let replayAction = this.getReplayAction();
                    if(replayAction) {
                        this.log(`üîÑ Replay: ${replayAction}`);
                        return replayAction;
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PRIORITY 0.5: Check for known failure state - take evasive action
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                let failureCheck = this.isKnownFailureState();
                if(failureCheck && Game.gameState === 'CITY') {
                    this.log(`‚ö†Ô∏è Known failure pattern ${failureCheck.pattern} - taking evasive action`);
                    // If water-related, build well
                    if(failureCheck.pattern.includes('water') || failureCheck.pattern.includes('thirst')) {
                        if(Game.food >= 20) return 'BUILD_WELL';
                    }
                    // If famine, build commercial
                    if(failureCheck.pattern.includes('famine')) {
                        if(Game.food >= 200 && Game.wood >= 200) return 'BUILD_COM';
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // PRIORITY 1: If we have a playbook from watching player, USE IT!
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(this.savedPlaybooks && this.savedPlaybooks.length > 0 && this.usePlaybook !== false) {
                    // Initialize playbook tracking
                    if(this.playbookStep === undefined) this.playbookStep = 0;
                    
                    let playbook = this.savedPlaybooks[0].playbook;
                    
                    if(this.playbookStep < playbook.length) {
                        let step = playbook[this.playbookStep];
                        let currentYear = Game.year || 0;
                        
                        // Wait if timing doesn't match yet
                        if(step.yearsSinceLastBuild > 1 && this.lastAIBuildYear !== undefined) {
                            let yearsWaited = currentYear - this.lastAIBuildYear;
                            if(yearsWaited < step.yearsSinceLastBuild - 1) {
                                return 'PASS_YEAR'; // Wait like player did
                            }
                        }
                        
                        // Execute the recorded action
                        return step.action;
                    }
                }
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // FALLBACK: Original AI behavior
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                
                // 1. WANDER MODE - Gather resources and nomads, then settle near water
                if (Game && Game.gameState === 'WANDER') {
                    const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                    let pop = Game.pop || 0;
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    let thirst = Game.thirst || 100;
                    let thirstCounter = Game.thirstCounter || 0;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL: THIRST SURVIVAL - Check every step if we need water!
                    // Game rule: Must drink every 100 steps or die
                    // AI rule: Start seeking water at 70 steps (thirst=30), URGENT at 85 steps
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Check if near drinkable water right now
                    let nearWater = this.checkNearWater();
                    
                    // URGENT WATER MODE: If thirst is critical (<30), drop everything and find water!
                    if(thirst < 30 || thirstCounter > 70) {
                        this.log(`üö® THIRST CRITICAL! thirst=${thirst} counter=${thirstCounter} - MUST find water!`);
                        
                        // If already near water, just keep wandering (will auto-drink)
                        if(nearWater) {
                            this.log('üíß Near water - drinking!');
                            return 'WANDER'; // Will walk to water and drink
                        }
                        
                        // Force water-seeking mode
                        this.waterSeekMode = true;
                        return 'WANDER'; // executeAction will prioritize water
                    }
                    
                    // PRE-EMPTIVE WATER SEEKING: At 50 thirst, start looking for water proactively
                    if(thirst < 50 || thirstCounter > 50) {
                        if(!nearWater) {
                            this.waterSeekMode = true;
                            this.log(`üíß Thirst at ${thirst} (step ${thirstCounter}) - seeking water proactively`);
                        }
                    }
                    
                    // === ADAPTIVE SETTLING BASED ON DEATH HISTORY ===
                    // If we keep dying from water/food issues, settle sooner
                    let settleEarly = this.consecutiveDeaths > 3 || 
                                     (this.lastDeathCause === 'thirst' && this.consecutiveDeaths > 1);
                    
                    // Settlement thresholds - adapt based on past failures
                    const MIN_NOMADS_IDEAL = settleEarly ? 5 : 10;
                    const MIN_FOOD_THRESHOLD = settleEarly ? REQ.MIN_FOOD : 150;
                    const MIN_WOOD_THRESHOLD = settleEarly ? REQ.MIN_WOOD : 40;
                    
                    // Check if we have enough resources
                    let hasEnoughFood = food >= MIN_FOOD_THRESHOLD;
                    let hasEnoughWood = wood >= MIN_WOOD_THRESHOLD;
                    let hasBasicResources = hasEnoughFood && hasEnoughWood;
                    
                    // nearWater already checked above
                    
                    // Urgent settle if thirst is low and we found water
                    if (thirst < 40 && nearWater && food >= REQ.MIN_FOOD && wood >= REQ.MIN_WOOD && pop >= REQ.MIN_POP) {
                        this.log('üÜò URGENT: Low thirst, settling near water!');
                        return 'SETTLE';
                    }
                    
                    // Settle if: have resources AND near water AND enough nomads
                    let shouldSettle = hasBasicResources && nearWater &&
                                      (pop >= MIN_NOMADS_IDEAL || 
                                       (pop >= 5 && food >= 200 && wood >= 50));
                    
                    // Also settle if we've been wandering too long (>50 steps) with minimum requirements
                    if (!shouldSettle && this.stepCount > 50 && nearWater && 
                        food >= REQ.MIN_FOOD && wood >= REQ.MIN_WOOD && pop >= REQ.MIN_POP) {
                        this.log('‚è∞ Long wander - settling with minimum requirements');
                        shouldSettle = true;
                    }
                    
                    if (shouldSettle) {
                        this.consecutiveDeaths = 0; // Reset on successful settle attempt
                        return 'SETTLE';
                    }
                    
                    // If we have resources but not near water, actively seek water
                    if (hasBasicResources && pop >= REQ.MIN_POP && !nearWater) {
                        this.waterSeekMode = true;
                        this.log('üîç Seeking water for settlement...');
                    }
                    
                    // Keep wandering to gather nomads, food, and wood
                    return 'WANDER';
                }
                
                // 2. CITY MODE - TUTORIAL-BASED BUILDING (Step by step guide)
                if (Game && Game.gameState === 'CITY') {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // AI GAME STATE READER - Read ENTIRE UI like a human would
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // === BUILDING COUNTS (from game state) ===
                    let resCount = Game.zoneCount || 0;  // Residential zones
                    let wellCount = Game.blds ? Game.blds.filter(b => b.t === 'WELL').length : 0;
                    let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    let roadCount = Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0;
                    
                    // === RESOURCE VALUES (same as dashboard shows) ===
                    let pop = Game.pop || 0;
                    let wood = Game.wood || 0;
                    let food = Game.food || 0;
                    let housingCap = Game.housingCap || 0;
                    let year = Game.year || 0;
                    
                    // Get costs from config EARLY
                    let resCost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1] ? CFG.BUILDING_LEVELS[1] : { food: 100, wood: 100 };
                    let wellCost = CFG.COST && CFG.COST.WELL ? CFG.COST.WELL : 20;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // STARTUP STRATEGY: First thing in CITY mode = RES + WELL + PASS_YEAR!
                    // This is the MOST IMPORTANT rule - get income flowing first!
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if(year === 0 && resCount === 0 && wellCount === 0) {
                        // YEAR 0 STARTUP: Build first residential
                        if(food >= resCost.food && wood >= resCost.wood) {
                            this.log('üéØ STARTUP: Year 0 - Building first Residential!');
                            return 'BUILD_RES';
                        }
                    }
                    
                    if(year === 0 && resCount >= 1 && wellCount === 0) {
                        // YEAR 0 STARTUP: Build first well (critical for water!)
                        if(food >= wellCost) {
                            this.log('üéØ STARTUP: Year 0 - Building first Well!');
                            return 'BUILD_WELL';
                        }
                    }
                    
                    if(year === 0 && resCount >= 1 && wellCount >= 1) {
                        // YEAR 0 STARTUP COMPLETE: Pass year to get income!
                        this.log('üéØ STARTUP COMPLETE: Passing year to start income flow!');
                        return 'PASS_YEAR';
                    }
                    let gold = Game.gold || 0;
                    let metal = Game.metal || 0;
                    let stone = Game.stone || 0;
                    
                    // === WATER STATUS (exact same calc as UI shows) ===
                    let waterCapacity = wellCount * 100;
                    let waterPercent = waterCapacity > 0 ? Math.round((pop / waterCapacity) * 100) : 0;
                    let wellsNeeded = Math.ceil(pop / 100);
                    let wellsWithBuffer = wellsNeeded;
                    if (pop > 50) {
                        wellsWithBuffer += 2; // Only add 2-buffer once past 50 pop
                    }
                    let needMoreWells = wellCount < wellsWithBuffer;
                    let baseWellDeficit = wellCount < wellsNeeded;
                    let bufferWellNeeded = !baseWellDeficit && needMoreWells;
                    let waterCrisis = pop > waterCapacity;
                    
                    // === RCI DEMAND (same as the R/C/I bars in UI) ===
                    let rci = Game.calculateRCIDemand ? Game.calculateRCIDemand() : { r: 50, c: 50, i: 50 };
                    let rDemand = rci.r; // Residential demand %
                    let cDemand = rci.c; // Commercial demand %
                    let iDemand = rci.i; // Industrial demand %
                    let highestDemand = rDemand >= cDemand && rDemand >= iDemand ? 'R' : (cDemand >= iDemand ? 'C' : 'I');
                    
                    // === WORKFORCE STATUS (same as workforce display) ===
                    let workforce = Game.workforce || { gatherers: 0, shortage: 0 };
                    let workerShortage = workforce.shortage > 0;
                    
                    // === HOUSING STATUS ===
                    let housingFull = pop >= housingCap;
                    let housingNearFull = pop >= housingCap - 2;
                    let homeless = Math.max(0, pop - housingCap);
                    
                    // === SATISFACTION/NEEDS (from needs warning panel) ===
                    let satisfaction = Game.satisfaction || 100;
                    let needsWater = waterPercent > 80 || waterCrisis;
                    let needsFood = food < pop * 5; // Less than 5 food per person
                    let needsHousing = housingFull || homeless > 0;
                    let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                    let highestUnlock = 1;
                    if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                        highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                    }
                    let civLevel = Game.civLevel || Game.level || 1;
                    let expansionStats = this.getCityExpansionStats();
                    
                    // Get additional costs from config (resCost/wellCost already declared above)
                    let comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                    let indCost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[1] ? CFG.INDUSTRIAL_LEVELS[1] : { food: 1000, wood: 1000 };
                    let roadCost = CFG.COST && CFG.COST.ROAD ? CFG.COST.ROAD : 5;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // AI "SEES" THE UI - Log what AI understands from the display
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    let tierStrategy = this.getPopTierStrategy(pop);
                    let blockers = this.diagnoseBlocker();
                    
                    this.log(`üëÅÔ∏è AI READS UI:`);
                    this.log(`   üó∫Ô∏è Stage ${stage} | Civ L${civLevel} | Unlock L${highestUnlock}`);
                    this.log(`   üìä Pop: ${pop}/${housingCap} | Food: ${Math.floor(food)} | Wood: ${Math.floor(wood)} | Year: ${year}`);
                    this.log(`   üíß Water: ${waterPercent}% (${wellCount} wells, need ${wellsWithBuffer}) ${waterCrisis ? 'üö®CRISIS!' : needMoreWells ? '‚ö†Ô∏èLOW' : '‚úÖOK'}`);
                    this.log(`   üìà RCI Demand: R:${rDemand}% C:${cDemand}% I:${iDemand}% ‚Üí Build ${highestDemand}`);
                    this.log(`   üèóÔ∏è Buildings: Res:${resCount} Com:${comCount} Ind:${indCount} Well:${wellCount} Road:${roadCount}`);
                    this.log(`   üåç Expansion: radius ${expansionStats.radius} | road push ${expansionStats.roadFrontier} | quadrants ${expansionStats.quadrants}`);
                    this.log(`   üìä Tier: ${tierStrategy.tier} | Priority: ${tierStrategy.priority} | ${tierStrategy.hint}`);
                    if(blockers && blockers.length > 0) {
                        let blockerStr = blockers.map(b => `${b.issue}(${b.severity})`).join(', ');
                        this.log(`   üöß Blockers: ${blockerStr}`);
                    }
                    this.log(`   ‚ö†Ô∏è Needs: ${needsWater ? 'WATER! ' : ''}${needsFood ? 'FOOD! ' : ''}${needsHousing ? 'HOUSING! ' : homeless > 0 ? homeless + ' HOMELESS! ' : ''}${workerShortage ? 'WORKERS!' : ''}`);
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL BLOCKER FIX - Handle critical issues immediately
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if(blockers) {
                        let critical = blockers.find(b => b.severity === 'critical');
                        if(critical) {
                            let fix = critical.fix;
                            // Check if we can afford the fix
                            if(fix === 'BUILD_WELL' && food >= wellCost) {
                                this.log(`üö® CRITICAL FIX: ${critical.issue} ‚Üí ${fix}`);
                                return fix;
                            }
                            if(fix === 'BUILD_RES' && food >= resCost.food && wood >= resCost.wood) {
                                this.log(`üö® CRITICAL FIX: ${critical.issue} ‚Üí ${fix}`);
                                return fix;
                            }
                            if(fix === 'BUILD_COM' && food >= comCost.food && wood >= comCost.wood) {
                                this.log(`üö® CRITICAL FIX: ${critical.issue} ‚Üí ${fix}`);
                                return fix;
                            }
                        }
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // WISDOM-BASED DECISIONS - Use learned rules
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if(this.wisdom && this.wisdom.survivalRules) {
                        // Build context for wisdom evaluation
                        let ctx = {
                            pop: pop,
                            wellCount: wellCount,
                            housingCap: housingCap,
                            food: food,
                            wood: wood,
                            roadCount: roadCount,
                            resCount: resCount,
                            comCount: comCount,
                            indCount: indCount,
                            wellCost: wellCost,
                            resCost: resCost,
                            comCost: comCost,
                            indCost: indCost,
                            roadCost: roadCost
                        };
                        
                        // Try wisdom-based action (70% chance to use wisdom)
                        if(Math.random() < 0.7) {
                            let wisdomAction = this.getWisdomAction(ctx);
                            if(wisdomAction) {
                                this.log(`üß† Wisdom suggests: ${wisdomAction}`);
                                return wisdomAction;
                            }
                        }
                        
                        // Try flow-based action (for early game)
                        let buildCount = (Game.blds ? Game.blds.length : 0);
                        if(buildCount < 10) {
                            let flowAction = this.getFlowAction(buildCount);
                            if(flowAction && this.canAffordAction(flowAction, ctx)) {
                                this.log(`üîÑ Flow suggests: ${flowAction}`);
                                return flowAction;
                            }
                        }
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // TUTORIAL MODE (1 in 5 episodes) - Strict scripted build order
                    // This teaches the AI a good baseline strategy
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Initialize tutorial tracking
                    if (this.tutorialMode === undefined) {
                        // 20% chance to follow tutorial (1 in 5)
                        this.tutorialMode = (this.episode % 5 === 0);
                        this.tutorialStep = 0;
                        this.tutorialCycle = 0; // 0-3, repeat 4 times before industrial
                        this.tutorialWaitUntilYear = 0;
                        this.log(`üìö Tutorial mode: ${this.tutorialMode ? 'ACTIVE' : 'OFF'} (Episode ${this.episode})`);
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // SUCCESS TEMPLATE GUIDANCE (20% chance to follow proven patterns)
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    let ctx = { pop, food, wood, year, highestDemand, needsWater, needsFood, needsHousing, 
                               workerShortage, homeless, housingNearFull, resCost, wellCost, comCost, indCost, roadCost };
                    let templateAction = this.getTemplateGuidedAction(ctx);
                    if(templateAction) {
                        return templateAction;
                    }

                    if(!this.tutorialMode) {
                        let macroAction = this.getMacroAction({
                            pop,
                            food,
                            wood,
                            year,
                            highestDemand,
                            needsWater,
                            needsFood,
                            needsHousing,
                            workerShortage,
                            homeless,
                            housingNearFull,
                            resCost,
                            wellCost,
                            comCost,
                            indCost,
                            roadCost
                        });
                        if(macroAction) {
                            return macroAction;
                        }
                    }
                    
                    // Log current state for debugging
                    this.log(`üìä AI State: Res=${resCount} Well=${wellCount}/${wellsWithBuffer} Road=${roadCount} Com=${comCount} Ind=${indCount} Pop=${pop}/${housingCap} Water=${waterPercent}% Year=${year}`);
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // EMERGENCY: Water crisis takes priority!
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (waterCrisis && food >= wellCost) {
                        this.log('üö® EMERGENCY: Water crisis! Building well immediately!');
                        return 'BUILD_WELL';
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // TUTORIAL MODE - Strict scripted build order
                    // Cycle: RES ‚Üí ROAD(2) ‚Üí WELL ‚Üí wait 7yrs ‚Üí RES + COM + extend road
                    // Repeat 4 times, then build first Industrial
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if (this.tutorialMode) {
                        // Tutorial Step Logic
                        // Steps per cycle:
                        // 0: Build RES
                        // 1: Build ROAD
                        // 2: Build ROAD (2nd)
                        // 3: Build WELL
                        // 4: Wait 7 years
                        // 5: Build RES
                        // 6: Build COM
                        // 7: Build ROAD (extend)
                        // 8: Cycle complete ‚Üí next cycle or Industrial
                        
                        let cycleStep = this.tutorialStep % 8;
                        
                        this.log(`üìö Tutorial: Cycle ${this.tutorialCycle+1}/4, Step ${cycleStep}, WaitUntil=${this.tutorialWaitUntilYear}`);
                        
                        // After 4 cycles, build Industrial
                        if (this.tutorialCycle >= 4) {
                            if (indCount === 0) {
                                if (food >= indCost.food && wood >= indCost.wood) {
                                    this.log('üè≠ Tutorial COMPLETE: Building first Industrial!');
                                    this.tutorialMode = false; // Exit tutorial after this
                                    return 'BUILD_IND';
                                } else {
                                    this.log('‚è≥ Saving for Industrial...');
                                    return 'PASS_YEAR';
                                }
                            }
                            // Tutorial complete, switch to normal mode
                            this.tutorialMode = false;
                        }
                        
                        switch(cycleStep) {
                            case 0: // Build RES
                                if (food >= resCost.food && wood >= resCost.wood) {
                                    this.log('üè† Tutorial: Building Residential');
                                    this.tutorialStep++;
                                    return 'BUILD_RES';
                                }
                                return 'PASS_YEAR';
                                
                            case 1: // Build ROAD 1
                            case 2: // Build ROAD 2
                                if (food >= roadCost) {
                                    this.log('üõ§Ô∏è Tutorial: Building Road ' + (cycleStep));
                                    this.tutorialStep++;
                                    return 'BUILD_ROAD';
                                }
                                return 'PASS_YEAR';
                                
                            case 3: // Build WELL
                                if (food >= wellCost) {
                                    this.log('üíß Tutorial: Building Well');
                                    this.tutorialStep++;
                                    this.tutorialWaitUntilYear = year + 7; // Wait 7 years
                                    return 'BUILD_WELL';
                                }
                                return 'PASS_YEAR';
                                
                            case 4: // Wait 7 years
                                if (year >= this.tutorialWaitUntilYear) {
                                    this.log('‚è∞ Tutorial: Wait complete, continuing...');
                                    this.tutorialStep++;
                                    // Fall through to step 5
                                } else {
                                    // While waiting, ensure we have buffer wells
                                    if (needMoreWells && food >= wellCost) {
                                        this.log('üíß Tutorial: Building buffer well while waiting');
                                        return 'BUILD_WELL';
                                    }
                                    return 'PASS_YEAR';
                                }
                                // Fall through intentionally
                                
                            case 5: // Build RES after wait
                                if (food >= resCost.food && wood >= resCost.wood) {
                                    this.log('üè† Tutorial: Building Residential (post-wait)');
                                    this.tutorialStep++;
                                    return 'BUILD_RES';
                                }
                                return 'PASS_YEAR';
                                
                            case 6: // Build COM
                                if (food >= comCost.food && wood >= comCost.wood) {
                                    this.log('üî• Tutorial: Building Commercial');
                                    this.tutorialStep++;
                                    return 'BUILD_COM';
                                }
                                return 'PASS_YEAR';
                                
                            case 7: // Extend ROAD
                                if (food >= roadCost) {
                                    this.log('üõ§Ô∏è Tutorial: Extending Road');
                                    this.tutorialStep++;
                                    this.tutorialCycle++; // Complete cycle
                                    return 'BUILD_ROAD';
                                }
                                return 'PASS_YEAR';
                        }
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // NORMAL MODE (4 out of 5 episodes) - Smart reactive building
                    // Priority: Emergency Wells > Housing > Buffer Wells > Roads > Commercial > Industrial
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // PRIORITY 1: First residential if none exist
                    if (resCount === 0) {
                        if (food >= resCost.food && wood >= resCost.wood) {
                            this.log('üè† Building first residential!');
                            return 'BUILD_RES';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 2: First well if none exist
                    if (wellCount === 0) {
                        if (food >= wellCost) {
                            this.log('üíß Building first well!');
                            return 'BUILD_WELL';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 3: First road
                    if (roadCount === 0) {
                        if (food >= roadCost) {
                            this.log('üõ§Ô∏è Building first road!');
                            return 'BUILD_ROAD';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 4: Maintain wells (urgent first, then buffer)
                    if (baseWellDeficit && food >= wellCost) {
                        this.log(`üíß Building required well (have ${wellCount}, need ${wellsNeeded})`);
                        return 'BUILD_WELL';
                    }
                    if (bufferWellNeeded && food >= wellCost && (needsWater || waterPercent > 85 || food > resCost.food * 2)) {
                        this.log(`üíß Building buffer well (have ${wellCount}, want ${wellsWithBuffer})`);
                        return 'BUILD_WELL';
                    }
                    
                    // PRIORITY 5: Housing when near capacity
                    if (pop >= housingCap - 2) {
                        if (food >= resCost.food && wood >= resCost.wood) {
                            this.log('üè† Building residential - population near capacity!');
                            return 'BUILD_RES';
                        }
                    }
                    
                    // PRIORITY 6: Roads (1 per 2 buildings minimum)
                    let totalBuildings = resCount + indCount + comCount + wellCount;
                    let roadsNeeded = Math.max(1, Math.ceil(totalBuildings / 2));
                    if (roadCount < roadsNeeded && food >= roadCost) {
                        this.log('üõ§Ô∏è Building road - need more infrastructure!');
                        return 'BUILD_ROAD';
                    }
                    
                    // PRIORITY 7: Commercial (1 per 3 residential)
                    let comNeeded = Math.max(1, Math.ceil(resCount / 3));
                    if (comCount < comNeeded && food >= comCost.food && wood >= comCost.wood) {
                        this.log('üî• Building commercial for production bonus!');
                        return 'BUILD_COM';
                    }
                    
                    // PRIORITY 8: First Industrial after 4 residential + 1 commercial
                    if (indCount === 0 && resCount >= 4 && comCount >= 1) {
                        if (food >= indCost.food && wood >= indCost.wood) {
                            this.log('üè≠ Building first Industrial!');
                            return 'BUILD_IND';
                        }
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // LEVEL 2/3 BUILDING LOGIC - When unlocked and affordable!
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Check for Level 2+ unlocks
                    if(highestUnlock >= 2) {
                        let resL2Cost = CFG.BUILDING_LEVELS[2] || { food: 300, wood: 300 };
                        let indL2Cost = CFG.INDUSTRIAL_LEVELS[2] || { food: 2000, wood: 2000 };
                        let comL2Cost = CFG.LEVEL_2_COSTS && CFG.LEVEL_2_COSTS.COMMERCIAL ? CFG.LEVEL_2_COSTS.COMMERCIAL : { food: 10000, wood: 10000 };
                        
                        // Build L2 Residential if we have good resources and housing is tight
                        if(pop >= housingCap - 5 && food >= resL2Cost.food && wood >= resL2Cost.wood) {
                            this.log('üè† Building Level 2 Residential for more capacity!');
                            return 'BUILD_RES_L2';
                        }
                        
                        // Build L2 Industrial if we have L1 already and good resources
                        if(indCount >= 1 && food >= indL2Cost.food && wood >= indL2Cost.wood && food >= 5000) {
                            this.log('üè≠ Upgrading to Level 2 Industrial!');
                            return 'BUILD_IND_L2';
                        }
                        
                        // Build L2 Commercial if we have plenty of resources
                        if(comCount >= 2 && food >= comL2Cost.food && wood >= comL2Cost.wood) {
                            this.log('üè™ Upgrading to Level 2 Commercial!');
                            return 'BUILD_COM_L2';
                        }
                    }
                    
                    // Check for Level 3 unlocks
                    if(highestUnlock >= 3) {
                        let resL3Cost = CFG.BUILDING_LEVELS[3] || { food: 900, wood: 900 };
                        let indL3Cost = CFG.INDUSTRIAL_LEVELS[3] || { food: 3000, wood: 3000 };
                        
                        // Build L3 Residential if we have good resources
                        if(pop >= housingCap - 3 && food >= resL3Cost.food && wood >= resL3Cost.wood && food >= 2000) {
                            this.log('üè° Building Level 3 Residential!');
                            return 'BUILD_RES_L3';
                        }
                        
                        // Build L3 Industrial if we have L2 and good resources
                        if(indCount >= 2 && food >= indL3Cost.food && wood >= indL3Cost.wood && food >= 8000) {
                            this.log('üè≠ Building Level 3 Industrial!');
                            return 'BUILD_IND_L3';
                        }
                    }
                    
                    // PRIORITY 9: Expand housing if resources plentiful
                    if (food >= resCost.food * 2 && wood >= resCost.wood * 2) {
                        this.log('üè† Building residential - expanding capacity!');
                        return 'BUILD_RES';
                    }
                    
                    // Default: Pass year
                    this.log('‚è≥ Passing year - waiting for resources/growth');
                    return 'PASS_YEAR';
                }
                
                // Exploration: try random things to find exploits
                if(Math.random() < this.explorationRate) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }
                // Exploitation: best known action
                let bestAction = this.actions[0];
                let bestValue = this.getQ(state, bestAction);
                for(let action of this.actions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                return bestAction;
            },
            
            // Execute an action in the game
            executeAction: function(action) {
                if(Game.gameState === 'WANDER') {
                    if(!Game.player) return false;
                    
                    // === EXPLORATION TEST MODE: Block settling, always explore ===
                    if(this.explorationTestMode && action === 'SETTLE') {
                        // Force WANDER instead - we want to explore, not settle!
                        action = 'WANDER';
                    }
                    
                    // If action is SETTLE, try to settle near water
                    if(action === 'SETTLE') {
                        // First check if we're near water, if not move toward water
                        const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                        let nearWater = false;
                        for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                            for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                                let x = Game.player.x + dx;
                                let y = Game.player.y + dy;
                                if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                    let tile = Game.tiles[x][y];
                                    if(tile && (tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP')) {
                                        nearWater = true;
                                        break;
                                    }
                                }
                            }
                            if(nearWater) break;
                        }
                        
                        if(nearWater) {
                            // We're near water - settle!
                            Game.settleHere();
                            if(Game && Game.player) {
                                this.aiSettlementPos = { x: Game.player.x, y: Game.player.y };
                            }
                            return true;
                        }
                        // If not near water, fall through to WANDER behavior below
                    }
                    
                    // WANDER action: hunt nomads, grab resources, explore, find water
                    const radius = 8;
                    let nomadTarget = null;
                    let berryTarget = null;
                    let woodTarget = null;
                    let waterTarget = null;
                    let animalTarget = null;
                    
                    // Check thirst level - prioritize water if low
                    let thirst = Game.thirst || 100;
                    let thirstCounter = Game.thirstCounter || 0;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // CRITICAL THIRST SURVIVAL: Water is ABSOLUTE priority when low!
                    // - At 70+ steps (thirst<30): MUST find water NOW
                    // - At 50+ steps (thirst<50): Start seeking water proactively
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    let needsWaterUrgent = thirst < 30 || thirstCounter > 70; // CRITICAL - will die soon!
                    let needsWater = thirst < 50 || thirstCounter > 50;       // Should seek water
                    
                    // Debug: log that we're in WANDER executeAction
                    console.log('üö∂ WANDER execute: action=', action, 'pos=', Game.player.x, Game.player.y, 'food=', Game.inventory.food, 'thirst=', thirst, 'counter=', thirstCounter);
                    
                    // URGENT WATER SEARCH: Use wider radius when thirsty!
                    let waterSearchRadius = needsWaterUrgent ? 15 : (needsWater ? 12 : radius);
                    
                    // Water-seeking mode for settlement
                    let seekingWaterForSettlement = this.waterSeekMode && !this.checkNearWater();
                    if(seekingWaterForSettlement) {
                        let waterPos = this.findNearestWater();
                        if(waterPos) {
                            waterTarget = waterPos;
                            this.log('üíß Moving toward water for settlement');
                        }
                    }
                    
                    if(Game.tiles) {
                        // Use wider radius for water search when thirsty!
                        let searchRadius = needsWaterUrgent ? waterSearchRadius : radius;
                        
                        for(let r = 1; r <= searchRadius; r++) {
                            for(let dx = -r; dx <= r; dx++) {
                                for(let dy = -r; dy <= r; dy++) {
                                    const tx = Game.player.x + dx;
                                    const ty = Game.player.y + dy;
                                    if(tx<0 || ty<0 || tx>=Game.tiles.length || ty>=Game.tiles[0].length) continue;
                                    const tile = Game.tiles[tx][ty];
                                    if(!tile) continue;
                                    
                                    // Look for water FIRST when thirsty (scan entire radius)
                                    if(!waterTarget && (tile.type === 'WATER' || tile.type === 'RIVER')) {
                                        waterTarget = {x: tx, y: ty};
                                        // If urgent, don't look for anything else - just water!
                                        if(needsWaterUrgent) continue;
                                    }
                                    
                                    // Only look for other targets if not in urgent water mode
                                    if(!needsWaterUrgent) {
                                        // Hunt friendly nomads for population - PRIORITY 1
                                        if(!nomadTarget && tile.entity && tile.entity.type === 'NOMAD' && tile.entity.is_hostile === false) {
                                            nomadTarget = {x: tx, y: ty};
                                        }
                                        // Grab berries for food
                                        if(!berryTarget && tile.entity && tile.entity.type === 'BERRY' && tile.entity.amount > 0) {
                                            berryTarget = {x: tx, y: ty};
                                        }
                                        // Look for animals near settlement spots (for Industrial placement)
                                        if(!animalTarget && tile.animal) {
                                            animalTarget = {x: tx, y: ty};
                                        }
                                        // Chop trees for wood (needed to settle)
                                        if(!woodTarget && tile.tree && Game.inventory && Game.inventory.wood < 50) {
                                            woodTarget = {x: tx, y: ty};
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Priority depends on thirst level:
                    // URGENT thirst: water ONLY, nothing else matters!
                    // Normal thirst: water FIRST, then nomads > berries > wood
                    // Not thirsty: nomads > berries > wood > water (for settling)
                    let target;
                    if(needsWaterUrgent && waterTarget) {
                        target = waterTarget; // CRITICAL: find water or die!
                        console.log('üö® URGENT THIRST! Seeking water at', waterTarget.x, waterTarget.y, 'thirst=', thirst);
                    } else if(needsWater && waterTarget) {
                        target = waterTarget; // Prioritize water
                        console.log('üíß THIRSTY! Seeking water at', waterTarget.x, waterTarget.y);
                    } else {
                        target = nomadTarget || berryTarget || animalTarget || woodTarget || waterTarget;
                    }
                    if(target) {
                        const stepX = Math.sign(target.x - Game.player.x);
                        const stepY = Math.sign(target.y - Game.player.y);
                        console.log('üéØ Moving toward target at', target.x, target.y, '| step:', stepX, stepY);
                        let moved = false;
                        if(Math.abs(target.x - Game.player.x) >= Math.abs(target.y - Game.player.y)) {
                            moved = Game.movePlayer(stepX, 0);
                            // If blocked, try perpendicular direction
                            if(!moved && stepY !== 0) moved = Game.movePlayer(0, stepY);
                        } else {
                            moved = Game.movePlayer(0, stepY);
                            // If blocked, try perpendicular direction
                            if(!moved && stepX !== 0) moved = Game.movePlayer(stepX, 0);
                        }
                        if(moved) return true;
                        // Fall through to try other directions if blocked
                    }
                    
                    // Explore unexplored tiles (or just try to move if all explored)
                    const dirs = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                    
                    // Shuffle directions for variety
                    for(let i = dirs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                    }
                    
                    const unexplored = [];
                    const walkable = [];
                    for(const d of dirs) {
                        const nx = Game.player.x + d.dx;
                        const ny = Game.player.y + d.dy;
                        if(nx<0 || ny<0 || nx>=Game.tiles.length || ny>=Game.tiles[0].length) continue;
                        const t = Game.tiles[nx][ny];
                        if(!t) continue;
                        if(t.type !== 'WATER' && t.type !== 'DEEP' && t.type !== 'RIVER' && t.type !== 'STONE') {
                            walkable.push(d);
                            if(!t.explored) {
                                unexplored.push(d);
                            }
                        }
                    }
                    
                    // Prefer unexplored, but try any walkable if none
                    let moveTargets = unexplored.length > 0 ? unexplored : walkable;
                    
                    for(const pick of moveTargets) {
                        console.log('üîç Trying move:', pick.dx, pick.dy);
                        if(Game.movePlayer(pick.dx, pick.dy)) {
                            return true;
                        }
                    }
                    
                    // Truly stuck - log it
                    console.log('‚ö†Ô∏è AI stuck! No valid moves. Food:', Game.inventory?.food, 'Pos:', Game.player.x, Game.player.y);
                    return false;
                }
                
                // Find a valid position to build - NOW USES PLAYBOOK IF AVAILABLE
                var self = this;
                
                // Smart road placement for expansion
                var findFrontierRoadSpot = function() {
                    if(!Game.settlementPos || !Game.blds || Game.blds.length === 0) return null;
                    
                    let origin = Game.settlementPos;
                    let expansionStats = self.getCityExpansionStats();
                    let tierStrategy = self.getPopTierStrategy(Game.pop || 0);
                    
                    // Find which quadrants are under-developed
                    let quadrantBuildings = { NE: 0, NW: 0, SE: 0, SW: 0 };
                    for(let b of Game.blds) {
                        if(b.x === undefined || b.y === undefined) continue;
                        let dx = b.x - origin.x;
                        let dy = b.y - origin.y;
                        if(dx >= 0 && dy < 0) quadrantBuildings.NE++;
                        else if(dx < 0 && dy < 0) quadrantBuildings.NW++;
                        else if(dx >= 0 && dy >= 0) quadrantBuildings.SE++;
                        else quadrantBuildings.SW++;
                    }
                    
                    // Find least-developed quadrant
                    let minQuad = 'NE', minCount = quadrantBuildings.NE;
                    for(let q in quadrantBuildings) {
                        if(quadrantBuildings[q] < minCount) {
                            minCount = quadrantBuildings[q];
                            minQuad = q;
                        }
                    }
                    
                    // Get direction toward least-developed quadrant
                    let targetDX = (minQuad === 'NE' || minQuad === 'SE') ? 1 : -1;
                    let targetDY = (minQuad === 'NE' || minQuad === 'NW') ? -1 : 1;
                    
                    // Find existing roads and look for frontier extension
                    let roads = Game.blds.filter(b => b.t === 'ROAD');
                    if(roads.length > 0) {
                        // Sort roads by distance from origin, farthest first in target direction
                        roads.sort((a, b) => {
                            let scoreA = (a.x - origin.x) * targetDX + (a.y - origin.y) * targetDY;
                            let scoreB = (b.x - origin.x) * targetDX + (b.y - origin.y) * targetDY;
                            return scoreB - scoreA; // Higher score = more in target direction
                        });
                        
                        // Try to extend from frontier roads
                        for(let road of roads) {
                            // Try directions, prioritizing target direction
                            let dirs = [
                                {dx: targetDX, dy: 0, priority: 2},
                                {dx: 0, dy: targetDY, priority: 2},
                                {dx: targetDX, dy: targetDY, priority: 1}, // Diagonal is lower priority
                                {dx: -targetDX, dy: 0, priority: 0},
                                {dx: 0, dy: -targetDY, priority: 0}
                            ];
                            dirs.sort((a, b) => b.priority - a.priority);
                            
                            for(let dir of dirs) {
                                let tx = road.x + dir.dx;
                                let ty = road.y + dir.dy;
                                if(self.isValidBuildSpot(tx, ty, 'ROAD')) {
                                    self.log(`üõ§Ô∏è Expanding road frontier toward ${minQuad} quadrant`);
                                    return { x: tx, y: ty };
                                }
                            }
                        }
                    }
                    
                    return null; // Fall through to regular buildspot
                };
                
                var findBuildSpot = function(zoneType) {
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // PRIORITY: Build CLUSTERED near settlement origin!
                    // Start from settlement, spiral outward, prefer adjacent to existing buildings
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    
                    // Helper: Check if tile is valid for building
                    var isGoodSpot = function(x, y) {
                        if(x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) return false;
                        let tile = Game.tiles[x][y];
                        if(!tile) return false;
                        if(!tile.explored) return false; // MUST be explored!
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                        if(tile.stoneDeposit) return false;
                        if(tile.zone || tile.building || tile.road) return false;
                        // Check blds array for overlap
                        for(let b of (Game.blds || [])) {
                            let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') ? 1 : 2;
                            if(x < b.x + bz && x + 1 > b.x && y < b.y + bz && y + 1 > b.y) return false;
                        }
                        return true;
                    };
                    
                    // Helper: Count adjacent buildings (higher = more clustered)
                    var countAdjacentBuildings = function(x, y) {
                        let count = 0;
                        for(let dx = -1; dx <= 1; dx++) {
                            for(let dy = -1; dy <= 1; dy++) {
                                if(dx === 0 && dy === 0) continue;
                                let nx = x + dx, ny = y + dy;
                                if(nx < 0 || ny < 0 || nx >= CFG.W || ny >= CFG.H) continue;
                                let t = Game.tiles[nx][ny];
                                if(t && (t.zone || t.building || t.road)) count++;
                                // Also check blds array
                                for(let b of (Game.blds || [])) {
                                    if(b.x === nx && b.y === ny) count++;
                                }
                            }
                        }
                        return count;
                    };
                    
                    // Get origin point (settlement position or player position)
                    let origin = Game.settlementPos || (Game.player ? { x: Game.player.x, y: Game.player.y } : { x: Math.floor(CFG.W/2), y: Math.floor(CFG.H/2) });
                    
                    // Collect all valid spots within range, sorted by clustering score
                    let candidates = [];
                    const maxRange = 8; // Don't build too far away
                    
                    for(let r = 1; r <= maxRange; r++) {
                        for(let dx = -r; dx <= r; dx++) {
                            for(let dy = -r; dy <= r; dy++) {
                                let x = origin.x + dx;
                                let y = origin.y + dy;
                                
                                if(isGoodSpot(x, y)) {
                                    let adjacentScore = countAdjacentBuildings(x, y);
                                    let distFromOrigin = Math.abs(dx) + Math.abs(dy);
                                    // Score: prefer adjacent buildings (cluster), penalize distance
                                    let score = adjacentScore * 10 - distFromOrigin;
                                    candidates.push({ x, y, score, adjacent: adjacentScore, dist: distFromOrigin });
                                }
                            }
                        }
                    }
                    
                    // Sort by score (highest first) - prefers clustered spots
                    candidates.sort((a, b) => b.score - a.score);
                    
                    // Return best spot (most clustered, closest to origin)
                    if(candidates.length > 0) {
                        let best = candidates[0];
                        console.log('üèóÔ∏è AI build spot: (' + best.x + ',' + best.y + ') adjacent=' + best.adjacent + ' dist=' + best.dist);
                        return { x: best.x, y: best.y };
                    }
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // Fallback: If no clustered spot found, try any valid explored tile nearby
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    for(let r = 1; r <= 15; r++) {
                        for(let dx = -r; dx <= r; dx++) {
                            for(let dy = -r; dy <= r; dy++) {
                                let x = origin.x + dx;
                                let y = origin.y + dy;
                                if(isGoodSpot(x, y)) {
                                    return { x, y };
                                }
                            }
                        }
                    }
                    
                    console.log('‚ö†Ô∏è AI: No valid build spot found!');
                    return null;
                };
                
                var spot;
                var unlockedLevels = PROGRESSION && PROGRESSION.unlockedLevels ? PROGRESSION.unlockedLevels : [1];
                var highestUnlock = Math.max(...unlockedLevels);
                
                switch(action) {
                    case 'BUILD_RES':
                        spot = findBuildSpot();
                        // Get residential cost from config (Level 1 = 100 food, 100 wood)
                        var resCost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1] ? CFG.BUILDING_LEVELS[1] : { food: 100, wood: 100 };
                        if(spot && Game.food >= resCost.food && Game.wood >= resCost.wood) {
                            Controller.selectedBuildingLevel = 1; // Set level before building
                            Game.build('RES', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_RES_L2':
                        // Only if Level 2 is unlocked
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var resL2Cost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[2] ? CFG.BUILDING_LEVELS[2] : { food: 300, wood: 300 };
                            if(spot && Game.food >= resL2Cost.food && Game.wood >= resL2Cost.wood) {
                                Controller.selectedBuildingLevel = 2;
                                Game.build('RES', spot.x, spot.y);
                                this.log('üè† Built Level 2 Residential!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L3':
                        // Only if Level 3 is unlocked
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            var resL3Cost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[3] ? CFG.BUILDING_LEVELS[3] : { food: 900, wood: 900 };
                            if(spot && Game.food >= resL3Cost.food && Game.wood >= resL3Cost.wood) {
                                Controller.selectedBuildingLevel = 3;
                                Game.build('RES', spot.x, spot.y);
                                this.log('üè° Built Level 3 Residential!');
                                return true;
                            }
                        }
                        break;
                        
                    case 'BUILD_IND':
                        spot = findBuildSpot();
                        // Industrial Level 1 costs 1000 food + 1000 wood
                        var indCost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[1] ? CFG.INDUSTRIAL_LEVELS[1] : { food: 1000, wood: 1000 };
                        if(spot && Game.food >= indCost.food && Game.wood >= indCost.wood) {
                            Controller.selectedIndustrialLevel = 1; // Set level before building
                            Game.build('IND', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_IND_L2':
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var indL2Cost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[2] ? CFG.INDUSTRIAL_LEVELS[2] : { food: 2000, wood: 2000 };
                            if(spot && Game.food >= indL2Cost.food && Game.wood >= indL2Cost.wood) {
                                Controller.selectedIndustrialLevel = 2;
                                Game.build('IND', spot.x, spot.y);
                                this.log('üè≠ Built Level 2 Industrial!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L3':
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            var indL3Cost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[3] ? CFG.INDUSTRIAL_LEVELS[3] : { food: 3000, wood: 3000 };
                            if(spot && Game.food >= indL3Cost.food && Game.wood >= indL3Cost.wood) {
                                Controller.selectedIndustrialLevel = 3;
                                Game.build('IND', spot.x, spot.y);
                                this.log('üè≠ Built Level 3 Industrial!');
                                return true;
                            }
                        }
                        break;
                        
                    case 'BUILD_COM':
                        spot = findBuildSpot();
                        // Commercial Level 1 = Pebble Trade Fire (200 food, 200 wood per LEVEL_1_COSTS)
                        var comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                        if(spot && Game.food >= comCost.food && Game.wood >= comCost.wood) {
                            Controller.selectedCommercialLevel = 1; // Set level before building
                            Game.build('COM', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_COM_L2':
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var comL2Cost = CFG.LEVEL_2_COSTS && CFG.LEVEL_2_COSTS.COMMERCIAL ? CFG.LEVEL_2_COSTS.COMMERCIAL : { food: 10000, wood: 10000 };
                            if(spot && Game.food >= comL2Cost.food && Game.wood >= comL2Cost.wood) {
                                Controller.selectedCommercialLevel = 2;
                                Game.build('COM', spot.x, spot.y);
                                this.log('üè™ Built Level 2 Commercial!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L3':
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            // Level 3 commercial - extrapolate cost
                            var comL3Cost = { food: 50000, wood: 50000 };
                            if(spot && Game.food >= comL3Cost.food && Game.wood >= comL3Cost.wood) {
                                Controller.selectedCommercialLevel = 3;
                                Game.build('COM', spot.x, spot.y);
                                this.log('üè¨ Built Level 3 Commercial!');
                                return true;
                            }
                        }
                        break;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LEVEL 4-6 BUILDINGS (Requires Clan Chief) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    case 'BUILD_RES_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var resL4Cost = CFG.BUILDING_DB['RES_4'] ? CFG.BUILDING_DB['RES_4'].cost : { food: 2000, wood: 2000, stone: 40 };
                            if(spot && Game.food >= resL4Cost.food && Game.wood >= resL4Cost.wood && (Game.stone || 0) >= (resL4Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 4;
                                Game.build('RES', spot.x, spot.y);
                                this.log('‚õ∫ Built Level 4 Tipi Village!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var resL5Cost = CFG.BUILDING_DB['RES_5'] ? CFG.BUILDING_DB['RES_5'].cost : { food: 8000, wood: 8000, stone: 80 };
                            if(spot && Game.food >= resL5Cost.food && Game.wood >= resL5Cost.wood && (Game.stone || 0) >= (resL5Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 5;
                                Game.build('RES', spot.x, spot.y);
                                this.log('üè† Built Level 5 Log Longhouse!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var resL6Cost = CFG.BUILDING_DB['RES_6'] ? CFG.BUILDING_DB['RES_6'].cost : { food: 20000, wood: 20000, stone: 100 };
                            if(spot && Game.food >= resL6Cost.food && Game.wood >= resL6Cost.wood && (Game.stone || 0) >= (resL6Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 6;
                                Game.build('RES', spot.x, spot.y);
                                this.log('üè∞ Built Level 6 Old Growth Compound!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var indL4Cost = CFG.BUILDING_DB['IND_4'] ? CFG.BUILDING_DB['IND_4'].cost : { food: 2400, wood: 2400, stone: 48 };
                            if(spot && Game.food >= indL4Cost.food && Game.wood >= indL4Cost.wood && (Game.stone || 0) >= (indL4Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 4;
                                Game.build('IND', spot.x, spot.y);
                                this.log('üê¢ Built Level 4 Turtle Hunting Ground!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var indL5Cost = CFG.BUILDING_DB['IND_5'] ? CFG.BUILDING_DB['IND_5'].cost : { food: 9600, wood: 9600, stone: 96 };
                            if(spot && Game.food >= indL5Cost.food && Game.wood >= indL5Cost.wood && (Game.stone || 0) >= (indL5Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 5;
                                Game.build('IND', spot.x, spot.y);
                                this.log('üêª Built Level 5 Bear Pit!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var indL6Cost = CFG.BUILDING_DB['IND_6'] ? CFG.BUILDING_DB['IND_6'].cost : { food: 24000, wood: 24000, stone: 120 };
                            if(spot && Game.food >= indL6Cost.food && Game.wood >= indL6Cost.wood && (Game.stone || 0) >= (indL6Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 6;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ü¶¨ Built Level 6 Buffalo Grounds!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var comL4Cost = CFG.BUILDING_DB['COM_4'] ? CFG.BUILDING_DB['COM_4'].cost : { food: 1600, wood: 1600, stone: 32 };
                            if(spot && Game.food >= comL4Cost.food && Game.wood >= comL4Cost.wood && (Game.stone || 0) >= (comL4Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 4;
                                Game.build('COM', spot.x, spot.y);
                                this.log('üõ¢Ô∏è Built Level 4 Barter Barrel!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var comL5Cost = CFG.BUILDING_DB['COM_5'] ? CFG.BUILDING_DB['COM_5'].cost : { food: 6400, wood: 6400, stone: 64 };
                            if(spot && Game.food >= comL5Cost.food && Game.wood >= comL5Cost.wood && (Game.stone || 0) >= (comL5Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 5;
                                Game.build('COM', spot.x, spot.y);
                                this.log('üõçÔ∏è Built Level 5 Blanket Market!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var comL6Cost = CFG.BUILDING_DB['COM_6'] ? CFG.BUILDING_DB['COM_6'].cost : { food: 16000, wood: 16000, stone: 80 };
                            if(spot && Game.food >= comL6Cost.food && Game.wood >= comL6Cost.wood && (Game.stone || 0) >= (comL6Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 6;
                                Game.build('COM', spot.x, spot.y);
                                this.log('üèõÔ∏è Built Level 6 Bear Market!');
                                return true;
                            }
                        }
                        break;
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê MILESTONE BUILDINGS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    case 'BUILD_CLAN_CHIEF':
                        // Requires 100k food, 100k wood, and 1 gold
                        if(!Game.hasClanChief && Game.food >= 100000 && Game.wood >= 100000 && (Game.gold || 0) >= 1) {
                            spot = findBuildSpot();
                            if(spot) {
                                Game.food -= 100000;
                                Game.wood -= 100000;
                                Game.gold = (Game.gold || 0) - 1;
                                Game.hasClanChief = true;
                                // Add the building to the game
                                Game.blds.push({ t: 'CLAN_CHIEF', x: spot.x, y: spot.y, level: 1 });
                                this.log('üèõÔ∏è Built Clan Chief\'s Hut! Levels 4-6 unlocked!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_DOCK':
                        // Requires 500k food, 500k wood, and 5 gold, plus Clan Chief
                        if(Game.hasClanChief && !Game.hasDock && Game.food >= 500000 && Game.wood >= 500000 && (Game.gold || 0) >= 5) {
                            spot = findBuildSpot();
                            if(spot) {
                                Game.food -= 500000;
                                Game.wood -= 500000;
                                Game.gold = (Game.gold || 0) - 5;
                                Game.hasDock = true;
                                Game.blds.push({ t: 'DOCK', x: spot.x, y: spot.y, level: 2 });
                                this.log('‚öì Built First Dock! Level 7+ unlocked!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'EXCHANGE_GOLD':
                        // Exchange 5000 metal for 1 gold
                        var metalNeeded = CFG.GOLD_EXCHANGE_RATE || 5000;
                        var totalMetal = (Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0);
                        if(totalMetal >= metalNeeded) {
                            // Deduct from pocket first, then main inventory
                            var remaining = metalNeeded;
                            if(Game.pocket && Game.pocket.metal > 0) {
                                var fromPocket = Math.min(Game.pocket.metal, remaining);
                                Game.pocket.metal -= fromPocket;
                                remaining -= fromPocket;
                            }
                            if(remaining > 0) {
                                Game.metal = (Game.metal || 0) - remaining;
                            }
                            Game.gold = (Game.gold || 0) + 1;
                            this.log('üí∞ Exchanged ' + metalNeeded + ' metal for 1 gold! Total gold: ' + Game.gold);
                            return true;
                        }
                        break;
                        
                    case 'BUILD_WELL':
                        spot = findBuildSpot();
                        // Well cost from config
                        var wellCost = CFG.COST && CFG.COST.WELL ? CFG.COST.WELL : 20;
                        if(spot && Game.food >= wellCost) {
                            Game.build('WELL', spot.x, spot.y);
                            return true;
                        }
                        break;
                        
                    case 'BUILD_ROAD':
                        // Try frontier expansion first, then regular spot
                        spot = findFrontierRoadSpot() || findBuildSpot();
                        // Road cost from config
                        var roadCost = CFG.COST && CFG.COST.ROAD ? CFG.COST.ROAD : 5;
                        if(spot && Game.food >= roadCost) {
                            Game.build('ROAD', spot.x, spot.y);
                            return true;
                        }
                        break;
                        
                    case 'PASS_YEAR':
                        Game.endTurn();
                        return true;
                        
                    case 'WAIT':
                        // Do nothing this step
                        return true;
                }
                
                return false;
            },
            
            // Calculate reward based on game state change - CURRICULUM LEARNING
            calculateReward: function(prevState, currentState, action) {
                let reward = 0;
                let phase = this.learningPhase || 1;
                let actualPop = Game.pop || 0;
                let year = Game.year || 0;
                if(!this.episodeStartSnapshotTaken) {
                    this.episodeStartSnapshotTaken = true;
                    this.episodeStartPop = actualPop;
                    this.episodeStartRes = Game.zoneCount || 0;
                    this.episodeStartStage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                    this.episodeStartYear = year;
                }
                let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                let highestUnlock = 1;
                if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                    highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                }
                let expansionStats = this.getCityExpansionStats();

                // Game over penalty (scales with phase - dying matters more as we advance)
                var gameOverPanel = document.getElementById('gameover-screen');
                if(gameOverPanel && gameOverPanel.style.display === 'flex') {
                    return -100 * phase; // -100 in phase 1, -200 in phase 2, -300 in phase 3
                }

                if(stage > (this.lastStageAwarded || 0)) {
                    let stageReward = stage === 1 ? 200 : stage === 2 ? 500 : 150;
                    reward += stageReward;
                    this.lastStageAwarded = stage;
                    this.progressMade = true;
                    this.log(`üöÄ Advanced to Stage ${stage}! +${stageReward}`);
                }

                if(highestUnlock > (this.lastLevelUnlockAward || 1)) {
                    let levelDelta = highestUnlock - (this.lastLevelUnlockAward || 1);
                    let levelReward = levelDelta * 150;
                    reward += levelReward;
                    this.lastLevelUnlockAward = highestUnlock;
                    this.progressMade = true;
                    this.log(`üèÖ Housing Level ${highestUnlock} unlocked! +${levelReward}`);
                }

                if(expansionStats.radius > (this.lastExpansionRadius || 0)) {
                    let radiusGain = expansionStats.radius - (this.lastExpansionRadius || 0);
                    reward += radiusGain * 5;
                    this.lastExpansionRadius = expansionStats.radius;
                    if(radiusGain > 0) this.progressMade = true;
                }

                if(expansionStats.quadrants > (this.lastQuadrantCount || 0)) {
                    let quadGain = expansionStats.quadrants - (this.lastQuadrantCount || 0);
                    let quadReward = quadGain * 200;
                    reward += quadReward;
                    this.lastQuadrantCount = expansionStats.quadrants;
                    this.progressMade = true;
                    this.log(`üåê Expanded into ${expansionStats.quadrants} map quadrants! +${quadReward}`);
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // MEGA MILESTONE REWARDS - Exponential scaling for population survival
                // The REAL goal: Keep many people alive for many years!
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                if(Game.gameState === 'CITY') {
                    // Population-Year Score: pop * years (base milestone tracking)
                    let popYearScore = actualPop * year;
                    
                    // Milestone bonuses (exponentially increasing)
                    // 10 pop √ó 10 years = 100 pop-years ‚Üí +100 reward
                    // 50 pop √ó 20 years = 1000 pop-years ‚Üí +500 reward
                    // 100 pop √ó 100 years = 10000 pop-years ‚Üí +5000 reward!
                    if(popYearScore >= 100 && !this.milestone100) { this.milestone100 = true; reward += 100; this.log('üèÜ Milestone: 100 pop-years!'); }
                    if(popYearScore >= 500 && !this.milestone500) { this.milestone500 = true; reward += 300; this.log('üèÜ Milestone: 500 pop-years!'); }
                    if(popYearScore >= 1000 && !this.milestone1k) { this.milestone1k = true; reward += 500; this.log('üèÜ Milestone: 1,000 pop-years!'); }
                    if(popYearScore >= 5000 && !this.milestone5k) { this.milestone5k = true; reward += 2000; this.log('üèÜüèÜ Milestone: 5,000 pop-years!'); }
                    if(popYearScore >= 10000 && !this.milestone10k) { this.milestone10k = true; reward += 5000; this.log('üèÜüèÜüèÜ LEGENDARY: 10,000 pop-years!'); }
                    if(popYearScore >= 50000 && !this.milestone50k) { this.milestone50k = true; reward += 25000; this.log('üëë GODLIKE: 50,000 pop-years!'); }
                    
                    // Continuous reward: Every step in CITY mode with living population
                    // More people = exponentially more reward per step
                    // Formula: pop^1.2 * 0.01 per step (100 pop = 2.5 pts/step, 1000 pop = 39 pts/step)
                    reward += Math.pow(actualPop, 1.2) * 0.01;
                    
                    // Year survival bonus (living another year is valuable!)
                    let prevYear = this.lastKnownYear || 0;
                    if(year > prevYear) {
                        // Bonus = population * years survived this step * 5
                        reward += actualPop * (year - prevYear) * 5;
                        this.lastKnownYear = year;
                    }
                }

                // === PHASE 1: SURVIVAL FOCUS ===
                // Big rewards for staying alive, drinking water, gathering food
                if(phase === 1) {
                    // Reward for being alive
                    reward += 2;
                    
                    // Thirst management is critical
                    let thirst = Game.thirst || 100;
                    if(thirst > 80) reward += 5;      // Well hydrated
                    else if(thirst < 30) reward -= 15; // Dangerously thirsty
                    
                    // Food gathering
                    let food = Game.inventory ? Game.inventory.food : 0;
                    if(food > 150) reward += 3;
                    
                    // Settling is the goal of phase 1
                    if(action === 'SETTLE' && Game.gameState === 'CITY') {
                        reward += 100; // HUGE reward for successfully settling
                    }
                }

                // === PHASE 2: CITY BUILDING FOCUS ===
                // Rewards for building any zones, roads, survival
                if(phase >= 2) {
                    // --- POPULATION GROWTH ---
                    let prevPopBucket = parseInt(prevState.match(/P(\d+)/)?.[1] || 0);
                    let currPopBucket = parseInt(currentState.match(/P(\d+)/)?.[1] || 0);
                    if(currPopBucket > prevPopBucket) reward += (currPopBucket - prevPopBucket) * 50; // Doubled!

                    // --- BUILDING COUNTS ---
                    let wellCount = parseInt(currentState.match(/WL(\d+)/)?.[1] || 0);
                    let resCount = parseInt(currentState.match(/R(\d+)/)?.[1] || 0);
                    let indCount = parseInt(currentState.match(/I(\d+)/)?.[1] || 0);
                    let comCount = parseInt(currentState.match(/C(\d+)/)?.[1] || 0);
                    let roadCount = Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0;
                    let totalBuildings = resCount + indCount + comCount + wellCount;

                    // Reward for each building type (scaled to building's impact)
                    reward += resCount * 15;  // Residential = population capacity
                    reward += indCount * 20;  // Industrial = resource production  
                    reward += comCount * 20;  // Commercial = trade/money
                    reward += wellCount * 10; // Wells = survival infrastructure
                    reward += roadCount * 5;  // Roads = efficiency
                    
                    // Big bonus for building actions
                    if(action === 'BUILD_RES') reward += 25;
                    if(action === 'BUILD_IND') reward += 35;
                    if(action === 'BUILD_COM') reward += 35;
                    if(action === 'BUILD_ROAD') reward += 15;
                    if(action === 'BUILD_WELL') reward += 20;
                }

                // === PHASE 3: BALANCED CITY FOCUS ===
                if(phase >= 3) {
                    let resCount = parseInt(currentState.match(/R(\d+)/)?.[1] || 0);
                    let indCount = parseInt(currentState.match(/I(\d+)/)?.[1] || 0);
                    let comCount = parseInt(currentState.match(/C(\d+)/)?.[1] || 0);
                    
                    // --- RCI DEMAND BALANCE ---
                    let rci = Game.calculateRCIDemand ? Game.calculateRCIDemand() : {r:0,c:0,i:0};
                    let allZonesPresent = (resCount > 0 && comCount > 0 && indCount > 0);
                    let balancedRCI = (rci.r < 40 && rci.c < 40 && rci.i < 40);
                    if(allZonesPresent) {
                        reward += 100; // Big bonus for having all 3 zones
                        if(balancedRCI) reward += 150; // Huge bonus for balanced city
                    }
                }

                // === ALWAYS ACTIVE REWARDS ===
                
                // --- EXPLORATION (WANDER) - Reduced! Building is more important ---
                if(Game.gameState === 'WANDER') {
                    const nowExplored = this.localExploredCount(3);
                    const deltaExplored = Math.max(0, nowExplored - (this.lastExploredCount || 0));
                    reward += deltaExplored * 0.5; // REDUCED from 2 to 0.5 - exploring is cheap
                    this.lastExploredCount = nowExplored;
                }

                // --- SETTLEMENT LOCATION BONUS ---
                // If just settled, check for nearby animals/berries
                if(action === 'SETTLE' && Game.player) {
                    let foundAnimal = false, foundBerry = false;
                    for(let dx=-3;dx<=3;dx++) for(let dy=-3;dy<=3;dy++) {
                        let tx = Game.player.x+dx, ty = Game.player.y+dy;
                        if(tx<0||ty<0||tx>=Game.tiles.length||ty>=Game.tiles[0].length) continue;
                        let tile = Game.tiles[tx][ty];
                        if(tile && tile.entity) {
                            if(tile.entity.type==='ANIMAL') foundAnimal = true;
                            if(tile.entity.type==='BERRY') foundBerry = true;
                        }
                        // Also check for animals on tile
                        if(tile && tile.animal) foundAnimal = true;
                    }
                    if(foundAnimal) {
                        reward += 15;
                        this.smartSettlements++; // Track smart settlement
                    }
                    if(foundBerry) {
                        reward += 10;
                        if(!foundAnimal) this.smartSettlements++; // Count if not already counted
                    }
                }

                // --- CRISIS PENALTIES ---
                if(currentState.includes('WC1')) reward -= 10;
                if(currentState.includes('FC1')) reward -= 10;

                // --- FOOD REWARD ---
                let prevFoodBucket = parseInt(prevState.match(/F(\d+)/)?.[1] || 0);
                let currFoodBucket = parseInt(currentState.match(/F(\d+)/)?.[1] || 0);
                if(currFoodBucket > prevFoodBucket) reward += (currFoodBucket - prevFoodBucket) * 3;

                // --- SURVIVAL BONUS ---
                reward += 1;

                // --- ACTION PENALTIES/BONUSES ---
                if(action === 'WAIT') reward -= 5;
                if(action === 'PASS_YEAR' && resCount > 0) reward += 5;

                if(actualPop > this.episodeStartPop || (Game.zoneCount || 0) > this.episodeStartRes || stage > this.episodeStartStage) {
                    this.progressMade = true;
                }

                if(!this.progressMade && Game.gameState === 'CITY' && year < 2) {
                    reward = Math.min(reward, 0);
                }

                return reward;
            },
            
            // Run one step of training
            step: function() {
                try {
                    if(!this.isTraining || this.isResetting) return; // Skip if resetting
                    
                    // Track steps per episode for timeout
                    if(!this.stepCount) this.stepCount = 0;
                    this.stepCount++;
                    
                    // === EXPLORATION TEST MODE TRACKING ===
                    if(this.explorationTestMode) {
                        this.trackExploration();
                    }
                    
                    // Track player position to detect stuck AI (only in WANDER mode)
                    let playerPos = Game.player ? `${Game.player.x},${Game.player.y}` : 'none';
                    if(Game.gameState === 'WANDER') {
                        if(playerPos === this.lastPlayerPos) {
                            this.stuckCounter = (this.stuckCounter || 0) + 1;
                            
                            // Log why we might be stuck every 20 stuck steps
                            if(this.stuckCounter % 20 === 0) {
                                let food = Game.inventory ? Game.inventory.food : 0;
                                let thirst = Game.thirst || 100;
                                console.log('‚ö†Ô∏è AI stuck! Count:', this.stuckCounter, 'Food:', food, 'Thirst:', thirst, 'Pos:', playerPos);
                                
                                // If stuck due to no food, end immediately
                                if(food <= 0) {
                                    this.log('üçñ Stuck with no food - ending episode');
                                }
                            }
                        } else {
                            this.stuckCounter = 0;
                            this.lastPlayerPos = playerPos;
                        }
                    } else {
                        // In CITY mode, track if we're making progress (building, passing years)
                        // Reset stuck counter only if year changed or we built something
                        let currentYear = Game.year || 0;
                        let currentBuildCount = Game.blds ? Game.blds.length : 0;
                        
                        if(currentYear !== this.lastCityYear || currentBuildCount !== this.lastCityBuildCount) {
                            this.stuckCounter = 0;
                            this.lastCityYear = currentYear;
                            this.lastCityBuildCount = currentBuildCount;
                        } else {
                            // Not making progress in CITY mode
                            this.stuckCounter = (this.stuckCounter || 0) + 1;
                            
                            // Log periodically
                            if(this.stuckCounter % 100 === 0) {
                                console.log('‚ö†Ô∏è CITY mode idle! Steps without progress:', this.stuckCounter, 'Year:', currentYear, 'Buildings:', currentBuildCount);
                            }
                            
                            // Force PASS_YEAR if stuck too long (500 steps without progress)
                            if(this.stuckCounter > 500 && this.stuckCounter % 100 === 0) {
                                console.log('‚è© Forcing PASS_YEAR due to idle');
                                Game.endTurn();
                                this.stuckCounter = 0;
                            }
                        }
                    }
                    
                    var prevState = this.getState();
                    var action = this.chooseAction(prevState);
                    
                    // Debug log every 100 steps (reduced from 50 for performance)
                    if(this.stepCount % 100 === 1) {
                        console.log('ü§ñ Step', this.stepCount, '| State:', prevState, '| Action:', action, '| Pop:', Game.pop, '| Food:', Game.inventory ? Game.inventory.food : Game.food);
                    }
                    
                    // Execute action
                    var success = this.executeAction(action);
                    
                    // Track build order for experience replay
                    if(success && action.startsWith('BUILD_')) {
                        if(!this.episodeBuildOrder) this.episodeBuildOrder = [];
                        this.episodeBuildOrder.push(action);
                    }
                    
                    // Get new state and reward
                    var currentState = this.getState();
                    var reward = this.calculateReward(prevState, currentState, action);
                    
                    // Update Q-table
                    this.updateQ(prevState, action, reward, currentState);
                    
                    this.totalReward += reward;
                    
                    // === PLAYTESTING: Detect bugs and track balance (less frequent for performance) ===
                    if(this.stepCount % 50 === 0) {
                        this.detectBugs();
                        this.trackBalanceMetrics();
                        this.detectExploits();
                    }
                    this.trackCoverage(action);
                    
                    // Update live stats every 25 steps (reduced from 10 for performance)
                    if(this.stepCount % 25 === 0) {
                        this.updateLiveStats(currentState, action);
                    }
                    
                    // Check for game over (multiple conditions)
                    var gameOverPanel = document.getElementById('gameover-screen');
                    var panelVisible = gameOverPanel && (gameOverPanel.style.display === 'flex' || gameOverPanel.style.display === 'block');
                    var noPop = (Game.pop !== undefined && Game.pop <= 0);
                    var tooManyYears = (Game.year > 100);
                    var tooManySteps = (this.stepCount > 3000); // Safety timeout (reduced from 5000)
                    var isStuck = (this.stuckCounter > 100); // Stuck for 100+ steps in WANDER
                    var isCityIdle = (Game.gameState === 'CITY' && this.stuckCounter > 1000); // 1000 steps without progress in CITY
                    var noFood = (Game.gameState === 'WANDER' && Game.inventory && Game.inventory.food <= 0);
                    
                    var isGameOver = panelVisible || noPop || tooManyYears || tooManySteps || isStuck || isCityIdle || noFood;
                    
                    if(isGameOver && !this.isResetting) {
                        let reason = panelVisible ? 'gameover' : noPop ? 'no-pop' : tooManyYears ? 'too-many-years' : tooManySteps ? 'timeout' : isStuck ? 'stuck' : isCityIdle ? 'city-idle' : noFood ? 'starved' : 'unknown';
                        
                        // Detailed death cause analysis
                        let deathCause = reason;
                        if(Game.gameState === 'WANDER') {
                            let thirst = Game.thirst || 0;
                            if(thirst <= 0) deathCause = 'thirst';
                            else if(noFood) deathCause = 'starved-wander';
                        } else if(Game.gameState === 'CITY') {
                            let waterCap = (Game.wellCount || 0) * 100;
                            if(Game.pop > waterCap) deathCause = 'water-crisis';
                            else if(Game.food <= 0) deathCause = 'famine';
                            else if(noPop) deathCause = 'population-collapse';
                        }
                        
                        this.recordDeath(deathCause);
                        this.recordSuccess(Game.pop || 0, Game.year || 0);
                        
                        // === EXPLORATION TEST MODE: Record death for analysis ===
                        if(this.explorationTestMode) {
                            this.recordExploreDeath(deathCause);
                        }
                        
                        this.log('üõë DEATH (' + deathCause + '): pop=' + Game.pop + ', yr=' + Game.year + ', steps=' + this.stepCount);
                        this.stepCount = 0;
                        this.stuckCounter = 0;
                        this.lastPlayerPos = null;
                        this.endEpisode();
                    }
                } catch(err) {
                    console.error('AI step error:', err);
                    // Don't let errors kill training
                }
            },
            
            // Log to the AI panel
            log: function(msg) {
                var logEl = document.getElementById('ai-log');
                if(logEl) {
                    var time = new Date().toLocaleTimeString();
                    logEl.innerHTML = '[' + time + '] ' + msg + '<br>' + logEl.innerHTML;
                    // Keep only last 50 lines
                    var lines = logEl.innerHTML.split('<br>');
                    if(lines.length > 50) {
                        logEl.innerHTML = lines.slice(0, 50).join('<br>');
                    }
                }
                console.log('ü§ñ ' + msg);
            },
            
            // Update live stats display
            updateLiveStats: function(state, action) {
                var stateEl = document.getElementById('ai-current-state');
                var actionEl = document.getElementById('ai-current-action');
                var stepEl = document.getElementById('ai-step-count');
                var popEl = document.getElementById('ai-current-pop');
                
                if(stateEl) stateEl.textContent = 'State: ' + (state || '--');
                if(actionEl) actionEl.textContent = 'Action: ' + (action || '--');
                if(stepEl) stepEl.textContent = 'Steps: ' + (this.stepCount || 0);
                if(popEl) popEl.textContent = 'Pop: ' + (Game.pop || 0) + ' | Food: ' + Math.floor(Game.food || 0) + ' | Yr: ' + (Game.year || 0);
            },
            
            // End current episode and start new one
            endEpisode: function() {
                if(this.isResetting) {
                    return; // Already resetting, skip
                }
                this.isResetting = true;
                this.stepCount = 0;

                this.episode++;
                this.gamesPlayed++;
                this.episodeRewards.push(this.totalReward);

                if(this.totalReward > this.bestScore) {
                    this.bestScore = this.totalReward;
                }
                
                // === EXPERIENCE REPLAY - Record this episode ===
                this.recordExperience();
                this.recordFailurePattern();

                // === TRACK LEARNING ANALYTICS ===
                // Track if AI built a city
                if(Game.gameState === 'CITY') {
                    this.citiesBuilt++;
                    
                    // Track best population
                    if(Game.pop > this.bestPopulation) {
                        this.bestPopulation = Game.pop;
                    }
                    
                    // Track best survival years
                    if(Game.year > this.bestSurvivalYears) {
                        this.bestSurvivalYears = Game.year;
                    }
                    
                    // Track balanced cities (all 3 zone types)
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                    if(resCount > 0 && comCount > 0 && indCount > 0) {
                        this.balancedCities++;
                    }
                }
                
                // === RESET MILESTONE TRACKERS FOR NEW EPISODE ===
                this.milestone100 = false;
                this.milestone500 = false;
                this.milestone1k = false;
                this.milestone5k = false;
                this.milestone10k = false;
                this.milestone50k = false;
                this.lastKnownYear = 0;
                
                // === RESET TUTORIAL STATE FOR NEW EPISODE ===
                this.tutorialMode = undefined; // Will be randomly set in chooseAction
                this.tutorialStep = 0;
                this.tutorialCycle = 0;
                this.tutorialWaitUntilYear = 0;
                
                // === RESET MACRO TACTIC FOR NEW EPISODE ===
                this.activeMacroTactic = null;
                this.currentMacroStep = 0;
                this.macroStepStartYear = 0;
                this.lastDeathCause = null; // Reset death cause (consecutiveDeaths stays)
                this.waterSeekMode = false;
                
                // === RESET PROGRESSION TRACKERS ===
                this.progressMade = false;
                this.lastExpansionRadius = 0;
                this.lastQuadrantCount = 0;
                this.lastStageAwarded = 0;
                this.lastLevelUnlockAward = 1;
                this.episodeStartSnapshotTaken = false;
                this.episodeBuildOrder = []; // Track build sequence for experience replay
                this.useReplayMode = false;  // Reset replay mode
                
                // === CURRICULUM PHASE ADVANCEMENT ===
                let oldPhase = this.learningPhase;
                if(this.learningPhase === 1 && this.citiesBuilt >= this.phase1Threshold) {
                    this.learningPhase = 2;
                    this.log('üéì PHASE 2: Learning city building!');
                }
                if(this.learningPhase === 2 && this.balancedCities >= this.phase2Threshold) {
                    this.learningPhase = 3;
                    this.log('üéì PHASE 3: Mastering balanced cities!');
                }
                
                // Track reward history for graph (keep last 20)
                this.rewardHistory.push(this.totalReward);
                if(this.rewardHistory.length > 20) {
                    this.rewardHistory.shift();
                }
                
                // Draw reward graph
                this.drawRewardGraph();

                // === ADAPTIVE EXPLORATION RATE ===
                // If we're failing a lot, explore more. If succeeding, exploit more.
                let baseDecay = this.explorationDecay;
                if(this.consecutiveDeaths >= 5) {
                    // Stuck - increase exploration
                    this.explorationRate = Math.min(0.5, this.explorationRate * 1.2);
                    this.log('üîÑ Stuck! Increasing exploration to ' + (this.explorationRate * 100).toFixed(1) + '%');
                } else if(this.totalReward > 100 && Game.pop >= 20) {
                    // Good run - faster decay to exploit knowledge
                    this.explorationRate = Math.max(this.minExploration, this.explorationRate * baseDecay * 0.9);
                } else {
                    // Normal decay
                    this.explorationRate = Math.max(this.minExploration, this.explorationRate * baseDecay);
                }
                
                // === EPISODE SUMMARY ===
                let tierStrategy = this.getPopTierStrategy(Game.pop || 0);
                let expansionStats = this.getCityExpansionStats();
                this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                this.log(`üìä EPISODE ${this.episode} SUMMARY:`);
                this.log(`   üéØ Reward: ${this.totalReward.toFixed(0)} | Best: ${this.bestScore.toFixed(0)}`);
                this.log(`   üë• Pop: ${Game.pop || 0} (${tierStrategy.tier}) | Year: ${Game.year || 0}`);
                this.log(`   üèóÔ∏è Buildings: Res=${Game.zoneCount||0} Well=${Game.wellCount||0} Com=${Game.blds ? Game.blds.filter(b=>b.t==='COM').length : 0} Ind=${Game.blds ? Game.blds.filter(b=>b.t==='IND').length : 0}`);
                this.log(`   üåç Expansion: radius=${expansionStats.radius} quadrants=${expansionStats.quadrants}`);
                if(this.activeMacroTactic) {
                    this.log(`   üìã Tactic: ${this.activeMacroTactic.name} (step ${this.currentMacroStep || 0})`);
                }
                if(this.lastDeathCause) {
                    this.log(`   üíÄ Death cause: ${this.lastDeathCause} (${this.consecutiveDeaths} in a row)`);
                }
                this.log(`   üé≤ Exploration: ${(this.explorationRate * 100).toFixed(1)}%`);
                this.log(`   üíæ Buffer: ${(this.experienceBuffer||[]).length}/${this.maxBufferSize} | Templates: ${(this.successTemplates||[]).length}`);
                if(this.bestRunEver) {
                    this.log(`   üèÜ Best Ever: Pop ${this.bestRunEver.pop}, Year ${this.bestRunEver.year}`);
                }
                this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                // Log progress
                this.log('üéÆ Ep ' + this.episode + ': R=' + this.totalReward.toFixed(0) + ', Best=' + this.bestScore.toFixed(0));

                // --- Persistent logging ---
                try {
                    let sessionId = localStorage.getItem('citgame_ai_session_id');
                    if(!sessionId) {
                        sessionId = 'sess_' + Date.now() + '_' + Math.floor(Math.random()*1000000);
                        localStorage.setItem('citgame_ai_session_id', sessionId);
                    }
                    let log = JSON.parse(localStorage.getItem('citgame_ai_log') || '[]');
                    log.push({
                        session: sessionId,
                        episode: this.episode,
                        reward: this.totalReward,
                        bestScore: this.bestScore,
                        explorationRate: this.explorationRate,
                        statesLearned: Object.keys(this.qTable).length,
                        timestamp: new Date().toISOString()
                    });
                    localStorage.setItem('citgame_ai_log', JSON.stringify(log));
                } catch(e) { console.warn('AI log error', e); }

                // Update UI
                this.updateTrainingUI();

                // Reset for next episode
                this.totalReward = 0;

                // Delay before reset so user can see death screen (4 seconds at slow speeds)
                let deathScreenDelay = this.trainingSpeed <= 1 ? 4000 : (this.trainingSpeed <= 5 ? 2000 : 500);
                let self = this;
                setTimeout(function() {
                    self.forceResetGame();
                    self.isResetting = false;
                }, deathScreenDelay);
            },
            
            // Force reset game without any dialogs or page reloads
            forceResetGame: function() {
                try {
                    console.log('üîÑ forceResetGame starting...');
                    
                    // Hide game over screen
                    var gameOverPanel = document.getElementById('gameover-screen');
                    if(gameOverPanel) gameOverPanel.style.display = 'none';
                    
                    // Direct game state reset
                    if(typeof Game !== 'undefined') {
                        // Re-init with new seed - this will reset everything including player
                        Game.init(Math.floor(Math.random() * 999999));
                        
                        console.log('üîÑ Game.init complete. Player:', Game.player ? 'OK at ' + Game.player.x + ',' + Game.player.y : 'NULL');
                        console.log('üîÑ Tiles:', Game.tiles ? Game.tiles.length + 'x' + (Game.tiles[0] ? Game.tiles[0].length : 0) : 'NULL');
                        
                        // Force camera to player position (Game.init sets this, but ensure it)
                        if(typeof Controller !== 'undefined' && Game.player) {
                            Controller.cam.x = Game.player.x * CFG.TILE;
                            Controller.cam.y = Game.player.y * CFG.TILE;
                            Controller.cam.z = CFG.CAMERA.START_ZOOM || 1;
                            console.log('üîÑ Camera set to:', Controller.cam.x, Controller.cam.y);
                        }
                        
                        // Force explore starting area (in case spawnPlayer missed it)
                        if(Game.player && Game.exploreArea) {
                            Game.exploreArea(Game.player.x, Game.player.y, 5);
                        }

                        this.episodeStartSnapshotTaken = false;
                        this.progressMade = false;
                        this.lastExpansionRadius = 0;
                        this.lastQuadrantCount = 0;
                        this.lastStageAwarded = 0;
                        this.lastLevelUnlockAward = 1;
                        this.assignMacroTactic(true);
                    }
                    
                    // Reset progression
                    if(typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) {
                        PROGRESSION.reset();
                    }
                    
                    // Update UI
                    if(typeof Controller !== 'undefined' && Controller.updateUI) {
                        Controller.updateUI();
                    }
                    
                    // Force a render refresh
                    if(typeof Renderer !== 'undefined' && Renderer.resize) {
                        Renderer.resize();
                    }
                    
                    console.log('üîÑ forceResetGame complete!');
                    
                } catch(err) {
                    console.error('Force reset error:', err);
                    // DO NOT reload page - just continue
                }
            },
            
            // Start training
            startTraining: function() {
                var self = this;
                this.isTraining = true;
                this.isResetting = false;
                this.stepCount = 0;
                this.loopCounter = 0;
                this.errorCount = 0;
                
                // Initialize wisdom system if not already done
                if(!this.wisdom || !this.wisdom.survivalRules || this.wisdom.survivalRules.length === 0) {
                    this.initWisdom();
                    this.log('üß† Wisdom system initialized');
                }
                
                // Load any saved playbooks from watching player
                this.loadPlaybooks();
                this.playbookStep = 0;
                this.lastAIBuildPos = null;
                this.lastAIBuildYear = 0;
                this.aiSettlementPos = null;
                this.episodeStartSnapshotTaken = false;
                this.progressMade = false;
                this.lastExpansionRadius = 0;
                this.lastQuadrantCount = 0;
                this.lastStageAwarded = 0;
                this.lastLevelUnlockAward = 1;
                this.activeMacroTactic = null;
                this.macroStepIndex = 0;
                this.macroWaitUntilYear = 0;
                this.macroRotationIndex = this.macroPlaybooks ? Math.floor(Math.random() * this.macroPlaybooks.length) : 0;
                this.assignMacroTactic(false);
                
                if(this.savedPlaybooks && this.savedPlaybooks.length > 0) {
                    this.log('üìö Using learned playbook with ' + this.savedPlaybooks[0].playbook.length + ' steps!');
                    this.log('üéØ Target: Pop=' + this.savedPlaybooks[0].finalPop + ', Year=' + this.savedPlaybooks[0].finalYear);
                } else {
                    this.log('üìù No playbook - Watch player to learn their strategy!');
                }
                
                this.log('‚ñ∂Ô∏è Training STARTED at speed ' + this.trainingSpeed + 'x');
                
                // Show floating hard stop button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'block';
                
                // Clear any existing intervals
                if(this.trainingIntervalId) clearInterval(this.trainingIntervalId);
                
                // The main training interval - NEVER stops unless user clicks stop
                this.trainingIntervalId = setInterval(function() {
                    try {
                        if(!self.isTraining) {
                            return; // Don't clear interval, just skip
                        }
                        
                        self.loopCounter++;
                        
                        // Skip steps while resetting
                        if(self.isResetting) {
                            return; // Let reset complete
                        }
                        
                        // Run steps with error protection
                        // Handle fractional speeds (< 1) by skipping frames
                        if(self.trainingSpeed < 1) {
                            // For 0.25x speed: only run every 4th frame (0.25 = 1/4)
                            // For 0.1x speed: only run every 10th frame
                            // For 0.05x speed: only run every 20th frame (super slow!)
                            self.frameSkipCounter = (self.frameSkipCounter || 0) + self.trainingSpeed;
                            if(self.frameSkipCounter >= 1) {
                                self.frameSkipCounter -= 1;
                                try {
                                    self.step();
                                } catch(stepErr) {
                                    self.errorCount++;
                                    if(self.errorCount < 10) {
                                        console.error('Step error:', stepErr);
                                    }
                                }
                            }
                        } else {
                            // Normal speed: run multiple steps per frame
                            for(var i = 0; i < self.trainingSpeed; i++) {
                                try {
                                    self.step();
                                } catch(stepErr) {
                                    self.errorCount++;
                                    if(self.errorCount < 10) {
                                        console.error('Step error:', stepErr);
                                    }
                                }
                            }
                        }
                        
                        // Periodic status log
                        if(self.loopCounter % 600 === 0) { // Every ~10 seconds
                            self.log('üíì Running: Ep=' + self.episode + ', Loop=' + self.loopCounter + ', Errors=' + self.errorCount);
                        }
                        
                    } catch(loopErr) {
                        console.error('Loop error:', loopErr);
                        self.errorCount++;
                    }
                }, 16);
                
                this.updateTrainingUI();
            },
            
            // Stop training
            stopTraining: function() {
                this.isTraining = false;
                if(this.trainingIntervalId) {
                    clearInterval(this.trainingIntervalId);
                    this.trainingIntervalId = null;
                }
                
                // Hide floating hard stop button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'none';
                
                this.log('‚èπÔ∏è STOPPED - ' + this.episode + ' episodes, ' + this.errorCount + ' errors');
                this.updateTrainingUI();
            },
            
            // HARD STOP - Emergency stop all AI activity
            hardStop: function() {
                // Stop training
                this.isTraining = false;
                if(this.trainingIntervalId) {
                    clearInterval(this.trainingIntervalId);
                    this.trainingIntervalId = null;
                }
                
                // Stop watching
                this.isWatching = false;
                
                // Stop exploration test
                if(this.explorationTestMode) {
                    this.explorationTestMode = false;
                    var exploreBtn = document.getElementById('ai-explore-btn');
                    var exploreStatus = document.getElementById('ai-explore-status');
                    if(exploreBtn) {
                        exploreBtn.style.background = '#E91E63';
                        exploreBtn.textContent = 'üó∫Ô∏è Explore Test';
                    }
                    if(exploreStatus) exploreStatus.style.display = 'none';
                }
                
                // Hide floating button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'none';
                
                // Update all UI
                this.updateTrainingUI();
                
                this.log('üö® HARD STOP - All AI activity halted!');
                Controller.toast('üö® AI HARD STOPPED');
            },
            
            // Get memory usage stats
            getMemoryStats: function() {
                let qTableSize = Object.keys(this.qTable).length;
                let bufferSize = (this.experienceBuffer || []).length;
                let templateSize = (this.successTemplates || []).length;
                let playbookSize = (this.savedPlaybooks || []).length;
                
                // Estimate memory usage (rough)
                let estimatedMB = (JSON.stringify(this.qTable).length / 1024 / 1024).toFixed(2);
                
                return {
                    qTableStates: qTableSize,
                    experienceBuffer: bufferSize,
                    templates: templateSize,
                    playbooks: playbookSize,
                    estimatedMB: estimatedMB
                };
            },
            
            // Clear memory to reduce usage
            clearMemory: function(keepBest = true) {
                let oldStats = this.getMemoryStats();
                
                // Clear Q-table
                this.qTable = {};
                
                // Clear experience buffer but keep best if requested
                if(keepBest && this.bestRunEver) {
                    this.experienceBuffer = [this.bestRunEver];
                } else {
                    this.experienceBuffer = [];
                }
                
                // Keep only top 3 templates
                if(this.successTemplates && this.successTemplates.length > 3) {
                    this.successTemplates = this.successTemplates.slice(0, 3);
                }
                
                // Clear playbooks except best
                if(this.savedPlaybooks && this.savedPlaybooks.length > 1) {
                    this.savedPlaybooks = this.savedPlaybooks.slice(0, 1);
                }
                
                // Clear movement history
                if(this.movementHistory) this.movementHistory = [];
                
                // Clear death locations
                if(this.exploreStats && this.exploreStats.deathLocations) {
                    this.exploreStats.deathLocations = this.exploreStats.deathLocations.slice(-100);
                }
                
                let newStats = this.getMemoryStats();
                this.log(`üßπ Memory cleared: ${oldStats.qTableStates} ‚Üí ${newStats.qTableStates} states, ${oldStats.estimatedMB}MB ‚Üí ${newStats.estimatedMB}MB`);
                Controller.toast(`üßπ Memory cleared! Was ${oldStats.estimatedMB}MB`);
                
                this.updateTrainingUI();
            },
            
            // Export stats to file
            exportStats: function() {
                var stats = {
                    totalEpisodes: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    statesLearned: Object.keys(this.qTable).length,
                    recentRewards: this.episodeRewards.slice(-100),
                    avgReward: this.episodeRewards.length > 0 ? 
                        (this.episodeRewards.reduce(function(a,b){return a+b;}, 0) / this.episodeRewards.length).toFixed(2) : 0,
                    exportDate: new Date().toISOString()
                };
                
                var blob = new Blob([JSON.stringify(stats, null, 2)], {type: 'application/json'});
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.download = 'ai_training_stats_' + this.episode + '_episodes.json';
                a.click();
                URL.revokeObjectURL(url);
                this.log('üìä Stats exported!');
            },
            
            // ===== FILE-BASED Q-TABLE SAVE/LOAD =====
            // Save Q-table to a downloadable JSON file
            saveBrainToFile: function() {
                var data = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    qTable: this.qTable,
                    episode: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    episodeRewards: this.episodeRewards.slice(-100),
                    bestRunEver: this.bestRunEver,
                    successTemplates: this.successTemplates || [],
                    experienceBuffer: this.experienceBuffer || []
                };
                
                var blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                var filename = 'civilzones_ai_ep' + this.episode + '_' + new Date().toISOString().slice(0,10) + '.json';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                Controller.toast('üì• AI saved to file: ' + filename);
                this.log('üì• AI brain saved: ' + Object.keys(this.qTable).length + ' states');
            },
            
            // Load Q-table from a JSON file
            loadBrainFromFile: function(file) {
                if(!file) return;
                
                var reader = new FileReader();
                var self = this;
                reader.onload = function(e) {
                    try {
                        var data = JSON.parse(e.target.result);
                        
                        // Validate the file has Q-table data
                        if(!data.qTable) {
                            Controller.toast('‚ùå Invalid AI file: missing qTable data', true);
                            return;
                        }
                        
                        // Load all data
                        self.qTable = data.qTable;
                        self.episode = data.episode || 0;
                        self.bestScore = data.bestScore || 0;
                        self.explorationRate = data.explorationRate || 0.1;
                        self.episodeRewards = data.episodeRewards || [];
                        
                        // Load experience data if present
                        if(data.bestRunEver) self.bestRunEver = data.bestRunEver;
                        if(data.successTemplates) self.successTemplates = data.successTemplates;
                        if(data.experienceBuffer) self.experienceBuffer = data.experienceBuffer;
                        
                        self.updateTrainingUI();
                        
                        var statesCount = Object.keys(self.qTable).length;
                        Controller.toast('üì§ Loaded AI from file! ' + statesCount + ' states, Episode ' + self.episode);
                        self.log('üì§ AI brain loaded: ' + statesCount + ' states, Episode ' + self.episode);
                        
                    } catch(err) {
                        Controller.toast('‚ùå Error loading AI file: ' + err.message, true);
                        console.error('Error loading AI file:', err);
                    }
                };
                reader.readAsText(file);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // EXPLORATION TEST MODE - Test map collection in WANDER mode
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            toggleExplorationTest: function() {
                this.explorationTestMode = !this.explorationTestMode;
                
                let btn = document.getElementById('ai-explore-btn');
                let status = document.getElementById('ai-explore-status');
                
                if(this.explorationTestMode) {
                    // Start exploration test
                    this.resetExploreStats();
                    this.exploreStats.startTime = Date.now();
                    
                    // Count total explorable tiles
                    this.countExplorableTiles();
                    
                    if(btn) btn.style.background = '#C2185B';
                    if(btn) btn.textContent = 'üó∫Ô∏è Stop Test';
                    if(status) status.style.display = 'block';
                    
                    // Make sure we're in WANDER mode
                    if(Game.gameState !== 'WANDER') {
                        Controller.toast('‚ö†Ô∏è Exploration test works best in WANDER mode. Starting new game...');
                        this.forceResetGame();
                    }
                    
                    // Start training if not already
                    if(!this.isTraining) {
                        this.startTraining();
                    }
                    
                    this.log('üó∫Ô∏è EXPLORATION TEST STARTED - Goal: Visit all tiles, collect everything!');
                    Controller.toast('üó∫Ô∏è Exploration Test Mode: ON');
                } else {
                    // Stop exploration test
                    if(btn) btn.style.background = '#E91E63';
                    if(btn) btn.textContent = 'üó∫Ô∏è Explore Test';
                    if(status) status.style.display = 'none';
                    
                    // Show final report before resetting
                    this.showExplorationReport();
                    
                    // Reset stats so next run starts fresh
                    this.resetExploreStats();
                    this.updateExploreUI();
                    
                    this.log('üó∫Ô∏è EXPLORATION TEST STOPPED & RESET');
                    Controller.toast('üó∫Ô∏è Exploration Test Mode: OFF (Stats Reset)');
                }
            },
            
            resetExploreStats: function() {
                this.exploreStats = {
                    tilesVisited: new Set(),
                    totalTiles: 0,
                    resourcesCollected: 0,
                    berriesCollected: 0,
                    woodCollected: 0,
                    nomadsRecruited: 0,
                    animalsHunted: 0,
                    deaths: 0,
                    totalSteps: 0,
                    stepsThisRun: 0,
                    runsCompleted: 0,
                    deathLocations: [],
                    dangerZones: {},
                    startTime: Date.now()
                };
            },
            
            countExplorableTiles: function() {
                if(!Game.tiles) return;
                let count = 0;
                for(let x = 0; x < Game.tiles.length; x++) {
                    for(let y = 0; y < Game.tiles[x].length; y++) {
                        let tile = Game.tiles[x][y];
                        if(tile && tile.type !== 'WATER' && tile.type !== 'DEEP' && tile.type !== 'RIVER' && tile.type !== 'STONE') {
                            count++;
                        }
                    }
                }
                this.exploreStats.totalTiles = count;
                this.log(`üó∫Ô∏è Total explorable tiles: ${count}`);
            },
            
            // Called during step() when in exploration test mode
            trackExploration: function() {
                if(!this.explorationTestMode || Game.gameState !== 'WANDER') return;
                
                this.exploreStats.stepsThisRun++;
                this.exploreStats.totalSteps++;
                
                // Track current tile
                if(Game.player) {
                    let tileKey = `${Game.player.x},${Game.player.y}`;
                    this.exploreStats.tilesVisited.add(tileKey);
                    
                    // Check for resources on this tile
                    let tile = Game.tiles[Game.player.x][Game.player.y];
                    if(tile) {
                        // Track resource collection (the game auto-collects when walking over)
                        if(tile.entity) {
                            if(tile.entity.type === 'BERRY' && tile.entity.amount > 0) {
                                this.exploreStats.berriesCollected++;
                                this.exploreStats.resourcesCollected++;
                            } else if(tile.entity.type === 'NOMAD') {
                                this.exploreStats.nomadsRecruited++;
                                this.exploreStats.resourcesCollected++;
                            }
                        }
                        if(tile.tree) {
                            this.exploreStats.woodCollected++;
                            this.exploreStats.resourcesCollected++;
                        }
                        if(tile.animal) {
                            this.exploreStats.animalsHunted++;
                            this.exploreStats.resourcesCollected++;
                        }
                    }
                }
                
                // Update UI every 10 steps
                if(this.exploreStats.totalSteps % 10 === 0) {
                    this.updateExploreUI();
                }
            },
            
            // Called when AI dies in exploration test mode
            recordExploreDeath: function(cause) {
                if(!this.explorationTestMode) return;
                
                this.exploreStats.deaths++;
                this.exploreStats.runsCompleted++;
                
                // Record death location
                if(Game.player) {
                    let loc = {
                        x: Game.player.x,
                        y: Game.player.y,
                        cause: cause,
                        steps: this.exploreStats.stepsThisRun
                    };
                    this.exploreStats.deathLocations.push(loc);
                    
                    // Track danger zones
                    let key = `${Game.player.x},${Game.player.y}`;
                    this.exploreStats.dangerZones[key] = (this.exploreStats.dangerZones[key] || 0) + 1;
                }
                
                this.exploreStats.stepsThisRun = 0;
                this.updateExploreUI();
                
                this.log(`üíÄ Explore death #${this.exploreStats.deaths}: ${cause} at (${Game.player?.x},${Game.player?.y})`);
            },
            
            updateExploreUI: function() {
                let tilesEl = document.getElementById('ai-explore-tiles');
                let resEl = document.getElementById('ai-explore-resources');
                let deathsEl = document.getElementById('ai-explore-deaths');
                let dangerEl = document.getElementById('ai-explore-danger');
                
                let visited = this.exploreStats.tilesVisited.size;
                let total = this.exploreStats.totalTiles || 1;
                let pct = ((visited / total) * 100).toFixed(1);
                
                let avgSteps = this.exploreStats.deaths > 0 
                    ? (this.exploreStats.totalSteps / this.exploreStats.deaths).toFixed(0) 
                    : '--';
                
                // Calculate danger per tile (deaths per 100 tiles visited)
                let dangerPer100 = visited > 0 
                    ? ((this.exploreStats.deaths / visited) * 100).toFixed(2)
                    : '--';
                
                if(tilesEl) tilesEl.textContent = `Tiles: ${visited}/${total} (${pct}%)`;
                if(resEl) resEl.textContent = `Resources: ${this.exploreStats.resourcesCollected} (ü´ê${this.exploreStats.berriesCollected} ü™µ${this.exploreStats.woodCollected} üë•${this.exploreStats.nomadsRecruited})`;
                if(deathsEl) deathsEl.textContent = `Deaths: ${this.exploreStats.deaths} | Avg Steps/Death: ${avgSteps}`;
                if(dangerEl) dangerEl.textContent = `Danger/100 tiles: ${dangerPer100}% death chance`;
            },
            
            showExplorationReport: function() {
                let stats = this.exploreStats;
                let visited = stats.tilesVisited.size;
                let total = stats.totalTiles || 1;
                let pct = ((visited / total) * 100).toFixed(1);
                let avgSteps = stats.deaths > 0 ? (stats.totalSteps / stats.deaths).toFixed(0) : 'N/A';
                let dangerPer100 = visited > 0 ? ((stats.deaths / visited) * 100).toFixed(3) : 'N/A';
                let duration = stats.startTime ? ((Date.now() - stats.startTime) / 1000 / 60).toFixed(1) : '0';
                
                // Find most dangerous zones
                let dangerList = Object.entries(stats.dangerZones)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([loc, count]) => `  ${loc}: ${count} deaths`)
                    .join('\n') || '  None recorded';
                
                // Death cause breakdown
                let causes = {};
                stats.deathLocations.forEach(d => {
                    causes[d.cause] = (causes[d.cause] || 0) + 1;
                });
                let causeList = Object.entries(causes)
                    .sort((a, b) => b[1] - a[1])
                    .map(([cause, count]) => `  ${cause}: ${count}`)
                    .join('\n') || '  None recorded';
                
                let report = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üó∫Ô∏è EXPLORATION TEST REPORT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä COVERAGE:
  Tiles Visited: ${visited} / ${total} (${pct}%)
  Test Duration: ${duration} minutes
  Total Steps: ${stats.totalSteps}
  Runs Completed: ${stats.runsCompleted}

üì¶ RESOURCES COLLECTED:
  Berries: ${stats.berriesCollected}
  Wood: ${stats.woodCollected}
  Nomads Recruited: ${stats.nomadsRecruited}
  Animals Hunted: ${stats.animalsHunted}
  Total: ${stats.resourcesCollected}

üíÄ SURVIVAL ANALYSIS:
  Total Deaths: ${stats.deaths}
  Avg Steps Before Death: ${avgSteps}
  Danger Rating: ${dangerPer100}% per 100 tiles

‚ò†Ô∏è DEATH CAUSES:
${causeList}

‚ö†Ô∏è MOST DANGEROUS LOCATIONS:
${dangerList}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${visited >= total ? 'üèÜ MAP 100% EXPLORED!' : `Progress: ${pct}% - Keep exploring!`}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;
                
                console.log(report);
                alert(report);
                this.log('üìà Exploration report generated - check console for details');
            },
            
            // Modified chooseAction for exploration test mode
            getExplorationAction: function() {
                // In exploration mode, never settle - just explore!
                if(Game.gameState !== 'WANDER') return null;
                
                // Always WANDER to explore
                return 'WANDER';
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // WISDOM SYSTEM - Summarized knowledge instead of raw data
            // Complex ideas = simple working tasks put together logically
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Learned rules (wisdom extracted from experience)
            wisdom: {
                // Survival rules: condition ‚Üí required action
                survivalRules: [],
                // Build order patterns that work
                successFlows: [],
                // Ratios that work well
                optimalRatios: { wellsPerPop: 0.01, resPerWell: 4, comPerRes: 0.25, indPerRes: 0.15 },
                // Timing rules
                timingRules: [],
                // Statistics for rule confidence
                ruleStats: {}
            },
            
            // Initialize wisdom with basic rules
            initWisdom: function() {
                // Core survival rules (condition ‚Üí action ‚Üí priority)
                this.wisdom.survivalRules = [
                    { id: 'thirst', condition: 'pop > wells * 100', action: 'BUILD_WELL', priority: 10, confidence: 1.0 },
                    { id: 'housing', condition: 'pop >= housingCap - 5', action: 'BUILD_RES', priority: 8, confidence: 1.0 },
                    { id: 'food_low', condition: 'food < pop * 5', action: 'BUILD_COM', priority: 7, confidence: 0.8 },
                    { id: 'expand', condition: 'pop > 20 && roads < pop/5', action: 'BUILD_ROAD', priority: 5, confidence: 0.7 }
                ];
                
                // Basic success flow (what order to build)
                this.wisdom.successFlows = [
                    { name: 'Basic Start', steps: ['SETTLE', 'BUILD_WELL', 'BUILD_RES', 'BUILD_RES', 'BUILD_WELL', 'BUILD_COM'], avgPop: 0, uses: 0, successes: 0 }
                ];
                
                // Timing rules (when to do things)
                this.wisdom.timingRules = [
                    { id: 'early_wells', rule: 'Build well before pop > 50', yearRange: [0, 5], triggered: 0, helped: 0 },
                    { id: 'expand_y10', rule: 'Build roads after year 10', yearRange: [10, 20], triggered: 0, helped: 0 }
                ];
            },
            
            // Learn from a completed episode - extract patterns
            learnFromEpisode: function(result) {
                let dominated = result.pop < 10 && result.year < 5; // Quick death, not useful
                
                // Update rule confidence based on what happened
                if(result.deathCause) {
                    this.updateRuleFromFailure(result);
                }
                
                if(result.pop >= 20 || result.year >= 10) {
                    this.updateRuleFromSuccess(result);
                }
                
                // Update optimal ratios from successful runs
                if(result.pop >= 30 && result.year >= 15) {
                    this.updateOptimalRatios(result);
                }
                
                // Extract successful build flows
                if(result.buildOrder && result.buildOrder.length >= 5 && result.pop >= 25) {
                    this.extractSuccessFlow(result);
                }
                
                // Prune low-confidence rules
                this.pruneWisdom();
            },
            
            // Update rules based on failure
            updateRuleFromFailure: function(result) {
                let cause = result.deathCause || 'unknown';
                let stats = this.wisdom.ruleStats;
                
                // Track failure patterns (summarized, not individual)
                let patternKey = `${cause}_pop${Math.floor(result.pop/20)*20}_yr${Math.floor(result.year/10)*10}`;
                stats[patternKey] = stats[patternKey] || { count: 0, lastSeen: 0 };
                stats[patternKey].count++;
                stats[patternKey].lastSeen = Date.now();
                
                // If same failure happens 3+ times, create/strengthen a rule
                if(stats[patternKey].count >= 3) {
                    let existingRule = this.wisdom.survivalRules.find(r => r.id === 'learned_' + patternKey);
                    if(!existingRule) {
                        // Create new rule based on failure pattern
                        let newRule = this.createRuleFromFailure(cause, result);
                        if(newRule) {
                            this.wisdom.survivalRules.push(newRule);
                            console.log(`[WISDOM] New rule learned: ${newRule.id} ‚Üí ${newRule.action}`);
                        }
                    } else {
                        existingRule.confidence = Math.min(1.0, existingRule.confidence + 0.1);
                    }
                }
            },
            
            // Create a rule from repeated failures
            createRuleFromFailure: function(cause, result) {
                let pop = result.pop || 0;
                let wells = result.wells || 0;
                let res = result.resCount || 0;
                
                switch(cause) {
                    case 'thirst':
                    case 'water-crisis':
                    case 'dehydration':
                        return {
                            id: 'learned_water_' + Math.floor(pop/20)*20,
                            condition: `pop > ${Math.max(10, pop - 20)} && wells < ${wells + 1}`,
                            action: 'BUILD_WELL',
                            priority: 10,
                            confidence: 0.6,
                            learned: true
                        };
                    case 'famine':
                    case 'starvation':
                        return {
                            id: 'learned_food_' + Math.floor(pop/20)*20,
                            condition: `pop > ${Math.max(10, pop - 10)} && food < pop * 3`,
                            action: 'BUILD_COM',
                            priority: 8,
                            confidence: 0.6,
                            learned: true
                        };
                    case 'overcrowding':
                        return {
                            id: 'learned_housing_' + Math.floor(pop/20)*20,
                            condition: `pop >= housingCap - 10`,
                            action: 'BUILD_RES',
                            priority: 7,
                            confidence: 0.6,
                            learned: true
                        };
                    default:
                        return null;
                }
            },
            
            // Update rules from successful runs
            updateRuleFromSuccess: function(result) {
                // Boost confidence of rules that match successful state
                let wells = result.wells || 0;
                let pop = result.pop || 0;
                
                // If we had enough wells and survived, that ratio works
                if(pop > 50 && wells > 0) {
                    let ratio = pop / wells;
                    // Update optimal ratio (weighted average)
                    this.wisdom.optimalRatios.wellsPerPop = 
                        (this.wisdom.optimalRatios.wellsPerPop * 0.9) + ((1/ratio) * 0.1);
                }
            },
            
            // Update optimal ratios from very successful runs
            updateOptimalRatios: function(result) {
                if(!result.buildings) return;
                
                let res = result.buildings.filter(b => b.t === 'RES' || b.t === 'R').length;
                let com = result.buildings.filter(b => b.t === 'COM' || b.t === 'C').length;
                let ind = result.buildings.filter(b => b.t === 'IND' || b.t === 'I').length;
                let wells = result.wells || 0;
                
                if(res > 0) {
                    // Weighted update of ratios
                    let w = 0.1; // Learning weight
                    if(com > 0) this.wisdom.optimalRatios.comPerRes = this.wisdom.optimalRatios.comPerRes * (1-w) + (com/res) * w;
                    if(ind > 0) this.wisdom.optimalRatios.indPerRes = this.wisdom.optimalRatios.indPerRes * (1-w) + (ind/res) * w;
                    if(wells > 0) this.wisdom.optimalRatios.resPerWell = this.wisdom.optimalRatios.resPerWell * (1-w) + (res/wells) * w;
                }
            },
            
            // Extract a successful build flow
            extractSuccessFlow: function(result) {
                // Simplify build order (remove duplicates in sequence)
                let simplified = [];
                let lastAction = null;
                for(let action of result.buildOrder.slice(0, 15)) {
                    if(action !== lastAction || action === 'BUILD_RES') {
                        simplified.push(action);
                        lastAction = action;
                    }
                }
                
                // Check if similar flow exists
                let similar = this.wisdom.successFlows.find(f => {
                    if(f.steps.length !== simplified.length) return false;
                    let matches = 0;
                    for(let i = 0; i < f.steps.length; i++) {
                        if(f.steps[i] === simplified[i]) matches++;
                    }
                    return matches / f.steps.length > 0.7; // 70% similar
                });
                
                if(similar) {
                    // Update existing flow
                    similar.uses++;
                    similar.avgPop = (similar.avgPop * (similar.uses - 1) + result.pop) / similar.uses;
                    if(result.pop >= 30) similar.successes++;
                } else if(this.wisdom.successFlows.length < 10) {
                    // Add new flow
                    this.wisdom.successFlows.push({
                        name: `Flow_${Date.now()}`,
                        steps: simplified,
                        avgPop: result.pop,
                        uses: 1,
                        successes: result.pop >= 30 ? 1 : 0
                    });
                }
                
                // Sort by success rate and prune to top 5
                this.wisdom.successFlows.sort((a, b) => {
                    let rateA = a.uses > 0 ? a.successes / a.uses : 0;
                    let rateB = b.uses > 0 ? b.successes / b.uses : 0;
                    return rateB - rateA;
                });
                this.wisdom.successFlows = this.wisdom.successFlows.slice(0, 5);
            },
            
            // Prune low-value wisdom to save memory
            pruneWisdom: function() {
                // Remove low-confidence learned rules
                this.wisdom.survivalRules = this.wisdom.survivalRules.filter(r => 
                    !r.learned || r.confidence >= 0.3
                );
                
                // Remove old failure stats (older than 1 hour)
                let cutoff = Date.now() - 3600000;
                for(let key in this.wisdom.ruleStats) {
                    if(this.wisdom.ruleStats[key].lastSeen < cutoff && this.wisdom.ruleStats[key].count < 5) {
                        delete this.wisdom.ruleStats[key];
                    }
                }
                
                // Keep rule stats under 100 entries
                let statsKeys = Object.keys(this.wisdom.ruleStats);
                if(statsKeys.length > 100) {
                    statsKeys.sort((a, b) => this.wisdom.ruleStats[b].count - this.wisdom.ruleStats[a].count);
                    for(let i = 100; i < statsKeys.length; i++) {
                        delete this.wisdom.ruleStats[statsKeys[i]];
                    }
                }
            },
            
            // Get best action from wisdom (rule-based)
            getWisdomAction: function(ctx) {
                if(!ctx) return null;
                
                // Evaluate all survival rules
                let applicableRules = [];
                for(let rule of this.wisdom.survivalRules) {
                    if(this.evaluateCondition(rule.condition, ctx)) {
                        applicableRules.push(rule);
                    }
                }
                
                if(applicableRules.length === 0) return null;
                
                // Sort by priority * confidence
                applicableRules.sort((a, b) => (b.priority * b.confidence) - (a.priority * a.confidence));
                
                // Return highest priority action we can afford
                for(let rule of applicableRules) {
                    if(this.canAffordAction(rule.action, ctx)) {
                        return rule.action;
                    }
                }
                
                return null;
            },
            
            // Simple condition evaluator
            evaluateCondition: function(condition, ctx) {
                try {
                    // Replace variables with context values
                    let expr = condition
                        .replace(/pop/g, ctx.pop || 0)
                        .replace(/wells/g, ctx.wellCount || 0)
                        .replace(/housingCap/g, ctx.housingCap || 0)
                        .replace(/food/g, ctx.food || 0)
                        .replace(/roads/g, ctx.roadCount || 0)
                        .replace(/res/g, ctx.resCount || 0)
                        .replace(/com/g, ctx.comCount || 0)
                        .replace(/ind/g, ctx.indCount || 0);
                    
                    // Safely evaluate (basic math only)
                    return Function('"use strict"; return (' + expr + ')')();
                } catch(e) {
                    return false;
                }
            },
            
            // Get suggested flow step
            getFlowAction: function(buildCount) {
                if(this.wisdom.successFlows.length === 0) return null;
                
                // Use best flow (highest success rate)
                let bestFlow = this.wisdom.successFlows[0];
                if(buildCount < bestFlow.steps.length) {
                    return bestFlow.steps[buildCount];
                }
                return null;
            },
            
            // Show wisdom summary
            showWisdom: function() {
                let w = this.wisdom;
                let msg = 'üß† AI WISDOM SUMMARY\n\n';
                
                msg += 'üìã SURVIVAL RULES:\n';
                w.survivalRules.slice(0, 8).forEach(r => {
                    msg += `  ${r.learned ? 'üÜï' : 'üìå'} ${r.action} (priority:${r.priority}, conf:${(r.confidence*100).toFixed(0)}%)\n`;
                });
                
                msg += '\nüìä OPTIMAL RATIOS:\n';
                msg += `  Wells: 1 per ${Math.round(1/w.optimalRatios.wellsPerPop)} pop\n`;
                msg += `  RES per Well: ${w.optimalRatios.resPerWell.toFixed(1)}\n`;
                msg += `  COM per RES: ${(w.optimalRatios.comPerRes*100).toFixed(0)}%\n`;
                msg += `  IND per RES: ${(w.optimalRatios.indPerRes*100).toFixed(0)}%\n`;
                
                msg += '\nüîÑ SUCCESS FLOWS:\n';
                w.successFlows.slice(0, 3).forEach((f, i) => {
                    let rate = f.uses > 0 ? ((f.successes/f.uses)*100).toFixed(0) : 0;
                    msg += `  ${i+1}. ${f.steps.slice(0,5).join('‚Üí')}...\n`;
                    msg += `     AvgPop:${f.avgPop.toFixed(0)} Success:${rate}% (${f.uses} uses)\n`;
                });
                
                msg += `\nüíæ Stats tracked: ${Object.keys(w.ruleStats).length} patterns`;
                
                alert(msg);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // EXPERIENCE REPLAY BUFFER - Simplified, wisdom-based
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            experienceBuffer: [],
            maxBufferSize: 10, // Reduced from 50 - we learn rules, not store data
            successTemplates: [],  // Proven build sequences
            bestRunEver: null,     // Single best run for replay
            
            // Record experience at end of episode - now uses wisdom system
            recordExperience: function() {
                let exp = {
                    episode: this.episode,
                    reward: this.totalReward,
                    pop: Game.pop || 0,
                    year: Game.year || 0,
                    wells: Game.wellCount || 0,
                    resCount: Game.zoneCount || 0,
                    buildings: Game.blds ? Game.blds.map(b => ({t: b.t})) : [], // Just type, not position
                    buildOrder: (this.episodeBuildOrder || []).slice(0, 20), // Max 20 actions
                    deathCause: this.lastDeathCause
                };
                
                // LEARN FROM THIS EPISODE - extract wisdom instead of storing raw data
                this.learnFromEpisode(exp);
                
                // Only keep top 10 experiences (not 50)
                this.experienceBuffer.push(exp);
                this.experienceBuffer.sort((a, b) => b.reward - a.reward);
                if(this.experienceBuffer.length > this.maxBufferSize) {
                    this.experienceBuffer.pop();
                }
                
                // Track best run ever (single reference)
                if(!this.bestRunEver || exp.reward > this.bestRunEver.reward) {
                    this.bestRunEver = exp;
                    this.log(`üèÜ NEW BEST! Pop:${exp.pop} Year:${exp.year}`);
                }
            },
            
            // Create a success template from a good run
            createSuccessTemplate: function(exp) {
                // Check if we already have a similar template
                let dominated = this.successTemplates.some(t => 
                    t.pop >= exp.pop && t.year >= exp.year
                );
                if(dominated) return;
                
                let template = {
                    id: 'auto_' + Date.now(),
                    name: `Pop${exp.pop}_Yr${exp.year}`,
                    pop: exp.pop,
                    year: exp.year,
                    reward: exp.reward,
                    buildOrder: exp.buildOrder.slice(0, 20), // First 20 actions
                    stage: exp.stage,
                    created: new Date().toISOString()
                };
                
                // Remove templates this one dominates
                this.successTemplates = this.successTemplates.filter(t => 
                    t.pop > template.pop || t.year > template.year
                );
                
                this.successTemplates.push(template);
                this.successTemplates.sort((a, b) => b.pop - a.pop);
                
                // Keep only top 10 templates
                if(this.successTemplates.length > 10) {
                    this.successTemplates = this.successTemplates.slice(0, 10);
                }
                
                this.log(`üìã Created success template: ${template.name}`);
            },
            
            // Replay the best run (use its build order)
            replayBestRun: function() {
                if(!this.bestRunEver || !this.bestRunEver.buildOrder.length) {
                    Controller.toast('No best run recorded yet! Train more first.');
                    return;
                }
                
                // Convert best run to a playbook format
                this.replayPlaybook = this.bestRunEver.buildOrder.slice();
                this.replayStep = 0;
                this.useReplayMode = true;
                
                Controller.toast(`üîÑ Replaying best run (Pop:${this.bestRunEver.pop}, Yr:${this.bestRunEver.year})`);
                this.log(`üîÑ Replay mode: ${this.replayPlaybook.length} actions from best run`);
            },
            
            // Get next action from replay if active
            getReplayAction: function() {
                if(!this.useReplayMode || !this.replayPlaybook) return null;
                
                if(this.replayStep >= this.replayPlaybook.length) {
                    this.useReplayMode = false;
                    this.log('üîÑ Replay complete, resuming normal AI');
                    return null;
                }
                
                let action = this.replayPlaybook[this.replayStep];
                this.replayStep++;
                return action;
            },
            
            // Show success templates in a popup
            showSuccessTemplates: function() {
                if(this.successTemplates.length === 0) {
                    Controller.toast('No success templates yet! Get pop 30+ for 10+ years.');
                    return;
                }
                
                let msg = 'üìã SUCCESS TEMPLATES:\n\n';
                this.successTemplates.forEach((t, i) => {
                    msg += `${i+1}. ${t.name}\n`;
                    msg += `   Pop:${t.pop} Year:${t.year} Stage:${t.stage}\n`;
                    msg += `   Build: ${t.buildOrder.slice(0,5).join('‚Üí')}...\n\n`;
                });
                msg += '\nAI will automatically use these patterns!';
                
                alert(msg);
            },
            
            // Soft reset - keep best patterns but reset Q-table
            softReset: function() {
                // Keep these
                let keepTemplates = this.successTemplates.slice();
                let keepBest = this.bestRunEver;
                let keepBuffer = this.experienceBuffer.slice(0, 10); // Top 10
                let keepTacticStats = this.tacticStats ? {...this.tacticStats} : {};
                
                // Reset Q-table but boost exploration
                this.qTable = {};
                this.episode = 0;
                this.totalReward = 0;
                this.episodeRewards = [];
                this.explorationRate = 0.8; // High but not 1.0
                
                // Restore keepers
                this.successTemplates = keepTemplates;
                this.bestRunEver = keepBest;
                this.experienceBuffer = keepBuffer;
                this.tacticStats = keepTacticStats;
                
                this.log('‚ôªÔ∏è Soft reset: Q-table cleared, patterns preserved');
                Controller.toast('‚ôªÔ∏è Soft Reset! Patterns kept, fresh start.');
                this.updateTrainingUI();
            },
            
            // Use success template to guide early actions
            getTemplateGuidedAction: function(ctx) {
                if(this.successTemplates.length === 0) return null;
                if(Game.year > 15) return null; // Only guide early game
                
                // Find best matching template for current situation
                let bestTemplate = null;
                for(let t of this.successTemplates) {
                    if(t.buildOrder && t.buildOrder.length > 0) {
                        bestTemplate = t;
                        break;
                    }
                }
                
                if(!bestTemplate) return null;
                
                // Count how many builds we've done
                let buildCount = (Game.blds ? Game.blds.length : 0);
                if(buildCount < bestTemplate.buildOrder.length) {
                    // 30% chance to follow template (not deterministic)
                    if(Math.random() < 0.3) {
                        let suggestedAction = bestTemplate.buildOrder[buildCount];
                        if(this.canAffordAction(suggestedAction, ctx)) {
                            this.log(`üìã Template suggests: ${suggestedAction}`);
                            return suggestedAction;
                        }
                    }
                }
                
                return null;
            },
            
            // Check if AI can afford an action
            canAffordAction: function(action, ctx) {
                if(!ctx) return true;
                switch(action) {
                    case 'BUILD_RES': return ctx.food >= ctx.resCost.food && ctx.wood >= ctx.resCost.wood;
                    case 'BUILD_WELL': return ctx.food >= ctx.wellCost;
                    case 'BUILD_ROAD': return ctx.food >= ctx.roadCost;
                    case 'BUILD_COM': return ctx.food >= ctx.comCost.food && ctx.wood >= ctx.comCost.wood;
                    case 'BUILD_IND': return ctx.food >= ctx.indCost.food && ctx.wood >= ctx.indCost.wood;
                    default: return true;
                }
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // FAILURE PATTERN DETECTION - Learn what NOT to do
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            failurePatterns: {},
            
            recordFailurePattern: function() {
                if(!this.lastDeathCause) return;
                
                // Create pattern key from recent state
                let pop = Game.pop || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.zoneCount || 0;
                let year = Game.year || 0;
                
                let pattern = `${this.lastDeathCause}_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`;
                
                this.failurePatterns[pattern] = (this.failurePatterns[pattern] || 0) + 1;
                
                // If we've hit this pattern 3+ times, it's a known failure
                if(this.failurePatterns[pattern] >= 3) {
                    this.log(`‚ö†Ô∏è Known failure pattern: ${pattern} (${this.failurePatterns[pattern]}x)`);
                }
            },
            
            // Check if current state matches a known failure pattern
            isKnownFailureState: function() {
                let pop = Game.pop || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.zoneCount || 0;
                let year = Game.year || 0;
                
                // Check common failure causes
                let patterns = [
                    `thirst_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`,
                    `water-crisis_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`,
                    `famine_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`
                ];
                
                for(let p of patterns) {
                    if(this.failurePatterns[p] >= 3) {
                        return { pattern: p, count: this.failurePatterns[p] };
                    }
                }
                return null;
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ADVANCED PLAYTESTING FEATURES - Bug Detection & Balance Testing
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            playtestMetrics: {
                bugsFound: [],
                balanceIssues: [],
                exploitsDetected: [],
                coverageMap: {},
                milestoneTimings: []
            },
            
            // Detect potential bugs/anomalies in game state
            detectBugs: function() {
                let bugs = [];
                
                // Check for negative values
                if(Game.pop < 0) bugs.push({type: 'NEGATIVE_POP', value: Game.pop, severity: 'critical'});
                if(Game.food < 0) bugs.push({type: 'NEGATIVE_FOOD', value: Game.food, severity: 'warning'});
                if(Game.wood < 0) bugs.push({type: 'NEGATIVE_WOOD', value: Game.wood, severity: 'warning'});
                
                // Check for impossible states
                if(Game.pop > 0 && Game.zoneCount === 0) {
                    bugs.push({type: 'POP_WITHOUT_HOUSING', pop: Game.pop, severity: 'warning'});
                }
                
                // Check for water without wells
                if(Game.gameState === 'CITY' && Game.wellCount === 0 && Game.year > 3) {
                    bugs.push({type: 'NO_WATER_SOURCE', year: Game.year, severity: 'balance'});
                }
                
                // Check for NaN values
                if(isNaN(Game.pop)) bugs.push({type: 'NAN_POP', severity: 'critical'});
                if(isNaN(Game.food)) bugs.push({type: 'NAN_FOOD', severity: 'critical'});
                
                // Record any new bugs
                for(let bug of bugs) {
                    let bugKey = `${bug.type}_${bug.severity}`;
                    if(!this.playtestMetrics.bugsFound.some(b => `${b.type}_${b.severity}` === bugKey)) {
                        this.playtestMetrics.bugsFound.push({...bug, episode: this.episode, timestamp: Date.now()});
                        this.log(`üêõ BUG DETECTED: ${bug.type} (${bug.severity})`);
                    }
                }
                
                return bugs;
            },
            
            // Track game balance metrics
            trackBalanceMetrics: function() {
                let year = Game.year || 0;
                let pop = Game.pop || 0;
                
                // Track milestone timings
                let milestones = [
                    { name: 'first_building', condition: () => Game.blds && Game.blds.length >= 1 },
                    { name: 'pop_10', condition: () => pop >= 10 },
                    { name: 'pop_25', condition: () => pop >= 25 },
                    { name: 'pop_50', condition: () => pop >= 50 },
                    { name: 'pop_100', condition: () => pop >= 100 },
                    { name: 'first_industrial', condition: () => Game.blds && Game.blds.some(b => b.t === 'IND') },
                    { name: 'level_2_unlock', condition: () => PROGRESSION && PROGRESSION.unlockedLevels && PROGRESSION.unlockedLevels.includes(2) },
                    { name: 'level_3_unlock', condition: () => PROGRESSION && PROGRESSION.unlockedLevels && PROGRESSION.unlockedLevels.includes(3) },
                ];
                
                for(let m of milestones) {
                    if(!this['_milestone_' + m.name] && m.condition()) {
                        this['_milestone_' + m.name] = true;
                        this.playtestMetrics.milestoneTimings.push({
                            milestone: m.name,
                            year: year,
                            episode: this.episode,
                            timestamp: Date.now()
                        });
                        this.log(`üèÅ Milestone: ${m.name} at Year ${year}`);
                    }
                }
            },
            
            // Detect potential exploits
            detectExploits: function() {
                let exploits = [];
                let year = Game.year || 0;
                let pop = Game.pop || 0;
                
                // Fast population growth (might be exploit)
                if(year > 0 && pop / year > 10) {
                    exploits.push({type: 'FAST_POP_GROWTH', ratio: pop/year, severity: 'investigate'});
                }
                
                // Resource hoarding without using them
                if(Game.food > 10000 && Game.blds && Game.blds.length < 5) {
                    exploits.push({type: 'RESOURCE_HOARD', food: Game.food, buildings: Game.blds.length, severity: 'investigate'});
                }
                
                // Dying with lots of resources (might indicate unclear mechanics)
                if(this.lastDeathCause && Game.food > 500 && Game.wood > 200) {
                    exploits.push({type: 'DEATH_WITH_RESOURCES', cause: this.lastDeathCause, food: Game.food, severity: 'balance'});
                }
                
                for(let e of exploits) {
                    let key = `${e.type}_${this.episode}`;
                    if(!this.playtestMetrics.exploitsDetected.some(x => x.key === key)) {
                        e.key = key;
                        this.playtestMetrics.exploitsDetected.push(e);
                        this.log(`‚ö° EXPLOIT?: ${e.type}`);
                    }
                }
            },
            
            // Track which game mechanics have been tested
            trackCoverage: function(action) {
                this.playtestMetrics.coverageMap[action] = (this.playtestMetrics.coverageMap[action] || 0) + 1;
            },
            
            // Generate playtest report
            generatePlaytestReport: function() {
                let report = {
                    summary: {
                        totalEpisodes: this.episode,
                        bestPopulation: this.bestPopulation,
                        bestSurvivalYears: this.bestSurvivalYears,
                        citiesBuilt: this.citiesBuilt,
                        balancedCities: this.balancedCities
                    },
                    bugs: this.playtestMetrics.bugsFound,
                    exploits: this.playtestMetrics.exploitsDetected,
                    milestones: this.playtestMetrics.milestoneTimings,
                    coverage: this.playtestMetrics.coverageMap,
                    deathCauses: this.deathCauses || {},
                    failurePatterns: Object.entries(this.failurePatterns || {})
                        .filter(([k, v]) => v >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                };
                
                // Log summary
                this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                this.log('üìä PLAYTEST REPORT');
                this.log(`   Episodes: ${report.summary.totalEpisodes}`);
                this.log(`   Best Pop: ${report.summary.bestPopulation}`);
                this.log(`   Bugs Found: ${report.bugs.length}`);
                this.log(`   Exploits: ${report.exploits.length}`);
                this.log(`   Actions Tested: ${Object.keys(report.coverage).length}`);
                this.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                return report;
            },
            
            // Show playtest report in alert
            showPlaytestReport: function() {
                let report = this.generatePlaytestReport();
                
                let msg = 'üéÆ AI PLAYTEST REPORT\\n\\n';
                msg += `üìä ${report.summary.totalEpisodes} episodes played\\n`;
                msg += `üë• Best population: ${report.summary.bestPopulation}\\n`;
                msg += `üìÖ Longest survival: ${report.summary.bestSurvivalYears} years\\n`;
                msg += `üèôÔ∏è Cities built: ${report.summary.citiesBuilt}\\n\\n`;
                
                if(report.bugs.length > 0) {
                    msg += `üêõ BUGS FOUND (${report.bugs.length}):\\n`;
                    report.bugs.slice(0, 5).forEach(b => {
                        msg += `   - ${b.type} (${b.severity})\\n`;
                    });
                    msg += '\\n';
                }
                
                if(report.exploits.length > 0) {
                    msg += `‚ö° POTENTIAL EXPLOITS (${report.exploits.length}):\\n`;
                    report.exploits.slice(0, 5).forEach(e => {
                        msg += `   - ${e.type}\\n`;
                    });
                    msg += '\\n';
                }
                
                msg += 'üíÄ TOP DEATH CAUSES:\\n';
                Object.entries(report.deathCauses)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .forEach(([cause, count]) => {
                        msg += `   - ${cause}: ${count}x\\n`;
                    });
                
                alert(msg);
            },
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // IMITATION LEARNING V2 - AI learns EXACT patterns from player
            // Records: what you built, where relative to other buildings,
            // timing (years between builds), and terrain context
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            // Start watching player - records detailed playbook
            startWatching: function() {
                this.isWatching = true;
                this.watchStartState = this.getState();
                this.watchStartYear = Game.year || 0;
                this.watchStartPop = Game.pop || 0;
                
                // The playbook - a sequence of actions with context
                this.playerPlaybook = [];
                this.lastBuildPos = null;      // Last building position
                this.lastBuildYear = 0;        // Year of last build
                this.settlementPos = null;     // Where player settled
                
                this.log('üëÅÔ∏è AI is now WATCHING you play!');
                this.log('üìù Recording your exact build order, timing, and positions...');
                Controller.toast('üëÅÔ∏è AI is watching! Build your city and I\'ll learn your strategy!');
                this.updateWatchUI();
            },
            
            // Stop watching and compile the learned playbook
            stopWatching: function() {
                if(!this.isWatching) return;
                
                this.isWatching = false;
                let actions = this.playerPlaybook.length;
                
                if(actions > 0) {
                    // Save playbook to localStorage for future runs
                    this.savedPlaybooks = this.savedPlaybooks || [];
                    this.savedPlaybooks.push({
                        playbook: this.playerPlaybook,
                        finalPop: Game.pop,
                        finalYear: Game.year,
                        finalScore: Game.pop * 100 + Game.food,
                        timestamp: Date.now()
                    });
                    
                    // Keep only best 5 playbooks
                    this.savedPlaybooks.sort((a,b) => b.finalScore - a.finalScore);
                    this.savedPlaybooks = this.savedPlaybooks.slice(0, 5);
                    
                    localStorage.setItem('ai_playbooks', JSON.stringify(this.savedPlaybooks));
                    
                    this.log('üìö Learned playbook with ' + actions + ' steps!');
                    this.log('üìä Final: Pop=' + Game.pop + ', Year=' + Game.year);
                    this.log('üíæ Saved to memory. AI will try to copy this!');
                    Controller.toast('üéì AI learned ' + actions + ' steps from you! Score: ' + (Game.pop * 100 + Game.food));
                } else {
                    this.log('üëÅÔ∏è Stopped watching (no actions recorded)');
                }
                
                this.updateWatchUI();
            },
            
            // Record a player action with FULL context
            recordPlayerAction: function(action, x, y) {
                if(!this.isWatching) return;
                
                let currentYear = Game.year || 0;
                let yearsSinceLastBuild = currentYear - (this.lastBuildYear || 0);
                let currentPop = Game.pop || 0;
                let currentFood = Game.food || 0;
                let currentWood = Game.wood || 0;
                
                // Get position (from params or from click position)
                let buildX = x !== undefined ? x : (Controller.mx || 0);
                let buildY = y !== undefined ? y : (Controller.my || 0);
                
                // Calculate relative position from settlement or last build
                let relativePos = {x: 0, y: 0};
                if(this.settlementPos) {
                    relativePos.x = buildX - this.settlementPos.x;
                    relativePos.y = buildY - this.settlementPos.y;
                }
                
                // Check terrain context around build position
                let terrainContext = this.getTerrainContext(buildX, buildY);
                
                // Record the action with full context
                let record = {
                    action: action,
                    step: this.playerPlaybook.length + 1,
                    
                    // Position info
                    absolutePos: {x: buildX, y: buildY},
                    relativeToSettlement: relativePos,
                    distanceFromLast: this.lastBuildPos ? 
                        Math.sqrt(Math.pow(buildX - this.lastBuildPos.x, 2) + Math.pow(buildY - this.lastBuildPos.y, 2)) : 0,
                    
                    // Timing info
                    year: currentYear,
                    yearsSinceLastBuild: yearsSinceLastBuild,
                    
                    // Resource context
                    popWhenBuilt: currentPop,
                    foodWhenBuilt: currentFood,
                    woodWhenBuilt: currentWood,
                    
                    // Terrain context
                    nearWater: terrainContext.nearWater,
                    nearTrees: terrainContext.nearTrees,
                    nearRoad: terrainContext.nearRoad,
                    nearResidential: terrainContext.nearResidential,
                    
                    // Building counts at this moment
                    resCount: Game.zoneCount || 0,
                    wellCount: Game.wellCount || 0,
                    indCount: Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0,
                    comCount: Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0,
                    roadCount: Game.roadTileCount || 0
                };
                
                this.playerPlaybook.push(record);
                
                // Track settlement position
                if(action === 'SETTLE') {
                    this.settlementPos = {x: Game.player.x, y: Game.player.y};
                }
                
                // Update last build position
                if(action.startsWith('BUILD_')) {
                    this.lastBuildPos = {x: buildX, y: buildY};
                    this.lastBuildYear = currentYear;
                }
                
                console.log('üìù Recorded step', record.step, ':', action, 'at', buildX, ',', buildY);
                this.log('üìù Step ' + record.step + ': ' + action + ' (Pop:' + currentPop + ', Yr:' + currentYear + ')');
            },
            
            // Get terrain context around a position
            getTerrainContext: function(x, y) {
                let context = {
                    nearWater: false,
                    nearTrees: false,
                    nearRoad: false,
                    nearResidential: false
                };
                
                if(!Game.tiles) return context;
                
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let tx = x + dx, ty = y + dy;
                        if(tx < 0 || ty < 0 || tx >= CFG.W || ty >= CFG.H) continue;
                        let tile = Game.tiles[tx][ty];
                        if(!tile) continue;
                        
                        if(tile.type === 'WATER' || tile.type === 'RIVER') context.nearWater = true;
                        if(tile.tree || tile.type === 'FOREST') context.nearTrees = true;
                        if(tile.road) context.nearRoad = true;
                        if(tile.zone === 'R') context.nearResidential = true;
                    }
                }
                
                return context;
            },
            
            // AI tries to execute the learned playbook
            executePlaybook: function() {
                if(!this.savedPlaybooks || this.savedPlaybooks.length === 0) {
                    this.log('‚ùå No playbook learned! Watch player first.');
                    return false;
                }
                
                // Use the best playbook
                let playbook = this.savedPlaybooks[0].playbook;
                let currentStep = this.playbookStep || 0;
                
                if(currentStep >= playbook.length) {
                    this.log('‚úÖ Playbook completed!');
                    this.playbookStep = 0;
                    return false;
                }
                
                let step = playbook[currentStep];
                
                // Check if conditions match (similar year, pop level)
                let currentYear = Game.year || 0;
                let currentPop = Game.pop || 0;
                
                // Wait if not enough time has passed
                if(step.year > 0 && currentYear < step.year - 2) {
                    // Pass year to catch up
                    Game.endTurn();
                    return true;
                }
                
                // Find a similar spot to build
                let buildPos = this.findSimilarBuildSpot(step);
                
                if(buildPos) {
                    // Execute the action at the found position
                    this.log('üéØ Step ' + (currentStep + 1) + ': ' + step.action);
                    
                    if(step.action === 'SETTLE') {
                        Game.settleHere();
                    } else if(step.action === 'PASS_YEAR') {
                        Game.endTurn();
                    } else if(step.action.startsWith('BUILD_')) {
                        let tool = step.action.replace('BUILD_', '');
                        if(tool === 'RES') Controller.selectedBuildingLevel = 1;
                        if(tool === 'IND') Controller.selectedIndustrialLevel = 1;
                        if(tool === 'COM') Controller.selectedCommercialLevel = 1;
                        Game.build(tool, buildPos.x, buildPos.y);
                    }
                    
                    this.playbookStep++;
                    return true;
                }
                
                // Couldn't find suitable spot, skip this step
                this.log('‚ö†Ô∏è Skipping step ' + (currentStep + 1) + ' - no suitable spot');
                this.playbookStep++;
                return true;
            },
            
            // Find a similar spot to what player used
            findSimilarBuildSpot: function(step) {
                if(!Game.tiles) return null;
                
                let bestSpot = null;
                let bestScore = -Infinity;
                
                // Search around settlement if we have one
                let centerX = Game.player ? Game.player.x : CFG.W / 2;
                let centerY = Game.player ? Game.player.y : CFG.H / 2;
                
                // If step has relative position, try that offset first
                if(step.relativeToSettlement && this.aiSettlementPos) {
                    let idealX = this.aiSettlementPos.x + step.relativeToSettlement.x;
                    let idealY = this.aiSettlementPos.y + step.relativeToSettlement.y;
                    
                    // Check if ideal spot is valid
                    if(idealX >= 0 && idealX < CFG.W && idealY >= 0 && idealY < CFG.H) {
                        let tile = Game.tiles[idealX][idealY];
                        if(tile && this.isValidBuildSpot(idealX, idealY, step.action)) {
                            return {x: idealX, y: idealY};
                        }
                    }
                }
                
                // Search for best matching spot
                for(let r = 0; r <= 20; r++) {
                    for(let dx = -r; dx <= r; dx++) {
                        for(let dy = -r; dy <= r; dy++) {
                            if(Math.abs(dx) !== r && Math.abs(dy) !== r) continue; // Only ring
                            
                            let x = centerX + dx;
                            let y = centerY + dy;
                            
                            if(x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) continue;
                            if(!this.isValidBuildSpot(x, y, step.action)) continue;
                            
                            // Score this spot based on similarity to player's choice
                            let score = this.scoreBuildSpot(x, y, step);
                            
                            if(score > bestScore) {
                                bestScore = score;
                                bestSpot = {x: x, y: y};
                            }
                        }
                    }
                    
                    // Stop if we found a decent spot
                    if(bestSpot && bestScore > 50) break;
                }
                
                return bestSpot;
            },
            
            // Check if spot is valid for building
            isValidBuildSpot: function(x, y, action) {
                if(!Game.tiles || x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) return false;
                let tile = Game.tiles[x][y];
                if(!tile) return false;
                
                // Can't build on water, stone, or existing structures
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(tile.zone || tile.road) return false;
                if(tile.stoneDeposit) return false;
                
                return true;
            },
            
            // Score a spot based on similarity to player's recorded context
            scoreBuildSpot: function(x, y, step) {
                let score = 100; // Base score
                let context = this.getTerrainContext(x, y);
                
                // Match terrain preferences from player's build
                if(step.nearWater && context.nearWater) score += 30;
                if(step.nearTrees && context.nearTrees) score += 20;
                if(step.nearRoad && context.nearRoad) score += 25;
                if(step.nearResidential && context.nearResidential) score += 25;
                
                // Penalize if player wanted something that's missing
                if(step.nearWater && !context.nearWater) score -= 20;
                if(step.nearRoad && !context.nearRoad) score -= 15;
                
                // Bonus for matching distance from last build
                if(this.lastAIBuildPos) {
                    let dist = Math.sqrt(Math.pow(x - this.lastAIBuildPos.x, 2) + Math.pow(y - this.lastAIBuildPos.y, 2));
                    let targetDist = step.distanceFromLast || 2;
                    let distDiff = Math.abs(dist - targetDist);
                    score -= distDiff * 5; // Penalize distance mismatch
                }
                
                return score;
            },
            
            // Load saved playbooks from localStorage
            loadPlaybooks: function() {
                try {
                    let saved = localStorage.getItem('ai_playbooks');
                    if(saved) {
                        this.savedPlaybooks = JSON.parse(saved);
                        this.log('üìÇ Loaded ' + this.savedPlaybooks.length + ' playbooks');
                    }
                } catch(e) {
                    console.error('Failed to load playbooks:', e);
                }
            },
            
            // Update watch UI
            updateWatchUI: function() {
                let btn = document.getElementById('ai-watch-btn');
                if(btn) {
                    btn.textContent = this.isWatching ? '‚èπÔ∏è Stop Watching' : 'üëÅÔ∏è Watch Me';
                    btn.style.background = this.isWatching ? '#e74c3c' : '#9b59b6';
                }
                let countEl = document.getElementById('ai-demo-count');
                if(countEl) countEl.textContent = (this.playerPlaybook || []).length;
                
                // Show playbook count
                let playbookCountEl = document.getElementById('ai-playbook-count');
                if(playbookCountEl) playbookCountEl.textContent = (this.savedPlaybooks || []).length + ' playbooks saved';
            },
            
            // Update training UI panel
            updateTrainingUI: function() {
                let panel = document.getElementById('ai-training-panel');
                if(!panel) return;
                
                let avgReward = this.episodeRewards.length > 0 
                    ? (this.episodeRewards.slice(-20).reduce((a,b) => a+b, 0) / Math.min(20, this.episodeRewards.length)).toFixed(1)
                    : 0;
                
                document.getElementById('ai-episode').textContent = this.episode;
                document.getElementById('ai-best-score').textContent = this.bestScore.toFixed(1);
                document.getElementById('ai-avg-reward').textContent = avgReward;
                document.getElementById('ai-exploration').textContent = (this.explorationRate * 100).toFixed(1) + '%';
                document.getElementById('ai-states').textContent = Object.keys(this.qTable).length;
                
                // Update learning analytics
                let citiesEl = document.getElementById('ai-cities-built');
                let bestPopEl = document.getElementById('ai-best-pop');
                let bestYearEl = document.getElementById('ai-best-year');
                let rciEl = document.getElementById('ai-rci-balance');
                let smartEl = document.getElementById('ai-settled-near-res');
                
                if(citiesEl) citiesEl.textContent = 'Cities Built: ' + this.citiesBuilt;
                if(bestPopEl) bestPopEl.textContent = 'Best Population: ' + this.bestPopulation;
                if(bestYearEl) bestYearEl.textContent = 'Best Survival: ' + this.bestSurvivalYears + ' years';
                if(rciEl) rciEl.textContent = 'Balanced Cities: ' + this.balancedCities;
                if(smartEl) smartEl.textContent = 'Smart Settlements: ' + this.smartSettlements;
                
                // Update curriculum phase banner
                let phaseBanner = document.getElementById('ai-phase-banner');
                if(phaseBanner) {
                    let phase = this.learningPhase || 1;
                    if(phase === 1) {
                        phaseBanner.style.background = '#2e7d32';
                        phaseBanner.innerHTML = 'üéì Phase 1: Learning Survival (' + this.citiesBuilt + '/' + this.phase1Threshold + ' cities)';
                    } else if(phase === 2) {
                        phaseBanner.style.background = '#1565c0';
                        phaseBanner.innerHTML = 'üèóÔ∏è Phase 2: Building Cities (' + this.balancedCities + '/' + this.phase2Threshold + ' balanced)';
                    } else {
                        phaseBanner.style.background = '#6a1b9a';
                        phaseBanner.innerHTML = 'üëë Phase 3: Mastering Balance!';
                    }
                }
                
                // Update memory stats
                let memStats = this.getMemoryStats();
                let memStatesEl = document.getElementById('ai-mem-states');
                let memMbEl = document.getElementById('ai-mem-mb');
                if(memStatesEl) memStatesEl.textContent = memStats.qTableStates + ' states';
                if(memMbEl) {
                    memMbEl.textContent = memStats.estimatedMB + 'MB';
                    // Color code based on memory usage
                    if(parseFloat(memStats.estimatedMB) > 100) memMbEl.style.color = '#f44336'; // Red > 100MB
                    else if(parseFloat(memStats.estimatedMB) > 50) memMbEl.style.color = '#FF9800'; // Orange > 50MB
                    else memMbEl.style.color = '#4CAF50'; // Green
                }
                
                let btn = document.getElementById('ai-train-btn');
                if(btn) btn.textContent = this.isTraining ? '‚èπÔ∏è Stop' : '‚ñ∂Ô∏è Train';
            },
            
            // Draw reward trend graph
            drawRewardGraph: function() {
                let canvas = document.getElementById('ai-reward-graph');
                if(!canvas || !canvas.getContext) return;
                let ctx = canvas.getContext('2d');
                let w = canvas.width;
                let h = canvas.height;
                
                // Clear
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);
                
                if(this.rewardHistory.length < 2) return;
                
                // Find min/max
                let minR = Math.min(...this.rewardHistory, 0);
                let maxR = Math.max(...this.rewardHistory, 100);
                let range = maxR - minR || 1;
                
                // Draw zero line
                let zeroY = h - ((0 - minR) / range) * h;
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(w, zeroY);
                ctx.stroke();
                
                // Draw line graph
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#4CAF50';
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            
            // Get best action for current state (for display)
            getBestAction: function() {
                let state = this.getState();
                let bestAction = this.actions[0];
                let bestValue = this.getQ(state, bestAction);
                
                for(let action of this.actions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                
                return {action: bestAction, value: bestValue.toFixed(2)};
            }
        };
        
        // Try to load saved brain on startup
        setTimeout(() => QLearningAI.loadBrain(), 1000);

        window.onload=()=>{
            try {
                Controller.init();
            } catch(err) {
                console.error('Failed to initialize:', err);
                document.getElementById('toast').innerText = 'Initialization Error! Check console (F12)';
                document.getElementById('toast').style.opacity = '1';
            }
        };
    </script>

</body></html>