<!DOCTYPE html>
<!-- saved from url=(0087)file:///C:/Users/Elite/Documents/My%20Made%20Games/CitGame%20Early%20version/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Civil Zones v48.0 - Historical Zoning Simulator</title>
    <style>
        :root {
            /* Core Colors - Professional Dark Theme */
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --bg-elevated: #22222e;
            --bg-hover: #2a2a38;
            
            /* Accent Colors */
            --accent-primary: #10b981;
            --accent-secondary: #059669;
            --accent-glow: rgba(16, 185, 129, 0.4);
            --accent-subtle: rgba(16, 185, 129, 0.1);
            
            /* Zone Colors */
            --c-res: #3b82f6;
            --c-com: #f59e0b;
            --c-ind: #ef4444;
            --c-wat: #06b6d4;
            --c-road: #a78bfa;
            --c-bull: #f87171;
            
            /* Text Colors */
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --text-dim: #475569;
            
            /* Borders */
            --border-subtle: rgba(255,255,255,0.06);
            --border-default: rgba(255,255,255,0.1);
            --border-strong: rgba(255,255,255,0.15);
            
            /* Legacy compatibility */
            --bg: #0a0a0f;
            --text: #f8fafc;
            --panel: #12121a;
            --border: #1e1e2a;
            --accent: #10b981;
            --accent-hover: #34d399;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        html, body { 
            margin: 0; 
            width: 100%; 
            height: 100%; 
            background: var(--bg-primary);
            color: var(--text-primary); 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* ===== TOP MENUBAR ===== */
        #menubar { 
            height: 56px; 
            background: var(--bg-secondary);
            display: flex; 
            align-items: center; 
            padding: 0 16px; 
            gap: 8px; 
            border-bottom: 1px solid var(--border-default);
            z-index: 100; 
            box-shadow: 0 4px 24px rgba(0,0,0,0.4);
            backdrop-filter: blur(12px);
        }
        
        /* ===== VIEWPORT ===== */
        #viewport { 
            flex-grow: 1; 
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); 
            position: relative; 
            overflow: hidden; 
            display: flex; 
        }
        
        #sidebar { 
            width: 280px; 
            background: var(--bg-secondary); 
            border-right: 1px solid var(--border-default); 
            overflow-y: auto; 
            padding: 16px; 
            display: none; 
            z-index: 50; 
        }
        
        #canvas-container { flex-grow: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* ===== BOTTOM DASHBOARD ===== */
        #dashboard { 
            height: auto; 
            min-height: 72px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-default);
            display: flex; 
            align-items: center; 
            padding: 12px 20px; 
            justify-content: space-between; 
            gap: 16px;
            z-index: 100;
            box-shadow: 0 -4px 24px rgba(0,0,0,0.3);
            backdrop-filter: blur(12px);
        }

        /* ===== PROFESSIONAL BUTTON SYSTEM ===== */
        .btn { 
            padding: 10px 14px; 
            border: 1px solid var(--border-default);
            background: var(--bg-tertiary);
            color: var(--text-secondary); 
            cursor: pointer; 
            font-weight: 500; 
            border-radius: 8px; 
            font-family: 'Inter', sans-serif;
            font-size: 15px; 
            transition: all 0.15s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            min-width: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            letter-spacing: -0.01em;
        }
        
        .btn:hover { 
            background: var(--bg-hover);
            border-color: var(--border-strong);
            color: var(--text-primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .btn.active { 
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%) !important; 
            border-color: var(--accent-primary);
            color: white; 
            box-shadow: 0 0 20px var(--accent-glow), 0 4px 12px rgba(0,0,0,0.3);
            font-weight: 600;
        }
        
        .btn:disabled { 
            opacity: 0.4; 
            cursor: not-allowed; 
            background: var(--bg-tertiary);
            color: var(--text-dim);
            border-color: var(--border-subtle);
        }
        
        .btn:disabled:hover { 
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            background: var(--bg-tertiary);
            color: var(--text-dim);
        }
        
        /* Zone-colored button accents */
        .b-res { border-bottom: 2px solid var(--c-res); }
        .b-com { border-bottom: 2px solid var(--c-com); }
        .b-ind { border-bottom: 2px solid var(--c-ind); }
        .b-wat { border-bottom: 2px solid var(--c-wat); }
        .b-road { border-bottom: 2px solid var(--c-road); }
        
        /* ===== STAT CARDS ===== */
        .stat { 
            display: flex; 
            flex-direction: column; 
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
            min-width: 70px;
            transition: all 0.15s ease;
        }
        
        .stat:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }
        
        .lbl { 
            font-size: 10px; 
            color: var(--text-muted); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        
        .val { 
            font-size: 18px; 
            font-weight: 700;
            letter-spacing: -0.02em;
            font-variant-numeric: tabular-nums;
        }
        
        /* ===== MODAL PANELS ===== */
        #building-menu-panel,
        #industrial-menu-panel,
        #road-menu-panel { 
            position: absolute; 
            top: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 16px; 
            padding: 24px; 
            display: none; 
            z-index: 250;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5), 0 0 0 1px var(--border-subtle);
            max-width: 95vw;
            max-height: 85vh;
            backdrop-filter: blur(16px);
        }
        
        #building-menu-panel { 
            border-color: var(--accent-primary);
            width: 100%;
            max-width: 1100px;
        }
        
        #industrial-menu-panel { 
            border-color: var(--c-ind);
            max-width: 900px;
        }
        
        #road-menu-panel {
            border-color: var(--c-road);
            max-width: 800px;
        }
        
        .menu-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            text-align: center;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-default);
            letter-spacing: -0.02em;
        }
        
        #building-menu-panel .menu-title { color: var(--accent-primary); border-color: var(--accent-primary); }
        #industrial-menu-panel .menu-title { color: var(--c-ind); border-color: var(--c-ind); }
        #road-menu-panel .menu-title { color: var(--c-road); border-color: var(--c-road); }
        
        .menu-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 500;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-close-btn:hover {
            background: #ef4444;
            border-color: #ef4444;
            color: white;
            transform: scale(1.05);
        }
        
        /* ===== LEVEL CARD GRID ===== */
        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 12px;
            max-height: 65vh;
            overflow-y: auto;
            padding: 8px;
            padding-right: 12px;
        }
        
        .level-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .level-grid::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        .level-grid::-webkit-scrollbar-thumb {
            background: var(--text-dim);
            border-radius: 4px;
        }
        
        .level-grid::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        .level-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            padding: 16px 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            min-height: 130px;
        }
        
        .level-card:hover {
            background: var(--bg-hover);
            border-color: var(--border-strong);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .level-card.selected {
            background: var(--accent-subtle);
            border-color: var(--accent-primary);
            box-shadow: 0 0 24px var(--accent-glow);
        }
        
        #industrial-menu-panel .level-card.selected {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--c-ind);
            box-shadow: 0 0 24px rgba(239, 68, 68, 0.3);
        }
        
        #road-menu-panel .level-card.selected {
            background: rgba(167, 139, 250, 0.1);
            border-color: var(--c-road);
            box-shadow: 0 0 24px rgba(167, 139, 250, 0.3);
        }
        
        .level-card.level-locked {
            opacity: 0.35;
            cursor: not-allowed;
        }
        
        .level-card.level-locked:hover {
            transform: none;
            box-shadow: none;
            border-color: var(--border-default);
        }
        
        .level-card .level-icon {
            font-size: 36px;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .level-card .level-number {
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 600;
        }
        
        .level-card .level-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 6px;
            line-height: 1.3;
            min-height: 32px;
        }
        
        .level-card .level-stats {
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 6px;
        }
        
        .level-card .level-cost {
            font-size: 11px;
            color: var(--c-com);
            text-align: center;
            font-weight: 600;
            padding-top: 6px;
            border-top: 1px solid var(--border-subtle);
        }
        
        .level-card.level-locked .level-cost {
            color: var(--c-ind);
        }

        /* ===== TOAST NOTIFICATIONS ===== */
        #toast { 
            position: absolute; 
            top: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: var(--bg-secondary);
            border: 1px solid var(--accent-primary);
            color: var(--text-primary); 
            padding: 14px 32px; 
            border-radius: 12px; 
            opacity: 0; 
            transition: all 0.2s ease; 
            pointer-events: none; 
            z-index: 300; 
            font-weight: 500; 
            font-size: 14px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 48px var(--accent-glow);
            backdrop-filter: blur(12px);
        }
        
        /* ===== DEBUG PANEL ===== */
        #debug { 
            position: absolute; 
            bottom: 8px; 
            right: 8px; 
            font-size: 10px; 
            color: var(--text-dim); 
            pointer-events: none; 
            z-index: 101;
            background: rgba(0,0,0,0.6);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            backdrop-filter: blur(4px);
        }
        
        #file-input { display: none; }
        
        /* ===== TOOLTIP SYSTEM ===== */
        .btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-elevated);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid var(--border-default);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            font-weight: 500;
        }
        
        .btn[title]:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--border-default);
            pointer-events: none;
            z-index: 1001;
        }
        
        /* ===== CAMERA CONTROLS ===== */
        .camera-arrow { 
            position: absolute; 
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            color: var(--text-secondary); 
            font-size: 20px; 
            width: 44px; 
            height: 44px; 
            display: none; 
            cursor: pointer; 
            z-index: 150; 
            border-radius: 8px; 
            transition: all 0.15s ease;
        }
        
        .camera-arrow:hover { 
            background: var(--bg-hover);
            border-color: var(--border-strong);
            color: var(--text-primary);
        }
        
        .camera-arrow:active { 
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }
        
        #cam-up { top: 70px; left: 50%; transform: translateX(-50%); }
        #cam-down { bottom: 90px; left: 50%; transform: translateX(-50%); }
        #cam-left { top: 50%; left: 10px; transform: translateY(-50%); }
        #cam-right { top: 50%; right: 10px; transform: translateY(-50%); }
        
        /* ===== CATEGORY STYLES ===== */
        .build-category { margin-bottom: 16px; }
        .category-title { 
            color: var(--accent-primary); 
            font-weight: 600; 
            font-size: 12px; 
            margin-bottom: 8px; 
            padding-bottom: 6px; 
            border-bottom: 1px solid var(--border-subtle);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .build-btn { 
            width: 100%; 
            padding: 12px; 
            margin-bottom: 6px; 
            border: 1px solid var(--border-default); 
            background: var(--bg-tertiary); 
            color: var(--text-secondary); 
            cursor: pointer; 
            font-weight: 500; 
            border-radius: 8px; 
            font-family: 'Inter', sans-serif; 
            text-align: left; 
            font-size: 13px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            transition: all 0.15s ease;
        }
        
        .build-btn:hover { 
            background: var(--bg-hover); 
            border-color: var(--border-strong);
            color: var(--text-primary);
        }
        
        .build-btn.active { 
            background: var(--accent-primary); 
            border-color: var(--accent-primary); 
            color: white; 
        }
        
        .build-btn .cost { 
            font-size: 11px; 
            color: var(--text-dim); 
        }
        
        .build-btn.active .cost { 
            color: rgba(255,255,255,0.8); 
        }
        
        /* ===== AI PANEL PROFESSIONAL STYLING ===== */
        #ai-training-panel {
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-default) !important;
            border-radius: 12px !important;
            font-family: 'Inter', sans-serif !important;
            box-shadow: 0 16px 48px rgba(0,0,0,0.4) !important;
            backdrop-filter: blur(16px);
        }
        
        #ai-training-panel button {
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            border-radius: 6px;
            transition: all 0.15s ease;
        }
        
        #ai-training-panel button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
        
        #ai-training-panel select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-secondary);
            padding: 4px 8px;
        }
        
        /* ===== GAME OVER NEWSPAPER STYLING ===== */
        #gameover-screen {
            backdrop-filter: blur(8px);
        }
        
        #newspaper-article {
            background: linear-gradient(135deg, #faf8f0 0%, #f5f0e1 100%) !important;
            border: 1px solid #d4c9b0 !important;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5) !important;
        }
        
        /* ===== LOG MODAL STYLING ===== */
        #log-modal > div {
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-default);
            border-radius: 12px !important;
            box-shadow: 0 24px 64px rgba(0,0,0,0.5) !important;
        }
        
        #log-modal pre {
            background: var(--bg-tertiary) !important;
            border: 1px solid var(--border-subtle);
        }
    </style>
</head>
<body oncontextmenu="return false;" style="cursor: default;">

    <button id="btn-log" class="btn" style="position:absolute;top:8px;right:8px;z-index:1000;" onclick="Controller.showLog()" title="View Game Log">ğŸ“œ</button>
    <button id="btn-ai" class="btn" style="position:absolute;top:8px;right:60px;z-index:1000;" onclick="var p=document.getElementById(&#39;ai-training-panel&#39;);p.style.display=p.style.display===&#39;none&#39;?&#39;block&#39;:&#39;none&#39;;QLearningAI.updateTrainingUI();" title="Q-Learning AI">ğŸ¤–</button>
    <!-- Game Log Modal -->
    <div id="log-modal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);z-index:10000;align-items:center;justify-content:center;backdrop-filter:blur(4px);">
        <div onclick="event.stopPropagation();" style="background:var(--bg-secondary);color:var(--text-primary);padding:24px 32px;max-width:800px;width:90vw;max-height:85vh;overflow:hidden;border-radius:12px;box-shadow:0 24px 64px rgba(0,0,0,0.5);position:relative;display:flex;flex-direction:column;border:1px solid var(--border-default);">
            <button onclick="Controller.hideLog()" style="position:absolute;top:12px;right:12px;font-size:1.2em;background:var(--bg-tertiary);border:1px solid var(--border-default);color:var(--text-secondary);cursor:pointer;z-index:1;width:32px;height:32px;border-radius:8px;display:flex;align-items:center;justify-content:center;">âœ•</button>
            <h2 style="margin:0 0 16px 0;font-weight:600;font-size:18px;">Game Logs</h2>
            <div style="display:flex;gap:8px;margin-bottom:16px;">
                <button onclick="Controller.switchLog(&#39;player&#39;)" id="btn-player-log" style="padding:8px 16px;background:var(--accent-primary);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:500;font-family:'Inter',sans-serif;">Player Log</button>
                <button onclick="Controller.switchLog(&#39;technical&#39;)" id="btn-technical-log" style="padding:8px 16px;background:var(--bg-tertiary);color:var(--text-secondary);border:1px solid var(--border-default);border-radius:6px;cursor:pointer;font-family:'Inter',sans-serif;">Technical Log</button>
                <button onclick="Controller.copyLog()" style="padding:8px 16px;background:var(--c-res);color:#fff;border:none;border-radius:6px;cursor:pointer;margin-left:auto;font-family:'Inter',sans-serif;">ğŸ“‹ Copy</button>
            </div>
            <pre id="log-content" style="white-space:pre-wrap;word-wrap:break-word;font-family:'SF Mono','Fira Code',monospace;font-size:12px;background:var(--bg-tertiary);padding:16px;border-radius:8px;overflow-y:auto;flex:1;margin:0;border:1px solid var(--border-subtle);"></pre>
        </div>
    </div>

    <!-- AI Training Panel -->
    <div id="ai-training-panel" style="position:fixed;bottom:12px;right:12px;background:var(--bg-secondary);color:var(--text-primary);padding:16px;border-radius:12px;font-family:'Inter',sans-serif;font-size:12px;z-index:9000;border:1px solid var(--border-default);min-width:260px;display:block;box-shadow:0 16px 48px rgba(0,0,0,0.4);backdrop-filter:blur(16px);">
        <div style="font-weight:600;font-size:14px;margin-bottom:12px;color:var(--c-res);display:flex;align-items:center;gap:8px;">ğŸ¤– Q-Learning AI</div>
        
        <!-- PERMANENT CAREER SCORE - Like Chess ELO -->
        <div id="ai-career-panel" style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);padding:12px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <span style="color:#ffd700;font-weight:600;font-size:12px;">â™› CAREER SCORE</span>
                <span id="ai-career-score" style="color:#ffd700;font-weight:700;font-size:18px;">1000</span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:9px;">
                <div style="color:#888;">High Score: <span id="ai-career-high" style="color:#4CAF50;">1000</span></div>
                <div style="color:#888;">Pop Record: <span id="ai-career-pop-record" style="color:#2196F3;">0</span></div>
                <div style="color:#888;">Games: <span id="ai-career-games" style="color:#aaa;">0</span></div>
                <div style="color:#888;">Deaths: <span id="ai-career-deaths" style="color:#e74c3c;">0</span></div>
                <div style="color:#888;">Successes: <span id="ai-career-successes" style="color:#10b981;">0</span></div>
                <div style="color:#888;">Goal: <span style="color:#ff6b6b;">2M Pop</span></div>
            </div>
        </div>
        
        <!-- Curriculum Phase Banner -->
        <div id="ai-phase-banner" style="background:var(--c-res);padding:8px 12px;border-radius:6px;text-align:center;margin-bottom:12px;font-weight:500;font-size:11px;">ğŸ—ï¸ Phase 2: Building Cities (0/5 balanced)</div>
        <div style="display:grid;grid-template-columns:auto 1fr;gap:4px 12px;margin-bottom:12px;font-size:11px;">
            <span style="color:var(--text-muted);">Episode:</span><span id="ai-episode" style="color:var(--text-primary);">0</span>
            <span style="color:var(--text-muted);">Best Score:</span><span id="ai-best-score" style="color:var(--accent-primary);">0</span>
            <span style="color:var(--text-muted);">Avg Reward:</span><span id="ai-avg-reward" style="color:var(--text-primary);">0</span>
            <span style="color:var(--text-muted);">Exploration:</span><span id="ai-exploration" style="color:var(--text-primary);">80%</span>
            <span style="color:var(--text-muted);">States:</span><span id="ai-states" style="color:var(--text-primary);">0</span>
            <span style="color:var(--text-muted);">Demos:</span><span id="ai-demo-count" style="color:var(--c-road);">0</span>
        </div>
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
            <button id="ai-train-btn" onclick="QLearningAI.isTraining ? QLearningAI.stopTraining() : QLearningAI.startTraining()" style="padding:8px 14px;background:var(--accent-primary);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:500;flex:1;">â–¶ï¸ Train</button>
            <button id="ai-watch-btn" onclick="QLearningAI.isWatching ? QLearningAI.stopWatching() : QLearningAI.startWatching()" style="padding:8px 12px;background:var(--c-road);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:500;">ğŸ‘ï¸ Watch</button>
        </div>
        <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;">
            <button onclick="QLearningAI.saveBrain()" style="padding:6px 10px;background:var(--c-res);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:11px;">ğŸ’¾ Save</button>
            <button onclick="QLearningAI.loadBrain()" style="padding:6px 10px;background:var(--c-com);color:#000;border:none;border-radius:6px;cursor:pointer;font-size:11px;">ğŸ“‚ Load</button>
            <button onclick="QLearningAI.resetBrain()" style="padding:6px 10px;background:var(--c-ind);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:11px;">ğŸ—‘ï¸ Reset</button>
            <button onclick="QLearningAI.resetBrain(true)" style="padding:6px 10px;background:#e74c3c;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:11px;" title="Full reset including career score">ğŸ’€ Full Reset</button>
            <button onclick="QLearningAI.exportStats()" style="padding:6px 10px;background:var(--c-road);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:11px;">ğŸ“Š Export</button>
        </div>
        <div style="margin-top:10px;font-size:10px;color:var(--text-muted);">
            Speed: <select id="ai-speed" onchange="QLearningAI.trainingSpeed=parseInt(this.value)" style="background:var(--bg-tertiary);color:var(--text-secondary);border:1px solid var(--border-default);padding:4px 8px;border-radius:4px;font-size:10px;">
                <option value="1">1x (Slow)</option>
                <option value="5">5x</option>
                <option value="10" selected="">10x (Normal)</option>
                <option value="50">50x (Fast)</option>
                <option value="100">100x (Ultra)</option>
            </select>
        </div>
        <!-- Live Stats -->
        <div id="ai-live-stats" style="margin-top:10px;padding:10px;background:var(--bg-tertiary);border-radius:8px;font-size:10px;border:1px solid var(--border-subtle);">
            <div style="color:var(--c-res);margin-bottom:6px;font-weight:500;">ğŸ“Š Live Stats</div>
            <div id="ai-current-state" style="color:var(--text-muted);">State: WANDER_P0_F1_W1</div>
            <div id="ai-current-action" style="color:var(--text-muted);">Action: WANDER</div>
            <div id="ai-step-count" style="color:var(--text-muted);">Steps: 0</div>
            <div id="ai-current-pop" style="color:var(--text-muted);">Pop: 4 | Food: 0 | Yr: 0</div>
        </div>
        <!-- Learning Progress -->
        <div id="ai-learning-progress" style="margin-top:8px;padding:10px;background:rgba(16,185,129,0.1);border-radius:8px;font-size:10px;border:1px solid rgba(16,185,129,0.2);">
            <div style="color:var(--accent-primary);margin-bottom:6px;font-weight:500;">ğŸ“ˆ Learning Progress</div>
            <div id="ai-cities-built" style="color:var(--text-muted);">Cities Built: 0</div>
            <div id="ai-best-pop" style="color:var(--text-muted);">Best Population: 0</div>
            <div id="ai-best-year" style="color:var(--text-muted);">Best Survival: 0 years</div>
            <div id="ai-rci-balance" style="color:var(--text-muted);">Balanced Cities: 0</div>
            <div id="ai-settled-near-res" style="color:var(--text-muted);">Smart Settlements: 0</div>
        </div>
        <!-- DEATH MEMORY - What AI learned from past deaths -->
        <div id="ai-death-memory" style="margin-top:8px;padding:10px;background:rgba(231,76,60,0.1);border-radius:8px;font-size:10px;border:1px solid rgba(231,76,60,0.3);">
            <div style="color:#e74c3c;margin-bottom:6px;font-weight:500;">ğŸ’€ Death Memory (what killed me)</div>
            <div id="ai-death-water" style="color:var(--text-muted);">ğŸ’§ Water Crisis: <span style="color:#3498db;">0</span></div>
            <div id="ai-death-food" style="color:var(--text-muted);">ğŸŒ¾ Food Crisis: <span style="color:#f1c40f;">0</span></div>
            <div id="ai-death-housing" style="color:var(--text-muted);">ğŸ  No Housing: <span style="color:#e67e22;">0</span></div>
            <div id="ai-death-overpop" style="color:var(--text-muted);">ğŸ“ˆ Overpopulation: <span style="color:#9b59b6;">0</span></div>
            <div id="ai-death-last" style="color:#e74c3c;margin-top:4px;font-style:italic;">Last death: none yet</div>
        </div>
        <!-- Learning Curve (Mini Graph) -->
        <div style="margin-top:8px;">
            <div style="color:var(--c-res);font-size:10px;margin-bottom:4px;font-weight:500;">ğŸ“‰ Reward Trend (last 20)</div>
            <canvas id="ai-reward-graph" width="200" height="40" style="background:var(--bg-tertiary);border-radius:6px;width:100%;border:1px solid var(--border-subtle);"></canvas>
        </div>
        <!-- Log Window -->
        <div style="margin-top:8px;">
            <div style="color:var(--c-res);font-size:10px;margin-bottom:4px;font-weight:500;">ğŸ“œ Training Log</div>
            <div id="ai-log" style="background:var(--bg-tertiary);padding:8px;border-radius:6px;height:70px;overflow-y:auto;font-size:9px;color:var(--accent-primary);font-family:'SF Mono','Fira Code',monospace;border:1px solid var(--border-subtle);"></div>
        </div>
    </div>

    <div id="toast" style="opacity:0;">â›°ï¸ Stone deposit blocking path.</div>

    <div id="gameover-screen" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(10,10,15,0.95);z-index:9999;justify-content:center;align-items:center;flex-direction:column;font-family:serif;overflow-y:auto;padding:20px 0;backdrop-filter:blur(8px);">
        <div id="newspaper-article" style="max-width:700px;background:linear-gradient(135deg,#faf8f0 0%,#f5f0e1 100%);color:#222;padding:40px 50px;margin:20px;border-radius:12px;box-shadow:0 24px 64px rgba(0,0,0,0.5);border:1px solid #d4c9b0;position:relative;">
            <!-- Newspaper Header -->
            <div style="text-align:center;border-bottom:3px double #333;padding-bottom:15px;margin-bottom:20px;">
                <div style="font-size:0.75em;color:#666;letter-spacing:4px;text-transform:uppercase;">The Prehistoric Times</div>
                <div id="newspaper-date" style="font-size:0.85em;color:#888;margin-top:5px;">December 29, 2025</div>
            </div>
            <!-- Fossil Illustration -->
            <div style="display:flex;justify-content:center;align-items:center;margin-bottom:10px;">
                <canvas id="fossil-illustration" width="280" height="140" style="background:#E8DCC8;border:2px solid #998;border-radius:8px;margin-bottom:10px;"></canvas>
            </div>
            <!-- Headline -->
            <h1 id="newspaper-headline" style="font-family:'Times New Roman',serif;font-size:2.2em;font-weight:900;text-align:center;line-height:1.2;margin:0 0 15px 0;color:#111;">Settlement Died of Thirst</h1>
            <!-- Subheadline -->
            <div id="newspaper-subheadline" style="font-family:'Times New Roman',serif;font-size:1.1em;font-style:italic;text-align:center;color:#444;margin-bottom:20px;padding-bottom:15px;border-bottom:1px solid #ccc;">Archaeological findings reveal the story</div>
            <!-- Article Body -->
            <div id="newspaper-body" style="font-family:Georgia,serif;font-size:1em;line-height:1.7;color:#333;text-align:justify;"></div>
            <!-- Stats Box -->
            <div id="newspaper-stats" style="margin-top:25px;padding:15px;background:#EDE8D9;border:1px solid #ccc;border-radius:8px;font-family:'SF Mono','Courier New',monospace;font-size:0.9em;"></div>
            <!-- New Game Button -->
            <div style="text-align:center;margin-top:30px;">
                <button id="btn-newgame" style="font-size:1.1em;padding:14px 36px;background:var(--accent-primary);color:white;border:none;border-radius:8px;font-family:'Inter',sans-serif;font-weight:600;cursor:pointer;box-shadow:0 4px 16px rgba(16,185,129,0.3);transition:all 0.15s ease;">Try Again</button>
            </div>
        </div>
    </div>

    <div id="menubar" style="display:flex !important;visibility:visible !important;">
        <div style="font-weight:700;font-size:15px;margin-right:16px;font-family:'Inter',sans-serif;display:flex;align-items:center;gap:6px;">
            <span style="color:var(--text-primary);">CIVIL ZONES</span>
            <span style="color:var(--accent-primary);font-size:12px;font-weight:500;background:var(--accent-subtle);padding:2px 8px;border-radius:4px;">v48.0</span>
        </div>
            <script>
            // Show/hide both Pass Year buttons based on level
            function updatePassYearButton() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                // Show if in CITY mode (settled)
                var show = (typeof Game !== 'undefined' && Game.gameState === 'CITY');
                if (btn2) btn2.style.display = show ? 'inline-block' : 'none';
            }

            // Unified Pass Year click handler
            function handlePassYearClick() {
                if (typeof Game !== 'undefined' && typeof Game.endTurn === 'function') {
                    Game.endTurn();
                    if (typeof Controller !== 'undefined' && typeof Controller.updateUI === 'function') {
                        Controller.updateUI();
                    }
                    updatePassYearButton();
                }
            }

            // Hook up both Pass Year buttons when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                if (btn2) btn2.addEventListener('click', handlePassYearClick);
                
                // Initial update after short delay to ensure Game is initialized
                setTimeout(function() {
                    updatePassYearButton();
                }, 100);
            });
            </script>
        <button class="btn" id="t-pan" onclick="Controller.setTool(&#39;PAN&#39;)" title="Pan Camera">âœ‹</button>
        <button class="btn b-road" id="t-road" onclick="Controller.openRoadMenu()" style="display: inline-block;" title="Build Roads">ğŸ›£ï¸</button>
        <button class="btn b-wat" id="t-well" onclick="Controller.setTool(&#39;WELL&#39;)" style="display: inline-block;" title="Build Well ($20)">ğŸ’§</button>
        <div id="sep1" style="width: 1px; height: 24px; background: rgb(85, 85, 85); display: inline-block;"></div>
        <button class="btn" id="t-demolish" onclick="Controller.setTool(&#39;DEMOLISH&#39;)" style="display: inline-block;" title="Demolish Building">ğŸ”¨</button>
        <button class="btn b-res" id="t-res" onclick="Controller.openBuildingMenu()" style="display: inline-block;" title="Build Residential">ğŸ—ï¸</button>
        <button class="btn b-com" id="t-com" onclick="Controller.setTool(&#39;COM&#39;)" style="display: inline-block;" title="Build campfire to unlock commerce">ğŸ¢</button>
        <button class="btn b-ind" id="t-ind" onclick="Controller.openIndustrialMenu()" style="display: inline-block;" title="Build hunting ground">ğŸ­</button>
        <button class="btn" id="t-chief" onclick="Controller.setTool(&#39;CHIEF&#39;)" style="display: inline-block;" title="ğŸ”’ LOCKED: Build campfire first (10000 food)" disabled="">ğŸ›ï¸</button>
        <button class="btn" id="t-basket" onclick="Controller.setTool(&#39;BASKET&#39;)" style="display: inline-block;" title="ğŸ”’ LOCKED: Build campfire first" disabled="">ğŸ§º</button>
        <button class="btn" id="t-pottery" onclick="Controller.setTool(&#39;POTTERY&#39;)" style="display: inline-block;" title="ğŸ”’ LOCKED: Build campfire first" disabled="">ğŸº</button>
        <button class="btn" id="t-granary" onclick="Controller.setTool(&#39;GRANARY&#39;)" style="display: inline-block;" title="ğŸ”’ LOCKED: Build campfire first" disabled="">ğŸ›ï¸</button>
        <button class="btn" id="t-palace" onclick="Controller.setTool(&#39;PALACE&#39;)" style="display: inline-block;" title="ğŸ”’ LOCKED: Build campfire first" disabled="">ğŸ°</button>
        <div id="sep2" style="width: 1px; height: 24px; background: rgb(85, 85, 85); display: inline-block;"></div>
        <button class="btn" id="btn-settle" onclick="console.log(&#39;Settlement button clicked!&#39;); Game.settleHere();" style="background: rgb(76, 175, 80); border-color: rgb(129, 199, 132); display: none;" title="Start Settlement">ğŸ›ï¸</button>
        <button class="btn" id="btn-turn" onclick="Game.endTurn()" style="display: inline-block;" title="Pass Turn">â­ï¸</button>
        <div style="flex-grow:1;"></div>
        <button class="btn" id="btn-view" onclick="Controller.toggleView()" style="display: inline-block;" title="Toggle View Mode">ğŸ‘ï¸</button>
        <button class="btn" onclick="Controller.saveMap()" title="Save Game">ğŸ’¾</button>
        <button class="btn" onclick="Controller.loadMap()" title="Load Game">ğŸ“‚</button>
        <button class="btn" onclick="Controller.zoomIn()" title="Zoom In">ğŸ”+</button>
        <button class="btn" onclick="Controller.zoomOut()" title="Zoom Out">ğŸ”-</button>
        <button class="btn" id="btn-ai" onclick="Controller.toggleAI()" title="Toggle AI Autoplay">ğŸ¤–</button>
        <button class="btn" onclick="Controller.reset()" title="New Game">ğŸ”„</button>
    </div>

    <!-- Building Menu Panel -->
    <div id="building-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeBuildingMenu()">Ã—</button>
        <div class="menu-title">ğŸ—ï¸ Choose Building Type</div>
        <div class="level-grid" id="building-level-grid">
            <!-- Dynamically populated by Controller.openBuildingMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Buildings evolve through 4 states based on desirability. Higher levels = more capacity &amp; bonuses!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmBuildingSelection()" style="background: #4CAF50; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Industrial Menu Panel -->
    <div id="industrial-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeIndustrialMenu()">Ã—</button>
        <div class="menu-title">ğŸ­ Choose Industrial Type</div>
        <div class="level-grid" id="industrial-level-grid">
            <!-- Dynamically populated by Controller.openIndustrialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Industrial buildings produce resources and provide jobs for your population!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmIndustrialSelection()" style="background: #E53935; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Roads Menu Panel -->
    <div id="road-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeRoadMenu()">Ã—</button>
        <div class="menu-title">ğŸ›£ï¸ Choose Road Type</div>
        <div class="level-grid" id="road-level-grid">
            <!-- Level 1: Path -->
            <div class="level-card selected" id="card-road-1" onclick="Controller.selectRoadLevel(1)">
                <div class="level-icon">ğŸš¶</div>
                <div class="level-name">Path</div>
                <div class="level-stats">Level 1 â€¢ Basic footpath</div>
                <div class="level-cost">Cost: $5</div>
            </div>
            <!-- Level 2: Road (Locked) -->
            <div class="level-card level-locked" id="card-road-2" onclick="Controller.selectRoadLevel(2)">
                <div class="level-icon">ğŸ›¤ï¸</div>
                <div class="level-name">Road</div>
                <div class="level-stats">Level 2 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
            <!-- Level 3: (Locked) -->
            <div class="level-card level-locked" id="card-road-3" onclick="Controller.selectRoadLevel(3)">
                <div class="level-icon">ğŸš—</div>
                <div class="level-name">Paved Road</div>
                <div class="level-stats">Level 3 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
            <!-- Level 4: (Locked) -->
            <div class="level-card level-locked" id="card-road-4" onclick="Controller.selectRoadLevel(4)">
                <div class="level-icon">ğŸï¸</div>
                <div class="level-name">Highway</div>
                <div class="level-stats">Level 4 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Roads improve desirability and connect your buildings!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmRoadSelection()" style="background: var(--c-road); padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <div id="viewport"><canvas id="cvs" width="1014" height="749"></canvas><div id="debug">Pos: 103, 116</div></div>

    <div id="dashboard">
        <button class="btn" id="btn-newgame" onclick="window.startNewGame()" style="background:#1976D2; color:#fff; margin-right:16px;">ğŸ†• New Game</button>
        <button class="btn" id="btn-pass-year-dash" style="display: none; background: rgb(56, 142, 60); color: rgb(255, 255, 255); margin-right: 16px;" title="Pass Year">â© Pass Year</button>
        <div style="display:flex; align-items:center; flex-wrap:wrap; gap:4px;">
            <div class="stat"><span class="lbl">Population</span><span class="val" id="v-pop" style="color:var(--c-res)">4</span></div>
            <div class="stat"><span class="lbl">Food</span><span class="val" id="v-food" style="color:#4CAF50">280/450</span></div>
            <div class="stat" id="stat-wood" style="display: flex;"><span class="lbl">Wood</span><span class="val" id="v-wood" style="color:#A86838">158</span></div>
            <div class="stat" id="stat-metal" style="display: flex;"><span class="lbl">Metal</span><span class="val" id="v-metal" style="color:#78909C">0</span></div>
            <div class="stat" id="stat-stone" style="display: flex;"><span class="lbl">Stone</span><span class="val" id="v-stone" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-inventory" style="display: flex;"><span class="lbl">Total Inventory</span><span class="val" id="v-inventory" style="color:#64B5F6">438/450</span></div>
            <div class="stat" id="stat-year" style="display: flex;"><span class="lbl">Year</span><span class="val" id="v-year" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-nomad" style="display: flex;"><span class="lbl">Nomads Found</span><span class="val" id="v-nomad" style="color:#FFA726">0</span></div>
            <div class="stat" id="stat-thirst" style="display: flex;"><span class="lbl">ğŸ’§ Thirst</span><span class="val" id="v-thirst" style="color: rgb(41, 182, 246);">87</span></div>
            <div class="stat" id="stat-water" style="display: flex;"><span class="lbl">Water</span><span class="val" id="v-wat" style="color:var(--c-wat)">âš ï¸ 0/1</span></div>
            <div class="stat" id="stat-workforce" style="display: none;"><span class="lbl">Workforce</span><span class="val" id="v-workforce" style="color:#AB47BC">ğŸ‘· 5 gathering</span></div>
            <div class="stat" id="stat-funds" style="display: flex;"><span class="lbl">Gold</span><span class="val" id="v-res" style="color:var(--c-com)">0</span></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
            <div class="val" id="v-epoch" style="font-size:14px; font-weight:600;">ğŸŒ EXPLORING THE WORLD</div>
            <!-- RCI Demand Indicator (SimCity-style) -->
            <div id="rci-meters" style="display: none; margin-top: 4px; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px; border: 1px solid rgb(68, 68, 68);">
                <div style="display:flex; gap:6px; align-items:flex-end; height:60px;">
                    <!-- Residential Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="r-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(46, 125, 50), rgb(76, 175, 80)); transition: height 0.3s; height: 40%;"></div>
                        </div>
                        <span style="color:#4caf50; font-weight:bold; font-size:11px; margin-top:2px;">R</span>
                    </div>
                    <!-- Commercial Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="c-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(21, 101, 192), rgb(66, 165, 245)); transition: height 0.3s; height: 90%;"></div>
                        </div>
                        <span style="color:#42a5f5; font-weight:bold; font-size:11px; margin-top:2px;">C</span>
                    </div>
                    <!-- Industrial Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="i-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(230, 81, 0), rgb(255, 152, 0)); transition: height 0.3s; height: 80%;"></div>
                        </div>
                        <span style="color:#ff9800; font-weight:bold; font-size:11px; margin-top:2px;">I</span>
                    </div>
                </div>
                <div id="rci-tooltip" style="font-size:9px; color:#888; text-align:center; margin-top:4px;">R:1 C:0 I:0</div>
            </div>
        </div>
        <div style="display:flex; align-items:center; gap:10px;">
            <button onclick="Controller.showStatsMenu()" style="background:#333; color:#ccc; border:1px solid #555; padding:6px 12px; border-radius:4px; font-size:12px; font-weight:500; cursor:pointer;">ğŸ“Š Stats</button>
            <span style="font-size:11px; color:#666;">Click to Move</span>
        </div>
    </div>

    <!-- Stats Menu Popup -->
    <div id="stats-menu" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#2a2a2a; border:2px solid #555; border-radius:8px; padding:25px; max-width:500px; min-width:400px; z-index:1000; color:white;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#4CAF50;">ğŸ“Š Game Statistics</h3>
            <button onclick="Controller.hideStatsMenu()" style="background:none; border:none; color:#fff; font-size:18px; cursor:pointer;">Ã—</button>
        </div>
        <div id="stats-content" style="line-height:1.8; font-size:14px;">
            <!-- Stats will be populated by JavaScript -->
        </div>
    </div>
    <div id="stats-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999;" onclick="Controller.hideStatsMenu()"></div>

    <!-- New Game Confirmation Modal -->
    <div id="newgame-confirm-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.8); z-index:10000; align-items:center; justify-content:center;">
        <div onclick="event.stopPropagation();" style="background:linear-gradient(135deg, #1a1a1a 0%, #252525 100%); border:3px solid #E53935; border-radius:12px; padding:30px; max-width:450px; width:85vw; box-shadow:0 10px 40px rgba(0,0,0,0.9); color:#fff; text-align:center;">
            <div style="font-size:48px; margin-bottom:15px;">âš ï¸</div>
            <h2 style="margin:0 0 15px 0; color:#E53935; font-size:24px;">Start New Game?</h2>
            <p style="margin:0 0 25px 0; color:#ccc; font-size:16px; line-height:1.5;">All current progress will be permanently lost!<br>This action cannot be undone.</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button onclick="window.confirmNewGame()" style="padding:12px 30px; background:linear-gradient(135deg, #E53935 0%, #C62828 100%); color:#fff; border:2px solid #EF5350; border-radius:8px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s;" onmouseover="this.style.transform=&#39;scale(1.05)&#39;" onmouseout="this.style.transform=&#39;scale(1)&#39;">
                    âœ“ Yes, Start Over
                </button>
                <button onclick="window.cancelNewGame()" style="padding:12px 30px; background:linear-gradient(135deg, #2d2d2d 0%, #232323 100%); color:#fff; border:2px solid #4CAF50; border-radius:8px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s;" onmouseover="this.style.transform=&#39;scale(1.05)&#39;" onmouseout="this.style.transform=&#39;scale(1)&#39;">
                    âœ— Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- NEEDS WARNING PANEL -->
    <div id="needs-warning-panel" style="position: fixed; bottom: 20px; right: 20px; background: rgba(20,20,20,0.95); border: 2px solid #FF6B6B; border-radius: 10px; padding: 15px; width: 300px; font-size: 13px; display: none; z-index: 100; box-shadow: 0 8px 25px rgba(255,107,107,0.3);">
        <div style="color: #FF6B6B; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
            âš ï¸ RESIDENTS NEED:
        </div>
        <div id="needs-list" style="color: #FFF; line-height: 1.6;">
            <!-- Populated by updateNeedsWarning() -->
        </div>
        <div id="satisfaction-meter" style="margin-top: 10px; background: #333; height: 20px; border-radius: 4px; overflow: hidden; border: 1px solid #555;">
            <div id="satisfaction-bar" style="background: linear-gradient(90deg, #FF6B6B 0%, #FFD93D 50%, #6BCF7F 100%); height: 100%; width: 100%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: #000; font-size: 10px; font-weight: bold;">
                50%
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".json">

    <!-- External AI Module -->
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/ai.js"></script>
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/assign_population.js"></script>

        <script>
        window.startNewGame = function() {
            // Show custom confirmation modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) {
                modal.style.display = 'flex';
            }
        };
        
        window.confirmNewGame = function() {
            // Hide modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
            
            // Reset progression and all game state
            if (typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) PROGRESSION.reset();
            // Re-initialize the game with a new seed
            if (typeof Game.init === 'function') {
                Game.init(Math.floor(Math.random()*100000));
            }
            // Reset camera and UI
            Controller.cam.x = CFG.CAMERA.START_X;
            Controller.cam.y = CFG.CAMERA.START_Y;
            Controller.cam.z = CFG.CAMERA.START_ZOOM;
            Controller.updateUI();
            Controller.toast('ğŸ†• New game started!');
        };
        
        window.cancelNewGame = function() {
            // Just hide the modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
        };
        </script>

    <script>
        /* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
           â•‘                    CIVIL ZONES v48.0 - EVOLUTION SYSTEM             â•‘
           â•‘                   Historical City Building Simulator               â•‘
           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           
           CODE STRUCTURE:
           ===============
           1. CONFIG MODULE       - Game constants and configuration
           2. PROGRESSION MODULE  - Unlock system and advancement
           3. TERRAIN MODULE      - Perlin noise map generation
           4. ENTITIES MODULE     - Berries, nomads, animals, player
           5. GAME MODULE         - Core game logic, building, turns
           6. RENDERER MODULE     - Canvas drawing and visual effects
           7. CONTROLLER MODULE   - UI updates and input handling
           8. INITIALIZATION      - Game startup and event listeners
           
           NAVIGATION GUIDE:
           =================
           - Press Ctrl+F and search for "MODULE" to jump between sections
           - Each major function has a comment header explaining its purpose
           - Key systems: Building (line ~3200), AI (line ~2658), Rendering (line ~3600)
           
           BALANCE REFERENCE (see GAME_BALANCE.txt for full details):
           ============================================================
           Level 1 Cost: 100 Food + 100 Wood
           Level 1 Upkeep: 1 wood/year (occupied), 2 wood/year (empty)
           Level 1 Abandoned Timer: 5 years empty
           Animals: 1064 total (50% Deer, 35% Bison, 15% Mammoth)
           Nomads: 1200 total (83% friendly, 17% hostile)
           Inventory: 150 base + 100/nomad | Pocket: 1000 max
           Herd Danger: Adjacent animals cost 1-3 pop to kill
           
           WORKFORCE SYSTEM:
           =================
           Workers auto-assigned: Wells(2) > Roads(1/5tiles) > Commercial(3) > Gathering
           Well: 2 workers â†’ serves 100 people water
           Road: 1 worker per 5 tiles â†’ maintains desirability bonus
           Commercial: 3 workers â†’ operates the building
           Gatherers: 0.5 food/year per unassigned worker
        */

        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ MODULE 1: CONFIG - Game Configuration & Constants                 â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // All game settings, costs, and balance values are defined here.
        // Modify these values to change game difficulty and behavior.
        // !! IMPORTANT: When changing values here, also update GAME_BALANCE.txt !!
        
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘                   CIVIL ZONES v40.0 - MASTER CONFIGURATION                    â•‘
        // â•‘                                                                               â•‘
        // â•‘  This CFG object contains ALL game balance variables. When modifying game     â•‘
        // â•‘  mechanics, update values here and in GAME_BALANCE.txt for documentation.     â•‘
        // â•‘                                                                               â•‘
        // â•‘  EPOCH SYSTEM:                                                                â•‘
        // â•‘  - Epoch 0 (WANDER): Survival phase - explore, gather, recruit nomads         â•‘
        // â•‘  - Epoch 1 (PIT AGE): Subsistence phase - build settlements, manage labor     â•‘
        // â•‘  - Epoch 2 (TENTS): Advanced phase - commercial, granaries (LOCKED)           â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const CFG = {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // I. GLOBAL RULES (The Physics Engine)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === MAP & RENDERING ===
            TILE: 48,           // Tile size in pixels for rendering
            W: 250,             // Map width in tiles (250x250 = 62,500 tiles)
            H: 250,             // Map height in tiles
            
            // === INVENTORY SYSTEM ===
            // Backpack: Holds Food & Wood, scales with population
            // Sack (Rare): Holds Stone & Metal, fixed capacity
            INVENTORY: {
                BACKPACK_BASE: 150,         // Starting backpack capacity
                BACKPACK_PER_POP: 100,      // Additional capacity per population
                SACK_CAPACITY: 1000,        // Fixed rare item storage (Stone & Metal)
                OVERFLOW_DELETE: true       // Overflow items are deleted instantly
            },
            
            // === VISUAL STATES ===
            // Buildings change appearance based on occupancy percentage
            // 0=Abandoned (0%, 10yrs), 1=Light (1-30%), 2=Medium (31-80%), 3=Extreme (81-100%)
            VISUAL_STATES: {
                ABANDONED_YEARS: 10,        // Years at 0 occupancy before abandoned
                LIGHT_MAX: 0.30,            // 1-30% occupancy
                MEDIUM_MAX: 0.80,           // 31-80% occupancy
                EXTREME_MIN: 0.81           // 81-100% occupancy
            },
            
            // === BULLDOZE MECHANIC ===
            BULLDOZE_REFUND: 0.10,          // 10% of construction cost returned
            
            // === PERFORMANCE OPTIMIZATION ===
            PERF: {
                SPATIAL_GRID_SIZE: 10,
                PARTICLE_POOL_SIZE: 100,
                ENABLE_OFFSCREEN_CACHE: true,
                DIRTY_RECT_RENDERING: true
            },
            
            // === TERRAIN & BUILDING COLORS ===
            COLORS: {
                // Terrain colors - Yoshi's Island soft pastels
                DEEP: "#5890E8", WATER: "#78C8FF", RIVER: "#A0DCFF", SAND: "#FFE8A0", 
                GRASS: "#78E878", FOREST: "#40B040", EARTH: "#E8A860", ROCK: "#B8B8C8", SNOW: "#F8F8FF", 
                STONE: "#A0A0B0",
                // Building colors - friendly bright tones
                ROAD: "#D8A050", RES: "#FF78A8", COM: "#FFD878", IND: "#B888E8", WELL: "#68D8FF",
                BASKET: "#F8A868", POTTERY: "#E8B860", GRANARY: "#D8B078", PALACE: "#FFE078", CHIEF: "#E8B068",
                // UI colors
                OK: "rgba(255,255,255,0.4)", NO: "rgba(248,88,88,0.85)"
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // II. EPOCH 0: THE WANDERER (Survival Phase)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === MOVEMENT & EXPLORATION ===
            PLAYER: { 
                START_HEALTH: 3,            // Initial health (population = health in Epoch 0)
                VISION_RADIUS: 3            // Fog of war reveal radius
            },
            
            // === MOVEMENT FOOD COST ===
            // Walking costs food - 1 food per 15 tiles per population
            MOVEMENT: {
                STEPS_PER_FOOD: 15,         // Every 15 steps costs food
                FOOD_PER_PERSON: 1          // 1 food consumed per person per 15 steps
            },
            
            // === FOREST TILE ===
            // Passive step: +1 Wood (Scavenging)
            FOREST: {
                WOOD_PER_STEP: 1            // Wood gained when stepping on forest
            },
            
            // === OPEN GROUND ===
            // Passive step: 0.01% chance for rare find
            OPEN_GROUND: {
                RARE_FIND_CHANCE: 0.01,     // 1% chance per step
                METAL_CHANCE: 0.5,          // 50% metal, 50% stone if rare find
                FIND_AMOUNT: 1              // +1 Metal or +1 Stone
            },
            
            // === BERRY BUSH ===
            BERRIES: { 
                SPAWN_COUNT: 400,           // Number of berry bushes on map
                FOOD_VALUE: 10,             // Food gained (90% chance)
                POISON_CHANCE: 0.10,        // 10% chance of poison
                POISON_DAMAGE: 1            // -1 Pop if poisoned
            },
            
            // === ANIMALS (Deer/Bison/Mammoth) ===
            // Pack Logic: If touching another animal, -1 Pop
            // Wolves are separate entity type (always cost pop, fixed reward)
            ANIMALS: { 
                SPAWN_COUNT: 1064,          // Total animals on map (excluding wolves)
                PACK_DAMAGE: 1,             // -1 Pop if in pack (adjacent to another)
                TYPES: [
                    { name: 'DEER', hitToKill: 2, foodReward: [1, 30], popCost: 0, color: '#C89858', speed: 1, spawnRate: 0.50 },
                    { name: 'BISON', hitToKill: 3, foodReward: [5, 30], popCost: 0, color: '#A06830', speed: 0.5, spawnRate: 0.35 },
                    { name: 'MAMMOTH', hitToKill: 5, foodReward: [15, 30], popCost: 0, color: '#806040', speed: 0.3, spawnRate: 0.15 }
                ]
            },
            
            // === NOMADS ===
            // 84% Friendly: +1 Pop, +Map Reveal, Loot
            // 16% Hostile: Ambush (-1 to -3 Pop)
            NOMAD: { 
                SPAWN_COUNT: 1500,          // Total nomads on map (increased)
                HOSTILE_CHANCE: 0.33,       // 33% hostile (increased)
                FRIENDLY_POP_BONUS: 1,      // +1 Pop from friendly
                HOSTILE_DAMAGE: [1, 3],     // -1 to -3 Pop from hostile
                LOOT_RANGES: {              // Loot from friendly nomads
                    FOOD: [5, 30],
                    WOOD: [5, 30],
                    METAL: [0, 10],
                    STONE: [0, 5]           // No stone loot per spec (0-10 metal only)
                }
            },
            
            // === SETTLEMENT TRANSITION REQUIREMENTS ===
            // To unlock "Found Settlement" button (Epoch 0 â†’ Epoch 1)
            // SimCity-style: Can settle ANYWHERE, but get bonuses for good locations
            SETTLEMENT_REQUIREMENTS: {
                MIN_POP: 2,                 // Population >= 2 (player + 1 nomad)
                MIN_FOOD: 100,              // Food >= 100
                MIN_WOOD: 25,               // Wood >= 25 (lowered to allow quick start)
                WATER_DISTANCE: 5           // Water proximity for BONUS only (not required)
            },
            
            // === SIMCITY-STYLE SETTLEMENT LOCATION BONUSES ===
            // Players can settle anywhere but get bonuses for strategic locations
            SETTLEMENT_LOCATION_BONUS: {
                // Water proximity bonuses (stacks with distance)
                WATER_ADJACENT: 0.30,       // +30% if water within 2 tiles
                WATER_NEARBY: 0.15,         // +15% if water within 5 tiles
                WATER_RANGE: 5,             // Max range to check for water
                
                // Resource proximity bonuses
                FOREST_NEARBY: 0.10,        // +10% for nearby forest/trees
                STONE_NEARBY: 0.10,         // +10% for nearby stone deposits
                BERRY_NEARBY: 0.15,         // +15% for nearby berry bushes
                
                // Terrain bonuses
                GRASSLAND_BONUS: 0.05,      // +5% for settling on grass
                HILL_BONUS: 0.05,           // +5% for settling on hills (defense)
                
                // Future: Special building proximity (to be added)
                SPECIAL_BUILDING_BONUS: 0.20 // +20% near special structures
            },
            
            // === SETTLEMENT BONUSES (for recruiting before settling) ===
            SETTLEMENT_BONUS: {
                THRESHOLD_50: 0.10,         // 50 people = +10% inventory bonus
                THRESHOLD_100: 0.20,        // 100 people = +20%
                THRESHOLD_150: 0.30,        // 150 people = +30%
                THRESHOLD_200: 0.40         // 200 people = +40% (max)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // III. EPOCH 1: THE PIT AGE (Subsistence Phase)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === BUILDING COSTS (Construction) ===
            BUILDING_COSTS: {
                MUD_PIT: { food: 100, wood: 100, stone: 0 },
                DIRT_ROAD: { food: 5, wood: 5, stone: 0 },
                WATER_WELL: { food: 50, wood: 200, stone: 5 },
                HUNTING_GROUND: { food: 500, wood: 100, stone: 0 }
            },
            
            // === BUILDING UPKEEP (Per Year) ===
            BUILDING_UPKEEP: {
                MUD_PIT: { wood: 1 },
                DIRT_ROAD: { wood: 0 },
                WATER_WELL: { wood: 0 },
                HUNTING_GROUND: { wood: 5 }
            },
            
            // === BUILDING LABOR COSTS (Workers) ===
            BUILDING_LABOR: {
                MUD_PIT: 0,                 // No workers needed
                DIRT_ROAD: 1,               // 1 worker per road tile
                WATER_WELL: 0.1,            // 1 worker per 10 people served
                HUNTING_GROUND_MIN: 20,     // Minimum 20 workers
                HUNTING_GROUND_MAX: 100     // Maximum 100 workers
            },
            
            // === BUILDING CAPACITIES & STATS ===
            BUILDING_STATS: {
                MUD_PIT: {
                    capacity: 20,           // Max 20 people per Mud Pit
                    efficiency: 0.50,       // 50% efficiency (high consumption)
                    growth_light: 0.01,     // +1% growth at light occupancy
                    growth_extreme: 0.05    // +5% growth at extreme occupancy
                },
                WATER_WELL: {
                    capacity: 500,          // Each well serves 500 people
                    workers: 2              // Each well requires 2 workers
                },
                HUNTING_GROUND: {
                    range_walk: 7,          // Range without roads
                    range_road: 17,         // Range with roads (doubles + 3)
                    unlock_residences: 20,  // OR 20 residences built
                    unlock_pop: 100         // OR 100 population
                }
            },
            
            // === DIRT ROAD EFFECT ===
            ROAD: {
                MOVEMENT_MULTIPLIER: 2      // Doubles movement range for services
            },
            
            // === LOCKED BUILDINGS (Epoch 2+) ===
            LOCKED_EPOCH1: ['COMMERCIAL', 'GRANARY'],
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // IV. EPOCH 1: THREATS & CRISES (The Math of Death)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            CRISES: {
                // STARVATION: Food < 0
                STARVATION: {
                    trigger: 'FOOD_NEGATIVE',
                    death_rate: 0.20        // Instant loss of 20% Population
                },
                
                // THIRST: Pop > (Wells * 100)
                THIRST: {
                    trigger: 'INSUFFICIENT_WATER',
                    death_rate: 0.10        // Instant loss of 10% Population
                },
                
                // LABOR COLLAPSE: Workers Needed > Pop
                LABOR_COLLAPSE: {
                    trigger: 'INSUFFICIENT_LABOR',
                    effect: 'SHUTDOWN'      // Roads lose bonus, Wells stop
                },
                
                // ABANDONMENT: Occupancy == 0 for 10 years
                ABANDONMENT: {
                    trigger: 'EMPTY_10_YEARS',
                    upkeep_multiplier: 2    // Double upkeep or repair cost
                },
                
                // ROT: Food > Storage Cap
                ROT: {
                    trigger: 'OVER_STORAGE',
                    spoilage_rate: 0.30     // Lose 30% of surplus food per year
                },
                
                // OVERPOPULATION: Pop > Housing Cap
                OVERPOPULATION: {
                    trigger: 'OVER_HOUSING',
                    theft_rate: 0.05,       // Homeless steal 5% of food
                    plague_kill: 0.30       // Plague kills 30% of total Pop
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // V. EPOCH 2 TRANSITION REQUIREMENTS (The Boss Fight)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            EPOCH2_REQUIREMENTS: {
                POPULATION: 500,            // 500+ people
                INDUSTRY: 10,               // 10 Hunting Grounds built
                FOOD: 20000,                // 20,000 food stockpile
                WOOD: 10000,                // 10,000 wood stockpile
                STONE: 100,                 // 100 stone (scavenged)
                METAL: 100                  // 100 metal (scavenged)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LEGACY CONFIGURATION (For backward compatibility)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            COST: { RES:100, COM:250, IND:500, WELL:50, BULL:1, ROAD:5 },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILDING DATABASE - Unified data-driven building system
            // All buildings defined in one place for easy expansion
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === LEVEL 1 RESIDENTIAL GATHERING RATES (per your docs) ===
            LEVEL_1_GATHER: {
                HOMELESS: { food: 3, wood: 3, stone: 0, metal: 0 },
                MUD_PIT: { food: 6, wood: 6, stone: 0, metal: 0 },      // 3 base + 3 bonus
                STRAW_PIT: { food: 7, wood: 7, stone: 0, metal: 0 },    // Mud + 1
                LARGE_STRAW_PIT: { food: 8, wood: 8, stonePerPerson: 1, metalPerPerson: 1 }  // Mud + 2 + per person bonus
            },
            
            // === LEVEL 1 ZONE COSTS ===
            LEVEL_1_COSTS: {
                PATH: 5,                                                // $5 per path
                COMMERCIAL: { wood: 200, food: 200 },                   // Campfire
                INDUSTRIAL: { wood: 200, food: 200 }                    // Hunting Grounds
            },
            
            // === LEVEL 2 ZONE COSTS ===
            LEVEL_2_COSTS: {
                RESIDENTIAL: { wood: 10000, food: 10000 },              // Grub Class
                COMMERCIAL: { wood: 10000, food: 10000 },               // Fire Pit
                INDUSTRIAL: { wood: 10000, food: 10000 },               // Water Industry
                DOCK: { wood: 100000, food: 10000 }                     // One-time special structure
            },
            
            // === LEVEL 2 PROGRESSION ===
            LEVEL_2_REQ: {
                POP: 2000,
                DOCK_BONUS: 0.05                                        // +5% output when connected
            },
            
            // === LEVEL 3 PROGRESSION ===
            LEVEL_3_REQ: {
                POP: 10000,
                MINE_COST: { wood: 1000000, food: 1000000 }
            },
            
            // === OVERPOPULATION PENALTY ===
            OVERPOP: {
                YEARS_BEFORE_PENALTY: 10,
                FIRST_PENALTY: 0.50,                                    // -50% after 10 years
                MAX_PENALTY: 0.80,                                      // Up to -80%
                MIN_POPULATION: 3                                       // Never below 3
            },
            
            // === ABANDONMENT ===
            ABANDON: {
                ZONE_YEARS: 20,                                         // Zone disappears after 20 years empty
                HOMELESS_DEATH_YEARS: 5                                 // Homeless die after 5 years
            },
            
            BUILDING_DB: {
                /*
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                UNIVERSAL UNLOCK SYSTEM - Reference Guide
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                Each building can have an `unlockReq` object with ANY combination of:
                
                â€¢ pop: number              â†’ Minimum population (e.g., pop: 5000)
                â€¢ resources: { res: n }    â†’ Must have X resource in stock
                                             (e.g., resources: { wood: 500, stone: 200 })
                â€¢ buildings: { ... }       â†’ Must have built specific buildings:
                    - type + level + count â†’ { type: 'IND', level: 2, count: 5 }
                    - type + count         â†’ { type: 'COM', count: 3 }
                    - category + count     â†’ { category: 'RESIDENTIAL', count: 10 }
                    - id + count           â†’ { id: 'WELL', count: 1 }
                    - Array for multiple   â†’ [{ type: 'IND', count: 2 }, { type: 'COM', count: 1 }]
                â€¢ year: number             â†’ Must reach Year X
                â€¢ level: number            â†’ Must be at Civilization Level X
                â€¢ tech: string[]           â†’ Must have researched technologies (future)
                â€¢ achievements: string[]   â†’ Must have earned achievements (future)
                
                EXAMPLES:
                â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Simple: just population
                unlockReq: { pop: 2000 }
                
                // Medium: population + resources
                unlockReq: { pop: 5000, resources: { wood: 1000, stone: 500 } }
                
                // Complex: pop + resources + buildings
                unlockReq: { 
                    pop: 10000, 
                    resources: { food: 5000 },
                    buildings: { type: 'IND', level: 2, count: 3 }
                }
                
                // Multi-building gate
                unlockReq: {
                    pop: 50000,
                    buildings: [
                        { type: 'IND', level: 3, count: 2 },
                        { type: 'COM', level: 2, count: 5 }
                    ]
                }
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                */
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESIDENTIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                'RES_1': {
                    id: 'RES_1', category: 'RESIDENTIAL', level: 1, name: 'Pit Class',
                    cost: { food: 100, wood: 100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20,
                    upkeep: { wood: 1, food: 1 },
                    // State thresholds per your docs: Mud Pit (1-6), Straw Pit (7-14), Large Straw Pit (15-20)
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned', icon: 'ğŸ•³ï¸' },
                        { min: 1, max: 6, name: 'Mud Pit', icon: 'ğŸšï¸', gather: { food: 6, wood: 6 } },
                        { min: 7, max: 14, name: 'Straw Pit', icon: 'ğŸ ', gather: { food: 7, wood: 7 } },
                        { min: 15, max: 20, name: 'Large Straw Pit', icon: 'ğŸ˜ï¸', gather: { food: 8, wood: 8, stonePerPerson: 1, metalPerPerson: 1 } }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 6 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 6 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Mud Pit', icon: 'ğŸšï¸', bonusMult: 1.0 },
                        { name: 'Straw Pit', icon: 'ğŸ ', bonusMult: 1.17 },
                        { name: 'Large Straw Pit', icon: 'ğŸ˜ï¸', bonusMult: 1.33 }
                    ],
                    unlockReq: { pop: 0 } // Always available with resources
                },
                'RES_2': {
                    id: 'RES_2', category: 'RESIDENTIAL', level: 2, name: 'Grub Class',
                    cost: { food: 10000, wood: 10000, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 60,
                    upkeep: { wood: 3, food: 3 },
                    bonusMultiplier: 2.5,  // 2.5x Level 1 bonuses
                    // State thresholds: Grubhouse (1-20), Classic GrubenhÃ¤user (21-40), Mammoth Bone Pit (41-60)
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned', icon: 'ğŸ•³ï¸' },
                        { min: 1, max: 20, name: 'Grubhouse', icon: 'â›º' },
                        { min: 21, max: 40, name: 'Classic GrubenhÃ¤user', icon: 'ğŸ•ï¸' },
                        { min: 41, max: 60, name: 'Mammoth Bone Pit', icon: 'ğŸ¦£' }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 2 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 2 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Grubhouse', icon: 'â›º', bonusMult: 1.0 },
                        { name: 'Classic GrubenhÃ¤user', icon: 'ğŸ•ï¸', bonusMult: 1.5 },
                        { name: 'Mammoth Bone Pit', icon: 'ğŸ¦£', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 2000, resources: { wood: 5000 } }  // Requires pop AND wood stockpile
                },
                'RES_3': {
                    id: 'RES_3', category: 'RESIDENTIAL', level: 3, name: 'Mud Brick',
                    cost: { food: 900, wood: 900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 100,
                    upkeep: { wood: 3, food: 3 },
                    benefits: [
                        { type: 'HOUSING', value: 100 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 30 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 30 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 1 }
                    ],
                    variants: [
                        { name: 'Ruins', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Small Cob', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Rondavel Hut', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Adobe Plaza', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { 
                        pop: 5000, 
                        resources: { wood: 2000, food: 2000 },
                        buildings: { type: 'COM', level: 1, count: 5 } 
                    }
                },
                'RES_4': {
                    id: 'RES_4', category: 'RESIDENTIAL', level: 4, name: 'Log House',
                    cost: { food: 2700, wood: 2700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 200,
                    upkeep: { wood: 4, food: 4 },
                    benefits: [
                        { type: 'HOUSING', value: 200 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 57 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 57 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 4 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 2 }
                    ],
                    variants: [
                        { name: 'Ruins', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Wood Shack', icon: 'ğŸ›–', bonusMult: 1.0 },
                        { name: 'Log House', icon: 'ğŸ ', bonusMult: 1.5 },
                        { name: 'Grand Log Hall', icon: 'ğŸ›ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 10000, buildings: { type: 'IND', level: 2, count: 5 } }
                },
                'RES_5': {
                    id: 'RES_5', category: 'RESIDENTIAL', level: 5, name: 'Residential Building - Level 5',
                    cost: { food: 8100, wood: 8100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 500,
                    upkeep: { wood: 5, food: 5 },
                    benefits: [
                        { type: 'HOUSING', value: 500 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 93 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 93 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 5 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 5 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 5 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 20000, buildings: { type: 'COM', level: 2, count: 5 } }
                },
                'RES_6': {
                    id: 'RES_6', category: 'RESIDENTIAL', level: 6, name: 'Residential Building - Level 6',
                    cost: { food: 24300, wood: 24300, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 1000,
                    upkeep: { wood: 6, food: 6 },
                    benefits: [
                        { type: 'HOUSING', value: 1000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 138 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 138 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 6 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 4 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 6 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 6 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 6 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 50000, buildings: { type: 'COM', level: 3, count: 5 } }
                },
                'RES_7': {
                    id: 'RES_7', category: 'RESIDENTIAL', level: 7, name: 'Residential Building - Level 7',
                    cost: { food: 72900, wood: 72900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 2000,
                    upkeep: { wood: 7, food: 7 },
                    benefits: [
                        { type: 'HOUSING', value: 2000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 192 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 192 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 7 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 5 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 7 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 7 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 7 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 100000, buildings: { type: 'COM', level: 4, count: 5 } }
                },
                'RES_8': {
                    id: 'RES_8', category: 'RESIDENTIAL', level: 8, name: 'Residential Building - Level 8',
                    cost: { food: 218700, wood: 218700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 4000,
                    upkeep: { wood: 8, food: 8 },
                    benefits: [
                        { type: 'HOUSING', value: 4000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 255 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 255 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 8 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 6 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 8 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 8 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 8 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 1000000 }
                },
                'RES_9': {
                    id: 'RES_9', category: 'RESIDENTIAL', level: 9, name: 'Residential Building - Level 9',
                    cost: { food: 656100, wood: 656100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 8000,
                    upkeep: { wood: 9, food: 9 },
                    benefits: [
                        { type: 'HOUSING', value: 8000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 327 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 327 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 9 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 7 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 9 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 9 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 9 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 2000000 }
                },
                'RES_10': {
                    id: 'RES_10', category: 'RESIDENTIAL', level: 10, name: 'Residential Building - Level 10',
                    cost: { food: 1968300, wood: 1968300, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 10000,
                    upkeep: { wood: 10, food: 10 },
                    benefits: [
                        { type: 'HOUSING', value: 10000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 408 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 408 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 8 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 10 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 10 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 10 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 4000000 }
                },
                'RES_11': {
                    id: 'RES_11', category: 'RESIDENTIAL', level: 11, name: 'Residential Building - Level 11',
                    cost: { food: 5904900, wood: 5904900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20000,
                    upkeep: { wood: 11, food: 11 },
                    benefits: [
                        { type: 'HOUSING', value: 20000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 498 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 498 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 11 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 9 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 11 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 11 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 11 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 10000000 }
                },
                'RES_12': {
                    id: 'RES_12', category: 'RESIDENTIAL', level: 12, name: 'Residential Building - Level 12',
                    cost: { food: 17714700, wood: 17714700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 40000,
                    upkeep: { wood: 12, food: 12 },
                    benefits: [
                        { type: 'HOUSING', value: 40000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 597 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 597 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 12 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 10 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 12 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 12 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 12 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 15000000 }
                },
                'RES_13': {
                    id: 'RES_13', category: 'RESIDENTIAL', level: 13, name: 'Residential Building - Level 13',
                    cost: { food: 53144100, wood: 53144100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 80000,
                    upkeep: { wood: 13, food: 13 },
                    benefits: [
                        { type: 'HOUSING', value: 80000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 705 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 705 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 13 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 11 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 13 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 13 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 13 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 17000000 }
                },
                'RES_14': {
                    id: 'RES_14', category: 'RESIDENTIAL', level: 14, name: 'Residential Building - Level 14',
                    cost: { food: 159432300, wood: 159432300, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 200000,
                    upkeep: { wood: 14, food: 14 },
                    benefits: [
                        { type: 'HOUSING', value: 200000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 822 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 822 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 14 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 12 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 14 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 14 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 14 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 20000000 }
                },
                'RES_15': {
                    id: 'RES_15', category: 'RESIDENTIAL', level: 15, name: 'Residential Building - Level 15',
                    cost: { food: 478296900, wood: 478296900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 400000,
                    upkeep: { wood: 15, food: 15 },
                    benefits: [
                        { type: 'HOUSING', value: 400000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 948 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 948 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 13 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 15 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 15 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 15 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 25000000 }
                },
                'RES_16': {
                    id: 'RES_16', category: 'RESIDENTIAL', level: 16, name: 'Residential Building - Level 16',
                    cost: { food: 1434890700, wood: 1434890700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 800000,
                    upkeep: { wood: 16, food: 16 },
                    benefits: [
                        { type: 'HOUSING', value: 800000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1083 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1083 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 16 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 14 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 16 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 16 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 16 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 27000000 }
                },
                'RES_17': {
                    id: 'RES_17', category: 'RESIDENTIAL', level: 17, name: 'Residential Building - Level 17',
                    cost: { food: 4304672100, wood: 4304672100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 1000000,
                    upkeep: { wood: 17, food: 17 },
                    benefits: [
                        { type: 'HOUSING', value: 1000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1227 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1227 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 17 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 15 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 17 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 17 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 17 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 35000000 }
                },
                'RES_18': {
                    id: 'RES_18', category: 'RESIDENTIAL', level: 18, name: 'Residential Building - Level 18',
                    cost: { food: 12914016300, wood: 12914016300, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 2000000,
                    upkeep: { wood: 18, food: 18 },
                    benefits: [
                        { type: 'HOUSING', value: 2000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1380 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1380 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 18 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 16 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 18 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 18 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 18 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 50000000 }
                },
                'RES_19': {
                    id: 'RES_19', category: 'RESIDENTIAL', level: 19, name: 'Residential Building - Level 19',
                    cost: { food: 38742048900, wood: 38742048900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 3000000,
                    upkeep: { wood: 19, food: 19 },
                    benefits: [
                        { type: 'HOUSING', value: 3000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1542 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1542 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 19 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 17 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 19 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 19 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 19 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 100000000 }
                },
                // Levels 20-24 from spreadsheet
                'RES_20': {
                    id: 'RES_20', category: 'RESIDENTIAL', level: 20, name: 'Residential Building - Level 20',
                    cost: { food: 116226146700, wood: 116226146700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 4000000,
                    upkeep: { wood: 20, food: 20 },
                    benefits: [
                        { type: 'HOUSING', value: 4000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1713 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1713 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 18 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 20 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 20 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 20 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 105000000 }
                },
                'RES_21': {
                    id: 'RES_21', category: 'RESIDENTIAL', level: 21, name: 'Residential Building - Level 21',
                    cost: { food: 348678440100, wood: 348678440100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 8000000,
                    upkeep: { wood: 21, food: 21 },
                    benefits: [
                        { type: 'HOUSING', value: 8000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 1893 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 1893 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 21 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 19 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 21 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 21 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 21 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 120000000 }
                },
                'RES_22': {
                    id: 'RES_22', category: 'RESIDENTIAL', level: 22, name: 'Residential Building - Level 22',
                    cost: { food: 1046035320300, wood: 1046035320300, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 10000000,
                    upkeep: { wood: 22, food: 22 },
                    benefits: [
                        { type: 'HOUSING', value: 10000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 2082 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 2082 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 22 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 20 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 22 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 22 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 22 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 200000000 }
                },
                'RES_23': {
                    id: 'RES_23', category: 'RESIDENTIAL', level: 23, name: 'Residential Building - Level 23',
                    cost: { food: 3138105960900, wood: 3138105960900, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20000000,
                    upkeep: { wood: 23, food: 23 },
                    benefits: [
                        { type: 'HOUSING', value: 20000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 2280 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 2280 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 23 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 21 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 23 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 23 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 23 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 220000000 }
                },
                'RES_24': {
                    id: 'RES_24', category: 'RESIDENTIAL', level: 24, name: 'Residential Building - Level 24',
                    cost: { food: 9414317882700, wood: 9414317882700, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50000000,
                    upkeep: { wood: 24, food: 24 },
                    benefits: [
                        { type: 'HOUSING', value: 50000000 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 2487 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 2487 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 24 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 22 }
                    ],
                    variants: [
                        { name: 'Abandoned', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Level 24 - Low', icon: 'ğŸ ', bonusMult: 1.0 },
                        { name: 'Level 24 - Medium', icon: 'ğŸ¡', bonusMult: 1.5 },
                        { name: 'Level 24 - High', icon: 'ğŸ˜ï¸', bonusMult: 2.0 }
                    ],
                    unlockReq: { pop: 250000000 }
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDUSTRIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                'IND_1': {
                    id: 'IND_1', category: 'INDUSTRIAL', level: 1, name: 'Hunting Ground',
                    cost: { food: 1000, wood: 1000, stone: 0, metal: 0 },
                    size: { w: 2, h: 2 }, capacity: 100,
                    upkeep: { wood: 1, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 100 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 1 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Abandoned Hunting Ground', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Hunting Ground', icon: 'ğŸ¹', bonusMult: 1.0 },
                        { name: 'Active Hunting Ground', icon: 'ğŸ¦Œ', bonusMult: 1.5 },
                        { name: 'Thriving Hunting Ground', icon: 'ğŸ•ï¸', bonusMult: 2.0 }
                    ],
                    popUnlock: 2
                },
                'IND_2': {
                    id: 'IND_2', category: 'INDUSTRIAL', level: 2, name: 'Hunting Pit',
                    cost: { food: 2000, wood: 2000, stone: 0, metal: 0 },
                    size: { w: 2, h: 2 }, capacity: 200,
                    upkeep: { wood: 2, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 200 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 4 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 4 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 4 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 2 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Collapsed Hunting Pit', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Hunting Pit', icon: 'âš”ï¸', bonusMult: 1.0 },
                        { name: 'Deep Hunting Pit', icon: 'ğŸ—¡ï¸', bonusMult: 1.5 },
                        { name: 'Grand Hunting Pit', icon: 'âš”ï¸', bonusMult: 2.0 }
                    ],
                    popUnlock: 100
                },
                'IND_3': {
                    id: 'IND_3', category: 'INDUSTRIAL', level: 3, name: 'Advanced Hunting Ground',
                    cost: { food: 3000, wood: 3000, stone: 100, metal: 100 },
                    size: { w: 2, h: 2 }, capacity: 300,
                    upkeep: { wood: 3, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 300 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Ruined Advanced Ground', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Advanced Hunting Ground', icon: 'ğŸ¯', bonusMult: 1.0 },
                        { name: 'Superior Hunting Ground', icon: 'ğŸ¦¬', bonusMult: 1.5 },
                        { name: 'Elite Hunting Ground', icon: 'ğŸ†', bonusMult: 2.0 }
                    ],
                    popUnlock: 500
                },
                'IND_4': {
                    id: 'IND_4', category: 'INDUSTRIAL', level: 4, name: 'Basic Tannery',
                    cost: { food: 4000, wood: 4000, stone: 500, metal: 500 },
                    size: { w: 2, h: 2 }, capacity: 400,
                    upkeep: { wood: 4, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 400 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 6 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 6 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 6 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 4 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Abandoned Tannery', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Basic Tannery', icon: 'ğŸ¥¾', bonusMult: 1.0 },
                        { name: 'Working Tannery', icon: 'ğŸ‘œ', bonusMult: 1.5 },
                        { name: 'Master Tannery', icon: 'ğŸ’', bonusMult: 2.0 }
                    ],
                    popUnlock: 2000
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMMERCIAL (Placeholder) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // User will define these via spreadsheet
                'COM_1': {
                    id: 'COM_1', category: 'COMMERCIAL', level: 1, name: 'Market Stall',
                    cost: { food: 500, wood: 500, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 10,
                    upkeep: { wood: 1, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 10 },
                        { type: 'INCOME', value: 5 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.2 }
                    ],
                    variants: [
                        { name: 'Abandoned Stall', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Market Stall', icon: 'ğŸª', bonusMult: 1.0 },
                        { name: 'Busy Stall', icon: 'ğŸ›’', bonusMult: 1.5 },
                        { name: 'Premium Stall', icon: 'ğŸ¬', bonusMult: 2.0 }
                    ],
                    popUnlock: 50
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SPECIAL (Placeholder) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // User will define these via spreadsheet
                'WELL': {
                    id: 'WELL', category: 'INFRASTRUCTURE', level: 1, name: 'Water Well',
                    cost: { food: 50, wood: 200, stone: 5, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'WATER', value: 100 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Dry Well', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Water Well', icon: 'ğŸ’§', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                },
                'CHIEF': {
                    id: 'CHIEF', category: 'SPECIAL', level: 1, name: "Chief's Hut",
                    cost: { food: 10000, wood: 0, stone: 0, metal: 0 },
                    size: { w: 2, h: 2 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 50, value: 2.0 },
                        { type: 'CULTURE', value: 10 }
                    ],
                    variants: [
                        { name: "Chief's Hut", icon: 'ğŸ›ï¸', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                }
            },
            
            // Category groupings for menus
            BUILDING_CATEGORIES: {
                RESIDENTIAL: ['RES_1', 'RES_2', 'RES_3', 'RES_4', 'RES_5', 'RES_6', 'RES_7', 'RES_8', 'RES_9', 
                              'RES_10', 'RES_11', 'RES_12', 'RES_13', 'RES_14', 'RES_15', 'RES_16', 'RES_17', 'RES_18', 'RES_19',
                              'RES_20', 'RES_21', 'RES_22', 'RES_23', 'RES_24'],
                INDUSTRIAL: ['IND_1', 'IND_2', 'IND_3', 'IND_4'],
                COMMERCIAL: ['COM_1'],  // Placeholder - user will expand
                INFRASTRUCTURE: ['WELL'],
                SPECIAL: ['CHIEF']  // Placeholder - user will expand
            },
            
            // Helper to get building by ID
            getBuilding(id) {
                return this.BUILDING_DB[id] || null;
            },
            
            // Helper to get buildings by category
            getBuildingsByCategory(category) {
                let ids = this.BUILDING_CATEGORIES[category] || [];
                return ids.map(id => this.BUILDING_DB[id]).filter(b => b);
            },
            
            // BACKWARD COMPATIBILITY: Map level number to BUILDING_DB entry
            // Returns building in OLD format for compatibility with existing code
            getResidentialByLevel(level) {
                let building = this.BUILDING_DB['RES_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            getIndustrialByLevel(level) {
                let building = this.BUILDING_DB['IND_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            // Helper to extract gatherBonus from benefits array
            _extractGatherBonus(building) {
                let bonus = { wood: 0, food: 0, stone: 0, metal: 0 };
                if(!building.benefits) return bonus;
                for(let b of building.benefits) {
                    if(b.type === 'GATHER_BONUS' && b.resource) {
                        bonus[b.resource] = b.value;
                    }
                }
                return bonus;
            },
            
            // ERAS control maximum building level based on population
            // Follows exponential scaling: each level requires ~3x previous population
            ERAS: [
                { name: 'Wanderer', level: 0, popUnlock: 0 },
                { name: 'Settlement', level: 1, popUnlock: 2 },
                { name: 'Village', level: 2, popUnlock: 20 },
                { name: 'Town', level: 3, popUnlock: 100 },
                { name: 'City', level: 4, popUnlock: 500 },
                { name: 'Metro', level: 5, popUnlock: 2000 },
                { name: 'Province', level: 6, popUnlock: 7000 },
                { name: 'Region', level: 7, popUnlock: 20000 },
                { name: 'State', level: 8, popUnlock: 60000 },
                { name: 'Nation', level: 9, popUnlock: 180000 },
                { name: 'Empire', level: 10, popUnlock: 500000 },
                { name: 'Dominion', level: 11, popUnlock: 1400000 },
                { name: 'Realm', level: 12, popUnlock: 4200000 },
                { name: 'Dynasty', level: 13, popUnlock: 13000000 },
                { name: 'Hegemony', level: 14, popUnlock: 38000000 },
                { name: 'Superpower', level: 15, popUnlock: 115000000 },
                { name: 'World Power', level: 16, popUnlock: 345000000 },
                { name: 'Hyperpower', level: 17, popUnlock: 1000000000 },
                { name: 'Civilization', level: 18, popUnlock: 3100000000 },
                { name: 'Eternal', level: 19, popUnlock: 10000000000 }
            ],
            
            // === BUILDING LEVELS (Multi-tier system) ===
            BUILDING_LEVELS: [
                // Level 0: WANDER epoch - no building
                { level: 0, name: 'Wanderer', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0 },
                
                // Level 1: Pit
                { level: 1, name: 'Pit', food: 100, wood: 100, stone: 0, metal: 0, capacity: 20,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 3, food: 3, stone: 1, metal: 0 },
                  variants: [
                    { name: 'Hole', icon: 'ğŸ•³ï¸' },
                    { name: 'Mud Pit', icon: 'ğŸšï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Straw Pit', icon: 'ğŸ ', bonus: { wood: 1, food: 1 } },
                    { name: 'Stone Straw Pit', icon: 'ğŸ˜ï¸', bonus: { wood: 1.5, food: 1.5 } }
                  ]
                },
                // Level 2: Leather Tent
                { level: 2, name: 'Leather Tent', food: 300, wood: 300, stone: 0, metal: 0, capacity: 50,
                  upkeep: { wood: 2, food: 2 },
                  gatherBonus: { wood: 12, food: 12, stone: 2, metal: 0 },
                  variants: [
                    { name: 'Old Skin Tent', icon: 'â›º' },
                    { name: 'Ragged Hide Tent', icon: 'ğŸ•ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Animal Hide Tent', icon: 'ğŸ›–', bonus: { wood: 2, food: 2 } },
                    { name: 'Large Wigwam Tipi', icon: 'ğŸª', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                // Level 3: Mud Brick
                { level: 3, name: 'Mud Brick', food: 900, wood: 900, stone: 0, metal: 0, capacity: 100,
                  upkeep: { wood: 3, food: 3 },
                  gatherBonus: { wood: 30, food: 30, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Ruins', icon: 'ğŸšï¸' },
                    { name: 'Small Cob', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Rondavel Hut', icon: 'ğŸ¡', bonus: { wood: 3, food: 3 } },
                    { name: 'Adobe Plaza', icon: 'ğŸ˜ï¸', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                // Level 4: Log House
                { level: 4, name: 'Log House', food: 2700, wood: 2700, stone: 0, metal: 0, capacity: 170,
                  upkeep: { wood: 4, food: 4 },
                  gatherBonus: { wood: 57, food: 57, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Ruins', icon: 'ğŸšï¸' },
                    { name: 'Wood Shack', icon: 'ğŸ›–', bonus: { wood: 0, food: 0 } },
                    { name: 'Log House', icon: 'ğŸ ', bonus: { wood: 4, food: 4 } },
                    { name: 'Grand Log Hall', icon: 'ğŸ¡', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                // Level 5: Stone Cottage
                { level: 5, name: 'Stone Cottage', food: 8100, wood: 8100, stone: 0, metal: 0, capacity: 260,
                  upkeep: { wood: 5, food: 5 },
                  gatherBonus: { wood: 93, food: 93, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Rubble', icon: 'ğŸª¨' },
                    { name: 'Stone Hut', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Stone Cottage', icon: 'ğŸ¡', bonus: { wood: 5, food: 5 } },
                    { name: 'Stone Manor', icon: 'ğŸ˜ï¸', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                },
                // Level 6: Timber Frame
                { level: 6, name: 'Timber Frame', food: 24300, wood: 24300, stone: 0, metal: 0, capacity: 370,
                  upkeep: { wood: 6, food: 6 },
                  gatherBonus: { wood: 138, food: 138, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Collapsed Frame', icon: 'ğŸšï¸' },
                    { name: 'Basic Frame', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Timber House', icon: 'ğŸ¡', bonus: { wood: 6, food: 6 } },
                    { name: 'Timber Hall', icon: 'ğŸ›ï¸', bonus: { wood: 6.5, food: 6.5 } }
                  ]
                },
                // Level 7: Brick House
                { level: 7, name: 'Brick House', food: 72900, wood: 72900, stone: 0, metal: 0, capacity: 500,
                  upkeep: { wood: 7, food: 7 },
                  gatherBonus: { wood: 192, food: 192, stone: 7, metal: 5 },
                  variants: [
                    { name: 'Crumbling Brick', icon: 'ğŸ§±' },
                    { name: 'Brick Shack', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Brick House', icon: 'ğŸ¡', bonus: { wood: 7, food: 7 } },
                    { name: 'Brick Mansion', icon: 'ğŸ˜ï¸', bonus: { wood: 7.5, food: 7.5 } }
                  ]
                },
                // Level 8: Town House
                { level: 8, name: 'Town House', food: 218700, wood: 218700, stone: 0, metal: 0, capacity: 650,
                  upkeep: { wood: 8, food: 8 },
                  gatherBonus: { wood: 255, food: 255, stone: 8, metal: 6 },
                  variants: [
                    { name: 'Abandoned Town', icon: 'ğŸšï¸' },
                    { name: 'Small Townhouse', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Town House', icon: 'ğŸ¡', bonus: { wood: 8, food: 8 } },
                    { name: 'Grand Townhouse', icon: 'ğŸ›ï¸', bonus: { wood: 8.5, food: 8.5 } }
                  ]
                },
                // Level 9: Villa
                { level: 9, name: 'Villa', food: 656100, wood: 656100, stone: 0, metal: 0, capacity: 820,
                  upkeep: { wood: 9, food: 9 },
                  gatherBonus: { wood: 327, food: 327, stone: 9, metal: 7 },
                  variants: [
                    { name: 'Ruined Villa', icon: 'ğŸšï¸' },
                    { name: 'Simple Villa', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Villa', icon: 'ğŸ¡', bonus: { wood: 9, food: 9 } },
                    { name: 'Grand Villa', icon: 'ğŸ°', bonus: { wood: 9.5, food: 9.5 } }
                  ]
                },
                // Level 10: Estate
                { level: 10, name: 'Estate', food: 1968300, wood: 1968300, stone: 0, metal: 0, capacity: 1010,
                  upkeep: { wood: 10, food: 10 },
                  gatherBonus: { wood: 408, food: 408, stone: 10, metal: 8 },
                  variants: [
                    { name: 'Ruined Estate', icon: 'ğŸšï¸' },
                    { name: 'Small Estate', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Estate', icon: 'ğŸ¡', bonus: { wood: 10, food: 10 } },
                    { name: 'Grand Estate', icon: 'ğŸ°', bonus: { wood: 10.5, food: 10.5 } }
                  ]
                },
                // Level 11: Manor
                { level: 11, name: 'Manor', food: 5904900, wood: 5904900, stone: 0, metal: 0, capacity: 1220,
                  upkeep: { wood: 11, food: 11 },
                  gatherBonus: { wood: 498, food: 498, stone: 11, metal: 9 },
                  variants: [
                    { name: 'Ruined Manor', icon: 'ğŸšï¸' },
                    { name: 'Small Manor', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Manor', icon: 'ğŸ›ï¸', bonus: { wood: 11, food: 11 } },
                    { name: 'Grand Manor', icon: 'ğŸ°', bonus: { wood: 11.5, food: 11.5 } }
                  ]
                },
                // Level 12: Palace
                { level: 12, name: 'Palace', food: 17714700, wood: 17714700, stone: 0, metal: 0, capacity: 1450,
                  upkeep: { wood: 12, food: 12 },
                  gatherBonus: { wood: 597, food: 597, stone: 12, metal: 10 },
                  variants: [
                    { name: 'Ruined Palace', icon: 'ğŸšï¸' },
                    { name: 'Small Palace', icon: 'ğŸ›ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Palace', icon: 'ğŸ°', bonus: { wood: 12, food: 12 } },
                    { name: 'Grand Palace', icon: 'ğŸ‘‘', bonus: { wood: 12.5, food: 12.5 } }
                  ]
                },
                // Level 13: Citadel
                { level: 13, name: 'Citadel', food: 53144100, wood: 53144100, stone: 0, metal: 0, capacity: 1700,
                  upkeep: { wood: 13, food: 13 },
                  gatherBonus: { wood: 705, food: 705, stone: 13, metal: 11 },
                  variants: [
                    { name: 'Ruined Citadel', icon: 'ğŸšï¸' },
                    { name: 'Small Citadel', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Citadel', icon: 'ğŸ¯', bonus: { wood: 13, food: 13 } },
                    { name: 'Grand Citadel', icon: 'âš”ï¸', bonus: { wood: 13.5, food: 13.5 } }
                  ]
                },
                // Level 14: Fortress
                { level: 14, name: 'Fortress', food: 159432300, wood: 159432300, stone: 0, metal: 0, capacity: 1970,
                  upkeep: { wood: 14, food: 14 },
                  gatherBonus: { wood: 822, food: 822, stone: 14, metal: 12 },
                  variants: [
                    { name: 'Ruined Fortress', icon: 'ğŸšï¸' },
                    { name: 'Small Fortress', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Fortress', icon: 'ğŸ¯', bonus: { wood: 14, food: 14 } },
                    { name: 'Grand Fortress', icon: 'ğŸ›¡ï¸', bonus: { wood: 14.5, food: 14.5 } }
                  ]
                },
                // Level 15: Castle
                { level: 15, name: 'Castle', food: 478296900, wood: 478296900, stone: 0, metal: 0, capacity: 2260,
                  upkeep: { wood: 15, food: 15 },
                  gatherBonus: { wood: 948, food: 948, stone: 15, metal: 13 },
                  variants: [
                    { name: 'Ruined Castle', icon: 'ğŸšï¸' },
                    { name: 'Small Castle', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Castle', icon: 'ğŸ¯', bonus: { wood: 15, food: 15 } },
                    { name: 'Grand Castle', icon: 'ğŸ‘‘', bonus: { wood: 15.5, food: 15.5 } }
                  ]
                },
                // Level 16: Kingdom
                { level: 16, name: 'Kingdom', food: 1434890700, wood: 1434890700, stone: 0, metal: 0, capacity: 2570,
                  upkeep: { wood: 16, food: 16 },
                  gatherBonus: { wood: 1083, food: 1083, stone: 16, metal: 14 },
                  variants: [
                    { name: 'Fallen Kingdom', icon: 'ğŸšï¸' },
                    { name: 'Small Kingdom', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Kingdom', icon: 'ğŸ‘‘', bonus: { wood: 16, food: 16 } },
                    { name: 'Grand Kingdom', icon: 'ğŸŒŸ', bonus: { wood: 16.5, food: 16.5 } }
                  ]
                },
                // Level 17: Empire
                { level: 17, name: 'Empire', food: 4304672100, wood: 4304672100, stone: 0, metal: 0, capacity: 2900,
                  upkeep: { wood: 17, food: 17 },
                  gatherBonus: { wood: 1227, food: 1227, stone: 17, metal: 15 },
                  variants: [
                    { name: 'Fallen Empire', icon: 'ğŸšï¸' },
                    { name: 'Small Empire', icon: 'ğŸ‘‘', bonus: { wood: 0, food: 0 } },
                    { name: 'Empire', icon: 'ğŸŒŸ', bonus: { wood: 17, food: 17 } },
                    { name: 'Grand Empire', icon: 'âœ¨', bonus: { wood: 17.5, food: 17.5 } }
                  ]
                },
                // Level 18: Dynasty
                { level: 18, name: 'Dynasty', food: 12914016300, wood: 12914016300, stone: 0, metal: 0, capacity: 3250,
                  upkeep: { wood: 18, food: 18 },
                  gatherBonus: { wood: 1380, food: 1380, stone: 18, metal: 16 },
                  variants: [
                    { name: 'Fallen Dynasty', icon: 'ğŸšï¸' },
                    { name: 'Rising Dynasty', icon: 'ğŸ‘‘', bonus: { wood: 0, food: 0 } },
                    { name: 'Dynasty', icon: 'ğŸŒŸ', bonus: { wood: 18, food: 18 } },
                    { name: 'Eternal Dynasty', icon: 'ğŸ’«', bonus: { wood: 18.5, food: 18.5 } }
                  ]
                },
                // Level 19: Civilization
                { level: 19, name: 'Civilization', food: 38742048900, wood: 38742048900, stone: 0, metal: 0, capacity: 3620,
                  upkeep: { wood: 19, food: 19 },
                  gatherBonus: { wood: 1542, food: 1542, stone: 19, metal: 17 },
                  variants: [
                    { name: 'Lost Civilization', icon: 'ğŸšï¸' },
                    { name: 'Young Civilization', icon: 'ğŸŒŸ', bonus: { wood: 0, food: 0 } },
                    { name: 'Civilization', icon: 'âœ¨', bonus: { wood: 19, food: 19 } },
                    { name: 'Eternal Civilization', icon: 'ğŸŒŒ', bonus: { wood: 19.5, food: 19.5 } }
                  ]
                }
            ],
            
            // === INDUSTRIAL BUILDING LEVELS (4 tiers) ===
            INDUSTRIAL_LEVELS: [
                // Level 0: Placeholder (not buildable)
                { level: 0, name: 'None', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0 },
                
                // Level 1: Hunting Ground
                { level: 1, name: 'Hunting Ground', food: 1000, wood: 1000, stone: 0, metal: 0, capacity: 100,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 3, food: 3, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Abandoned Hunting Ground', icon: 'ğŸšï¸' },
                    { name: 'Hunting Ground', icon: 'ğŸ¹', bonus: { wood: 0, food: 0 } },
                    { name: 'Active Hunting Ground', icon: 'ğŸ¦Œ', bonus: { wood: 2, food: 2 } },
                    { name: 'Thriving Hunting Ground', icon: 'ğŸ•ï¸', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                
                // Level 2: Hunting Pit
                { level: 2, name: 'Hunting Pit', food: 2000, wood: 2000, stone: 0, metal: 0, capacity: 200,
                  upkeep: { wood: 2, food: 1 },
                  gatherBonus: { wood: 4, food: 4, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Collapsed Hunting Pit', icon: 'ğŸ•³ï¸' },
                    { name: 'Hunting Pit', icon: 'âš”ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Deep Hunting Pit', icon: 'ğŸ—¡ï¸', bonus: { wood: 3, food: 3 } },
                    { name: 'Grand Hunting Pit', icon: 'âš”ï¸', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                
                // Level 3: Advanced Hunting Ground
                { level: 3, name: 'Advanced Hunting Ground', food: 3000, wood: 3000, stone: 100, metal: 100, capacity: 300,
                  upkeep: { wood: 3, food: 1 },
                  gatherBonus: { wood: 5, food: 5, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Ruined Advanced Ground', icon: 'ğŸšï¸' },
                    { name: 'Advanced Hunting Ground', icon: 'ğŸ¯', bonus: { wood: 0, food: 0 } },
                    { name: 'Superior Hunting Ground', icon: 'ğŸ¦¬', bonus: { wood: 4, food: 4 } },
                    { name: 'Elite Hunting Ground', icon: 'ğŸ†', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                
                // Level 4: Basic Tannery
                { level: 4, name: 'Basic Tannery', food: 4000, wood: 4000, stone: 500, metal: 500, capacity: 400,
                  upkeep: { wood: 4, food: 1 },
                  gatherBonus: { wood: 6, food: 6, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Abandoned Tannery', icon: 'ğŸšï¸' },
                    { name: 'Basic Tannery', icon: 'ğŸ¥¾', bonus: { wood: 0, food: 0 } },
                    { name: 'Working Tannery', icon: 'ğŸ‘œ', bonus: { wood: 5, food: 5 } },
                    { name: 'Master Tannery', icon: 'ğŸ’', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                }
            ],
            
            ZONE_COST: 50,
            CHIEF_COST: 10000,
            CHIEF_RADIUS: 50,
            CHIEF_BONUS: 2.0,
            GROWTH_THRESHOLD: 1.0,
            DECAY_THRESHOLD: 0.7,
            EFFICIENCY: {
                NO_ROAD_PENALTY: 0.05,
                WATER_BONUS_MAX: 0.5,
                FOREST_BONUS: 0.2,
                DECAY_RATE: 0.02,
                MIN_EFFICIENCY: 0.1
            },
            DESIRABILITY: {
                NEIGHBOR_BONUS: 0.10,
                TREE_BONUS: 0.25,
                WATER_BONUS: 0.50,
                WATER_RANGE: 5,             // Updated to match settlement requirement
                ISOLATION_PENALTY: 0.50,
                ISOLATION_RANGE: 2,
                WEALTH_FOOD_MULTIPLIER: 1.2,
                PATH_BONUS: 0.10, // Path (formerly road)
                WELL_BONUS: 0.15,
                INDUSTRIAL_BONUS: 0.15,
                // SimCity-style: Higher-level building proximity bonuses
                // People WANT to live near nicer buildings
                RES_LEVEL_2_BONUS: 0.10,    // +10% for nearby Level 2 residential
                RES_LEVEL_3_BONUS: 0.20,    // +20% for nearby Level 3 residential
                RES_LEVEL_4_BONUS: 0.30,    // +30% for nearby Level 4 residential
                COM_LEVEL_BONUS: 0.15,      // +15% per commercial level nearby
                IND_LEVEL_BONUS: 0.10,      // +10% per industrial level nearby (jobs!)
                LEVEL_BONUS_RANGE: 3,       // Range to check for higher-level buildings
            },
            ZOOM: { MIN: 0.1, MAX: 3, STEP: 1.1 },
            CAMERA: { START_X: 3200, START_Y: 3200, START_ZOOM: 1.0 },
            
            HOUSING: { MUD_HUT_CAPACITY: 20, WARNING_CAPACITY: 55, MAX_CAPACITY: 60, OVERPOPULATION_YEARS: 10, DECAY_TARGET: 30 },
            PRODUCTION: { 
                PERSON_HUNTS: 2, 
                PERSON_EATS: 1, 
                FOOD_TO_GROW: 10, 
                FOOD_FOR_HUT: 50,
                INDUSTRIAL_FOOD_PER_TURN: 100, 
                INDUSTRIAL_SUPPORTS_POPULATION: 200, 
                YEARS_TO_UNLOCK_INDUSTRIAL: 10, 
                INDUSTRIAL_UNLOCK_COST: 100, 
                FOOD_CONSUMPTION_PER_10_POP: 1, 
                INDUSTRIAL_POPULATION_REQUIREMENT: 100, 
                WOLVES_REQUIRED_FOR_INDUSTRIAL: 0, // Removed - wolves no longer in game
                SIMCITY_MODE_UNLOCK_COST: 10000,
                SIMCITY_POPULATION_GROWTH_RATE: 0.15,
                SIMCITY_FOOD_PER_PERSON: 0.1,
                STARVATION_RATE: 0.20,      // Updated: 20% death on starvation
                BASE_GROWTH_RATE: 3
            },
            UPGRADE: {
                BASE_COST: 100,
                COST_MULTIPLIER: 1.5,
                RES_CAPACITY_PER_LEVEL: 20,
                COM_PRODUCTION_PER_LEVEL: 10,
                IND_PRODUCTION_PER_LEVEL: 8
            },
            
            // === WORKFORCE SYSTEM ===
            WORKFORCE: {
                WELL_WORKERS: 2,            // 2 workers per well to operate it
                ROAD_WORKERS: 0,            // 0 workers per road tile (no upkeep needed)
                COMMERCIAL_WORKERS: 3,      // 3 workers per commercial building
                HUNTING_WORKERS_MIN: 20,    // Min workers for Hunting Ground
                HUNTING_WORKERS_MAX: 100,   // Max workers for Hunting Ground
                GATHERER_FOOD_RATE: 1.5,    // Food per gatherer per year
                GATHERER_WOOD_RATE: 3.0,    // Wood per gatherer per year
                HUNTER_FOOD_RATE: 1.0       // Food per hunter per year
            },
            
            WATER: {
                WELL_CAPACITY: 100,         // Each well serves 100 people
                PER_BUILDING: 0,            // No extra water for buildings under 100 pop
                PER_500_PEOPLE: 500         // 1 well per 500 people (won't trigger under 100)
            },
            
            RESOURCES: {
                WOOD_PER_STEP: 1,           // Wood from forest tiles
                RARE_FIND_CHANCE: 0.0001,   // 0.01% per step on open ground
                LUCKY_FIND_AMOUNT: 1
            },
            
            STONE_DEPOSITS: {
                SPAWN_COUNT: 80,
                // NERFED: Was 1M-10M, now 1-10 metal (1,000,000x less)
                MIN_METAL: 1,
                MAX_METAL: 10,
                // Stone yield is 10,000x less than metal
                MIN_STONE: 0.0001,
                MAX_STONE: 0.001
            },
            
            // TILE BUILDING BONUSES - Rewards for strategic placement
            TILE_BONUSES: {
                BERRY_FOOD_BONUS: 50,      // RES on berry = +50 food
                NOMAD_POP_BONUS: 2,        // RES on nomad = +2 pop
                TREE_WOOD_RATE: 5,         // COM on tree = +5 wood/year
                ANIMAL_FOOD_RATE: 10       // IND on animal = +10 food/year
            },
            
            CONSTANTS: {
                BASE_SPOILAGE: 0.30,        // 30% rot per year over capacity
                FOOD_PER_PERSON: 0.2,       // People eat 0.2 food/year (minimal survival)
                BASE_PROD: 1.5,
                STARVATION_DEATH: 0.20,     // 20% instant death when food < 0
                THIRST_DEATH: 0.10,         // 10% instant death when water shortage
                BASE_STORAGE: 200
            },
            
            BUILDINGS: {
                BASKET: { cost: 500, reqPop: 20, cap: 2000, desc: 'ğŸ§º Basket Storage', icon: 'ğŸ§º' },
                POTTERY: { cost: 5000, reqPop: 150, cap: 10000, desc: 'ğŸº Pottery Storage', icon: 'ğŸº' },
                GRANARY: { cost: 50000, reqPop: 1000, cap: 100000, desc: 'ğŸ›ï¸ Granary', icon: 'ğŸ›ï¸', locked: true },
                PALACE: { cost: 250000, reqPop: 5000, cap: 1000000, desc: 'ğŸ° Palace Storage', icon: 'ğŸ°', locked: true }
            },
            
            WATER_PROXIMITY: { MAX_DISTANCE: 5, MIN_EFFICIENCY: 0.3 }
        };
        // Historical ages for civilization advancement
        const AGES = [{n:"PALEOLITHIC",p:0,m:1},{n:"NEOLITHIC",p:500,m:1.5},{n:"BRONZE",p:2000,m:2},{n:"IRON",p:5000,m:3}];

        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ MODULE 2: PROGRESSION - Unlock & Advancement System               â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Tracks game progress and manages feature unlocking
        // Stage 0: Exploring â†’ Stage 1: Settlement â†’ Stage 2: Industrial
        
        const PROGRESSION = {
            stage: 0, // 0=exploring, 1=settlement, 2=industrial_unlocked
            nomadsFound: 0,
            berriesNeeded: 5,
            settlementBonus: 0, // Gold comes much later - start with 0
            settlementYear: 0,
            unlockedLevels: [1], // Level 1 is first buildable level (Level 0 = WANDER epoch only)
            unlockedIndustrialLevels: [1], // Industrial levels unlocked (Level 1 always available after industrial unlock)
            
            reset() {
                this.stage = 0;
                this.nomadsFound = 0;
                this.settlementYear = 0;
                this.unlockedLevels = [1]; // Level 1 is first buildable level
                this.unlockedIndustrialLevels = [1]; // Reset industrial levels
            },
            
            // Update unlocked building levels based on population AND building requirements
            updateUnlockedLevels(game) {
                let pop = game.pop || 0;
                let newUnlocks = [1]; // Level 1 always available
                
                // Check each residential building's unlock requirements
                let resBuildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let building of resBuildings) {
                    if(building.level === 1) continue; // Level 1 always unlocked
                    
                    let req = building.unlockReq;
                    if(!req) continue;
                    
                    // Use the universal unlock checker
                    let { met, reasons } = this.checkUnlockRequirements(req, game);
                    
                    if(met && !newUnlocks.includes(building.level)) {
                        newUnlocks.push(building.level);
                    }
                }
                
                // Check for new residential unlocks and notify
                for(let lvl of newUnlocks) {
                    if(!this.unlockedLevels.includes(lvl)) {
                        let building = CFG.BUILDING_DB['RES_' + lvl];
                        if(building) {
                            Controller.toast(`ğŸ‰ UNLOCKED: ${building.name} (Level ${lvl})!`);
                        }
                    }
                }
                
                this.unlockedLevels = newUnlocks;
                
                // Update industrial levels - requires same residential level unlocked
                // Industrial L2 requires Residential L2 unlocked, etc.
                let newIndUnlocks = [1]; // L1 always available
                if(this.unlockedLevels.includes(2)) newIndUnlocks.push(2);
                if(this.unlockedLevels.includes(3)) newIndUnlocks.push(3);
                if(this.unlockedLevels.includes(4)) newIndUnlocks.push(4);
                
                // Notify new industrial unlocks
                for(let lvl of newIndUnlocks) {
                    if(!this.unlockedIndustrialLevels.includes(lvl) && CFG.INDUSTRIAL_LEVELS[lvl]) {
                        Controller.toast(`ğŸ­ INDUSTRIAL UNLOCKED: ${CFG.INDUSTRIAL_LEVELS[lvl].name}!`);
                    }
                }
                
                this.unlockedIndustrialLevels = newIndUnlocks;
            },
            
            /**
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             * UNIVERSAL UNLOCK REQUIREMENT CHECKER
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             * Checks ANY combination of unlock requirements dynamically.
             * 
             * Supported requirement types:
             *   - pop: number           â†’ Minimum population
             *   - resources: {wood: n}  â†’ Must have X of resource in stock
             *   - buildings: {type, level?, count, category?} â†’ Must have X buildings
             *   - tech: string[]        â†’ Must have researched technologies (future)
             *   - year: number          â†’ Must reach year X
             *   - level: number         â†’ Player must be at civilization level X
             *   - custom: function      â†’ Custom check function (advanced)
             * 
             * Example unlockReq:
             * {
             *     pop: 5000,
             *     resources: { wood: 500, stone: 200 },
             *     buildings: { type: 'IND', level: 2, count: 3 },
             *     year: 50
             * }
             * 
             * Returns: { met: boolean, reasons: string[] }
             *   - met: true if ALL requirements are satisfied
             *   - reasons: array of unmet requirement descriptions (for UI)
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             */
            checkUnlockRequirements(req, game) {
                if(!req) return { met: true, reasons: [] };
                
                let unmetReasons = [];
                
                // --- POPULATION ---
                if(req.pop !== undefined) {
                    let currentPop = game.pop || 0;
                    if(currentPop < req.pop) {
                        unmetReasons.push(`Need ${req.pop.toLocaleString()} population (have ${currentPop.toLocaleString()})`);
                    }
                }
                
                // --- RESOURCES ---
                if(req.resources) {
                    for(let [resource, amount] of Object.entries(req.resources)) {
                        let current = game.res?.[resource] || 0;
                        if(current < amount) {
                            unmetReasons.push(`Need ${amount.toLocaleString()} ${resource} (have ${current.toLocaleString()})`);
                        }
                    }
                }
                
                // --- BUILDINGS ---
                if(req.buildings) {
                    // Build a count map of all buildings
                    let buildingCounts = this._countBuildings(game);
                    
                    // Support single building requirement or array of requirements
                    let buildingReqs = Array.isArray(req.buildings) ? req.buildings : [req.buildings];
                    
                    for(let bReq of buildingReqs) {
                        let count = 0;
                        
                        if(bReq.id) {
                            // Specific building ID (e.g., 'WELL', 'GRANARY')
                            count = buildingCounts.byId[bReq.id] || 0;
                        } else if(bReq.type && bReq.level !== undefined) {
                            // Type + Level combo (e.g., IND level 2)
                            let key = bReq.type + '_' + bReq.level;
                            count = buildingCounts.byTypeLevel[key] || 0;
                        } else if(bReq.type) {
                            // Any building of type (e.g., any IND)
                            count = buildingCounts.byType[bReq.type] || 0;
                        } else if(bReq.category) {
                            // Any building in category
                            count = buildingCounts.byCategory[bReq.category] || 0;
                        }
                        
                        let required = bReq.count || 1;
                        if(count < required) {
                            let desc = bReq.id || (bReq.type + (bReq.level ? ' L' + bReq.level : ''));
                            unmetReasons.push(`Need ${required}x ${desc} buildings (have ${count})`);
                        }
                    }
                }
                
                // --- YEAR ---
                if(req.year !== undefined) {
                    let currentYear = game.year || 0;
                    if(currentYear < req.year) {
                        unmetReasons.push(`Need to reach Year ${req.year} (current: ${currentYear})`);
                    }
                }
                
                // --- CIVILIZATION LEVEL ---
                if(req.level !== undefined) {
                    let currentLevel = game.civLevel || game.level || 1;
                    if(currentLevel < req.level) {
                        unmetReasons.push(`Need Civilization Level ${req.level} (current: ${currentLevel})`);
                    }
                }
                
                // --- TECHNOLOGIES (Future-proofing) ---
                if(req.tech) {
                    let techs = Array.isArray(req.tech) ? req.tech : [req.tech];
                    let researchedTechs = game.technologies || game.techs || [];
                    for(let tech of techs) {
                        if(!researchedTechs.includes(tech)) {
                            unmetReasons.push(`Need to research: ${tech}`);
                        }
                    }
                }
                
                // --- ACHIEVEMENTS (Future-proofing) ---
                if(req.achievements) {
                    let achievements = Array.isArray(req.achievements) ? req.achievements : [req.achievements];
                    let earnedAchievements = game.achievements || [];
                    for(let ach of achievements) {
                        if(!earnedAchievements.includes(ach)) {
                            unmetReasons.push(`Need achievement: ${ach}`);
                        }
                    }
                }
                
                // --- CUSTOM FUNCTION (Advanced) ---
                if(req.custom && typeof req.custom === 'function') {
                    try {
                        let customResult = req.custom(game);
                        if(customResult !== true) {
                            unmetReasons.push(customResult || 'Custom requirement not met');
                        }
                    } catch(e) {
                        console.error('Custom unlock check failed:', e);
                    }
                }
                
                return {
                    met: unmetReasons.length === 0,
                    reasons: unmetReasons
                };
            },
            
            /**
             * Helper: Count all buildings by various groupings
             * Returns { byId, byType, byTypeLevel, byCategory }
             */
            _countBuildings(game) {
                let counts = {
                    byId: {},         // e.g., { 'WELL': 3, 'GRANARY': 1 }
                    byType: {},       // e.g., { 'IND': 5, 'COM': 3 }
                    byTypeLevel: {},  // e.g., { 'IND_1': 2, 'IND_2': 3 }
                    byCategory: {}    // e.g., { 'RESIDENTIAL': 10, 'INDUSTRIAL': 5 }
                };
                
                let buildings = game.blds || [];
                
                for(let b of buildings) {
                    // By type + level
                    let typeKey = b.t + '_' + (b.lvl || 1);
                    counts.byTypeLevel[typeKey] = (counts.byTypeLevel[typeKey] || 0) + 1;
                    
                    // By type only
                    counts.byType[b.t] = (counts.byType[b.t] || 0) + 1;
                    
                    // By specific building ID (if stored)
                    if(b.id) {
                        counts.byId[b.id] = (counts.byId[b.id] || 0) + 1;
                    }
                    
                    // By category (lookup from BUILDING_DB)
                    let fullId = b.t + '_' + (b.lvl || 1);
                    let bDef = CFG.BUILDING_DB[fullId];
                    if(bDef && bDef.category) {
                        counts.byCategory[bDef.category] = (counts.byCategory[bDef.category] || 0) + 1;
                    }
                }
                
                return counts;
            },
            
            /**
             * Get human-readable unlock requirements for UI display
             */
            getUnlockRequirementsText(req, game) {
                if(!req) return 'Always available';
                
                let { met, reasons } = this.checkUnlockRequirements(req, game);
                
                if(met) return 'âœ… All requirements met';
                
                return reasons.map(r => 'âŒ ' + r).join('\n');
            },

            /**
             * Industrial tier unlock guidance
             * Returns { met, text } with a concise explanation
             */
            getIndustrialUnlockInfo(level, game) {
                // Prefer BUILDING_DB.popUnlock if available
                const b = CFG.BUILDING_DB['IND_' + level];
                const reqPop = (b && typeof b.popUnlock === 'number') ? b.popUnlock : (level === 1 ? 0 : (level === 2 ? 100 : level === 3 ? 500 : level === 4 ? 2000 : 0));
                const havePop = (game && game.pop) ? game.pop : 0;
                const met = havePop >= reqPop;
                if(reqPop === 0) return { met: true, text: 'âœ… Available' };
                const text = met
                    ? 'âœ… Requirement met'
                    : `ğŸ”’ Need ${reqPop.toLocaleString()} population (have ${havePop.toLocaleString()})`;
                return { met, text };
            },
            
            checkUnlock(game) {
                // Update building level unlocks based on population
                this.updateUnlockedLevels(game);
                
                if(this.stage === 0 && game.food >= this.berriesNeeded && this.nomadsFound >= 1) {
                    this.stage = 1;
                    game.res = this.settlementBonus;
                    this.settlementYear = game.year;
                    return 'settlement';
                }
                if(this.stage === 1) {
                    // Unlock hunting at stage 1 (no requirements)
                    this.stage = 2;
                    return 'industrial';
                }
                return false;
            }
        };

        // --- 2. NOISE ---
        const Noise = {
            seed: 1,
            init(s) { this.seed = s; },
            hash(x,y) { let h = Math.sin(x*12.98+y*78.23+this.seed)*43758.54; return h-Math.floor(h); },
            mix(a,b,t) { return a*(1-t)+b*t; },
            val(x,y) {
                let i=Math.floor(x), j=Math.floor(y), f={x:x-i, y:y-j};
                let u={x:f.x*f.x*(3-2*f.x), y:f.y*f.y*(3-2*f.y)};
                let a=this.hash(i,j), b=this.hash(i+1,j), c=this.hash(i,j+1), d=this.hash(i+1,j+1);
                return this.mix(this.mix(a,b,u.x), this.mix(c,d,u.x), u.y);
            },
            fbm(x,y) {
                let t=0, a=0.5;
                for(let i=0; i<5; i++) { t+=this.val(x,y)*a; x*=2; y*=2; a*=0.5; }
                return t;
            }
        };

        // --- 3. RENDERER ---
        const Renderer = {
            cvs: null, ctx: null, w: 0, h: 0, time: 0, particles: [], effects: [],
            init() {
                this.cvs = document.getElementById('cvs');
                this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.resize(); window.onresize = () => this.resize();
            },
            addWoodChips(tileX, tileY) {
                // Wood chip burst effect
                const start = performance.now();
                const duration = 600;
                const chips = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2) * (i / 8) + Math.random()*0.3;
                    const speed = 0.5 + Math.random()*0.7;
                    chips.push({ angle, speed });
                }
                this.effects.push({ type: 'woodchips', x: tileX, y: tileY, start, duration, chips });
            },
            addDust(tileX, tileY) {
                // 3-second cartoonish dust cloud effect
                const start = performance.now();
                const duration = 9000;
                const puffs = [];
                // Precompute puff offsets for a consistent look
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2) * (i / 6);
                    const radius = 0.18 + (i % 2) * 0.06; // tile-relative radius
                    puffs.push({ angle, radius });
                }
                this.effects.push({ type: 'dust', x: tileX, y: tileY, start, duration, puffs });
            },
            resize() {
                let vp = document.getElementById('viewport');
                let dpr = window.devicePixelRatio || 1;
                this.w = vp.clientWidth; this.h = vp.clientHeight;
                this.cvs.width = this.w * dpr; this.cvs.height = this.h * dpr;
                this.ctx.scale(dpr, dpr); this.ctx.imageSmoothingEnabled = false;
            },
            draw(cam) {
                let c = this.ctx, T = CFG.TILE; this.time += 0.05;
                c.save(); c.setTransform(1,0,0,1,0,0); c.fillStyle="#000"; c.fillRect(0,0,this.cvs.width,this.cvs.height); c.restore();
                
                if(!Game || !Game.tiles) {
                    c.restore();
                    return;
                }
                
                c.save(); c.translate(this.w/2, this.h/2); c.scale(cam.z, cam.z); c.translate(-cam.x, -cam.y);

                let sc = Math.max(0, Math.floor((cam.x - (this.w/cam.z)/2)/T));
                let ec = Math.min(CFG.W, Math.ceil((cam.x + (this.w/cam.z)/2)/T));
                let sr = Math.max(0, Math.floor((cam.y - (this.h/cam.z)/2)/T));
                let er = Math.min(CFG.H, Math.ceil((cam.y + (this.h/cam.z)/2)/T));

                for(let x=sc; x<ec; x++) for(let y=sr; y<er; y++) {
                    let t = Game.tiles[x][y];
                    
                    // Fog of war - only show explored tiles
                    if (!t.explored) {
                        c.fillStyle = "#000";
                        c.fillRect(x*T, y*T, T, T);
                        continue;
                    }
                    
                    // Draw all tiles including DEEP with Mario-style borders
                    c.fillStyle = CFG.COLORS[t.type]; 
                    if(t.type === 'FOREST' && t.tree) c.fillStyle = CFG.COLORS.EARTH;
                    c.fillRect(x*T, y*T, T, T);
                    
                    // Add black grid lines for pixel art look
                    c.strokeStyle = "rgba(0, 0, 0, 0.15)";
                    c.lineWidth = 1;
                    c.strokeRect(x*T, y*T, T, T);
                    
                    // Add Mario-style highlights and details
                    if(t.type === 'GRASS') {
                        // Yoshi's Island soft pastel green gradient
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#98FF98');
                        gradient.addColorStop(0.5, '#78E878');
                        gradient.addColorStop(1, '#58C858');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Soft white highlight on top edge
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        c.fillRect(x*T, y*T, T, 4);
                        
                        // Subtle shadow at bottom
                        c.fillStyle = 'rgba(0,80,0,0.15)';
                        c.fillRect(x*T, y*T + T - 4, T, 4);
                        
                        // Cute grass tufts
                        if((x + y) % 3 === 0) {
                            c.fillStyle = '#B0FFB0';
                            c.beginPath();
                            c.moveTo(x*T + 10, y*T + T - 8);
                            c.lineTo(x*T + 12, y*T + T - 16);
                            c.lineTo(x*T + 14, y*T + T - 8);
                            c.fill();
                            c.beginPath();
                            c.moveTo(x*T + 28, y*T + T - 10);
                            c.lineTo(x*T + 30, y*T + T - 18);
                            c.lineTo(x*T + 32, y*T + T - 10);
                            c.fill();
                        }
                        
                        // Little flower occasionally
                        if((x * 3 + y * 7) % 11 === 0) {
                            c.fillStyle = '#FFD0D0';
                            c.beginPath();
                            c.arc(x*T + 20, y*T + 24, 4, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#FFFF80';
                            c.beginPath();
                            c.arc(x*T + 20, y*T + 24, 2, 0, 6.28);
                            c.fill();
                        }
                    } else if(t.type === 'SAND') {
                        // Warm golden sand like Yoshi's Island beaches
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#FFFFC8');
                        gradient.addColorStop(0.5, '#FFE8A0');
                        gradient.addColorStop(1, '#F8D880');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Sparkly cream highlight
                        c.fillStyle = 'rgba(255,255,240,0.8)';
                        c.fillRect(x*T, y*T, T, 3);
                        
                        // Cute shell or pebble occasionally
                        if((x * 5 + y * 3) % 9 === 0) {
                            c.fillStyle = '#FFD0B0';
                            c.beginPath();
                            c.ellipse(x*T + 16, y*T + 20, 4, 3, 0.3, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#FFF0E0';
                            c.beginPath();
                            c.arc(x*T + 15, y*T + 19, 1.5, 0, 6.28);
                            c.fill();
                        }
                        
                        // Sand grain sparkles
                        if((x + y) % 2 === 0) {
                            c.fillStyle = 'rgba(255,255,200,0.5)';
                            c.fillRect(x*T + 8, y*T + 12, 2, 2);
                            c.fillRect(x*T + 28, y*T + 26, 2, 2);
                        }
                    } else if(t.type === 'WATER' || t.type === 'RIVER' || t.type === 'DEEP') {
                        // Yoshi's Island crystal clear water
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        if(t.type === 'DEEP') {
                            gradient.addColorStop(0, '#78A8FF');
                            gradient.addColorStop(1, '#5890E8');
                        } else if(t.type === 'WATER') {
                            gradient.addColorStop(0, '#B0E0FF');
                            gradient.addColorStop(1, '#78C8FF');
                        } else {
                            gradient.addColorStop(0, '#C8F0FF');
                            gradient.addColorStop(1, '#A0DCFF');
                        }
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Bright white wave highlight on top
                        c.fillStyle = 'rgba(255,255,255,0.7)';
                        c.fillRect(x*T, y*T, T, 4);
                        
                        // Animated sparkles
                        c.fillStyle = 'rgba(255,255,255,0.8)';
                        let sparkle1 = Math.sin(this.time * 1.5 + x * 0.5 + y) * 3;
                        let sparkle2 = Math.cos(this.time * 1.2 + x + y * 0.5) * 3;
                        c.beginPath();
                        c.arc(x*T + 12 + sparkle1, y*T + 14, 3, 0, 6.28);
                        c.arc(x*T + T - 14 + sparkle2, y*T + T - 16, 2.5, 0, 6.28);
                        c.fill();
                        
                        // Cute wave lines
                        c.strokeStyle = 'rgba(255,255,255,0.4)';
                        c.lineWidth = 2;
                        c.beginPath();
                        let wave = Math.sin(this.time + x * 0.3) * 2;
                        c.moveTo(x*T + 6, y*T + T/2 + wave);
                        c.quadraticCurveTo(x*T + T/2, y*T + T/2 - 3 + wave, x*T + T - 6, y*T + T/2 + wave);
                        c.stroke();
                        
                        // Bright white highlights on top
                        c.fillStyle = 'rgba(255,255,255,0.6)';
                        c.fillRect(x*T, y*T, T, 3);
                        
                        // Bubbly sparkles
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        let sparkle = Math.sin(this.time + x + y) * 2;
                        c.beginPath();
                        c.arc(x*T + 8 + sparkle, y*T + 10, 3, 0, 6.28);
                        c.arc(x*T + T-10 + sparkle, y*T + T-12, 2, 0, 6.28);
                        c.fill();
                        
                        // Reflection shimmer
                        c.fillStyle = 'rgba(200,240,255,0.4)';
                        c.fillRect(x*T + 4, y*T + T/2, T-8, 2);
                    } else if(t.type === 'STONE') {
                        // Yoshi's Island soft purple-gray stone
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#C8C8D8');
                        gradient.addColorStop(0.5, '#B0B0C0');
                        gradient.addColorStop(1, '#9898A8');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Bright highlight on top-left corner
                        c.fillStyle = 'rgba(255,255,255,0.6)';
                        c.fillRect(x*T, y*T, T, 5);
                        c.fillRect(x*T, y*T, 5, T);
                        
                        // Cute rounded rock shapes
                        c.fillStyle = 'rgba(80,80,100,0.2)';
                        c.beginPath();
                        c.arc(x*T + 14, y*T + 14, 8, 0, 6.28);
                        c.arc(x*T + 32, y*T + 24, 6, 0, 6.28);
                        c.arc(x*T + 24, y*T + 36, 5, 0, 6.28);
                        c.fill();
                        
                        // White sparkle spots
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        c.beginPath();
                        c.arc(x*T + 10, y*T + 10, 3, 0, 6.28);
                        c.arc(x*T + 28, y*T + 20, 2, 0, 6.28);
                        c.fill();
                    } else if(t.type === 'FOREST') {
                        // Yoshi's Island lush forest floor
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#60C860');
                        gradient.addColorStop(0.5, '#48B848');
                        gradient.addColorStop(1, '#38A038');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Dappled sunlight highlights
                        c.fillStyle = 'rgba(180,255,180,0.4)';
                        if((x + y) % 2 === 0) {
                            c.beginPath();
                            c.ellipse(x*T + 12, y*T + 16, 6, 4, 0.3, 0, 6.28);
                            c.fill();
                        }
                        if((x * 3 + y) % 4 === 0) {
                            c.beginPath();
                            c.ellipse(x*T + 30, y*T + 28, 5, 3, -0.2, 0, 6.28);
                            c.fill();
                        }
                        
                        // Shadow at bottom
                        c.fillStyle = 'rgba(0,60,0,0.25)';
                        c.fillRect(x*T, y*T + T - 6, T, 6);
                        
                        // Occasional mushroom
                        if((x * 7 + y * 11) % 17 === 0) {
                            // Mushroom cap
                            c.fillStyle = '#FF8080';
                            c.beginPath();
                            c.arc(x*T + 24, y*T + 32, 5, Math.PI, 0);
                            c.fill();
                            // White spots on cap
                            c.fillStyle = '#FFFFFF';
                            c.beginPath();
                            c.arc(x*T + 22, y*T + 30, 1.5, 0, 6.28);
                            c.arc(x*T + 26, y*T + 31, 1, 0, 6.28);
                            c.fill();
                            // Stem
                            c.fillStyle = '#FFF8E8';
                            c.fillRect(x*T + 22, y*T + 32, 4, 6);
                        }
                    }
                    
                    // Draw berry entity - Cave painting style berry clusters
                    if(t.entity && t.entity.type === 'BERRY') {
                        let bx = x*T+T/2;
                        let by = y*T+T/2;
                        
                        // Yoshi's Island style berry bush
                        // Draw cute bush base first
                        c.fillStyle = '#60C060';
                        c.beginPath();
                        c.arc(bx - 8, by + 8, 8, 0, 6.28);
                        c.arc(bx + 8, by + 8, 8, 0, 6.28);
                        c.arc(bx, by + 4, 10, 0, 6.28);
                        c.fill();
                        
                        // Bush highlight
                        c.fillStyle = '#90E890';
                        c.beginPath();
                        c.arc(bx - 6, by + 4, 4, 0, 6.28);
                        c.arc(bx + 4, by + 2, 3, 0, 6.28);
                        c.fill();
                        
                        // Draw 3-5 berries in cluster
                        let berryCount = 3 + Math.floor((x + y) % 3);
                        let positions = [
                            {x: 0, y: -8}, {x: -7, y: -2}, {x: 7, y: -2},
                            {x: -4, y: 4}, {x: 4, y: 4}
                        ];
                        
                        for(let i = 0; i < berryCount; i++) {
                            let pos = positions[i];
                            let bpx = bx + pos.x, bpy = by + pos.y;
                            
                            // Berry with cute gradient
                            let gradient = c.createRadialGradient(bpx-2, bpy-2, 1, bpx, bpy, 7);
                            if(t.entity.is_poisonous) {
                                gradient.addColorStop(0, '#E0B0FF');
                                gradient.addColorStop(0.5, '#C878F0');
                                gradient.addColorStop(1, '#A050D0');
                            } else {
                                gradient.addColorStop(0, '#FF90B0');
                                gradient.addColorStop(0.5, '#FF6090');
                                gradient.addColorStop(1, '#E04070');
                            }
                            c.fillStyle = gradient;
                            c.beginPath();
                            c.arc(bpx, bpy, 6, 0, 6.28);
                            c.fill();
                            
                            // Black outline for cartoon look
                            c.strokeStyle = 'rgba(0,0,0,0.3)';
                            c.lineWidth = 1.5;
                            c.stroke();
                            
                            // Big cute shine spot
                            c.fillStyle = 'rgba(255,255,255,0.8)';
                            c.beginPath();
                            c.arc(bpx-2, bpy-2, 2.5, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // Draw nomad entity - Cave painting style stick figure with spear
                    if(t.entity && t.entity.type === 'NOMAD') {
                        let nx = x*T + T/2, ny = y*T + T/2;
                        let scale = T/64;
                        
                        // All nomads look the same (don't reveal hostility)
                        c.strokeStyle = "#8B5A2B"; // Darker brown for better contrast
                        c.lineWidth = 2;
                        c.lineCap = "round";
                        c.lineJoin = "round";
                        
                        // Head (circle)
                        c.beginPath();
                        c.arc(nx, ny - 18*scale, 5*scale, 0, 6.28);
                        c.stroke();
                        
                        // Body (vertical line)
                        c.beginPath();
                        c.moveTo(nx, ny - 13*scale);
                        c.lineTo(nx, ny + 5*scale);
                        c.stroke();
                        
                        // Arms (one raised holding spear)
                        c.beginPath();
                        c.moveTo(nx, ny - 8*scale);
                        c.lineTo(nx - 8*scale, ny - 15*scale); // Left arm raised
                        c.moveTo(nx, ny - 8*scale);
                        c.lineTo(nx + 8*scale, ny - 2*scale); // Right arm down
                        c.stroke();
                        
                        // Legs (walking stance)
                        c.beginPath();
                        c.moveTo(nx, ny + 5*scale);
                        c.lineTo(nx - 6*scale, ny + 15*scale); // Left leg forward
                        c.moveTo(nx, ny + 5*scale);
                        c.lineTo(nx + 6*scale, ny + 15*scale); // Right leg back
                        c.stroke();
                        
                        // Spear (in raised hand)
                        c.strokeStyle = "#8B7355";
                        c.lineWidth = 1.5;
                        c.beginPath();
                        c.moveTo(nx - 8*scale, ny - 15*scale);
                        c.lineTo(nx - 10*scale, ny - 28*scale); // Spear shaft
                        c.stroke();
                        
                        // Spear tip
                        c.fillStyle = "#555";
                        c.beginPath();
                        c.moveTo(nx - 10*scale, ny - 28*scale);
                        c.lineTo(nx - 12*scale, ny - 24*scale);
                        c.lineTo(nx - 8*scale, ny - 24*scale);
                        c.fill();
                    }
                    
                    if(t.road) this.drawRoad(c, x, y, T);
                    else if(t.stoneDeposit) this.drawStoneDeposit(c, x*T, y*T, t.stoneDeposit);
                    else if(t.tree && !t.bld) this.drawTree(c, x*T, y*T, t.type);
                    else if(t.type === 'WATER' || t.type === 'RIVER') this.drawWaterAnim(c, x*T, y*T);
                    else if(t.type === 'SAND') this.drawGrain(c, x*T, y*T);

                    if (Game.vm === 'POL' && t.pol > 0) { c.fillStyle = `rgba(100,0,100,${Math.min(t.pol/100, 0.6)})`; c.fillRect(x*T, y*T, T, T); }
                    
                    // DESIRABILITY HEATMAP VIEW
                    if (Game.vm === 'DESIRABILITY') {
                        let desirability = Game.calculateDesirability(x, y, 1);
                        // Color gradient: Red (0) -> Yellow (0.5) -> Green (1.0) -> Blue (1.5+)
                        let r, g, b, alpha = 0.5;
                        if(desirability < 0.3) {
                            r = 255; g = Math.floor(desirability * 850); b = 0;
                        } else if(desirability < 0.7) {
                            r = Math.floor(255 - (desirability - 0.3) * 600); g = 255; b = 0;
                        } else if(desirability < 1.2) {
                            r = 0; g = 255; b = Math.floor((desirability - 0.7) * 510);
                        } else {
                            r = 0; g = Math.floor(255 - (desirability - 1.2) * 200); b = 255;
                        }
                        c.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Show value on hover
                        if(Math.abs(Controller.mx - x) === 0 && Math.abs(Controller.my - y) === 0) {
                            c.fillStyle = 'rgba(0,0,0,0.9)';
                            c.fillRect(x*T - 10, y*T - 25, 70, 20);
                            c.fillStyle = '#fff';
                            c.font = 'bold 11px sans-serif';
                            c.textAlign = 'left';
                            c.fillText(`D: ${desirability.toFixed(2)}`, x*T - 5, y*T - 10);
                        }
                    }
                }
                
                // Draw player - FRED FLINTSTONE STYLE!
                if (Game.player) {
                    let px = Game.player.x * T + T/2;
                    let py = Game.player.y * T + T/2;
                    let scale = T/64;
                    let dir = Game.player.direction || 'down';
                    
                    // Check bash animation state
                    let isBashing = Game.player.bashTime && (performance.now() - Game.player.bashTime) < 300;
                    let bashProgress = isBashing ? (performance.now() - Game.player.bashTime) / 300 : 0;
                    
                    // Soft shadow under character
                    c.fillStyle = 'rgba(0,0,0,0.25)';
                    c.beginPath();
                    c.ellipse(px, py + 20*scale, 14*scale, 5*scale, 0, 0, 6.28);
                    c.fill();
                    
                    // === FRED FLINTSTONE STYLE CAVEMAN ===
                    let facing = (dir === 'right') ? 1 : (dir === 'left') ? -1 : 0;
                    
                    // Big bare feet (Fred's signature look)
                    c.fillStyle = '#E8B090';
                    c.beginPath();
                    if(facing !== 0) {
                        c.ellipse(px - 4*facing*scale, py + 16*scale, 6*scale, 4*scale, 0, 0, 6.28);
                        c.ellipse(px + 6*facing*scale, py + 16*scale, 6*scale, 4*scale, 0, 0, 6.28);
                    } else {
                        c.ellipse(px - 6*scale, py + 16*scale, 6*scale, 4*scale, 0, 0, 6.28);
                        c.ellipse(px + 6*scale, py + 16*scale, 6*scale, 4*scale, 0, 0, 6.28);
                    }
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Legs (Fred's bare legs)
                    c.fillStyle = '#E8B090';
                    c.fillRect(px - 8*scale, py + 6*scale, 6*scale, 12*scale);
                    c.fillRect(px + 2*scale, py + 6*scale, 6*scale, 12*scale);
                    c.strokeStyle = '#000';
                    c.lineWidth = 1;
                    c.strokeRect(px - 8*scale, py + 6*scale, 6*scale, 12*scale);
                    c.strokeRect(px + 2*scale, py + 6*scale, 6*scale, 12*scale);
                    
                    // Fred's orange/brown animal skin outfit (one shoulder strap)
                    c.fillStyle = '#D2691E';
                    c.beginPath();
                    c.moveTo(px - 12*scale, py + 8*scale);
                    c.lineTo(px + 12*scale, py + 8*scale);
                    c.lineTo(px + 10*scale, py - 8*scale);
                    c.lineTo(px - 10*scale, py - 8*scale);
                    c.closePath();
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Jagged bottom edge (animal skin torn look)
                    c.fillStyle = '#D2691E';
                    c.beginPath();
                    c.moveTo(px - 12*scale, py + 8*scale);
                    c.lineTo(px - 10*scale, py + 12*scale);
                    c.lineTo(px - 6*scale, py + 8*scale);
                    c.lineTo(px - 2*scale, py + 11*scale);
                    c.lineTo(px + 2*scale, py + 8*scale);
                    c.lineTo(px + 6*scale, py + 12*scale);
                    c.lineTo(px + 10*scale, py + 8*scale);
                    c.lineTo(px + 12*scale, py + 8*scale);
                    c.closePath();
                    c.fill();
                    
                    // Black spots on outfit (leopard print)
                    c.fillStyle = '#000';
                    c.beginPath();
                    c.arc(px - 5*scale, py, 2*scale, 0, 6.28);
                    c.arc(px + 4*scale, py - 3*scale, 2*scale, 0, 6.28);
                    c.arc(px + 6*scale, py + 3*scale, 1.5*scale, 0, 6.28);
                    c.fill();
                    
                    // Big round head (Fred's distinctive shape)
                    c.fillStyle = '#E8B090';
                    c.beginPath();
                    c.arc(px, py - 16*scale, 12*scale, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.5;
                    c.stroke();
                    
                    // Fred's 5 o'clock shadow (blue-ish chin)
                    c.fillStyle = 'rgba(100,120,140,0.3)';
                    c.beginPath();
                    c.arc(px, py - 10*scale, 8*scale, 0.3, 2.84);
                    c.fill();
                    
                    // Big bulbous nose (Fred's signature)
                    c.fillStyle = '#E8B090';
                    c.beginPath();
                    c.arc(px + 2*facing*scale, py - 14*scale, 5*scale, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Eyes (wide and round)
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.ellipse(px - 5*scale, py - 18*scale, 4*scale, 5*scale, 0, 0, 6.28);
                    c.ellipse(px + 5*scale, py - 18*scale, 4*scale, 5*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    // Pupils (looking in direction)
                    c.fillStyle = '#000';
                    c.beginPath();
                    c.arc(px - 5*scale + 1*facing*scale, py - 17*scale, 2*scale, 0, 6.28);
                    c.arc(px + 5*scale + 1*facing*scale, py - 17*scale, 2*scale, 0, 6.28);
                    c.fill();
                    
                    // Fred's messy black hair
                    c.fillStyle = '#1a1a1a';
                    c.beginPath();
                    c.arc(px - 8*scale, py - 24*scale, 5*scale, 0, 6.28);
                    c.arc(px - 3*scale, py - 27*scale, 5*scale, 0, 6.28);
                    c.arc(px + 3*scale, py - 26*scale, 5*scale, 0, 6.28);
                    c.arc(px + 8*scale, py - 23*scale, 4*scale, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Mouth
                    c.strokeStyle = '#804020';
                    c.lineWidth = 1.2;
                    c.beginPath();
                    c.arc(px, py - 11*scale, 4*scale, 0.2, 2.9);
                    c.stroke();
                    
                    // Stone club in hand - with bash animation
                    c.save();
                    if(isBashing) {
                        // Swing animation - rotate club
                        let swingAngle = Math.sin(bashProgress * Math.PI) * -0.8; // Swing down
                        c.translate(px + 16*scale, py - 10*scale);
                        c.rotate(swingAngle);
                        c.translate(-(px + 16*scale), -(py - 10*scale));
                    }
                    
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.roundRect(px + 14*scale, py - 10*scale, 5*scale, 22*scale, 2);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Club head (stone)
                    c.fillStyle = '#909090';
                    c.beginPath();
                    c.ellipse(px + 16*scale, py - 14*scale, 7*scale, 8*scale, 0.3, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#000';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Stone texture on club
                    c.fillStyle = '#777';
                    c.beginPath();
                    c.arc(px + 14*scale, py - 16*scale, 2*scale, 0, 6.28);
                    c.arc(px + 18*scale, py - 12*scale, 1.5*scale, 0, 6.28);
                    c.fill();
                    
                    c.restore();
                    
                    // Bash impact effect
                    if(isBashing && bashProgress > 0.4 && bashProgress < 0.6) {
                        c.fillStyle = `rgba(255, 220, 100, ${0.8 - bashProgress})`;
                        c.beginPath();
                        c.arc(px + 24*scale, py + 8*scale, 12*scale, 0, Math.PI*2);
                        c.fill();
                    }
                }
                
                // Draw ancient animals - Yoshi's Island cute style
                Game.animals.forEach(animal => {
                    let tile = Game.tiles[animal.x][animal.y];
                    if(!tile.explored) return;
                    
                    let ax = animal.x * T + T/2;
                    let ay = animal.y * T + T/2;
                    let scale = T/64;
                    
                    // Get animal config
                    let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                    
                    // Yoshi's Island cute animal style
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    
                    // Cute shadow under animal
                    c.fillStyle = 'rgba(0,0,0,0.15)';
                    c.beginPath();
                    c.ellipse(ax, ay + 14*scale, 12*scale, 4*scale, 0, 0, 6.28);
                    c.fill();
                    
                    if(animal.type === 'DEER') {
                        // Cute deer with big eyes
                        // Body - soft tan with gradient
                        let bodyGrad = c.createRadialGradient(ax - 4*scale, ay - 3*scale, 2, ax, ay, 14*scale);
                        bodyGrad.addColorStop(0, '#F0D8B0');
                        bodyGrad.addColorStop(1, '#D8B878');
                        c.fillStyle = bodyGrad;
                        c.beginPath();
                        c.ellipse(ax, ay, 14*scale, 9*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // White belly
                        c.fillStyle = '#FFF8F0';
                        c.beginPath();
                        c.ellipse(ax, ay + 3*scale, 8*scale, 4*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Cute round head
                        let headGrad = c.createRadialGradient(ax + 10*scale, ay - 8*scale, 2, ax + 14*scale, ay - 4*scale, 10*scale);
                        headGrad.addColorStop(0, '#F8E8C8');
                        headGrad.addColorStop(1, '#D8B878');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 14*scale, ay - 4*scale, 8*scale, 7*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Big cute eyes
                        c.fillStyle = '#000';
                        c.beginPath();
                        c.ellipse(ax + 16*scale, ay - 6*scale, 2.5*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#FFF';
                        c.beginPath();
                        c.arc(ax + 15*scale, ay - 7*scale, 1*scale, 0, 6.28);
                        c.fill();
                        
                        // Cute pink nose
                        c.fillStyle = '#FFB0B0';
                        c.beginPath();
                        c.ellipse(ax + 20*scale, ay - 2*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Antlers
                        c.strokeStyle = '#A08060';
                        c.lineWidth = 2.5;
                        c.beginPath();
                        c.moveTo(ax + 12*scale, ay - 10*scale);
                        c.lineTo(ax + 10*scale, ay - 18*scale);
                        c.lineTo(ax + 8*scale, ay - 22*scale);
                        c.moveTo(ax + 10*scale, ay - 18*scale);
                        c.lineTo(ax + 14*scale, ay - 20*scale);
                        c.stroke();
                        
                        // Cute stick legs
                        c.strokeStyle = '#C0A070';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(ax - 6*scale, ay + 7*scale);
                        c.lineTo(ax - 6*scale, ay + 14*scale);
                        c.moveTo(ax + 6*scale, ay + 7*scale);
                        c.lineTo(ax + 6*scale, ay + 14*scale);
                        c.stroke();
                        
                    } else if(animal.type === 'BISON') {
                        // Cute chunky bison
                        // Big fluffy body
                        let bodyGrad = c.createRadialGradient(ax - 4*scale, ay - 2*scale, 4, ax, ay, 18*scale);
                        bodyGrad.addColorStop(0, '#C8A070');
                        bodyGrad.addColorStop(1, '#906840');
                        c.fillStyle = bodyGrad;
                        c.beginPath();
                        c.ellipse(ax, ay + 2*scale, 18*scale, 11*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Fluffy mane/hump
                        c.fillStyle = '#805830';
                        c.beginPath();
                        c.ellipse(ax - 6*scale, ay - 6*scale, 12*scale, 9*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.stroke();
                        
                        // Cute round head
                        let headGrad = c.createRadialGradient(ax + 14*scale, ay + 2*scale, 2, ax + 16*scale, ay + 4*scale, 10*scale);
                        headGrad.addColorStop(0, '#D8B888');
                        headGrad.addColorStop(1, '#A07848');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 16*scale, ay + 4*scale, 9*scale, 7*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.stroke();
                        
                        // Cute eyes
                        c.fillStyle = '#000';
                        c.beginPath();
                        c.arc(ax + 20*scale, ay + 2*scale, 2*scale, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#FFF';
                        c.beginPath();
                        c.arc(ax + 19*scale, ay + 1*scale, 0.8*scale, 0, 6.28);
                        c.fill();
                        
                        // Pink snout
                        c.fillStyle = '#E8B8A0';
                        c.beginPath();
                        c.ellipse(ax + 22*scale, ay + 6*scale, 4*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 1.5;
                        c.stroke();
                        
                        // Curved horns
                        c.strokeStyle = '#707070';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.arc(ax + 12*scale, ay - 2*scale, 5*scale, -2.5, -0.5, false);
                        c.stroke();
                        
                        // Chunky legs
                        c.strokeStyle = '#906840';
                        c.lineWidth = 5;
                        c.beginPath();
                        c.moveTo(ax - 10*scale, ay + 10*scale);
                        c.lineTo(ax - 10*scale, ay + 16*scale);
                        c.moveTo(ax + 8*scale, ay + 10*scale);
                        c.lineTo(ax + 8*scale, ay + 16*scale);
                        c.stroke();
                        
                    } else if(animal.type === 'MAMMOTH') {
                        // Cute fluffy mammoth
                        // Big fluffy body
                        let bodyGrad = c.createRadialGradient(ax - 6*scale, ay - 4*scale, 4, ax, ay, 24*scale);
                        bodyGrad.addColorStop(0, '#B89868');
                        bodyGrad.addColorStop(1, '#806040');
                        c.fillStyle = bodyGrad;
                        c.beginPath();
                        c.ellipse(ax, ay + 4*scale, 24*scale, 14*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2.5;
                        c.stroke();
                        
                        // Fluffy fur texture
                        c.fillStyle = '#A88858';
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.ellipse(ax - 16*scale + i*8*scale, ay + 10*scale, 4*scale, 6*scale, 0, 0, 6.28);
                            c.fill();
                        }
                        
                        // Big fluffy hump
                        c.fillStyle = '#907050';
                        c.beginPath();
                        c.ellipse(ax - 6*scale, ay - 12*scale, 16*scale, 12*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Cute round head
                        let headGrad = c.createRadialGradient(ax + 18*scale, ay - 4*scale, 3, ax + 22*scale, ay, 12*scale);
                        headGrad.addColorStop(0, '#C8A878');
                        headGrad.addColorStop(1, '#906850');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 22*scale, ay, 11*scale, 10*scale, 0, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Cute eye
                        c.fillStyle = '#000';
                        c.beginPath();
                        c.arc(ax + 26*scale, ay - 4*scale, 2.5*scale, 0, 6.28);
                        c.fill();
                        c.fillStyle = '#FFF';
                        c.beginPath();
                        c.arc(ax + 25*scale, ay - 5*scale, 1*scale, 0, 6.28);
                        c.fill();
                        
                        // Curvy trunk
                        c.strokeStyle = '#907050';
                        c.lineWidth = 5;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(ax + 30*scale, ay + 4*scale);
                        c.quadraticCurveTo(ax + 36*scale, ay + 16*scale, ax + 28*scale, ay + 20*scale);
                        c.stroke();
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.stroke();
                        c.moveTo(ax + 24*scale, ay + 4*scale);
                        c.quadraticCurveTo(ax + 28*scale, ay + 12*scale, ax + 26*scale, ay + 20*scale);
                        c.stroke();
                        
                        // Cute curved tusks
                        c.strokeStyle = '#FFF8E8';
                        c.lineWidth = 4;
                        c.beginPath();
                        c.arc(ax + 26*scale, ay + 8*scale, 10*scale, -1.5, 0.2, false);
                        c.stroke();
                        c.strokeStyle = '#000';
                        c.lineWidth = 1.5;
                        c.stroke();
                        
                        // Chunky legs
                        c.fillStyle = '#806040';
                        c.fillRect(ax - 16*scale, ay + 14*scale, 8*scale, 12*scale);
                        c.fillRect(ax - 4*scale, ay + 14*scale, 8*scale, 12*scale);
                        c.fillRect(ax + 8*scale, ay + 14*scale, 8*scale, 12*scale);
                        c.strokeStyle = '#000';
                        c.lineWidth = 2;
                        c.strokeRect(ax - 16*scale, ay + 14*scale, 8*scale, 12*scale);
                        c.strokeRect(ax - 4*scale, ay + 14*scale, 8*scale, 12*scale);
                        c.strokeRect(ax + 8*scale, ay + 14*scale, 8*scale, 12*scale);
                    }
                    
                    // Show hit count with cute style
                    if(animal.hits > 0) {
                        // Red heart damage indicator
                        c.fillStyle = '#FF6060';
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText(`ğŸ’” ${animal.hits}/${config.hitToKill}`, ax, ay - 26*scale);
                    }
                });

                // Draw zoned residential buildings with road connection check
                for(let x=sc; x<ec; x++) {
                    for(let y=sr; y<er; y++) {
                        let tile = Game.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            this.drawZonedRes(c, x*T, y*T, tile.building, x, y);
                            
                            // Check road connection for residential zones
                            let hasRoad = false;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H && Game.tiles[nx][ny].road) {
                                        hasRoad = true;
                                        break;
                                    }
                                }
                                if(hasRoad) break;
                            }
                            // Draw "!" indicator if no road connection
                            if(!hasRoad) {
                                this.drawIcon(c, x*T + T/2, y*T + T/2, "!", "red");
                            }
                        }
                    }
                }

                // Draw build effects (e.g., dust clouds)
                const now = performance.now();
                // Remove expired effects
                this.effects = this.effects.filter(e => (now - e.start) < e.duration);
                for(const e of this.effects) {
                    if(e.type === 'dust') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.8;
                        const wobble = this.time * 1.5;
                        for(const puff of e.puffs) {
                            const baseR = puff.radius * T * (1 + 0.4*Math.sin(wobble + puff.angle * 2));
                            const dx = Math.cos(puff.angle) * baseR * (1 + 0.3*Math.sin(wobble + puff.angle));
                            const dy = Math.sin(puff.angle) * baseR * (1 + 0.3*Math.cos(wobble + puff.angle));
                            const size = T * (0.12 + 0.06*Math.sin(wobble + puff.angle)) * (1 - progress);
                            c.fillStyle = `rgba(240, 220, 200, ${alpha})`;
                            c.beginPath();
                            c.ellipse(cx + dx, cy + dy, size, size * 0.85, 0, 0, Math.PI*2);
                            c.fill();
                            c.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
                            c.lineWidth = 1;
                            c.stroke();
                        }
                    } else if(e.type === 'woodchips') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.9;
                        for(const chip of e.chips) {
                            const dist = T * chip.speed * progress * (0.7 + Math.random()*0.3);
                            const dx = Math.cos(chip.angle) * dist;
                            const dy = Math.sin(chip.angle) * dist;
                            const size = T * (0.07 + Math.random()*0.03) * (1 - progress*0.7);
                            c.save();
                            c.translate(cx + dx, cy + dy);
                            c.rotate(chip.angle + progress*2);
                            c.fillStyle = `rgba(180, 120, 60, ${alpha})`;
                            c.fillRect(-size/2, -size/6, size, size/3);
                            c.restore();
                        }
                    }
                }

                Game.blds.forEach(b => {
                    if (b.x < sc-2 || b.x > ec || b.y < sr-2 || b.y > er) return;
                    let bx = b.x * T, by = b.y * T;
                    // COM/IND/WELL are 1x1 per documentation, others are 2x2
                    let size = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? T : 2 * T;
                    
                    // Only draw shadow for 2x2 buildings
                    if(size > T) {
                        c.fillStyle = "rgba(0,0,0,0.3)"; c.beginPath(); c.roundRect(bx+10, by+15, size-20, size-20, 10); c.fill();
                    }
                    
                    // Highlight if hovering
                    let isHover = Controller.mx >= b.x && Controller.mx < b.x + (size/T) && Controller.my >= b.y && Controller.my < b.y + (size/T);
                    if(isHover && Controller.tool === 'PAN') {
                        c.fillStyle = "rgba(255, 255, 0, 0.3)";
                        c.fillRect(bx, by, size, size);
                    }
                    
                    // Only draw base rect for 2x2 buildings (1x1 are handled in their draw functions)
                    if(size > T) {
                        c.fillStyle = CFG.COLORS[b.t]; c.beginPath(); c.roundRect(bx, by, size, size, 4); c.fill();
                    }
                    
                    if (b.t === 'COM') this.drawCom(c, bx, by, b);
                    else if (b.t === 'IND') this.drawInd(c, bx, by, b);
                    else if (b.t === 'CHIEF') this.drawChief(c, bx, by, b);
                    else if (b.t === 'WELL') this.drawWell(c, bx, by, b);
                    else if (b.t === 'BASKET') this.drawBasket(c, bx, by, b);
                    else if (b.t === 'POTTERY') this.drawPottery(c, bx, by, b);
                    else if (b.t === 'GRANARY') this.drawGranary(c, bx, by, b);
                    else if (b.t === 'PALACE') this.drawPalace(c, bx, by, b);

                    // Show building info on hover
                    if(isHover && Controller.tool === 'PAN') {
                        let upgradeCost = Game.getUpgradeCost(b.lvl);
                        let effPct = Math.floor(b.efficiency * 100);
                        let effColor = b.efficiency > 0.8 ? 'ğŸŸ¢' : (b.efficiency > 0.4 ? 'ğŸŸ¡' : 'ğŸ”´');
                        
                        let infoText = `L${b.lvl} ${effColor}${effPct}%`;
                        if(b.t === 'COM' || b.t === 'IND') infoText += ` | ${Math.floor(Game.getBuildingProduction(b) * b.efficiency)}`;
                        if(b.lvl < 200) infoText += ` | â†‘$${Math.floor(upgradeCost)}`;
                        if(!b.conn) infoText += ' | âš ï¸NO ROAD';
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.9)";
                        c.fillRect(bx - 10, by - 30, size + 20, 25);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 9px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(infoText, bx + size/2, by - 17);
                    }

                    c.strokeStyle = "#fff"; c.lineWidth = 2; c.strokeRect(bx, by, size, size);
                    if (b.t !== 'RES' && !b.conn) this.drawIcon(c, bx + size/2, by + size/2, "!", "red");
                });

                this.drawParticles(c);

                if (Controller.tool !== 'PAN' && Controller.tool !== 'NONE') {
                    let gx = Controller.mx, gy = Controller.my;
                    // All zones are 1x1 (ROAD, WELL, BULL, RES, COM, IND, DEMOLISH), only special buildings are 2x2
                    let sz = (Controller.tool=='ROAD'||Controller.tool=='WELL'||Controller.tool=='BULL'||Controller.tool=='RES'||Controller.tool=='COM'||Controller.tool=='IND'||Controller.tool=='DEMOLISH')?1:2;
                    let dx = gx; let dy = gy;
                    
                    let valid = true;
                    if (Controller.tool === 'BULL') valid = Game.blds.some(b => {
                        // COM, IND, WELL are 1x1 per documentation
                        let bSz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2;
                        return gx>=b.x && gx<b.x+bSz && gy>=b.y && gy<b.y+bSz;
                    }) || Game.tiles[gx][gy].road || Game.tiles[gx][gy].zone;
                    else valid = Game.isValid(dx, dy, Controller.tool);

                    c.fillStyle = valid ? CFG.COLORS.OK : CFG.COLORS.NO;
                    c.fillRect(dx*T, dy*T, sz*T, sz*T);
                    c.strokeStyle = "#fff"; c.lineWidth = 3; c.strokeRect(dx*T, dy*T, sz*T, sz*T);
                    
                    // PREVIEW: Show estimated capacity for RES zones
                    if(Controller.tool === 'RES' && valid) {
                        let previewDesirability = Game.calculateDesirability(dx, dy, sz);
                        let startEra = CFG.ERAS[0];
                        let previewCap = Math.floor(startEra.capacity * previewDesirability);
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.85)";
                        c.fillRect(dx*T, dy*T - 40, sz*T, 35);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 11px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(`Zone: ${startEra.name}`, dx*T + sz*T/2, dy*T - 28);
                        c.font = "10px sans-serif";
                        c.fillStyle = previewDesirability > 1.5 ? "#4CAF50" : (previewDesirability > 1.0 ? "#FFC107" : "#FF5252");
                        c.fillText(`Est. Capacity: ${previewCap}`, dx*T + sz*T/2, dy*T - 17);
                        c.font = "9px sans-serif";
                        c.fillStyle = "#FFFFFF";
                        c.fillText(`Desirability: ${Math.floor(previewDesirability*100)}%`, dx*T + sz*T/2, dy*T - 6);
                    }
                }
                c.restore();
            },
            drawRoad(c, x, y, T) {
                // Wider, more realistic grey path
                const tx = x * T, ty = y * T;
                const cx = tx + T/2, cy = ty + T/2;
                const lineWidth = Math.max(8, Math.floor(T * 0.26));

                // Neighbor connections
                const up = (y > 0) && !!Game.tiles[x][y-1].road;
                const down = (y < CFG.H - 1) && !!Game.tiles[x][y+1].road;
                const left = (x > 0) && !!Game.tiles[x-1][y].road;
                const right = (x < CFG.W - 1) && !!Game.tiles[x+1][y].road;

                // Main center stroke (dark grey)
                c.lineCap = 'round';
                c.lineJoin = 'round';
                c.strokeStyle = '#555555';
                c.lineWidth = lineWidth + 2;
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                // Always draw the short center stub so isolated tiles look rounded
                c.moveTo(cx, cy);
                c.lineTo(cx + 0.01, cy + 0.01);
                c.stroke();

                // Lighter inner strip to suggest compacted dirt
                c.strokeStyle = '#7a7a7a';
                c.lineWidth = Math.max(4, Math.floor(lineWidth * 0.5));
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                c.stroke();

                // Subtle edge shading for realism
                c.lineWidth = 1.5;
                c.strokeStyle = 'rgba(0,0,0,0.25)';
                if (up) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty); c.stroke(); }
                if (down) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty + T); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty + T); c.stroke(); }
                if (left) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx, cy + lineWidth/2); c.stroke(); }
                if (right) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx + T, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx + T, cy + lineWidth/2); c.stroke(); }

                // Deterministic speckles/pebbles along path (seeded by coords)
                const seed = ((x * 73856093) ^ (y * 19349663)) >>> 0;
                const rand = (n) => Math.abs(Math.sin(seed + n) * 10000) % 1;
                c.fillStyle = '#666';
                for (let i = 0; i < 4; i++) {
                    let t = 0.2 + i * 0.2 + rand(i) * 0.1; // position along axis
                    let px = cx + ( (left || right) ? (t - 0.5) * T : 0 );
                    let py = cy + ( (up || down) ? (t - 0.5) * T : 0 );
                    // offset perpendicular
                    let ox = (rand(i+10) - 0.5) * lineWidth * 0.6;
                    let oy = (rand(i+20) - 0.5) * lineWidth * 0.6;
                    if (left || right) { py = cy; px = tx + t * T; oy = (rand(i+20)-0.5) * lineWidth * 0.2; }
                    if (up || down) { px = cx; py = ty + t * T; ox = (rand(i+10)-0.5) * lineWidth * 0.2; }
                    c.beginPath();
                    c.ellipse(px + ox, py + oy, Math.max(1, Math.floor(lineWidth*0.12)), Math.max(1, Math.floor(lineWidth*0.08)), 0, 0, 6.28);
                    c.fill();
                }
            },
            drawWaterAnim(c, x, y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.strokeStyle = "rgba(255,255,255,0.2)"; c.lineWidth = 2*scale; 
                let offset = Math.sin(this.time + x) * 5*scale; 
                c.beginPath(); 
                c.moveTo(x*T+10*scale, y*T+T/2+offset); 
                c.quadraticCurveTo(x*T+T/2, y*T+20*scale+offset, x*T+54*scale, y*T+T/2+offset); 
                c.stroke(); 
            },
            drawStoneDeposit(c, x, y, deposit) {
                let T = CFG.TILE;
                let cx = x + T/2;
                let cy = y + T*0.7;
                let scale = T/64;
                
                // Determine color based on metal value (gradient from gray to gold)
                let metalValue = deposit.metal;
                let ratio = (metalValue - CFG.STONE_DEPOSITS.MIN_METAL) / (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL);
                
                // Color progression: Gray -> Blue -> Purple -> Gold
                let r, g, b;
                if(ratio < 0.33) {
                    // Gray to Blue
                    let t = ratio / 0.33;
                    r = Math.floor(120 + (80 - 120) * t);
                    g = Math.floor(120 + (160 - 120) * t);
                    b = Math.floor(120 + (240 - 120) * t);
                } else if(ratio < 0.66) {
                    // Blue to Purple
                    let t = (ratio - 0.33) / 0.33;
                    r = Math.floor(80 + (180 - 80) * t);
                    g = Math.floor(160 + (80 - 160) * t);
                    b = Math.floor(240 + (200 - 240) * t);
                } else {
                    // Purple to Gold
                    let t = (ratio - 0.66) / 0.34;
                    r = Math.floor(180 + (255 - 180) * t);
                    g = Math.floor(80 + (215 - 80) * t);
                    b = Math.floor(200 + (0 - 200) * t);
                }
                
                let baseColor = `rgb(${r},${g},${b})`;
                let darkColor = `rgb(${Math.floor(r*0.6)},${Math.floor(g*0.6)},${Math.floor(b*0.6)})`;
                let lightColor = `rgb(${Math.min(255, Math.floor(r*1.4))},${Math.min(255, Math.floor(g*1.4))},${Math.min(255, Math.floor(b*1.4))})`;
                
                // Shadow
                c.fillStyle = 'rgba(0,0,0,0.4)';
                c.beginPath();
                c.ellipse(cx + 4*scale, cy + 10*scale, 18*scale, 8*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - black outline
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy, 22*scale, 20*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - colored
                c.fillStyle = baseColor;
                c.beginPath();
                c.ellipse(cx, cy, 20*scale, 18*scale, 0, 0, 6.28);
                c.fill();
                
                // Dark patch (bottom right)
                c.fillStyle = darkColor;
                c.beginPath();
                c.ellipse(cx + 8*scale, cy + 6*scale, 8*scale, 7*scale, 0, 0, 6.28);
                c.fill();
                
                // Bright highlight (top left)
                c.fillStyle = lightColor;
                c.beginPath();
                c.ellipse(cx - 6*scale, cy - 6*scale, 8*scale, 7*scale, 0.3, 0, 6.28);
                c.fill();
                
                // Shine spot (Mario-style)
                c.fillStyle = 'rgba(255,255,255,0.8)';
                c.beginPath();
                c.ellipse(cx - 8*scale, cy - 8*scale, 4*scale, 3*scale, -0.3, 0, 6.28);
                c.fill();
                
                // Smaller shine
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.beginPath();
                c.arc(cx + 4*scale, cy - 4*scale, 2*scale, 0, 6.28);
                c.fill();
                
                // Show metal value on explored tiles
                if(Game.tiles && Game.tiles[Math.floor(x/T)] && Game.tiles[Math.floor(x/T)][Math.floor(y/T)]) {
                    let tile = Game.tiles[Math.floor(x/T)][Math.floor(y/T)];
                    if(tile.explored) {
                        c.fillStyle = '#000';
                        c.font = 'bold 8px sans-serif';
                        c.textAlign = 'center';
                        c.fillText(Controller.formatNum(metalValue), cx, cy + 22*scale);
                    }
                }
            },
            drawTree(c, x, y, t) {
                let T = CFG.TILE;
                let cx=x+T/2, cy=y+T*0.78;
                let scale = T/64; // Scale all measurements based on tile size
                
                // Shadow - improved with gradient for more natural look
                let shadowGrad = c.createRadialGradient(cx+6*scale, cy+6*scale, 0, cx+6*scale, cy+6*scale, 18*scale);
                shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)');
                shadowGrad.addColorStop(0.6, 'rgba(0,0,0,0.2)');
                shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
                c.fillStyle = shadowGrad; 
                c.beginPath(); 
                c.ellipse(cx+6*scale, cy+8*scale, 16*scale, 8*scale, 0.2, 0, 6.28); 
                c.fill();
                
                // Trunk with black outline
                c.fillStyle = "#000000";
                c.fillRect(cx-5*scale, cy-18*scale, 10*scale, 20*scale);
                c.fillStyle = "#8B4513";
                c.fillRect(cx-4*scale, cy-17*scale, 8*scale, 18*scale);
                
                // Trunk texture lines
                c.strokeStyle = "#654321";
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(cx-2*scale, cy-10*scale);
                c.lineTo(cx-2*scale, cy);
                c.stroke();
                c.beginPath();
                c.moveTo(cx+2*scale, cy-12*scale);
                c.lineTo(cx+2*scale, cy);
                c.stroke();
                
                if(t=='PINE'||t=='SNOW'){ 
                    // Pine tree style
                    c.fillStyle = "#000000";
                    c.beginPath(); 
                    c.moveTo(cx-20*scale, cy-10*scale); 
                    c.lineTo(cx+20*scale, cy-10*scale); 
                    c.lineTo(cx, cy-65*scale); 
                    c.fill();
                    
                    c.fillStyle = (t=='SNOW') ? "#2E7D32" : "#1B5E20";
                    c.beginPath(); 
                    c.moveTo(cx-18*scale, cy-10*scale); 
                    c.lineTo(cx+18*scale, cy-10*scale); 
                    c.lineTo(cx, cy-62*scale); 
                    c.fill(); 
                    
                    // Second layer
                    c.fillStyle = "#000000";
                    c.beginPath(); 
                    c.moveTo(cx-16*scale, cy-25*scale); 
                    c.lineTo(cx+16*scale, cy-25*scale); 
                    c.lineTo(cx, cy-70*scale); 
                    c.fill();
                    
                    c.fillStyle = (t=='SNOW') ? "#43A047" : "#2E7D32";
                    c.beginPath(); 
                    c.moveTo(cx-14*scale, cy-25*scale); 
                    c.lineTo(cx+14*scale, cy-25*scale); 
                    c.lineTo(cx, cy-68*scale); 
                    c.fill(); 
                    
                    if(t=='SNOW') { 
                        c.fillStyle="#FFF"; 
                        c.beginPath(); 
                        c.moveTo(cx-6*scale, cy-6*scale); 
                        c.lineTo(cx+6*scale, cy-6*scale); 
                        c.lineTo(cx, cy-14*scale); 
                        c.fill(); 
                    } 
                } else { 
                    // Round tree (Enhanced Mario-style - vibrant with more depth!)
                    // Back shadow foliage for depth
                    c.fillStyle = "#1B4D1B";
                    c.beginPath();
                    c.arc(cx, cy-32*scale, 26*scale, 0, 6.28);
                    c.fill();
                    
                    // Back foliage puff - rich green
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx-14*scale, cy-40*scale, 17*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#2D8B2D";
                    c.beginPath();
                    c.arc(cx-14*scale, cy-40*scale, 15*scale, 0, 6.28);
                    c.fill();
                    
                    // Right foliage puff - rich green
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx+14*scale, cy-40*scale, 17*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#3D9B3D";
                    c.beginPath();
                    c.arc(cx+14*scale, cy-40*scale, 15*scale, 0, 6.28);
                    c.fill();
                    
                    // Main center foliage - with gradient for more natural look
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx, cy-34*scale, 26*scale, 0, 6.28);
                    c.fill();
                    
                    let foliageGrad = c.createRadialGradient(cx-4*scale, cy-40*scale, 0, cx, cy-34*scale, 24*scale);
                    foliageGrad.addColorStop(0, '#7DEB7D');
                    foliageGrad.addColorStop(0.5, '#50C850');
                    foliageGrad.addColorStop(1, '#2D8B2D');
                    c.fillStyle = foliageGrad;
                    c.beginPath();
                    c.arc(cx, cy-34*scale, 24*scale, 0, 6.28);
                    c.fill();
                    
                    // Top highlight puff
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx, cy-52*scale, 12*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#5DD85D";
                    c.beginPath();
                    c.arc(cx, cy-52*scale, 10*scale, 0, 6.28);
                    c.fill();
                    
                    // Bright highlights for depth (softer)
                    c.fillStyle = "#8FFF8F";
                    c.beginPath();
                    c.arc(cx-5*scale, cy-42*scale, 8*scale, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.arc(cx+6*scale, cy-38*scale, 6*scale, 0, 6.28);
                    c.fill();
                    
                    // Subtle highlight spot
                    c.fillStyle = "#B8FFB8";
                    c.beginPath();
                    c.arc(cx-4*scale, cy-48*scale, 4*scale, 0, 6.28);
                    c.fill();
                }
            },
            drawZonedRes(c, x, y, bld, gridX, gridY) {
                let lvl = bld.level || 0;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;
                let desirability = bld.desirability || 1.0;
                
                // Check if within Chief's Hut radius for gold border
                let hasChiefBonus = false;
                let chiefHuts = Game.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(gridX - chief.x, 2) + Math.pow(gridY - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChiefBonus = true;
                        break;
                    }
                }
                
                // Get building level info from BUILDING_LEVELS config (not ERAS)
                let buildingConfig = CFG.BUILDING_LEVELS[lvl] || CFG.BUILDING_LEVELS[0];
                let era = { name: buildingConfig.name }; // Use building name, not era name
                
                // LEVEL 0 EVOLUTION VARIANTS
                // (Level 0 is Wanderer/Empty, so we don't draw buildings for it usually)
                
                // Ensure variant is set (default to deterministic random if missing)
                if (bld.variant === undefined) {
                    bld.variant = (gridX + gridY * 57) % 4;
                }
                let variant = bld.variant;

                // === BIRDS EYE VIEW MODE ===
                if(Game.vm === 'BIRDSEYE') {
                    // Draw ground base for all residential
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.15, T*0.4, T*0.2, 0, 0, 6.28);
                    c.fill();

                    if(lvl === 1) {
                        // LEVEL 1: PIT - Use the original drawing code to avoid errors
                        let tentColor = variant === 0 ? '#5D4037' : variant === 1 ? '#8B7355' : variant === 2 ? '#A08060' : '#D4A574';
                        
                        // Draw simple tent shape like original code
                        c.fillStyle = tentColor;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.35);
                        c.lineTo(cx - T*0.3, cy + T*0.15);
                        c.lineTo(cx + T*0.3, cy + T*0.15);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.stroke();

                        // Mud trim: thin ring around the base
                        c.strokeStyle = '#6D4C41';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.16, T*0.28, T*0.10, 0, 0, 6.28);
                        c.stroke();

                        // Flags: yellow for Straw Pit (variant===2), red when full (pop>=capacity)
                        let levelCfg = CFG.BUILDING_LEVELS[lvl] || {};
                        let capacity = levelCfg.capacity || bld.capacity || 0;
                        let isFull = (bld.pop || 0) >= capacity && capacity > 0;
                        let flagColor = null;
                        if (isFull) {
                            flagColor = '#E53935'; // Red when full
                        } else if (variant === 2) {
                            flagColor = '#FFD54F'; // Yellow for Straw Pit
                        }
                        if (flagColor) {
                            // Flag pole anchored at the exact tent tip
                            let apexX = cx;
                            let apexY = cy - T*0.35;
                            c.strokeStyle = '#3E2723';
                            // 7x thinner pole
                            c.lineWidth = 9/7; 
                            c.beginPath();
                            c.moveTo(apexX, apexY);
                            // 60% less tall pole
                            let poleTopY = apexY - T*0.24;
                            c.lineTo(apexX, poleTopY);
                            c.stroke();

                            // Waving triangular flag (red/yellow)
                            // Base size relative to tile, animated by Renderer.time
                            const wBase = T*0.24; // base width
                            const hBase = T*0.08; // base height
                            const t = Renderer.time || 0;
                            const windPhase = t*2 + gridX*0.3 + gridY*0.2;
                            const windPhaseY = t*3 + gridX*0.4;
                            const flapX = apexX + wBase * (1 + 0.25*Math.sin(windPhase));
                            const flapY = poleTopY - hBase * (0.5 + 0.4*Math.cos(windPhaseY));
                            c.fillStyle = flagColor;
                            c.beginPath();
                            c.moveTo(apexX, poleTopY);
                            c.lineTo(flapX, flapY);
                            c.lineTo(apexX, poleTopY - hBase);
                            c.closePath();
                            c.fill();
                        }
                    } else if(lvl === 2) {
                        // LEVEL 2: LEATHER TENT (was drawn at lvl 1)
                        let tentColor = variant === 0 ? '#5D4037' : variant === 1 ? '#8B7355' : variant === 2 ? '#A08060' : '#D4A574';
                        
                        // Tent body (cone shape)
                        c.fillStyle = tentColor;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.35);  // Top point
                        c.lineTo(cx - T*0.3, cy + T*0.15);  // Bottom left
                        c.lineTo(cx + T*0.3, cy + T*0.15);  // Bottom right
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Tent poles sticking out top
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy - T*0.35);
                        c.lineTo(cx - T*0.08, cy - T*0.45);
                        c.stroke();
                        c.beginPath();
                        c.moveTo(cx + T*0.05, cy - T*0.35);
                        c.lineTo(cx + T*0.08, cy - T*0.45);
                        c.stroke();
                        
                        // Door opening (darker)
                        c.fillStyle = 'rgba(0,0,0,0.5)';
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.05);
                        c.lineTo(cx - T*0.08, cy + T*0.12);
                        c.lineTo(cx + T*0.08, cy + T*0.12);
                        c.closePath();
                        c.fill();
                        
                        // Decorative stripes if higher variant
                        if(variant >= 2) {
                            c.strokeStyle = '#8D6E63';
                            c.lineWidth = 2;
                            c.beginPath();
                            c.moveTo(cx - T*0.2, cy);
                            c.lineTo(cx + T*0.2, cy);
                            c.stroke();
                        }
                    } else if(lvl === 3) {
                        // LEVEL 3: MUD BRICK (was drawn at lvl 2)
                        let hutColor = variant === 0 ? '#5D4037' : variant === 1 ? '#8D6E63' : variant === 2 ? '#A1887F' : '#BCAAA4';
                        
                        // Dome body
                        c.fillStyle = hutColor;
                        c.beginPath();
                        c.arc(cx, cy, T*0.3, Math.PI, 0, false);
                        c.lineTo(cx + T*0.3, cy + T*0.1);
                        c.lineTo(cx - T*0.3, cy + T*0.1);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Door
                        c.fillStyle = '#3E2723';
                        c.beginPath();
                        c.arc(cx, cy + T*0.05, T*0.08, Math.PI, 0, false);
                        c.lineTo(cx + T*0.08, cy + T*0.1);
                        c.lineTo(cx - T*0.08, cy + T*0.1);
                        c.closePath();
                        c.fill();
                        
                        // Smoke hole on top if higher variant
                        if(variant >= 2) {
                            c.fillStyle = '#333';
                            c.beginPath();
                            c.arc(cx, cy - T*0.25, T*0.04, 0, 6.28);
                            c.fill();
                        }
                    } else if(lvl >= 4) {
                        // LEVEL 4+: LOG HOUSE (was drawn at lvl 3)
                        let woodColor = variant === 0 ? '#4E342E' : variant === 1 ? '#6D4C41' : variant === 2 ? '#8D6E63' : '#A1887F';
                        
                        // Cabin base
                        c.fillStyle = woodColor;
                        c.fillRect(cx - T*0.3, cy - T*0.15, T*0.6, T*0.35);
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.3, cy - T*0.15, T*0.6, T*0.35);
                        
                        // Log lines
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 1;
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.3, cy - T*0.1 + i*T*0.07);
                            c.lineTo(cx + T*0.3, cy - T*0.1 + i*T*0.07);
                            c.stroke();
                        }
                        
                        // Roof
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.moveTo(cx - T*0.35, cy - T*0.15);
                        c.lineTo(cx, cy - T*0.38);
                        c.lineTo(cx + T*0.35, cy - T*0.15);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Door
                        c.fillStyle = '#3E2723';
                        c.fillRect(cx - T*0.06, cy, T*0.12, T*0.2);
                        
                        // Window if high variant
                        if(variant >= 2) {
                            c.fillStyle = '#FFEB3B';
                            c.fillRect(cx + T*0.12, cy - T*0.05, T*0.08, T*0.08);
                            c.strokeStyle = '#3E2723';
                            c.lineWidth = 1;
                            c.strokeRect(cx + T*0.12, cy - T*0.05, T*0.08, T*0.08);
                        }
                    }
                    
                    // Gold border if within Chief's Hut radius
                    if(hasChiefBonus) {
                        c.strokeStyle = "#FFD700";
                        c.lineWidth = 3;
                        c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                    }
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                
                // Get variant name from config
                let variantConfig = null;
                let variantName = buildingConfig.name;
                if(buildingConfig.variants && buildingConfig.variants[variant]) {
                    variantConfig = buildingConfig.variants[variant];
                    variantName = variantConfig.name;
                }
                
                // Color based on level AND variant - Generate colors dynamically
                // Each level gets progressively more vibrant/prestigious colors
                const generateLevelColors = (level) => {
                    // Base hue shifts from brown (30) through green (120) to blue (200) to purple (280)
                    let hueBase = 30 + (level - 1) * 15;
                    if(hueBase > 360) hueBase = hueBase % 360;
                    
                    // Saturation increases with level
                    let sat = Math.min(70, 30 + level * 3);
                    
                    return [
                        `hsla(${hueBase}, ${sat - 20}%, 25%, 0.8)`,   // Abandoned - Dark
                        `hsla(${hueBase}, ${sat}%, 35%, 0.85)`,       // Low - Medium
                        `hsla(${hueBase}, ${sat + 10}%, 45%, 0.9)`,   // Medium - Bright
                        `hsla(${hueBase}, ${sat + 15}%, 55%, 0.95)`   // High - Vibrant
                    ];
                };
                
                // Named colors for first 4 levels for thematic consistency
                let levelColors = {
                    1: [ // Pit level - Brown tones
                        'rgba(101, 67, 33, 0.8)',    
                        'rgba(141, 110, 99, 0.85)',  
                        'rgba(180, 140, 100, 0.9)',  
                        'rgba(212, 180, 130, 0.95)'  
                    ],
                    2: [ // Leather Tent level - Leather/hide tones
                        'rgba(90, 70, 50, 0.8)',     
                        'rgba(139, 90, 43, 0.85)',   
                        'rgba(160, 120, 80, 0.9)',   
                        'rgba(188, 152, 106, 0.95)'  
                    ],
                    3: [ // Mud Brick level - Clay/adobe tones
                        'rgba(80, 60, 40, 0.8)',     
                        'rgba(140, 100, 60, 0.85)',  
                        'rgba(180, 130, 80, 0.9)',   
                        'rgba(210, 160, 100, 0.95)'  
                    ],
                    4: [ // Log House - Wood tones
                        'rgba(60, 40, 20, 0.8)',     
                        'rgba(100, 70, 40, 0.85)', 
                        'rgba(139, 90, 43, 0.9)',  
                        'rgba(160, 120, 60, 0.95)'  
                    ]
                };
                
                // Get color for this level and variant
                let colorArray = levelColors[lvl] || generateLevelColors(lvl);
                let fillColor = colorArray[Math.min(variant, colorArray.length - 1)];
                
                // Draw building square
                c.fillStyle = fillColor;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);
                
                // Add visual details based on variant
                if(variant >= 2) {
                    // Higher variants get texture
                    c.strokeStyle = "rgba(255, 255, 255, 0.2)";
                    c.lineWidth = 1;
                    for(let i = 0; i < 2; i++) {
                        c.beginPath();
                        c.moveTo(x + 5, y + 15 + i * 12);
                        c.lineTo(x + T - 5, y + 15 + i * 12);
                        c.stroke();
                    }
                }
                
                // Gold border if within Chief's Hut radius
                if(hasChiefBonus) {
                    c.strokeStyle = "#FFD700";
                    c.lineWidth = 2;
                    c.strokeRect(x + 1, y + 1, T - 2, T - 2);
                }
                
                // Show variant name (truncate if too long)
                c.fillStyle = hasChiefBonus ? "#FFD700" : "#FFFFFF";
                c.font = "bold " + Math.floor(T/5) + "px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                
                // Show population count / capacity at top
                let pop = bld.pop || 0;
                let levelCfg = CFG.BUILDING_LEVELS[lvl] || {};
                let capacity = levelCfg.capacity || bld.capacity || 20;
                c.font = "bold " + Math.floor(T/5) + "px sans-serif";
                c.fillText(`ğŸ‘¥${pop}/${capacity}`, cx, y + T/5);
                
                // Split long names into 2 lines
                let displayName = variantName;
                c.font = "bold " + Math.floor(T/6) + "px sans-serif";
                if(displayName.length > 12) {
                    let words = displayName.split(' ');
                    if(words.length >= 2) {
                        let line1 = words.slice(0, Math.ceil(words.length/2)).join(' ');
                        let line2 = words.slice(Math.ceil(words.length/2)).join(' ');
                        c.fillText(line1, cx, cy - 3);
                        c.fillText(line2, cx, cy + 6);
                    } else {
                        c.fillText(displayName.substring(0, 10), cx, cy);
                    }
                } else {
                    c.fillText(displayName, cx, cy + 2);
                }
                
                // Level indicator at bottom
                c.font = Math.floor(T/6) + "px sans-serif";
                c.fillText(`L${lvl}`, cx, y + T - 4);
            },
            drawRes(c,x,y,b) {
                let lvl = b.lvl || 1;
                let cx = x + 32, cy = y + 32;
                let desirability = b.desirability || 1.0;
                
                // Visual feedback: High desirability = brighter/warmer, Low = darker/smaller
                let brightness = Math.min(1.5, Math.max(0.6, desirability));
                let scale = Math.min(1.1, Math.max(0.85, 0.9 + desirability * 0.1));
                
                // Determine architectural era based on level (1-200)
                if(lvl <= 40) {
                    // PRIMITIVE (1-40): Mud huts â†’ Stone huts
                    let progress = (lvl - 1) / 39;
                    let baseSize = 18 + progress * 8;
                    let roofHeight = 28 + progress * 12;
                    
                    c.fillStyle = "rgba(0,0,0,0.2)";
                    c.beginPath();
                    c.ellipse(cx, cy + 22, baseSize + 2, 6, 0, 0, 6.28);
                    c.fill();
                    
                    // Walls transition mud â†’ stone
                    let mudColor = [141, 110, 99];
                    let stoneColor = [120, 120, 120];
                    let wallColor = mudColor.map((m, i) => Math.floor((m + (stoneColor[i] - m) * progress) * brightness));
                    c.fillStyle = `rgb(${wallColor[0]}, ${wallColor[1]}, ${wallColor[2]})`;
                    c.beginPath();
                    c.arc(cx, cy, baseSize * scale, 0, 6.28);
                    c.fill();
                    
                    // Roof
                    let roofColor = lvl > 20 ? "#8B7355" : "#D4A574";
                    c.fillStyle = roofColor;
                    c.beginPath();
                    c.moveTo(cx - (baseSize + 4) * scale, cy);
                    c.lineTo(cx + (baseSize + 4) * scale, cy);
                    c.lineTo(cx, cy - roofHeight * scale);
                    c.fill();
                    
                    // High desirability: Smoke from chimney
                    if(desirability > 1.5 && Math.random() > 0.7) {
                        Renderer.particles.push({x: cx, y: cy - roofHeight * scale - 5, l: 30, c: "rgba(200,200,200,0.6)"});
                    }
                } else if(lvl <= 80) {
                    // ANCIENT (41-80): Stone houses â†’ Roman villas
                    let progress = (lvl - 41) / 39;
                    let width = (40 + progress * 15) * scale;
                    let height = (30 + progress * 10) * scale;
                    
                    c.fillStyle = `rgba(160, 130, 109, ${brightness})`;
                    c.fillRect(cx - width/2, cy - height/2, width, height);
                    
                    // Columns appear as we progress
                    if(lvl > 60) {
                        c.fillStyle = "#D4C5B9";
                        for(let i = 0; i < 3; i++) {
                            c.fillRect(cx - width/2 + 10 + i * 15, cy - height/2, 5, height);
                        }
                    }
                    
                    // Roof
                    c.fillStyle = "#8B4513";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 5, cy - height/2);
                    c.lineTo(cx + width/2 + 5, cy - height/2);
                    c.lineTo(cx, cy - height/2 - 20);
                    c.fill();
                } else if(lvl <= 120) {
                    // MEDIEVAL (81-120): Wooden houses â†’ Stone manors
                    let progress = (lvl - 81) / 39;
                    let stories = Math.floor(1 + progress * 2);
                    let width = 35 * scale;
                    let storyHeight = 18 * scale;
                    
                    for(let s = 0; s < stories; s++) {
                        let baseColor = s % 2 === 0 ? [101, 67, 33] : [139, 115, 85];
                        c.fillStyle = `rgb(${Math.floor(baseColor[0]*brightness)}, ${Math.floor(baseColor[1]*brightness)}, ${Math.floor(baseColor[2]*brightness)})`;
                        c.fillRect(cx - width/2, cy + 10 - s * storyHeight, width, storyHeight);
                        
                        // Windows
                        c.fillStyle = "#FFE4B5";
                        c.fillRect(cx - 8, cy + 15 - s * storyHeight, 6, 8);
                        c.fillRect(cx + 2, cy + 15 - s * storyHeight, 6, 8);
                    }
                    
                    // Roof
                    c.fillStyle = "#8B0000";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx + width/2 + 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx, cy - 5 - stories * storyHeight);
                    c.fill();
                } else if(lvl <= 160) {
                    // INDUSTRIAL (121-160): Brick apartments â†’ Early skyscrapers
                    let progress = (lvl - 121) / 39;
                    let stories = Math.floor(3 + progress * 5);
                    let width = 32 * scale;
                    let storyHeight = 12 * scale;
                    
                    c.fillStyle = "#8B4513";
                    c.fillRect(cx - width/2, cy + 15 - stories * storyHeight, width, stories * storyHeight);
                    
                    // Grid of windows
                    c.fillStyle = "#FFD700";
                    for(let s = 0; s < stories; s++) {
                        for(let w = 0; w < 2; w++) {
                            c.fillRect(cx - 12 + w * 14, cy + 18 - s * storyHeight, 8, 6);
                        }
                    }
                    
                    // Flat roof
                    c.fillStyle = "#696969";
                    c.fillRect(cx - width/2 - 2, cy + 15 - stories * storyHeight - 3, width + 4, 3);
                    
                    // High desirability: Smoke particles
                    if(desirability > 1.3 && Math.random() > 0.8) {
                        Renderer.particles.push({x: cx + 10, y: cy + 15 - stories * storyHeight - 10, l: 25, c: "rgba(180,180,180,0.5)"});
                    }
                } else {
                    // MODERN/FUTURISTIC (161-200): Skyscrapers â†’ Mega towers
                    let progress = (lvl - 161) / 39;
                    let stories = Math.floor(8 + progress * 12);
                    let width = 28 * scale;
                    let storyHeight = 10 * scale;
                    
                    // Main tower
                    let gradient = c.createLinearGradient(cx - width/2, 0, cx + width/2, 0);
                    gradient.addColorStop(0, "#4A90E2");
                    gradient.addColorStop(1, "#50C878");
                    c.fillStyle = gradient;
                    c.fillRect(cx - width/2, cy + 20 - stories * storyHeight, width, stories * storyHeight);
                    
                    // High-tech windows
                    c.fillStyle = lvl > 180 ? "#00FFFF" : "#87CEEB";
                    for(let s = 0; s < stories; s++) {
                        c.fillRect(cx - 10, cy + 22 - s * storyHeight, 20, 6);
                    }
                    
                    // Futuristic top (for highest levels)
                    if(lvl > 180) {
                        c.fillStyle = "#FF00FF";
                        c.beginPath();
                        c.arc(cx, cy + 20 - stories * storyHeight - 5, 5, 0, 6.28);
                        c.fill();
                    }
                }
                
                // Level indicator
                c.fillStyle = "#FFFFFF";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText(`L${lvl}`, cx, y + 60);
            },
            drawCom(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;  // Center for 1x1 tile
                
                // Get variant for activity level (0=abandoned, 1=low, 2=medium, 3=high)
                let variant = b.variant || 1;
                
                // === BIRDS EYE VIEW MODE - Cute campfire/trading spot ===
                if(Game.vm === 'BIRDSEYE') {
                    // Draw ground/clearing
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.1, T*0.42, T*0.32, 0, 0, 6.28);
                    c.fill();
                    
                    // Stone ring around fire
                    c.fillStyle = '#696969';
                    for(let i = 0; i < 8; i++) {
                        let angle = (i/8) * Math.PI * 2;
                        c.beginPath();
                        c.ellipse(
                            cx + Math.cos(angle) * T*0.25,
                            cy + Math.sin(angle) * T*0.18,
                            T*0.08, T*0.06, angle, 0, 6.28
                        );
                        c.fill();
                    }
                    
                    // Logs in fire (brown sticks)
                    c.strokeStyle = '#5D4037';
                    c.lineWidth = 3;
                    c.lineCap = 'round';
                    // Log 1
                    c.beginPath();
                    c.moveTo(cx - T*0.15, cy + T*0.08);
                    c.lineTo(cx + T*0.12, cy - T*0.05);
                    c.stroke();
                    // Log 2
                    c.beginPath();
                    c.moveTo(cx + T*0.15, cy + T*0.08);
                    c.lineTo(cx - T*0.1, cy - T*0.03);
                    c.stroke();
                    
                    // Fire flames (animated-looking by varying sizes based on variant)
                    if(variant > 0) {
                        // Outer orange glow
                        let glowGrad = c.createRadialGradient(cx, cy - T*0.05, 0, cx, cy, T*0.25);
                        glowGrad.addColorStop(0, 'rgba(255,100,0,0.4)');
                        glowGrad.addColorStop(1, 'rgba(255,100,0,0)');
                        c.fillStyle = glowGrad;
                        c.beginPath();
                        c.arc(cx, cy - T*0.05, T*0.25, 0, 6.28);
                        c.fill();
                        
                        // Yellow/orange flame core
                        let flameHeight = T * (0.2 + variant * 0.08);
                        c.fillStyle = '#FF6600';
                        c.beginPath();
                        c.moveTo(cx - T*0.1, cy);
                        c.quadraticCurveTo(cx - T*0.15, cy - flameHeight*0.6, cx, cy - flameHeight);
                        c.quadraticCurveTo(cx + T*0.15, cy - flameHeight*0.6, cx + T*0.1, cy);
                        c.closePath();
                        c.fill();
                        
                        // Inner yellow flame
                        c.fillStyle = '#FFCC00';
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy);
                        c.quadraticCurveTo(cx - T*0.08, cy - flameHeight*0.4, cx, cy - flameHeight*0.7);
                        c.quadraticCurveTo(cx + T*0.08, cy - flameHeight*0.4, cx + T*0.05, cy);
                        c.closePath();
                        c.fill();
                        
                        // Brightest center
                        c.fillStyle = '#FFFFAA';
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.05, T*0.04, T*0.06, 0, 0, 6.28);
                        c.fill();
                    } else {
                        // Abandoned - just ash/coals
                        c.fillStyle = '#333';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.12, T*0.08, 0, 0, 6.28);
                        c.fill();
                    }
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                // Simple colored square based on level - BLUE TONES for commercial
                let color = "#1565C0";  // Dark Blue base
                if(lvl === 2) color = "#1976D2"; // Level 2 - Fire Pit
                
                // Adjust for variant/activity
                if(variant === 0) color = '#5D4037'; // Abandoned - brown
                
                c.fillStyle = color;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);  // 1x1 tile
                
                // Border
                c.strokeStyle = '#333';
                c.lineWidth = 1;
                c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                
                // "C" label
                c.fillStyle = "#FFFFFF";
                c.font = "bold 16px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.fillText("C", cx, cy - 10);
                
                // Worker count / job capacity (COM zones provide jobs)
                let pop = b.pop || 0;
                let comConfig = CFG.COMMERCIAL_LEVELS ? CFG.COMMERCIAL_LEVELS[lvl] : null;
                let jobCap = comConfig ? comConfig.capacity : (lvl * 10);
                c.font = "bold 8px sans-serif";
                c.fillText(`ğŸ‘·${pop}/${jobCap}`, cx, cy + 2);
                
                // Level number
                c.font = "bold 10px sans-serif";
                c.fillText(`L${lvl}`, cx, cy + 12);
                
                // 3-Color Activity Bar (SNES SimCity style)
                let barWidth = T - 12;
                let barHeight = 4;
                let barX = x + 6;
                let barY = y + T - 8;
                
                // Background
                c.fillStyle = '#333';
                c.fillRect(barX, barY, barWidth, barHeight);
                
                // Activity color based on variant
                let activityColor = variant === 0 ? '#666' : variant === 1 ? '#FFEB3B' : variant === 2 ? '#4CAF50' : '#F44336';
                let activityWidth = variant === 0 ? 0 : (variant / 3) * barWidth;
                c.fillStyle = activityColor;
                c.fillRect(barX, barY, activityWidth, barHeight);
            },
            drawInd(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;  // Center for 1x1 tile
                
                // Get config and variant for this industrial level
                let levelConfig = CFG.INDUSTRIAL_LEVELS[lvl];
                let variant = b.variant || 1; // 0=abandoned, 1=low, 2=medium, 3=high
                
                // === BIRDS EYE VIEW MODE - Forest with Hunting Sign (Bugs Bunny style) ===
                if(Game.vm === 'BIRDSEYE') {
                    // Ground - forest floor with grass
                    c.fillStyle = '#4A7C23';
                    c.fillRect(x, y, T, T);
                    
                    // Add some grass texture
                    c.fillStyle = '#5D9E2B';
                    for(let i = 0; i < 6; i++) {
                        c.beginPath();
                        c.ellipse(x + Math.random()*T, y + T*0.7 + Math.random()*T*0.3, T*0.08, T*0.04, 0, 0, 6.28);
                        c.fill();
                    }
                    
                    // Draw little trees (2-3 based on variant)
                    let numTrees = 1 + Math.min(variant, 2);
                    let treePositions = [[0.25, 0.5], [0.7, 0.35], [0.5, 0.7]];
                    
                    for(let i = 0; i < numTrees; i++) {
                        let tx = x + treePositions[i][0] * T;
                        let ty = y + treePositions[i][1] * T;
                        let treeScale = 0.6 + i * 0.1;
                        
                        // Tree trunk
                        c.fillStyle = '#5D4037';
                        c.fillRect(tx - T*0.03, ty, T*0.06, T*0.15*treeScale);
                        
                        // Tree foliage (pine tree shape)
                        c.fillStyle = '#2E7D32';
                        c.beginPath();
                        c.moveTo(tx, ty - T*0.25*treeScale);
                        c.lineTo(tx - T*0.12*treeScale, ty + T*0.02);
                        c.lineTo(tx + T*0.12*treeScale, ty + T*0.02);
                        c.closePath();
                        c.fill();
                        
                        // Second layer
                        c.fillStyle = '#388E3C';
                        c.beginPath();
                        c.moveTo(tx, ty - T*0.18*treeScale);
                        c.lineTo(tx - T*0.1*treeScale, ty - T*0.02);
                        c.lineTo(tx + T*0.1*treeScale, ty - T*0.02);
                        c.closePath();
                        c.fill();
                    }
                    
                    // BUGS BUNNY STYLE HUNTING SIGN!
                    // Sign post
                    c.fillStyle = '#8B7355';
                    c.fillRect(cx - T*0.03, cy - T*0.1, T*0.06, T*0.45);
                    
                    // Sign board (slightly tilted for cartoon effect)
                    c.save();
                    c.translate(cx, cy - T*0.15);
                    c.rotate(-0.08); // Slight tilt
                    
                    // Sign background
                    c.fillStyle = '#F5DEB3'; // Tan/wooden color
                    c.fillRect(-T*0.22, -T*0.12, T*0.44, T*0.22);
                    
                    // Sign border
                    c.strokeStyle = '#5D4037';
                    c.lineWidth = 2;
                    c.strokeRect(-T*0.22, -T*0.12, T*0.44, T*0.22);
                    
                    // "HUNTING" text at top
                    c.fillStyle = '#D32F2F';
                    c.font = 'bold ' + Math.floor(T*0.12) + 'px serif';
                    c.textAlign = 'center';
                    c.textBaseline = 'middle';
                    c.fillText('HUNTING', 0, -T*0.04);
                    
                    // "SEASON" text below
                    c.fillText('SEASON', 0, T*0.06);
                    
                    c.restore();
                    
                    // Little rabbit silhouette (Bugs Bunny reference!)
                    if(variant >= 2) {
                        c.fillStyle = '#888';
                        c.beginPath();
                        // Bunny body
                        c.ellipse(x + T*0.15, y + T*0.75, T*0.06, T*0.04, 0, 0, 6.28);
                        c.fill();
                        // Bunny ears
                        c.beginPath();
                        c.ellipse(x + T*0.12, y + T*0.68, T*0.015, T*0.05, -0.3, 0, 6.28);
                        c.ellipse(x + T*0.17, y + T*0.68, T*0.015, T*0.05, 0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                // Color based on level - BROWN/ORANGE tones for industrial
                let color = '#8D6E63';  // Brown base
                if(lvl === 2) color = '#795548';  // Darker brown for Level 2
                if(lvl === 3) color = '#6D4C41';  // Even darker for Level 3
                if(lvl === 4) color = '#5D4037';  // Darkest for Level 4
                
                // Adjust for variant/activity
                if(variant === 0) color = '#424242'; // Abandoned - gray
                else if(variant === 3) color = '#FF5722'; // High activity - orange
                
                c.fillStyle = color;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);  // 1x1 tile
                
                // Border
                c.strokeStyle = variant === 3 ? '#FFD700' : '#333';
                c.lineWidth = variant === 3 ? 2 : 1;
                c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                
                // "I" label
                c.fillStyle = "#FFFFFF";
                c.font = "bold 16px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.fillText("I", cx, cy - 10);
                
                // Worker count / capacity (IND zones provide jobs)
                let pop = b.pop || 0;
                let indConfig = CFG.INDUSTRIAL_LEVELS ? CFG.INDUSTRIAL_LEVELS[lvl] : null;
                let workerCap = indConfig ? indConfig.capacity : (lvl * 15);
                c.font = "bold 8px sans-serif";
                c.fillText(`ğŸ‘·${pop}/${workerCap}`, cx, cy + 2);
                
                // Level number
                c.font = "bold 10px sans-serif";
                c.fillText(`L${lvl}`, cx, cy + 12);
                
                // 3-Color Activity Bar (SNES SimCity style)
                let barWidth = T - 12;
                let barHeight = 4;
                let barX = x + 6;
                let barY = y + T - 8;
                
                // Background
                c.fillStyle = '#333';
                c.fillRect(barX, barY, barWidth, barHeight);
                
                // Activity color based on variant: Yellow=Low, Green=Medium, Red=High
                let activityColor = variant === 0 ? '#666' : variant === 1 ? '#FFEB3B' : variant === 2 ? '#4CAF50' : '#F44336';
                let activityWidth = variant === 0 ? 0 : (variant / 3) * barWidth;
                c.fillStyle = activityColor;
                c.fillRect(barX, barY, activityWidth, barHeight);
            },
            drawWell(c,x,y) {
                let T = CFG.TILE;
                let cx = x + T * 0.5;
                let cy = y + T * 0.55;

                // Drop shadow (smaller, offset)
                c.save();
                c.fillStyle = 'rgba(0,0,0,0.25)';
                c.beginPath();
                c.ellipse(cx + T*0.08, cy + T*0.08, T*0.18, T*0.09, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden rim (elliptical, plank tone gradient)
                let rimGrad = c.createLinearGradient(cx, cy - T*0.12, cx, cy + T*0.12);
                rimGrad.addColorStop(0, '#8D6E63');
                rimGrad.addColorStop(1, '#5D4037');
                c.fillStyle = rimGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.18, T*0.12, 0, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#4E342E';
                c.lineWidth = 2;
                c.stroke();

                // Ambient occlusion under rim
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy + T*0.03, T*0.17, T*0.11, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Water surface (inner ellipse with highlight)
                let waterGrad = c.createLinearGradient(cx, cy - T*0.08, cx, cy + T*0.08);
                waterGrad.addColorStop(0, '#81D4FA');
                waterGrad.addColorStop(1, '#29B6F6');
                c.fillStyle = waterGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.12, T*0.08, 0, 0, Math.PI*2);
                c.fill();
                // Highlight
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#FFFFFF';
                c.beginPath();
                c.ellipse(cx - T*0.04, cy - T*0.03, T*0.06, T*0.03, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden posts (left/right) and crossbeam
                let postW = T*0.04, postH = T*0.22;
                let postY = cy - T*0.22;
                c.fillStyle = '#6D4C41';
                // Left post
                c.fillRect(cx - T*0.16, postY, postW, postH);
                // Right post
                c.fillRect(cx + T*0.12, postY, postW, postH);
                // Crossbeam
                c.fillStyle = '#8D6E63';
                c.fillRect(cx - T*0.16, postY - T*0.02, T*0.32 + postW, T*0.03);

                // Rope + bucket hint
                c.strokeStyle = '#D7CCC8';
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(cx, postY);
                c.lineTo(cx, cy - T*0.03);
                c.stroke();
                c.fillStyle = '#5D4037';
                c.fillRect(cx - T*0.015, cy - T*0.03, T*0.03, T*0.02);
            },
            drawChief(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Shadow
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                // Main structure - ornate building
                c.fillStyle = "#8B7355";
                c.fillRect(x + 15, y + 30, T*2 - 30, T*2 - 40);
                
                // Columns (4 columns)
                c.fillStyle = "#D4C5B9";
                for(let i = 0; i < 4; i++) {
                    c.fillRect(x + 20 + i * 28, y + 30, 8, T*2 - 40);
                }
                
                // Roof with triangular pediment
                c.fillStyle = "#CD853F";
                c.beginPath();
                c.moveTo(x + 10, y + 30);
                c.lineTo(x + T*2 - 10, y + 30);
                c.lineTo(cx, y + 5);
                c.closePath();
                c.fill();
                
                // Decorative elements
                c.fillStyle = "#FFD700";
                c.beginPath();
                c.arc(cx, y + 15, 8, 0, 6.28);
                c.fill();
                
                // Door
                c.fillStyle = "#654321";
                c.fillRect(cx - 12, cy + 35, 24, 35);
                
                // Cultural symbol (fire bowl on top)
                c.fillStyle = "#FF6347";
                c.beginPath();
                c.arc(cx, y + 8, 6, 0, 6.28);
                c.fill();
                
                    // Smoke/culture particles
                if(Math.random() > 0.5) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 5, 
                        40, 
                        "rgba(255, 215, 0, 0.7)"
                    );
                    if(p) Renderer.particles.push(p);
                }                // Label
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("CHIEF'S HUT", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${Math.floor(CFG.CHIEF_BONUS*100)}% Culture Bonus`, cx, y + T*2 + 27);
            },
            drawBasket(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#D2691E";
                c.fillRect(x + 20, y + 40, T*2 - 40, T*2 - 50);
                
                c.strokeStyle = "#8B4513";
                c.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.moveTo(x + 20, y + 40 + i * 6);
                    c.lineTo(x + T*2 - 20, y + 40 + i * 6);
                    c.stroke();
                }
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("BASKET", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.BASKET.cap} storage`, cx, y + T*2 + 27);
            },
            drawPottery(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.beginPath();
                c.moveTo(x + 30, y + 60);
                c.quadraticCurveTo(x + 25, y + 40, x + 35, y + 35);
                c.lineTo(x + T*2 - 35, y + 35);
                c.quadraticCurveTo(x + T*2 - 25, y + 40, x + T*2 - 30, y + 60);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#DAA520";
                c.fillRect(x + 35, y + 30, T*2 - 70, 5);
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("POTTERY", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.POTTERY.cap} storage`, cx, y + T*2 + 27);
            },
            drawGranary(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#A0826D";
                c.fillRect(x + 25, y + 35, T*2 - 50, T*2 - 45);
                
                c.fillStyle = "#8B7355";
                c.beginPath();
                c.moveTo(x + 20, y + 35);
                c.lineTo(x + T*2 - 20, y + 35);
                c.lineTo(cx, y + 15);
                c.closePath();
                c.fill();
                
                for(let i = 0; i < 3; i++) {
                    c.fillStyle = "#654321";
                    c.fillRect(x + 30 + i * 20, y + 45, 8, 30);
                }
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("GRANARY", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.GRANARY.cap} storage`, cx, y + T*2 + 27);
            },
            drawPalace(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.fillRect(x + 20, y + 30, T*2 - 40, T*2 - 35);
                
                c.fillStyle = "#FFD700";
                for(let i = 0; i < 5; i++) {
                    c.fillRect(x + 25 + i * 18, y + 30, 6, T*2 - 35);
                }
                
                c.fillStyle = "#DAA520";
                c.beginPath();
                c.moveTo(x + 15, y + 30);
                c.lineTo(x + T*2 - 15, y + 30);
                c.lineTo(cx, y + 10);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#FF6347";
                c.beginPath();
                c.arc(cx, y + 15, 5, 0, 6.28);
                c.fill();
                
                if(Math.random() > 0.7) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 10, 
                        30, 
                        "rgba(255, 215, 0, 0.8)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("PALACE", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.PALACE.cap} storage`, cx, y + T*2 + 27);
            },
            drawIcon(c,x,y,txt,color) { c.fillStyle=color; c.font="bold 24px sans-serif"; c.textAlign="center"; c.textBaseline="middle"; c.fillText(txt, x, y); },
            drawGrain(c,x,y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.fillStyle="#F9A825";
                // Use deterministic positions based on tile coordinates to prevent movement
                const tx = Math.floor(x / T);
                const ty = Math.floor(y / T);
                // Create pseudo-random but fixed positions using tile coords
                for(let i=0;i<4;i++) {
                    const seed = (tx * 7 + ty * 13 + i * 31) % 1000;
                    const px = x + (seed % T);
                    const py = y + ((seed * 17) % T);
                    c.fillRect(px, py, 3*scale, 3*scale);
                }
            },
            drawParticles(c) { 
                for (let i=this.particles.length-1; i>=0; i--) { 
                    let p=this.particles[i]; 
                    p.y-=1; 
                    p.l--; 
                    c.fillStyle=p.c; 
                    c.beginPath(); 
                    c.arc(p.x, p.y, 5, 0, 6.28); 
                    c.fill(); 
                    if(p.l<=0) {
                        if(p.active !== undefined) p.active = false; // Return to pool
                        this.particles.splice(i,1);
                    }
                } 
            }
        };

        // --- SOUND SYSTEM ---
        const SoundFX = {
            audioCtx: null,
            enabled: true,
            master: null,
            wetBus: null,
            convolver: null,
            _initialized: false,
            
            // Helper: create noise buffer
            _noiseSource(durationSec) {
                const ctx = this.audioCtx;
                const buffer = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * durationSec), ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;
                const src = ctx.createBufferSource();
                src.buffer = buffer;
                return src;
            },
            
            // Helper: create impulse response for reverb
            _createImpulse(seconds, decay) {
                const ctx = this.audioCtx;
                const length = Math.floor(ctx.sampleRate * seconds);
                const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
                for(let c=0;c<2;c++){
                    const ch = impulse.getChannelData(c);
                    for(let i=0;i<length;i++) {
                        ch[i] = (Math.random()*2 - 1) * Math.pow(1 - i/length, decay);
                    }
                }
                return impulse;
            },
            
            // Helper: send to reverb
            _sendToReverb(node, wet=0.15) {
                if(!this.convolver) return;
                const send = this.audioCtx.createGain();
                send.gain.value = wet;
                node.connect(send);
                send.connect(this.convolver);
            },
            
            init() {
                if(this._initialized) return;
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    // Master routing
                    this.master = this.audioCtx.createGain();
                    this.master.gain.value = 0.9;
                    this.master.connect(this.audioCtx.destination);

                    // Simple small-room reverb (now helpers are defined)
                    this.wetBus = this.audioCtx.createGain();
                    this.wetBus.gain.value = 0.22;
                    this.convolver = this.audioCtx.createConvolver();
                    this.convolver.buffer = this._createImpulse(0.18, 1.8);
                    this.wetBus.connect(this.audioCtx.destination);
                    this.convolver.connect(this.wetBus);
                    this._initialized = true;
                    console.log('[SoundFX] Initialized successfully');
                } catch(e) {
                    console.log('[SoundFX] Audio not supported:', e);
                    this.enabled = false;
                }
            },
            
            // Resume audio context (needed for browsers that suspend it)
            resume() {
                if(this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
            },
            
            // Realistic layered collection sounds (sample-free synthesis)
            playCollect(type) {
                console.log('[SoundFX] playCollect called with type:', type, 'enabled:', this.enabled, 'audioCtx:', !!this.audioCtx);
                if(!this.enabled || !this.audioCtx) return;
                this.resume();

                const ctx = this.audioCtx;
                const now = ctx.currentTime;

                const rnd = (min, max) => min + Math.random()*(max-min);
                
                if(type === 'food') {
                    // FOOD: Juicy berry squish + stem snap + satisfied grunt
                    
                    // 1. Wet squish (low filtered noise burst)
                    const squish = this._noiseSource(0.15);
                    const squishLP = ctx.createBiquadFilter();
                    squishLP.type = 'lowpass'; squishLP.frequency.value = rnd(400, 600);
                    const squishG = ctx.createGain();
                    squishG.gain.setValueAtTime(0, now);
                    squishG.gain.linearRampToValueAtTime(0.5, now + 0.02);
                    squishG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    squish.connect(squishLP); squishLP.connect(squishG); squishG.connect(this.master);
                    squish.start(now); squish.stop(now + 0.15);
                    
                    // 2. Stem snap (high click)
                    const snap = ctx.createOscillator(); snap.type = 'square';
                    snap.frequency.setValueAtTime(rnd(1800, 2400), now);
                    snap.frequency.exponentialRampToValueAtTime(800, now + 0.015);
                    const snapG = ctx.createGain();
                    snapG.gain.setValueAtTime(0.3, now);
                    snapG.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
                    snap.connect(snapG); snapG.connect(this.master);
                    snap.start(now); snap.stop(now + 0.03);
                    
                    // 3. Satisfied caveman grunt (low formant)
                    const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                    grunt.frequency.setValueAtTime(rnd(95, 115), now + 0.08);
                    grunt.frequency.linearRampToValueAtTime(rnd(80, 95), now + 0.22);
                    const gruntLP = ctx.createBiquadFilter(); gruntLP.type = 'lowpass'; gruntLP.frequency.value = 350;
                    const gruntG = ctx.createGain();
                    gruntG.gain.setValueAtTime(0, now + 0.08);
                    gruntG.gain.linearRampToValueAtTime(0.18, now + 0.1);
                    gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    grunt.connect(gruntLP); gruntLP.connect(gruntG); gruntG.connect(this.master);
                    this._sendToReverb(gruntG, 0.15);
                    grunt.start(now + 0.08); grunt.stop(now + 0.28);
                    return;
                }

                if(type === 'wood') {
                    // WOOD: Axe impact + wood fiber crack + resonant body
                    
                    // 1. Sharp axe impact (broadband attack)
                    const impact = this._noiseSource(0.04);
                    const impactBP = ctx.createBiquadFilter(); impactBP.type = 'bandpass'; impactBP.frequency.value = rnd(1200, 1800); impactBP.Q.value = 1.5;
                    const impactG = ctx.createGain();
                    impactG.gain.setValueAtTime(0.45, now);
                    impactG.gain.exponentialRampToValueAtTime(0.001, now + 0.035);
                    impact.connect(impactBP); impactBP.connect(impactG); impactG.connect(this.master);
                    impact.start(now); impact.stop(now + 0.04);
                    
                    // 2. Wood fiber cracking (multiple short bursts)
                    for(let i = 0; i < 3; i++) {
                        const crack = this._noiseSource(0.025);
                        const crackHP = ctx.createBiquadFilter(); crackHP.type = 'highpass'; crackHP.frequency.value = rnd(2000, 3500);
                        const crackG = ctx.createGain();
                        const t = now + 0.02 + i * 0.015;
                        crackG.gain.setValueAtTime(rnd(0.15, 0.25), t);
                        crackG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                        crack.connect(crackHP); crackHP.connect(crackG); crackG.connect(this.master);
                        crack.start(t); crack.stop(t + 0.03);
                    }
                    
                    // 3. Resonant wood body thunk (low frequency)
                    const body = ctx.createOscillator(); body.type = 'sine';
                    body.frequency.setValueAtTime(rnd(85, 110), now);
                    body.frequency.exponentialRampToValueAtTime(rnd(55, 70), now + 0.15);
                    const bodyG = ctx.createGain();
                    bodyG.gain.setValueAtTime(0, now);
                    bodyG.gain.linearRampToValueAtTime(0.35, now + 0.008);
                    bodyG.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    body.connect(bodyG); bodyG.connect(this.master);
                    this._sendToReverb(bodyG, 0.08);
                    body.start(now); body.stop(now + 0.2);
                    return;
                }

                if(type === 'metal') {
                    // METAL: Realistic ore chunk clinking with metallic ring
                    
                    // 1. Sharp metallic impact
                    const strike = this._noiseSource(0.02);
                    const strikeHP = ctx.createBiquadFilter(); strikeHP.type = 'highpass'; strikeHP.frequency.value = 2500;
                    const strikeG = ctx.createGain();
                    strikeG.gain.setValueAtTime(0.3, now);
                    strikeG.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                    strike.connect(strikeHP); strikeHP.connect(strikeG); strikeG.connect(this.master);
                    strike.start(now); strike.stop(now + 0.025);
                    
                    // 2. Metallic ring (inharmonic partials)
                    const partials = [1, 2.4, 4.5, 6.7]; // Inharmonic like real metal
                    const baseFreq = rnd(380, 450);
                    partials.forEach((ratio, i) => {
                        const o = ctx.createOscillator(); o.type = 'sine';
                        const f = baseFreq * ratio;
                        o.frequency.setValueAtTime(f, now);
                        // Slight frequency wobble for realism
                        o.frequency.setValueAtTime(f * 1.002, now + 0.1);
                        const g = ctx.createGain();
                        const vol = 0.18 / (i + 1);
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(vol, now + 0.003);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.25 - i * 0.03);
                        o.connect(g); g.connect(this.master);
                        if(i === 0) this._sendToReverb(g, 0.2);
                        o.start(now); o.stop(now + 0.3);
                    });
                    
                    // 3. Low thud (stone/ore mass)
                    const thud = ctx.createOscillator(); thud.type = 'sine';
                    thud.frequency.setValueAtTime(rnd(100, 130), now);
                    thud.frequency.exponentialRampToValueAtTime(60, now + 0.1);
                    const thudG = ctx.createGain();
                    thudG.gain.setValueAtTime(0, now);
                    thudG.gain.linearRampToValueAtTime(0.2, now + 0.005);
                    thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    thud.connect(thudG); thudG.connect(this.master);
                    thud.start(now); thud.stop(now + 0.15);
                    return;
                }

                if(type === 'stone') {
                    // STONE: Rocks clacking together + grinding
                    
                    // 1. Primary clack (two stones hitting)
                    const clack1 = this._noiseSource(0.03);
                    const clack1BP = ctx.createBiquadFilter(); clack1BP.type = 'bandpass'; clack1BP.frequency.value = rnd(800, 1100); clack1BP.Q.value = 2;
                    const clack1G = ctx.createGain();
                    clack1G.gain.setValueAtTime(0.4, now);
                    clack1G.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                    clack1.connect(clack1BP); clack1BP.connect(clack1G); clack1G.connect(this.master);
                    clack1.start(now); clack1.stop(now + 0.04);
                    
                    // 2. Secondary bounce clack
                    const clack2 = this._noiseSource(0.02);
                    const clack2BP = ctx.createBiquadFilter(); clack2BP.type = 'bandpass'; clack2BP.frequency.value = rnd(700, 900); clack2BP.Q.value = 2.5;
                    const clack2G = ctx.createGain();
                    clack2G.gain.setValueAtTime(0.2, now + 0.06);
                    clack2G.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
                    clack2.connect(clack2BP); clack2BP.connect(clack2G); clack2G.connect(this.master);
                    clack2.start(now + 0.06); clack2.stop(now + 0.1);
                    
                    // 3. Low frequency mass thump
                    const thump = ctx.createOscillator(); thump.type = 'sine';
                    thump.frequency.setValueAtTime(rnd(70, 95), now);
                    thump.frequency.exponentialRampToValueAtTime(45, now + 0.08);
                    const thumpG = ctx.createGain();
                    thumpG.gain.setValueAtTime(0, now);
                    thumpG.gain.linearRampToValueAtTime(0.25, now + 0.005);
                    thumpG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    thump.connect(thumpG); thumpG.connect(this.master);
                    this._sendToReverb(thumpG, 0.06);
                    thump.start(now); thump.stop(now + 0.12);
                    return;
                }

                if(type === 'population') {
                    // POPULATION: Caveman greeting call + response
                    
                    // 1. First voice "OOH" (formant)
                    const voice1 = ctx.createOscillator(); voice1.type = 'sawtooth';
                    voice1.frequency.setValueAtTime(rnd(110, 130), now);
                    voice1.frequency.linearRampToValueAtTime(rnd(140, 160), now + 0.12);
                    const v1Form = ctx.createBiquadFilter(); v1Form.type = 'bandpass'; v1Form.frequency.value = rnd(400, 500); v1Form.Q.value = 4;
                    const v1G = ctx.createGain();
                    v1G.gain.setValueAtTime(0, now);
                    v1G.gain.linearRampToValueAtTime(0.2, now + 0.02);
                    v1G.gain.linearRampToValueAtTime(0.15, now + 0.1);
                    v1G.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    voice1.connect(v1Form); v1Form.connect(v1G); v1G.connect(this.master);
                    this._sendToReverb(v1G, 0.12);
                    voice1.start(now); voice1.stop(now + 0.2);
                    
                    // 2. Response voice "AAH" (different formant)
                    const voice2 = ctx.createOscillator(); voice2.type = 'sawtooth';
                    voice2.frequency.setValueAtTime(rnd(130, 150), now + 0.12);
                    voice2.frequency.linearRampToValueAtTime(rnd(100, 120), now + 0.28);
                    const v2Form = ctx.createBiquadFilter(); v2Form.type = 'bandpass'; v2Form.frequency.value = rnd(700, 900); v2Form.Q.value = 3;
                    const v2G = ctx.createGain();
                    v2G.gain.setValueAtTime(0, now + 0.12);
                    v2G.gain.linearRampToValueAtTime(0.18, now + 0.14);
                    v2G.gain.linearRampToValueAtTime(0.12, now + 0.24);
                    v2G.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    voice2.connect(v2Form); v2Form.connect(v2G); v2G.connect(this.master);
                    this._sendToReverb(v2G, 0.15);
                    voice2.start(now + 0.12); voice2.stop(now + 0.32);
                    return;
                }
            },
            
            // Negative sound for damage/poison - caveman pain grunt
            playHurt() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Sharp inhale gasp (breath noise)
                const gasp = this._noiseSource(0.12);
                const gaspBP = ctx.createBiquadFilter(); gaspBP.type = 'bandpass'; gaspBP.frequency.value = rnd(800, 1200); gaspBP.Q.value = 2;
                const gaspG = ctx.createGain();
                gaspG.gain.setValueAtTime(0, now);
                gaspG.gain.linearRampToValueAtTime(0.25, now + 0.02);
                gaspG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                gasp.connect(gaspBP); gaspBP.connect(gaspG); gaspG.connect(this.master);
                gasp.start(now); gasp.stop(now + 0.12);
                
                // 2. Pain grunt "UGHH" (falling pitch formant)
                const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                grunt.frequency.setValueAtTime(rnd(180, 220), now + 0.05);
                grunt.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.35);
                const gruntForm = ctx.createBiquadFilter(); gruntForm.type = 'bandpass'; gruntForm.frequency.value = rnd(500, 700); gruntForm.Q.value = 3;
                const gruntG = ctx.createGain();
                gruntG.gain.setValueAtTime(0, now + 0.05);
                gruntG.gain.linearRampToValueAtTime(0.3, now + 0.08);
                gruntG.gain.linearRampToValueAtTime(0.2, now + 0.2);
                gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                grunt.connect(gruntForm); gruntForm.connect(gruntG); gruntG.connect(this.master);
                this._sendToReverb(gruntG, 0.1);
                grunt.start(now + 0.05); grunt.stop(now + 0.45);
                
                // 3. Impact thud (body hit)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(70, 90), now);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now);
                thudG.gain.linearRampToValueAtTime(0.25, now + 0.01);
                thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                thud.connect(thudG); thudG.connect(this.master);
                thud.start(now); thud.stop(now + 0.18);
            },
            
            // Lucky find - exciting discovery sound
            playLucky() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Bright discovery shimmer (ascending harmonics)
                [0, 0.06, 0.12].forEach((delay, i) => {
                    const o = ctx.createOscillator(); o.type = 'sine';
                    const f = 600 + i * 280;
                    o.frequency.setValueAtTime(f, now + delay);
                    o.frequency.exponentialRampToValueAtTime(f * 1.1, now + delay + 0.1);
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.18 - i * 0.03, now + delay + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.2);
                    o.connect(g); g.connect(this.master);
                    this._sendToReverb(g, 0.25);
                    o.start(now + delay); o.stop(now + delay + 0.22);
                });
                
                // 2. Excited caveman "OOH!"
                const ooh = ctx.createOscillator(); ooh.type = 'sawtooth';
                ooh.frequency.setValueAtTime(rnd(150, 180), now + 0.1);
                ooh.frequency.linearRampToValueAtTime(rnd(200, 240), now + 0.2);
                const oohForm = ctx.createBiquadFilter(); oohForm.type = 'bandpass'; oohForm.frequency.value = rnd(500, 600); oohForm.Q.value = 4;
                const oohG = ctx.createGain();
                oohG.gain.setValueAtTime(0, now + 0.1);
                oohG.gain.linearRampToValueAtTime(0.15, now + 0.12);
                oohG.gain.exponentialRampToValueAtTime(0.001, now + 0.28);
                ooh.connect(oohForm); oohForm.connect(oohG); oohG.connect(this.master);
                this._sendToReverb(oohG, 0.15);
                ooh.start(now + 0.1); ooh.stop(now + 0.3);
            },
            
            // Tree falling thud - realistic timber crash
            playThud() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                
                const ctx = this.audioCtx;
                const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Wood creaking before fall
                const creak = ctx.createOscillator(); creak.type = 'sawtooth';
                creak.frequency.setValueAtTime(rnd(180, 220), now);
                creak.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.15);
                const creakBP = ctx.createBiquadFilter(); creakBP.type = 'bandpass'; creakBP.frequency.value = rnd(300, 500); creakBP.Q.value = 5;
                const creakG = ctx.createGain();
                creakG.gain.setValueAtTime(0, now);
                creakG.gain.linearRampToValueAtTime(0.2, now + 0.02);
                creakG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                creak.connect(creakBP); creakBP.connect(creakG); creakG.connect(this.master);
                creak.start(now); creak.stop(now + 0.18);
                
                // 2. Heavy ground impact (deep bass thud)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(55, 70), now + 0.1);
                thud.frequency.exponentialRampToValueAtTime(25, now + 0.4);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now + 0.1);
                thudG.gain.linearRampToValueAtTime(0.8, now + 0.12);
                thudG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                thud.connect(thudG); thudG.connect(this.master);
                this._sendToReverb(thudG, 0.15);
                thud.start(now + 0.1); thud.stop(now + 0.55);
                
                // 3. Secondary bounce
                const bounce = ctx.createOscillator(); bounce.type = 'sine';
                bounce.frequency.setValueAtTime(rnd(40, 50), now + 0.25);
                bounce.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                const bounceG = ctx.createGain();
                bounceG.gain.setValueAtTime(0, now + 0.25);
                bounceG.gain.linearRampToValueAtTime(0.4, now + 0.26);
                bounceG.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                bounce.connect(bounceG); bounceG.connect(this.master);
                bounce.start(now + 0.25); bounce.stop(now + 0.5);
                
                // 4. Branch/leaf rustling (noise burst)
                const rustle = this._noiseSource(0.3);
                const rustleBP = ctx.createBiquadFilter(); rustleBP.type = 'bandpass'; rustleBP.frequency.value = rnd(2000, 3500); rustleBP.Q.value = 1;
                const rustleG = ctx.createGain();
                rustleG.gain.setValueAtTime(0, now + 0.08);
                rustleG.gain.linearRampToValueAtTime(0.25, now + 0.12);
                rustleG.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                rustle.connect(rustleBP); rustleBP.connect(rustleG); rustleG.connect(this.master);
                this._sendToReverb(rustleG, 0.1);
                rustle.start(now + 0.08); rustle.stop(now + 0.38);
                
                // 5. Splintering wood
                for(let i = 0; i < 4; i++) {
                    const splinter = this._noiseSource(0.02);
                    const splinterHP = ctx.createBiquadFilter(); splinterHP.type = 'highpass'; splinterHP.frequency.value = rnd(3000, 5000);
                    const splinterG = ctx.createGain();
                    const t = now + 0.1 + i * 0.03;
                    splinterG.gain.setValueAtTime(rnd(0.1, 0.2), t);
                    splinterG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                    splinter.connect(splinterHP); splinterHP.connect(splinterG); splinterG.connect(this.master);
                    splinter.start(t); splinter.stop(t + 0.025);
                }
            }
        };
        
        // Initialize sound on first user interaction
        document.addEventListener('click', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });
        document.addEventListener('keydown', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });

        // --- 4. GAME LOGIC ---
        const Game = {
            tiles:[], blds:[], res:0, food:0, water:100, pop:0, year:0, age:0, housingCap:0, waterCap:0, ordinance:false, ordEnd:0, vm:'NORMAL',
            player: null, // {x, y, health, direction}
            nomadsFound: 0,
            wolves: [], // [{x, y, hits}]
            simcityMode: false,
            pathQueue: [],
            lastMoveTime: 0, // Timer for smooth pathfinding movement
            aiEnabled: false, // AI autoplay toggle
            aiState: 'EXPLORE', // 'EXPLORE', 'GATHER', 'SETTLE', 'BUILD'
            aiTarget: null, // Current AI target position or entity
            aiLastAction: 0, // Timestamp of last AI action
            gameLog: [], // Event log for game history
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GAME STATE & INVENTORY SYSTEM
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // gameState: 'WANDER' (Epoch 0 exploration) or 'CITY' (settled, building)
            //
            // MAIN INVENTORY: Affected by nomad count
            //   - Base capacity: 150
            //   - Bonus: +100 per friendly nomad recruited
            //   - Holds: Food, Wood, Metal, Stone
            //   - Overflow: Partial pickups allowed
            //
            // POCKET INVENTORY: Separate, immutable storage
            //   - Capacity: 1000 max (anti-cheat cap)
            //   - Holds: Metal, Stone only
            //   - Source: Passive walking collection (0.01% every 5 steps)
            //   - Not affected by nomad bonuses
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            gameState: 'WANDER', // 'WANDER' or 'CITY'
            gatheringMultiplier: 1.0, // Resource gathering rate multiplier (scales with initial population)
            inventory: {
                capacity: 150,      // Base 150, +100 per nomad
                food: 0,
                wood: 0,
                metal: 0.0,        // Track as float for 0.2 increments
                stone: 0.0         // Track as float
            },
            // POCKET INVENTORY: Separate storage for passive finds (immutable, max 1000)
            // Triggered every 5 steps with 0.01% chance to find 1-5 metal OR stone
            pocket: {
                metal: 0,
                stone: 0,
                capacity: 1000     // Max 1000 total (anti-cheat cap)
            },
            stepCounter: 0,        // Track steps for passive collection (triggers at 5)
            thirstCounter: 0,      // Steps since last drink (WANDER mode thirst mechanic)
            thirst: 100,           // Current thirst level (0-100, dies at 0)
            siteTraits: [],
            totalFoodCollected: 0, // Track total food gathered for stats        // Set during settlement (e.g., ['Arid', 'Mineral Rich'])
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WORKFORCE TRACKING - How residents are assigned
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            workforce: {
                total: 0,           // Total available workers (from residential pop)
                wellWorkers: 0,     // Assigned to wells
                roadWorkers: 0,     // Assigned to road maintenance  
                comWorkers: 0,      // Assigned to commercial buildings
                gatherers: 0,       // Remaining workers (gather/hunt)
                // Calculated needs
                wellsNeeded: 0,     // Workers needed for all wells
                roadsNeeded: 0,     // Workers needed for all roads
                comNeeded: 0,       // Workers needed for all commercial
                shortage: 0         // Worker shortage (negative = surplus)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEEDS TRACKING - What people require to be happy/productive
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            needs: {
                housing: { have: 0, need: 0, satisfied: 1.0 },
                water: { have: 0, need: 0, satisfied: 1.0 },
                food: { have: 0, need: 0, satisfied: 1.0 },
                jobs: { have: 0, need: 0, satisfied: 1.0 },
                paths: { have: 0, need: 0, satisfied: 1.0 },
                overall: 1.0  // Combined satisfaction (0.0 - 1.0)
            },
            
            // Performance optimizations
            spatialGrid: null, // Fast building lookup grid
            particlePool: [], // Reusable particle objects
            terrainCache: null, // Offscreen canvas for terrain
            dirtyRegions: new Set(), // Track changed areas

            init(seed) {
                Noise.init(seed); this.tiles = []; this.blds = []; this.res=0; this.food=0; this.year=0; this.pop=4; this.age=0;
                PROGRESSION.reset();
                
                // Initialize game state & inventory (see balance values above)
                this.gameState = 'WANDER';
                this.inventory = {
                    capacity: 450,  // 150 base + 300 (3 extra people Ã— 100)
                    food: 250,  // Starting food (50 more than before)
                    wood: 150,  // Starting wood (50 more than before)
                    metal: 0.0,
                    stone: 0.0
                };
                // Initialize pocket inventory (separate, immutable storage for passive finds)
                this.pocket = {
                    metal: 0,
                    stone: 0,
                    capacity: 1000  // Max to prevent exploit
                };
                this.stepCounter = 0;  // Resets every 5 steps (passive collection)
                this.foodStepCounter = 0;  // Resets every 15 steps (food cost)
                this.thirstCounter = 0;   // Steps since last drink
                this.thirst = 100;        // Start fully hydrated
                this.siteTraits = [];
                this.nomadsFound = 0;
                this.animals = [];
                this.simcityMode = false;
                this.pathQueue = [];
                
                // Initialize workforce tracking
                this.workforce = {
                    total: 0,
                    wellWorkers: 0,
                    roadWorkers: 0,
                    comWorkers: 0,
                    gatherers: 0,
                    wellsNeeded: 0,
                    roadsNeeded: 0,
                    comNeeded: 0,
                    shortage: 0
                };
                this.roadTileCount = 0; // Track road tiles for workforce calculation
                
                // NEW: Resource tracking for Epoch 1+
                this.wood = 0;
                this.metal = 0;
                this.stone = 0;
                
                // Initialize performance structures
                this.initSpatialGrid();
                this.initParticlePool();
                this.dirtyRegions.clear();
                
                for (let x=0; x<CFG.W; x++) {
                    this.tiles[x] = [];
                    for (let y=0; y<CFG.H; y++) {
                        // ENHANCED TERRAIN GENERATION WITH OCEANS & LAKES & IMPASSABLE MOUNTAINS
                        let h = Noise.fbm(x*0.02, y*0.02); 
                        h = (h / 1.8); // Normalize 0..1
                        
                        // Ocean noise - creates large ocean bodies
                        let oceanNoise = Noise.fbm(x*0.01, y*0.01);
                        oceanNoise = (oceanNoise / 1.8);
                        
                        // Lake noise - creates inland lakes
                        let lakeNoise = Noise.fbm(x*0.08+500, y*0.08+500);
                        lakeNoise = (lakeNoise / 1.8);
                        
                        // Mountain noise - creates impassable stone peaks
                        let mountainNoise = Noise.fbm(x*0.015+1000, y*0.015+1000);
                        mountainNoise = (mountainNoise / 1.8);
                        
                        // River noise
                        let r = Noise.fbm(x*0.05+100, y*0.05+100); 
                        r = (r/1.8);
                        let isRiver = Math.abs(r - 0.5) < 0.02;

                        let t = 'GRASS'; // Default
                        
                        // IMPASSABLE STONE MOUNTAINS (highest elevation)
                        if (mountainNoise > 0.72 && h > 0.6) {
                            t = 'STONE';
                        }
                        // Generate oceans (large bodies at edges and low areas)
                        else if (oceanNoise < 0.35 && h < 0.3) {
                            t = 'DEEP';
                        } else if (oceanNoise < 0.38 && h < 0.32) {
                            t = 'WATER';
                        }
                        // Generate inland lakes
                        else if (lakeNoise < 0.2 && h > 0.3 && h < 0.7) {
                            t = 'WATER';
                        }
                        // Standard elevation-based terrain
                        else if (h < 0.28) {
                            t = 'SAND'; 
                        } else if (h < 0.6) {
                            t = 'GRASS';
                        } else if (h < 0.75) {
                            t = 'FOREST'; 
                        } else if (h < 0.85) {
                            t = 'ROCK'; 
                        } else {
                            t = 'SNOW';
                        }

                        // Carve Rivers (avoid deep ocean)
                        if (isRiver && t !== 'DEEP' && t !== 'WATER') {
                            t = 'RIVER';
                        }

                        let tree = (t=='GRASS'||t=='FOREST'||t=='SNOW') && Math.random()>0.8;
                        
                        // DEEP TILE SYSTEM: Rich data model
                        let tileData = { 
                            type:t, 
                            road:false, 
                            tree:tree, 
                            pol:0, 
                            bld:null, 
                            explored:false,
                            zone: null,     // 'R', 'C', 'I', or null
                            building: null, // { level, growth, desirability }
                            
                            // Resource deposits (for STONE tiles)
                            resource: null, // { type, amount, metal_yield }
                            
                            // Stone deposits (Mario-style rocks with metal)
                            stoneDeposit: null, // { metal: number }
                            
                            // Entity data (complex objects replace simple booleans)
                            entity: null    // { type, data... }
                        };
                        
                        // STONE tiles contain massive resources
                        if(t === 'STONE') {
                            tileData.resource = {
                                type: 'STONE',
                                amount: 1000000 + Math.floor(Math.random() * 500000), // 1M-1.5M stone
                                metal_yield: 0.2 // Hidden metal bonus when worked
                            };
                        }
                        
                        this.tiles[x][y] = tileData;
                    }
                }
                
                // Spawn player in a safe location
                this.spawnPlayer();
                
                // Spawn stone deposits (Mario-style rocks with metal)
                this.spawnStoneDeposits(CFG.STONE_DEPOSITS.SPAWN_COUNT);
                
                // Spawn berries randomly on land tiles
                this.spawnBerries(CFG.BERRIES.SPAWN_COUNT);
                
                // Spawn wolves (separate from other animals)
                // Wolves removed from game
                
                // Spawn other animals (deer, bison, mammoth)
                this.spawnAnimals(CFG.ANIMALS.SPAWN_COUNT);
                
                // Spawn multiple nomads
                for(let i=0; i<CFG.NOMAD.SPAWN_COUNT; i++) {
                    this.spawnNomad();
                }
                
                // HARDCORE MODE: Randomize dangerous berries and hostile nomads
                for(let x=0; x<CFG.W; x++) {
                    for(let y=0; y<CFG.H; y++) {
                        let t = this.tiles[x][y];
                        
                        // 10% Chance of Poison Berry
                        if(t.berry) {
                            t.isPoison = (Math.random() < 0.1);
                        }
                        
                        // 10% Chance of Hostile Nomad carrying 1-10 food
                        if(t.nomad) {
                            t.isHostile = (Math.random() < 0.1);
                            t.carriedFood = Math.floor(Math.random() * 10) + 1;
                        }
                    }
                }
                
                Controller.updateUI();
            },
            
            // PERFORMANCE: Spatial grid for fast building/zone lookups
            initSpatialGrid() {
                const gridSize = Math.ceil(CFG.W / CFG.PERF.SPATIAL_GRID_SIZE);
                this.spatialGrid = [];
                for(let i = 0; i < gridSize; i++) {
                    this.spatialGrid[i] = [];
                    for(let j = 0; j < gridSize; j++) {
                        this.spatialGrid[i][j] = [];
                    }
                }
            },
            
            updateSpatialGrid(x, y, obj, remove = false) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                if(gx < 0 || gy < 0 || gx >= this.spatialGrid.length || gy >= this.spatialGrid[0].length) return;
                
                if(remove) {
                    const idx = this.spatialGrid[gx][gy].indexOf(obj);
                    if(idx !== -1) this.spatialGrid[gx][gy].splice(idx, 1);
                } else {
                    this.spatialGrid[gx][gy].push(obj);
                }
            },
            
            getNearbyObjects(x, y, radius = 1) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                const gridRadius = Math.ceil(radius / CFG.PERF.SPATIAL_GRID_SIZE);
                const nearby = [];
                
                for(let dx = -gridRadius; dx <= gridRadius; dx++) {
                    for(let dy = -gridRadius; dy <= gridRadius; dy++) {
                        const gxi = gx + dx;
                        const gyi = gy + dy;
                        if(gxi >= 0 && gyi >= 0 && gxi < this.spatialGrid.length && gyi < this.spatialGrid[0].length) {
                            nearby.push(...this.spatialGrid[gxi][gyi]);
                        }
                    }
                }
                return nearby;
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RCI DEMAND CALCULATION (SimCity-style interdependent zones)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // R demand: People want to live where there are jobs (C+I)
            // C demand: Commerce needs customers (R) AND goods to sell (I)
            // I demand: Industry needs workers (R) AND buyers for goods (C)
            // Returns: {r: 0-100, c: 0-100, i: 0-100} - higher = more needed
            calculateRCIDemand() {
                let resCount = this.zoneCount || 0;
                let comCount = this.blds ? this.blds.filter(b => b.t === 'COM').length : 0;
                let indCount = this.blds ? this.blds.filter(b => b.t === 'IND').length : 0;
                let pop = this.pop || 0;
                let housingCap = this.housingCap || 0;
                
                let totalZones = resCount + comCount + indCount;
                
                // Jobs come from Commercial (10 each) and Industrial (15 each)
                let jobCapacity = (comCount * 10) + (indCount * 15);
                let unemployed = Math.max(0, pop - jobCapacity);
                let housingNeed = housingCap > 0 ? (housingCap - pop) / housingCap : 0;
                
                // === RESIDENTIAL DEMAND ===
                // High when: jobs available but housing full, or C+I exist but R doesn't
                let rDemand = 0;
                if(totalZones === 0) {
                    rDemand = 100; // Nothing built - need residential first!
                } else if(housingNeed < 0.2 && jobCapacity > pop * 0.5) {
                    rDemand = 80; // Housing nearly full but jobs available
                } else if(comCount + indCount > resCount * 0.5) {
                    rDemand = 60; // More industry than people to work it
                } else if(pop < housingCap * 0.5) {
                    rDemand = 40; // Room to grow
                } else {
                    rDemand = Math.max(10, 50 - (resCount / Math.max(1, comCount + indCount)) * 10);
                }
                
                // === COMMERCIAL DEMAND ===
                // Needs BOTH residential (customers) AND industrial (goods to sell)
                let customersPerCom = resCount > 0 ? comCount / resCount : 0;
                let goodsSupply = indCount > 0 ? comCount / indCount : 0;
                
                let cDemand = 0;
                if(resCount === 0) {
                    cDemand = 10; // No customers yet
                } else if(comCount === 0 && resCount > 0) {
                    cDemand = 90; // People but no shops!
                } else if(customersPerCom < 0.3 && indCount > 0) {
                    cDemand = 70; // Not enough shops for the people
                } else if(goodsSupply > 2) {
                    cDemand = 20; // Too many shops, not enough goods
                } else {
                    let idealComRatio = 0.5; // 1 commercial per 2 residential
                    let actualRatio = resCount > 0 ? comCount / resCount : 0;
                    cDemand = Math.max(10, Math.min(80, (idealComRatio - actualRatio) * 100 + 50));
                }
                
                // === INDUSTRIAL DEMAND ===
                // Industry provides: jobs for R, goods for C
                let workersPerInd = resCount > 0 ? indCount / resCount : 0;
                let supplyDemand = comCount > 0 ? indCount / comCount : 0;
                
                let iDemand = 0;
                if(resCount === 0) {
                    iDemand = 10; // No workers yet
                } else if(indCount === 0 && resCount > 0) {
                    iDemand = 80; // People but no industry!
                } else if(comCount > indCount * 2) {
                    iDemand = 90; // Commerce needs goods to sell!
                } else if(unemployed > pop * 0.3) {
                    iDemand = 70; // People need jobs
                } else {
                    let idealIndRatio = 0.5; // 1 industrial per 2 residential
                    let actualRatio = resCount > 0 ? indCount / resCount : 0;
                    iDemand = Math.max(10, Math.min(80, (idealIndRatio - actualRatio) * 100 + 50));
                }
                
                // Clamp all demands 0-100
                return {
                    r: Math.max(0, Math.min(100, rDemand)),
                    c: Math.max(0, Math.min(100, cDemand)),
                    i: Math.max(0, Math.min(100, iDemand))
                };
            },
            
            // PERFORMANCE: Object pooling for particles
            initParticlePool() {
                this.particlePool = [];
                for(let i = 0; i < CFG.PERF.PARTICLE_POOL_SIZE; i++) {
                    this.particlePool.push({x: 0, y: 0, l: 0, c: '', active: false});
                }
            },
            
            getPooledParticle(x, y, life, color) {
                for(let p of this.particlePool) {
                    if(!p.active) {
                        p.x = x; p.y = y; p.l = life; p.c = color; p.active = true;
                        return p;
                    }
                }
                // Pool exhausted, create new (rare)
                const p = {x, y, l: life, c: color, active: true};
                this.particlePool.push(p);
                return p;
            },
            
            markDirty(x, y, size = 1) {
                if(!CFG.PERF.DIRTY_RECT_RENDERING) return;
                for(let dx = 0; dx < size; dx++) {
                    for(let dy = 0; dy < size; dy++) {
                        const key = `${x+dx},${y+dy}`;
                        this.dirtyRegions.add(key);
                    }
                }
            },
            
            spawnPlayer() {
                // Find a safe grass tile with at least 60 reachable land tiles
                function floodFillCount(tiles, x, y, maxTiles = 200) {
                    let W = tiles.length, H = tiles[0].length;
                    let seen = Array.from({length: W}, () => Array(H).fill(false));
                    let queue = [[x, y]];
                    let count = 0;
                    while(queue.length > 0 && count < maxTiles) {
                        let [cx, cy] = queue.shift();
                        if(cx < 0 || cy < 0 || cx >= W || cy >= H) continue;
                        if(seen[cx][cy]) continue;
                        let t = tiles[cx][cy].type;
                        if(!(t === 'GRASS' || t === 'FOREST' || t === 'SAND')) continue;
                        seen[cx][cy] = true;
                        count++;
                        queue.push([cx+1, cy]);
                        queue.push([cx-1, cy]);
                        queue.push([cx, cy+1]);
                        queue.push([cx, cy-1]);
                    }
                    return count;
                }
                
                function isValidSpawn(tiles, x, y) {
                    if(x < 0 || x >= tiles.length || y < 0 || y >= tiles[0].length) return false;
                    let t = tiles[x][y].type;
                    // NEVER spawn in water, ocean, river, or stone
                    return t === 'GRASS' || t === 'FOREST' || t === 'SAND' || t === 'SNOW' || t === 'ROCK';
                }
                
                // Phase 1: Try center area (20 tile radius)
                for(let attempt = 0; attempt < 100; attempt++) {
                    let x = Math.floor(CFG.W/2 + (Math.random()-0.5)*40);
                    let y = Math.floor(CFG.H/2 + (Math.random()-0.5)*40);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 60) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(center search)');
                            return;
                        }
                    }
                }
                
                // Phase 2: Try wider area (whole map, but prefer land)
                for(let attempt = 0; attempt < 500; attempt++) {
                    let x = Math.floor(Math.random() * CFG.W);
                    let y = Math.floor(Math.random() * CFG.H);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 30) { // Lower threshold for fallback
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(wide search)');
                            return;
                        }
                    }
                }
                
                // Phase 3: Emergency - scan entire map for ANY valid land tile
                console.warn('âš ï¸ Emergency spawn search...');
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        if(isValidSpawn(this.tiles, x, y)) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(emergency)');
                            return;
                        }
                    }
                }
                
                // Phase 4: Absolute last resort - spawn at center regardless
                console.error('âŒ No valid spawn found! Forcing center spawn.');
                let cx = Math.floor(CFG.W/2);
                let cy = Math.floor(CFG.H/2);
                this.player = {x:cx, y:cy, health:3, direction: 'down'};
                this.exploreArea(cx, cy, 5);
                Controller.cam.x = cx * CFG.TILE;
                Controller.cam.y = cy * CFG.TILE;
            },
            
            spawnBerries(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    if((tile.type=='GRASS' || tile.type=='FOREST') && !tile.entity) {
                        // DEEP DATA: Rich berry entity using CFG values (Master Design v40.0)
                        tile.entity = {
                            type: 'BERRY',
                            amount: CFG.BERRIES.FOOD_VALUE, // Fixed 10 food per spec
                            poison_chance: CFG.BERRIES.POISON_CHANCE,
                            is_poisonous: Math.random() < CFG.BERRIES.POISON_CHANCE // 10% poison
                        };
                        spawned++;
                    }
                }
            },
            
            spawnStoneDeposits(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    // Spawn on grass, forest, or rock terrain
                    if((tile.type=='GRASS' || tile.type=='FOREST' || tile.type=='ROCK') && !tile.entity && !tile.stoneDeposit && !tile.tree) {
                        // Random metal value between 1M and 10M
                        let metalValue = CFG.STONE_DEPOSITS.MIN_METAL + 
                            Math.floor(Math.random() * (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL));
                        
                        tile.stoneDeposit = {
                            metal: metalValue
                        };
                        spawned++;
                    }
                }
            },
            
            spawnNomad() {
                for(let attempt=0; attempt<200; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if((tile.type=='GRASS' || tile.type=='FOREST') && dist > 15 && !tile.entity) {
                        // DEEP DATA: Rich nomad entity using CFG values (Master Design v40.0)
                        let isHostile = Math.random() < CFG.NOMAD.HOSTILE_CHANCE; // 16% hostile
                        let hostileDamageRange = CFG.NOMAD.HOSTILE_DAMAGE;
                        let lootRanges = CFG.NOMAD.LOOT_RANGES;
                        
                        tile.entity = {
                            type: 'NOMAD',
                            pop: CFG.NOMAD.FRIENDLY_POP_BONUS, // +1 Pop
                            loot: {
                                food: lootRanges.FOOD[0] + Math.floor(Math.random() * (lootRanges.FOOD[1] - lootRanges.FOOD[0] + 1)), // 5-30
                                wood: lootRanges.WOOD[0] + Math.floor(Math.random() * (lootRanges.WOOD[1] - lootRanges.WOOD[0] + 1)), // 5-30
                                metal: lootRanges.METAL[0] + Math.floor(Math.random() * (lootRanges.METAL[1] - lootRanges.METAL[0] + 1)), // 0-10
                                stone: lootRanges.STONE[0] + Math.floor(Math.random() * (lootRanges.STONE[1] - lootRanges.STONE[0] + 1))  // 0-5
                            },
                            hostile_chance: CFG.NOMAD.HOSTILE_CHANCE,
                            is_hostile: isHostile,
                            damage: isHostile ? (hostileDamageRange[0] + Math.floor(Math.random() * (hostileDamageRange[1] - hostileDamageRange[0] + 1))) : 0 // 1-3 if hostile
                        };
                        return;
                    }
                }
            },
            
            // Spawn wolves as separate entity type (Master Design v40.0)
            // Wolves always cost -1 Pop to kill, always give +50 Food
            // spawnWolves removed - wolves no longer in game
            
            spawnAnimals(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*20 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let t = this.tiles[x][y].type;
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if((t=='GRASS' || t=='FOREST') && dist > 10) {
                        // Use CFG.ANIMALS.TYPES for spawn rates (Master Design v40.0)
                        let rand = Math.random();
                        let cumulative = 0;
                        let animalType = 'DEER'; // Default
                        
                        for(let type of CFG.ANIMALS.TYPES) {
                            cumulative += type.spawnRate;
                            if(rand < cumulative) {
                                animalType = type.name;
                                break;
                            }
                        }
                        
                        this.animals.push({x:x, y:y, hits:0, type: animalType});
                        spawned++;
                    }
                }
            },
            
            exploreArea(cx, cy, radius) {
                for(let x=cx-radius; x<=cx+radius; x++) {
                    for(let y=cy-radius; y<=cy+radius; y++) {
                        if(x>=0 && x<CFG.W && y>=0 && y<CFG.H) {
                            let dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
                            if(dist <= radius) {
                                this.tiles[x][y].explored = true;
                            }
                        }
                    }
                }
            },
            
            getWaterProximity(x, y, size) {
                // Calculate distance to nearest water for a building
                let minDist = Infinity;
                for(let bx=x; bx<x+size; bx++) {
                    for(let by=y; by<y+size; by++) {
                        // Check surrounding area
                        for(let cx=bx-CFG.WATER_PROXIMITY.MAX_DISTANCE; cx<=bx+CFG.WATER_PROXIMITY.MAX_DISTANCE; cx++) {
                            for(let cy=by-CFG.WATER_PROXIMITY.MAX_DISTANCE; cy<=by+CFG.WATER_PROXIMITY.MAX_DISTANCE; cy++) {
                                if(cx>=0 && cx<CFG.W && cy>=0 && cy<CFG.H) {
                                    let tile = this.tiles[cx][cy];
                                    if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                        let dist = Math.sqrt((cx-bx)**2 + (cy-by)**2);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                            }
                        }
                    }
                }
                // Convert distance to efficiency (0=far, 1=adjacent)
                if(minDist === 0) return 1.0;
                if(minDist > CFG.WATER_PROXIMITY.MAX_DISTANCE) return CFG.WATER_PROXIMITY.MIN_EFFICIENCY;
                return Math.max(CFG.WATER_PROXIMITY.MIN_EFFICIENCY, 1.0 - (minDist / CFG.WATER_PROXIMITY.MAX_DISTANCE) * (1.0 - CFG.WATER_PROXIMITY.MIN_EFFICIENCY));
            },
            
            getForestProximity(x, y, size) {
                // Calculate if building is near forest
                for(let bx=x-1; bx<=x+size; bx++) {
                    for(let by=y-1; by<=y+size; by++) {
                        if(bx>=0 && bx<CFG.W && by>=0 && by<CFG.H) {
                            if(this.tiles[bx][by].type === 'FOREST') return true;
                        }
                    }
                }
                return false;
            },
            
            movePlayer(dx, dy) {
                if(!this.player) return false;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return false;
                }
                
                // FOOD COST CHECK: Block movement if no food in WANDER mode
                if(this.gameState === 'WANDER' && this.inventory.food <= 0) {
                    Controller.toast("ğŸ– No food! Your tribe cannot travel without food.");
                    return false;
                }
                
                let newX = this.player.x + dx;
                let newY = this.player.y + dy;
                
                if(newX < 0 || newX >= CFG.W || newY < 0 || newY >= CFG.H) return false;
                
                let tile = this.tiles[newX][newY];
                
                // === AI WATCH MODE: Record player movement context ===
                // This helps AI learn what players move TOWARD (resources, nomads, water)
                if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching && this.gameState === 'WANDER') {
                    // Check what's at the destination to understand player intent
                    let destEntity = tile.entity ? tile.entity.type : null;
                    let destType = tile.type;
                    let hasTree = tile.tree;
                    
                    // Record movement toward specific targets
                    if(destEntity === 'NOMAD') {
                        QLearningAI.recordPlayerAction('MOVE_TO_NOMAD');
                    } else if(destEntity === 'BERRY') {
                        QLearningAI.recordPlayerAction('MOVE_TO_BERRY');
                    } else if(destType === 'WATER' || destType === 'RIVER') {
                        QLearningAI.recordPlayerAction('MOVE_TO_WATER');
                    } else if(hasTree) {
                        QLearningAI.recordPlayerAction('MOVE_TO_TREE');
                    } else {
                        // General exploration/wander
                        QLearningAI.recordPlayerAction('WANDER');
                    }
                }
                
                // Block water tiles
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') return false;
                
                // Block stone deposits
                if(tile.stoneDeposit) {
                    Controller.toast("â›°ï¸ Stone deposit blocking path.");
                    return false;
                }
                
                // Block STONE terrain in WANDER mode
                if(tile.type === 'STONE' && this.gameState === 'WANDER') {
                    Controller.toast("â›°ï¸ Dense rock formation. Impassable.");
                    return false;
                }
                
                // Update direction based on movement
                if(dx > 0) this.player.direction = 'right';
                else if(dx < 0) this.player.direction = 'left';
                else if(dy > 0) this.player.direction = 'down';
                else if(dy < 0) this.player.direction = 'up';
                
                // Move player
                this.player.x = newX;
                this.player.y = newY;
                
                // FOOD COST: 1 food per 15 steps per population (in WANDER mode only)
                if(this.gameState === 'WANDER') {
                    this.foodStepCounter++;
                    if(this.foodStepCounter >= CFG.MOVEMENT.STEPS_PER_FOOD) {
                        this.foodStepCounter = 0;
                        let popCount = Math.max(1, this.pop);
                        let foodCost = popCount * CFG.MOVEMENT.FOOD_PER_PERSON;
                        this.inventory.food = Math.max(0, this.inventory.food - foodCost);
                        // Always show food cost message
                        Controller.toast(`ğŸ– -${foodCost} food (${popCount} people traveling) | Remaining: ${Math.floor(this.inventory.food)}`);
                        
                        // Check for starvation game over
                        if(this.inventory.food <= 0) {
                            Controller.showGameOver('LEVEL1');
                            return false;
                        }
                    }
                }
                
                // THIRST MECHANIC (WANDER mode only): Must drink water every 100 steps
                if(this.gameState === 'WANDER') {
                    this.thirstCounter++;
                    // Thirst depletes by 1 every step
                    this.thirst = Math.max(0, 100 - this.thirstCounter);
                    
                    // Check if standing on drinkable water (RIVER or WATER, NOT ocean/deep)
                    let currentTile = this.tiles[newX][newY];
                    let isDrinkableWater = currentTile && (currentTile.type === 'RIVER' || currentTile.type === 'WATER');
                    
                    if(isDrinkableWater) {
                        this.thirstCounter = 0;
                        this.thirst = 100;
                        Controller.toast(`ğŸ’§ Drank from water source! Thirst replenished.`);
                    }
                    
                    // Warning at 30% thirst
                    if(this.thirst === 30) {
                        Controller.toast(`âš ï¸ Getting thirsty! Find a river or lake soon!`);
                    }
                    // Warning at 15% thirst
                    if(this.thirst === 15) {
                        Controller.toast(`ğŸ”´ DEHYDRATED! Find water NOW or your tribe will die!`);
                    }
                    
                    // Death at 0 thirst
                    if(this.thirst <= 0) {
                        Controller.showGameOver('THIRST');
                        return false;
                    }
                }
                
                // PASSIVE COLLECTION: Every 5 steps, 0.01% chance to find 1-5 metal or stone
                this.stepCounter++;
                if(this.stepCounter >= 5) {
                    this.stepCounter = 0;
                    if(Math.random() < 0.0001) { // 0.01% chance
                        let pocketTotal = this.pocket.metal + this.pocket.stone;
                        if(pocketTotal < this.pocket.capacity) {
                            let amount = 1 + Math.floor(Math.random() * 5); // 1-5
                            let spaceLeft = this.pocket.capacity - pocketTotal;
                            amount = Math.min(amount, spaceLeft);
                            
                            if(Math.random() < 0.5) {
                                this.pocket.metal += amount;
                                Controller.toast(`âœ¨ Found ${amount} metal nugget${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            } else {
                                this.pocket.stone += amount;
                                Controller.toast(`ğŸ’ Found ${amount} stone${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            }
                        }
                    }
                }
                
                // Explore around player
                this.exploreArea(newX, newY, 3);
                
                // Animals are now handled by click handler (instant kill)
                // Walking onto animal square does nothing, UNLESS it's a herd
                
                // Check for hostile herds (groups of touching animals)
                if(this.gameState === 'WANDER' && tile.animal) {
                    let adjacentAnimals = 0;
                    for(let dx = -1; dx <= 1; dx++) {
                        for(let dy = -1; dy <= 1; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            let checkX = newX + dx;
                            let checkY = newY + dy;
                            if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                                let adjacentTile = this.tiles[checkX][checkY];
                                if(adjacentTile && adjacentTile.animal) {
                                    adjacentAnimals++;
                                }
                            }
                        }
                    }
                    
                    // If 2+ adjacent animals, it's a hostile herd
                    let isHerd = adjacentAnimals >= 2;
                    
                    if(isHerd) {
                        // Hostile herd encounter - lose population
                        let popLoss = Math.min(2, Math.floor(this.pop * 0.1)); // Lose up to 2 people or 10% of pop
                        this.pop = Math.max(1, this.pop - popLoss); // Keep at least 1 person
                        SoundFX.playHurt();
                        let animalEmoji = tile.animal.emoji || 'ğŸ¦Œ';
                        Controller.toast(`ğŸ’€ Hostile ${animalEmoji} Herd! Lost ${popLoss} wanderers. Population: ${this.pop}`);
                        
                        // Don't remove the animal - herds are dangerous to approach
                        this.aiTarget = null;
                        this.checkProgression();
                        return; // Don't continue with movement
                    }
                }
                
                // === FOREST TILE: Passive +1 Wood (Master Design v40.0) ===
                // Stepping on FOREST terrain gives +1 wood (scavenging), doesn't destroy forest
                if(this.gameState === 'WANDER' && tile.type === 'FOREST') {
                    let woodAmount = CFG.FOREST.WOOD_PER_STEP; // +1 wood per step
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        SoundFX.playCollect('wood');
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        // Don't destroy forest - passive collection
                        Controller.toast(`ğŸŒ² Scavenged +${woodAmount} wood (${Math.floor(this.inventory.wood)}W total)`);
                    } else if(spaceAvailable === 0) {
                        Controller.toast(`âš ï¸ Inventory full! Cannot collect wood`);
                    }
                }
                
                // Individual trees can be chopped for more wood (2-5)
                if(this.gameState === 'WANDER' && tile.tree) {
                    let woodAmount = 2 + Math.floor(Math.random() * 4); // 2-5 wood per tree
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        tile.tree = false; // Remove individual tree
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ğŸªµ Chopped tree! +${woodAmount} wood (${this.inventory.wood} total)`);
                    } else if(spaceAvailable > 0) {
                        this.inventory.wood += spaceAvailable;
                        tile.tree = false;
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ğŸªµ Chopped tree! +${spaceAvailable}/${woodAmount} wood (Inventory Full!)`);
                    } else {
                        Controller.toast(`âš ï¸ Inventory full! Cannot chop tree`);
                    }
                }
                
                // === OPEN GROUND: Rare Find (Master Design v40.0) ===
                // 0.01% chance per step on GRASS/SAND to find +1 Metal or +1 Stone
                if(this.gameState === 'WANDER' && (tile.type === 'GRASS' || tile.type === 'SAND')) {
                    if(Math.random() < CFG.OPEN_GROUND.RARE_FIND_CHANCE) {
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        if(spaceAvailable > 0) {
                            // 50% metal, 50% stone
                            if(Math.random() < CFG.OPEN_GROUND.METAL_CHANCE) {
                                this.inventory.metal += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`âœ¨ Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Metal! (${this.inventory.metal}M total)`);
                            } else {
                                this.inventory.stone += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`âœ¨ Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Stone! (${this.inventory.stone}S total)`);
                            }
                        }
                    }
                }
                
                // --- HARDCORE INTERACTION LOGIC (DEEP ENTITY SYSTEM) ---
                
                // Check for entity interactions
                console.log(`[Entity Debug] tile.entity:`, tile.entity, `at (${newX}, ${newY})`);
                if(tile.entity) {
                    let entity = tile.entity;
                    console.log(`[Entity Debug] Found entity type: ${entity.type}`);
                    
                    // BERRY ENTITY
                    if(entity.type === 'BERRY') {
                        if(entity.is_poisonous) {
                            // Trigger bash for poison berry
                            if(this.player) this.player.bashTime = performance.now();
                            this.pop = Math.max(0, this.pop - 1);
                            SoundFX.playHurt();
                            Controller.toast(`â˜ ï¸ POISON BERRY! -1 Population - YUCK!`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                            tile.entity = null; // Remove poison berry after eating
                        } else {
                            let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - totalInventory;
                            console.log(`[Berry Debug] totalInventory: ${totalInventory}, spaceAvailable: ${spaceAvailable}, berryAmount: ${entity.amount}`);
                            // Patch: Always collect as much food as possible if space allows
                            let foodToCollect = Math.min(entity.amount, spaceAvailable);
                            if(foodToCollect > 0) {
                                // Trigger bash animation AFTER confirming collection
                                if(this.player) this.player.bashTime = performance.now();
                                this.inventory.food += foodToCollect;
                                this.totalFoodCollected += foodToCollect;
                                SoundFX.playCollect('food');
                                if(foodToCollect === entity.amount) {
                                    Controller.toast(`ğŸ« Found Berry! +${entity.amount} food (${Math.floor(this.inventory.food)}/${this.inventory.capacity}) - YUM!`);
                                } else {
                                    Controller.toast(`ğŸ« Found Berry! +${foodToCollect}/${entity.amount} food (Inventory Full!) - YUM!`);
                                }
                                tile.entity = null; // Remove entity
                            } else {
                                // Don't bash if inventory is full
                                Controller.toast(`âš ï¸ Inventory full! (${Math.floor(totalInventory)}/${this.inventory.capacity}) - Cannot collect berry`);
                                return; // Don't remove berry if inventory completely full
                            }
                        }
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                    
                    // NOMAD ENTITY
                    else if(entity.type === 'NOMAD') {
                        if(entity.is_hostile) {
                            // Trigger bash for hostile encounter
                            if(this.player) this.player.bashTime = performance.now();
                            let damage = entity.damage;
                            this.pop = Math.max(0, this.pop - damage);
                            SoundFX.playHurt();
                            Controller.toast(`âš”ï¸ HOSTILE NOMAD! Ambush! -${damage} Population`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                        } else {
                            // Trigger bash for friendly greeting
                            if(this.player) this.player.bashTime = performance.now();
                            PROGRESSION.nomadsFound++;
                            this.nomadsFound++;
                            this.pop += entity.pop;
                            SoundFX.playCollect('population');
                            
                            // Update building populations when nomads join
                            if(typeof assignPopulationToResidential === 'function') {
                                assignPopulationToResidential(this);
                            }
                            
                            // Calculate total loot
                            let totalLoot = entity.loot.food + entity.loot.wood + entity.loot.metal + (entity.loot.stone || 0);
                            let currentInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - currentInventory;
                            
                            // Transfer what fits
                            let foodAdded = 0, woodAdded = 0, metalAdded = 0, stoneAdded = 0;
                            
                            if(spaceAvailable >= totalLoot) {
                                // All loot fits
                                this.inventory.food += entity.loot.food;
                                this.totalFoodCollected += entity.loot.food;
                                this.inventory.wood += entity.loot.wood;
                                this.inventory.metal += entity.loot.metal;
                                this.inventory.stone += entity.loot.stone || 0;
                                foodAdded = entity.loot.food;
                                woodAdded = entity.loot.wood;
                                metalAdded = entity.loot.metal;
                                stoneAdded = entity.loot.stone || 0;
                            } else if(spaceAvailable > 0) {
                                // Partial loot - prioritize food > wood > metal > stone
                                let remaining = spaceAvailable;
                                foodAdded = Math.min(entity.loot.food, remaining);
                                this.inventory.food += foodAdded;
                                this.totalFoodCollected += foodAdded;
                                remaining -= foodAdded;
                                
                                if(remaining > 0) {
                                    woodAdded = Math.min(entity.loot.wood, remaining);
                                    this.inventory.wood += woodAdded;
                                    remaining -= woodAdded;
                                }
                                if(remaining > 0) {
                                    metalAdded = Math.min(entity.loot.metal, remaining);
                                    this.inventory.metal += metalAdded;
                                    remaining -= metalAdded;
                                }
                                if(remaining > 0) {
                                    stoneAdded = Math.min(entity.loot.stone || 0, remaining);
                                    this.inventory.stone += stoneAdded;
                                }
                            }
                            
                            // Increase capacity (+100 per nomad)
                            this.inventory.capacity += 100;
                            
                            // Nomad shares local knowledge
                            this.exploreArea(newX, newY, 15);
                            
                            let lootMsg = spaceAvailable >= totalLoot 
                                ? `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S` 
                                : `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S (Inventory was full!)`;
                            Controller.toast(`ğŸ‘¤ OOGA BOOGA! Nomad joined! +${entity.pop} Pop, ${lootMsg}, Capacity: ${this.inventory.capacity}`);
                        }
                        tile.entity = null; // Remove entity
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                }
                
                // Camera follows player smoothly
                Controller.cam.x = this.player.x * CFG.TILE;
                Controller.cam.y = this.player.y * CFG.TILE;
                
                Controller.updateUI();
                
                return true; // Successfully moved
            },
            
            movePlayerToTile(targetX, targetY) {
                if(!this.player) return;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return;
                }

                if(targetX < 0 || targetX >= CFG.W || targetY < 0 || targetY >= CFG.H) return;
                
                // Check if clicking on an animal to attack it (works from adjacent or same tile)
                let animalIndex = this.animals.findIndex(a => a.x === targetX && a.y === targetY);
                if(animalIndex !== -1) {
                    // Animal attack is now handled by click (instant kill)
                    // Just pathfind to the location normally
                }
                
                let tile = this.tiles[targetX][targetY];
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) return;
                
                // Generate path to target
                this.pathQueue = this.findPath(this.player.x, this.player.y, targetX, targetY);
            },
            
            findPath(startX, startY, endX, endY) {
                // Simple A* pathfinding
                let openSet = [{x: startX, y: startY, g: 0, h: Math.abs(endX - startX) + Math.abs(endY - startY), parent: null}];
                let closedSet = new Set();
                
                while(openSet.length > 0) {
                    // Find node with lowest f score
                    openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                    let current = openSet.shift();
                    
                    if(current.x === endX && current.y === endY) {
                        // Reconstruct path
                        let path = [];
                        while(current.parent) {
                            path.unshift({x: current.x, y: current.y});
                            current = current.parent;
                        }
                        return path;
                    }
                    
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check neighbors
                    let directions = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                    for(let dir of directions) {
                        let nx = current.x + dir.x;
                        let ny = current.y + dir.y;
                        
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        if(closedSet.has(`${nx},${ny}`)) continue;
                        
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) continue;
                        
                        let g = current.g + 1;
                        let h = Math.abs(endX - nx) + Math.abs(endY - ny);
                        
                        let existing = openSet.find(n => n.x === nx && n.y === ny);
                        if(!existing) {
                            openSet.push({x: nx, y: ny, g: g, h: h, parent: current});
                        } else if(g < existing.g) {
                            existing.g = g;
                            existing.parent = current;
                        }
                    }
                    
                    // Limit search to prevent lag
                    if(closedSet.size > 1000) break;
                }
                
                // No path found, return empty
                return [];
            },
            
            processPath() {
                // Only move every 150ms for smooth visible walking animation
                let now = performance.now();
                if(now - this.lastMoveTime < 150) {
                    return;
                }
                
                if(this.pathQueue.length > 0) {
                    let next = this.pathQueue[0];
                    let dx = next.x - this.player.x;
                    let dy = next.y - this.player.y;
                    
                    if(Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                        let moved = this.movePlayer(dx, dy);
                        if(moved) {
                            this.pathQueue.shift();
                            this.lastMoveTime = now;
                        } else {
                            // Can't move (blocked), clear path and let AI recalculate
                            console.warn('AI: Path blocked, clearing queue');
                            this.pathQueue = [];
                            if(this.aiTarget) this.aiTarget = null;
                        }
                    } else {
                        // Path is invalid, clear it
                        console.warn('AI: Invalid path step, clearing queue');
                        this.pathQueue = [];
                    }
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AI AUTOPLAY SYSTEM - Delegated to External Module
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AI logic has been moved to js/ai.js for better organization
            // and easier debugging. This wrapper maintains compatibility.
            
            aiUpdate() {
                // Delegate to external AI module with safety check
                if(typeof AI !== 'undefined' && AI && typeof AI.update === 'function') {
                    AI.update(this);
                }
            },
            
            // Helper function for AI building attempts
            tryBuild(type, searchRadius) {
                for(let attempt = 0; attempt < 15; attempt++) {
                    let buildX = Math.floor(this.player.x + (Math.random() - 0.5) * searchRadius * 2);
                    let buildY = Math.floor(this.player.y + (Math.random() - 0.5) * searchRadius * 2);
                    buildX = Math.max(0, Math.min(CFG.W - 1, buildX));
                    buildY = Math.max(0, Math.min(CFG.H - 1, buildY));
                    
                    if(this.isValid(buildX, buildY, type)) {
                        this.build(buildX, buildY, type);
                        return true;
                    }
                }
                return false;
            },
            
            // === BUILDING EVOLUTION SYSTEM ===
            // Level 0 buildings evolve based on location desirability
            // Run every 60 frames (~1 second) to update building states
            updateBuildingEvolution() {
                try {
                    if(!this.evolutionFrameCounter) this.evolutionFrameCounter = 0;
                    this.evolutionFrameCounter++;
                    
                    // Only update every 300 frames (5 seconds at 60fps) - OPTIMIZED for performance
                    if(this.evolutionFrameCounter < 300) return;
                    this.evolutionFrameCounter = 0;
                    
                    // Don't run in nomad mode
                    if(this.gameState !== 'CITY') return;
                    
                    // Limit checks to avoid performance issues - REDUCED for better FPS
                    let checksThisFrame = 0;
                    const MAX_CHECKS_PER_FRAME = 20;
                    
                    // Iterate through ALL residential buildings (ALL LEVELS 0-4)
                    for(let x = 0; x < CFG.W && checksThisFrame < MAX_CHECKS_PER_FRAME; x++) {
                        for(let y = 0; y < CFG.H && checksThisFrame < MAX_CHECKS_PER_FRAME; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                checksThisFrame++;
                                
                                let bld = tile.building;
                                
                                // Calculate local desirability for this tile (pass building level)
                                let desirability = this.calculateTileDesirability(x, y, bld.level);
                                
                                // Store desirability for future reference
                                bld.desirability = desirability;
                                
                                // Determine variant based on building level
                                let oldVariant = bld.variant || 0;
                                let newVariant = 0;
                                
                                if(bld.level === 1) {
                                    // Level 1: Abandoned (0 pop) â†’ Open Pit (1-7) â†’ Mud Pit (8-14) â†’ Straw Pit (15-20)
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Open Pit
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Mud Pit
                                    } else {
                                        newVariant = 3; // Straw Pit
                                    }
                                    
                                    // Level 1 population scaling (0-20 people)
                                    let newPopulation;
                                    if(newVariant === 0) {
                                        // Abandoned: 0 people
                                        newPopulation = 0;
                                    } else if(newVariant === 1) {
                                        // Open Pit: 1-7 people
                                        newPopulation = 1 + Math.floor((desirability - 0.1) / 0.3 * 6);
                                    } else if(newVariant === 2) {
                                        // Mud Pit: 8-14 people
                                        newPopulation = 8 + Math.floor((desirability - 0.4) / 0.3 * 6);
                                    } else {
                                        // Straw Pit: 15-20 people
                                        newPopulation = 15 + Math.floor((desirability - 0.7) / 0.3 * 5);
                                    }
                                    bld.population = Math.max(0, Math.min(20, newPopulation));
                                } else {
                                    // Levels 2-4: Use same 4-variant system
                                    // Variant 0: Abandoned (desirability < 0.1)
                                    // Variant 1: Low (desirability 0.1-0.4) - Base income
                                    // Variant 2: Medium (desirability 0.4-0.7) - Full bonus
                                    // Variant 3: High (desirability >= 0.7) - Enhanced bonus
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned state
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Low state
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Medium state
                                    } else {
                                        newVariant = 3; // High state
                                    }
                                }
                                
                                // Update variant and notify if changed
                                if(newVariant !== oldVariant) {
                                    tile.building.variant = newVariant;
                                    
                                    // Get variant name from BUILDING_LEVELS config
                                    let levelConfig = CFG.BUILDING_LEVELS[tile.building.level] || CFG.BUILDING_LEVELS[1];
                                    let variantName = 'Building';
                                    if(levelConfig.variants && levelConfig.variants[newVariant]) {
                                        variantName = levelConfig.variants[newVariant].name;
                                    }
                                    
                                    let icons = ['ğŸ•³ï¸', 'ğŸšï¸', 'ğŸ ', 'ğŸ˜ï¸'];
                                    
                                    // Show notification for upgrades only (not downgrades to avoid spam)
                                    if(newVariant > oldVariant) {
                                        Controller.toast(`${icons[newVariant]} Upgraded to ${variantName}!`);
                                    }
                                    
                                    // Mark tile for redraw
                                    this.markDirty(x, y, 1);
                                }
                                
                                // Store desirability for future reference
                                tile.building.desirability = desirability;
                            }
                        }
                    }
                } catch(err) {
                    console.error('Evolution update error:', err);
                }
            },
            
            // Calculate desirability for a specific tile - LEVEL 1 SPECIAL CALCULATION
            // Level 1 uses different factors: water, dirt roads, commercial, industrial, berries
            calculateLevel1Desirability(x, y) {
                let score = 0.25; // Lower baseline for Level 1 (minimal bonuses philosophy)
                
                // Water proximity (+0.15 bonus)
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        let dist = Math.abs(dx) + Math.abs(dy);
                        if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                            waterDist = Math.min(waterDist, dist);
                            if(dist === 0) waterFound = true;
                        }
                    }
                }
                if(waterDist <= 3) score += 0.15;
                else if(waterDist <= 5) score += 0.08;
                
                // Dirt road adjacent (+0.10 bonus, but ONLY if roads are maintained!)
                // Roads need workers: 1 worker per 5 road tiles
                // If workforce shortage, road bonus is reduced proportionally
                let hasAdjacentRoad = false;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        // Check for road using tile.road property (not zone)
                        if(this.tiles[nx][ny].road) {
                            hasAdjacentRoad = true;
                            break;
                        }
                    }
                    if(hasAdjacentRoad) break;
                }
                if(hasAdjacentRoad) {
                    // Calculate road maintenance effectiveness
                    let roadMaintenance = 1.0; // 100% if fully staffed
                    if(this.workforce && this.workforce.roadsNeeded > 0) {
                        roadMaintenance = Math.min(1.0, this.workforce.roadWorkers / this.workforce.roadsNeeded);
                    }
                    score += 0.10 * roadMaintenance; // Road bonus scaled by maintenance
                }
                
                // Commercial nearby (+0.08 bonus within 8 tiles)
                let commercialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'COMMERCIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        commercialNearby = true;
                        break;
                    }
                }
                if(commercialNearby) score += 0.08;
                
                // Industrial proximity (+0.15 bonus within 8 tiles - primitive people want to live near butcher/hunter)
                let industrialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'INDUSTRIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        industrialNearby = true;
                        break;
                    }
                }
                if(industrialNearby) score += 0.15;
                
                // Berry tiles nearby (+0.20 bonus if any berries within 3 tiles)within 3 tiles)
                let berryCount = 0;
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'BERRY') berryCount++;
                    }
                }
                if(berryCount >= 1) score += 0.20;
                
                return Math.max(0, Math.min(1, score));
            },
            
            // Calculate desirability for a specific tile
            // Factors: Water proximity, Wells, Roads, Commercial, Industrial distance, Population density
            calculateTileDesirability(x, y, buildingLevel) {
                // Use Level 1 special calculation
                if(buildingLevel === 1) {
                    return this.calculateLevel1Desirability(x, y);
                }
                
                let score = 0.35; // BUFFED base score (was 0.3) to help reach higher tiers
                
                // === WATER PROXIMITY (Critical: +0.30 BUFFED) ===
                // OPTIMIZED: Reduced search area and added early exit
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            let tile = this.tiles[nx][ny];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                waterDist = Math.min(waterDist, dist);
                                if(dist === 0) waterFound = true; // Early exit if adjacent
                            }
                        }
                    }
                }
                // Closer water = better. 1 tile away = +0.30 (was +0.25), 5 tiles = +0.06
                if(waterDist <= 5) {
                    score += 0.30 * (1 - (waterDist / 6));
                }
                
                // === WELL PROXIMITY (Important: +0.25 BUFFED) ===
                // OPTIMIZED: Only check wells within reasonable range
                let nearestWell = 999;
                for(let well of this.blds) {
                    if(well.t !== 'WELL') continue;
                    let dist = Math.abs(x - well.x) + Math.abs(y - well.y);
                    if(dist > 8) continue; // Skip distant wells
                    nearestWell = Math.min(nearestWell, dist);
                    if(dist === 0) break; // Early exit if on well
                }
                // Well within 8 tiles is valuable: +0.25 (was +0.20)
                if(nearestWell <= 8) {
                    score += 0.25 * (1 - (nearestWell / 9));
                }
                
                // === ROAD CONNECTIVITY (Infrastructure: +0.20 BUFFED) ===
                // OPTIMIZED: Smaller search area with early exit
                let roadDist = 999;
                let roadFound = false;
                for(let dx = -2; dx <= 2 && !roadFound; dx++) {
                    for(let dy = -2; dy <= 2 && !roadFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].road) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                roadDist = Math.min(roadDist, dist);
                                if(dist === 0) roadFound = true;
                            }
                        }
                    }
                }
                if(roadDist <= 2) {
                    score += 0.20 * (1 - (roadDist / 3)); // Was +0.15
                }
                
                // === COMMERCIAL PROXIMITY (Convenience: +0.12) ===
                // OPTIMIZED: Skip if no commercial buildings exist
                let nearestCom = 999;
                for(let com of this.blds) {
                    if(com.t !== 'COM') continue;
                    let dist = Math.abs(x - com.x) + Math.abs(y - com.y);
                    if(dist > 10) continue; // Skip distant ones
                    nearestCom = Math.min(nearestCom, dist);
                    if(dist === 0) break;
                }
                // Commercial within 10 tiles is good
                if(nearestCom <= 10) {
                    score += 0.12 * (1 - (nearestCom / 11));
                }
                
                // === INDUSTRIAL DISTANCE (Pollution penalty: up to -0.20) ===
                // OPTIMIZED: Skip if no industrial buildings exist
                let nearestInd = 999;
                for(let ind of this.blds) {
                    if(ind.t !== 'IND') continue;
                    let dist = Math.abs(x - ind.x) + Math.abs(y - ind.y);
                    if(dist >= 15) continue; // Skip if too far to matter
                    nearestInd = Math.min(nearestInd, dist);
                }
                // Industrial within 3 tiles = severe penalty, 15+ tiles = no penalty
                if(nearestInd < 15) {
                    let penalty = nearestInd < 3 ? -0.20 : -0.20 * (1 - ((nearestInd - 3) / 12));
                    score += penalty;
                }
                
                // === POPULATION DENSITY (Clustering: +0.08) ===
                // OPTIMIZED: Smaller search radius (3 -> 2) and count limit
                let neighbors = 0;
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].zone === 'R') {
                                neighbors++;
                                if(neighbors > 10) break; // Early exit if overcrowded
                            }
                        }
                    }
                    if(neighbors > 10) break;
                }
                // Sweet spot: 2-6 neighbors. Too few = isolated, too many = crowded
                if(neighbors >= 2 && neighbors <= 6) {
                    score += 0.08;
                } else if(neighbors > 6) {
                    // Overcrowding penalty
                    score -= Math.min(0.10, (neighbors - 6) * 0.02);
                } else if(neighbors === 0) {
                    // Severe isolation penalty
                    score -= 0.15;
                }
                
                // === NATURAL FEATURES (Aesthetics: +0.05) ===
                // SIMPLIFIED: Just check immediate surroundings
                let trees = 0;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].tree) trees++;
                        }
                    }
                }
                score += Math.min(0.05, trees * 0.015);
                
                // Clamp between 0 and 1
                return Math.max(0, Math.min(1, score));
            },
            
            attackAnimal(animalIndex) {
                let animal = this.animals[animalIndex];
                animal.hits++;
                
                // Get animal config
                let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                
                if(animal.hits >= config.hitToKill) {
                    // Animal defeated!
                    
                    // HERD DANGER: Check if other animals are on same tile or adjacent
                    let nearbyAnimals = this.animals.filter((a, idx) => {
                        if(idx === animalIndex) return false; // Skip self
                        let dx = Math.abs(a.x - animal.x);
                        let dy = Math.abs(a.y - animal.y);
                        return dx <= 1 && dy <= 1; // Same tile or adjacent
                    });
                    
                    let isHerd = nearbyAnimals.length > 0;
                    let herdDamage = 0;
                    
                    if(isHerd && this.gameState === 'WANDER') {
                        // Herd attack - costs 1-3 population
                        herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                        this.pop = Math.max(0, this.pop - herdDamage);
                        
                        if(this.pop === 0) {
                            Controller.toast("ğŸ’€ Your tribe has perished attacking a herd!");
                            this.animals.splice(animalIndex, 1);
                            Controller.updateUI();
                            return;
                        }
                    }
                    
                    // Calculate food reward (random for animals)
                    let foodReward;
                    if(Array.isArray(config.foodReward)) {
                        // Random range [min, max]
                        foodReward = config.foodReward[0] + Math.floor(Math.random() * (config.foodReward[1] - config.foodReward[0] + 1));
                    } else {
                        // Fixed value (wolf)
                        foodReward = config.foodReward;
                    }
                    
                    // Apply base population cost (wolf costs -1 Pop to kill)
                    let popCost = config.popCost || 0;
                    let popLostMsg = '';
                    if(popCost > 0 && this.pop > 0) {
                        this.pop = Math.max(0, this.pop - popCost);
                        popLostMsg = ` (-${popCost} Pop!)`;
                        
                        // Check for game over
                        if(this.pop === 0) {
                            Controller.showGameOver('HUNTING');
                            return;
                        }
                    }
                    
                    // Add herd damage to message
                    if(herdDamage > 0) {
                        popLostMsg += ` (Herd cost: ${herdDamage} pop)`;
                    }
                    
                    if(this.gameState === 'WANDER') {
                        // Check capacity
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        // Build message with herd context
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        
                        if(spaceAvailable >= foodReward) {
                            this.inventory.food += foodReward;
                            this.totalFoodCollected += foodReward;
                            SoundFX.playCollect('food');
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} ğŸ–`);
                        } else if(spaceAvailable > 0) {
                            this.inventory.food += spaceAvailable;
                            this.totalFoodCollected += spaceAvailable;
                            SoundFX.playCollect('food');
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${spaceAvailable}/${foodReward} Food${herdMsg}`);
                        } else {
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} Food lost - Inventory Full!${herdMsg}`);
                        }
                    } else {
                        // City mode - add to main food storage
                        this.food += foodReward;
                        SoundFX.playCollect('food');
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} ğŸ–`);
                    }
                    
                    this.animals.splice(animalIndex, 1);
                    this.checkProgression();
                } else {
                    Controller.toast(`ğŸ’¥ Hit ${animalName.toLowerCase()}! (${animal.hits}/${config.hitToKill})`);
                }
                Controller.updateUI();
            },
            
            checkProgression() {
                let unlock = PROGRESSION.checkUnlock(this);
                if(unlock === 'settlement') {
                    Controller.toast("Settlement Unlocked! Explore to find water, then build Mud Huts! ğŸ ");
                    Controller.showSettlementUI();
                    // Immediately check for industrial unlock too
                    this.checkProgression();
                } else if(unlock === 'industrial') {
                    Controller.toast("Hunting Grounds Unlocked! Cost: 1000 Food + 1000 Wood. ğŸ­");
                    Controller.showIndustrialUI();
                } else if(unlock === 'industrial_need_population') {
                    Controller.toast(`âš ï¸ Need ${CFG.PRODUCTION.INDUSTRIAL_POPULATION_REQUIREMENT} population to unlock Hunting Grounds!`);
                } else if(unlock === 'industrial_need_food') {
                    Controller.toast(`âš ï¸ Need ${CFG.PRODUCTION.INDUSTRIAL_UNLOCK_COST} food to unlock Hunting Grounds!`);
                }
            },
            
            settleHere() {
                console.log('settleHere() called!');
                console.log('gameState:', this.gameState);
                console.log('pop:', this.pop);
                console.log('inventory.food:', this.inventory.food);
                console.log('inventory.wood:', this.inventory.wood);
                
                // Record player action for AI learning
                if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                    QLearningAI.recordPlayerAction('SETTLE');
                }
                
                // Prevent settling if already in CITY mode
                if(this.gameState === 'CITY') {
                    Controller.toast("âš ï¸ Already settled!");
                    return;
                }
                
                // Get requirements from CFG (Master Design v40.0)
                const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                const LOC_BONUS = CFG.SETTLEMENT_LOCATION_BONUS;
                
                // Check requirements: Pop >= 2, Food >= 100, Wood >= 25
                // NOTE: No water requirement - SimCity style, settle anywhere!
                if(this.pop < REQ.MIN_POP) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_POP}+ population to settle! (${this.pop}/${REQ.MIN_POP} - find nomads)`);
                    return;
                }
                if(this.inventory.food < REQ.MIN_FOOD) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_FOOD} food to settle! (${this.inventory.food}/${REQ.MIN_FOOD})`);
                    return;
                }
                if(this.inventory.wood < REQ.MIN_WOOD) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_WOOD} wood to settle! (${this.inventory.wood}/${REQ.MIN_WOOD})`);
                    return;
                }
                
                console.log('All requirements met! Calculating location bonuses...');
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SIMCITY-STYLE LOCATION BONUS CALCULATION
                // Players can settle ANYWHERE but get bonuses for strategic locations
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                let px = this.player.x;
                let py = this.player.y;
                let locationBonus = 0;
                
                // Track what bonuses we're getting for the toast message
                let bonusReasons = [];
                
                // === WATER PROXIMITY BONUS (not required, but gives bonus) ===
                let waterDistance = Infinity;
                let waterFound = false;
                
                for(let dx = -LOC_BONUS.WATER_RANGE; dx <= LOC_BONUS.WATER_RANGE; dx++) {
                    for(let dy = -LOC_BONUS.WATER_RANGE; dy <= LOC_BONUS.WATER_RANGE; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                waterDistance = Math.min(waterDistance, dist);
                                waterFound = true;
                            }
                        }
                    }
                }
                
                if(waterFound) {
                    if(waterDistance <= 2) {
                        locationBonus += LOC_BONUS.WATER_ADJACENT;
                        bonusReasons.push('ğŸŒŠ Riverside +30%');
                    } else if(waterDistance <= LOC_BONUS.WATER_RANGE) {
                        locationBonus += LOC_BONUS.WATER_NEARBY;
                        bonusReasons.push('ğŸ’§ Near Water +15%');
                    }
                }
                
                // === SCAN 5x5 AREA FOR RESOURCES ===
                let stoneCount = 0;
                let berryCount = 0;
                let forestCount = 0;
                let grassCount = 0;
                
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'STONE' || tile.stoneDeposit) stoneCount++;
                            if(tile.type === 'FOREST' || tile.tree) forestCount++;
                            if(tile.type === 'GRASS' || tile.type === 'LAND') grassCount++;
                            if(tile.entity && tile.entity.type === 'BERRY') berryCount++;
                        }
                    }
                }
                
                // Apply resource proximity bonuses
                if(forestCount >= 3) {
                    locationBonus += LOC_BONUS.FOREST_NEARBY;
                    bonusReasons.push('ğŸŒ² Forest +10%');
                }
                if(stoneCount >= 2) {
                    locationBonus += LOC_BONUS.STONE_NEARBY;
                    bonusReasons.push('ğŸª¨ Stone +10%');
                }
                if(berryCount >= 2) {
                    locationBonus += LOC_BONUS.BERRY_NEARBY;
                    bonusReasons.push('ğŸ« Berries +15%');
                }
                if(grassCount >= 15) {
                    locationBonus += LOC_BONUS.GRASSLAND_BONUS;
                    bonusReasons.push('ğŸŒ¿ Grassland +5%');
                }
                
                // === DETERMINE SITE TRAITS (for flavor and future mechanics) ===
                this.siteTraits = [];
                if(waterDistance <= 2) this.siteTraits.push('Riverside');
                if(stoneCount >= 3) this.siteTraits.push('Mineral Rich');
                if(berryCount >= 2) this.siteTraits.push('Fertile');
                if(forestCount >= 5) this.siteTraits.push('Wooded');
                if(waterDistance <= 2 && berryCount >= 2) this.siteTraits.push('Paradise');
                if(!waterFound) this.siteTraits.push('Arid');  // No water nearby - challenging!
                
                // Store location bonus for future calculations
                this.settlementLocationBonus = locationBonus;
                
                console.log('Location bonus:', locationBonus, 'Traits:', this.siteTraits);
                
                // Transition to CITY mode
                console.log('Transitioning to CITY mode...');
                this.gameState = 'CITY';
                console.log('gameState set to CITY');
                
                // Transfer inventory to main resources (no deduction - resources persist)
                // NaN protection: ensure all values are valid numbers
                this.food = Number(this.inventory.food) || 0;
                this.wood = Number(this.inventory.wood) || 0;
                this.metal = Number(this.inventory.metal) || 0;
                this.stone = Number(this.inventory.stone) || 0;
                console.log('Resources transferred:', {food: this.food, wood: this.wood, metal: this.metal, stone: this.stone});
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // COMBINED SETTLEMENT BONUSES
                // Population bonus + Location bonus = Total starting advantage
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Population bonus: More nomads recruited = stronger start
                let popBonus = Math.floor((this.pop - 1) * 10); // Each nomad adds +10% bonus
                let gatheringMultiplier = 0.5 + (this.pop * 0.1); // 0.5 base + 0.1 per nomad
                
                // Location bonus: Good spots give resource bonuses
                let totalBonus = popBonus + Math.floor((locationBonus || 0) * 100);
                
                // Apply combined bonus to starting resources
                if (totalBonus > 0) {
                    let bonusFood = Math.floor(Number(this.food) * (totalBonus / 100));
                    let bonusWood = Math.floor(Number(this.wood) * (totalBonus / 100));
                    bonusFood = isNaN(bonusFood) ? 0 : bonusFood;
                    bonusWood = isNaN(bonusWood) ? 0 : bonusWood;
                    this.food = Number(this.food) + bonusFood;
                    this.wood = Number(this.wood) + bonusWood;
                    console.log(`Settlement bonus (${this.pop} people + location): +${bonusFood} food, +${bonusWood} wood`);
                }
                
                // Location also affects gathering rate
                this.gatheringMultiplier = Math.min(3.0, gatheringMultiplier + ((locationBonus || 0) * 0.5)); // Location adds up to 0.5x
                console.log(`Gathering rate: ${(this.gatheringMultiplier * 100).toFixed(0)}% (${this.pop} settlers + location)`);
                
                // Build toast message
                let traitText = this.siteTraits.length > 0 ? ` (${this.siteTraits.join(', ')})` : '';
                let bonusText = totalBonus > 0 ? ` +${totalBonus}% Start!` : '';
                let locationText = bonusReasons.length > 0 ? '\n' + bonusReasons.join(' ') : '';
                
                // Show main toast
                Controller.toast(`ğŸ›ï¸ Settlement Started!${traitText}${bonusText}`);
                
                // If there are location bonuses, show them in a second toast
                if(bonusReasons.length > 0) {
                    setTimeout(() => {
                        Controller.toast(`ğŸ“ Location bonuses: ${bonusReasons.join(' ')}`);
                    }, 1500);
                } else {
                    // Warn about poor location
                    setTimeout(() => {
                        Controller.toast(`âš ï¸ Remote location - no bonuses. Consider settling near water/resources!`);
                    }, 1500);
                }
                
                console.log('Calling Controller.showCityUI()...');
                
                // Force UI update
                setTimeout(() => {
                    console.log('Delayed showCityUI call...');
                    Controller.showCityUI();
                    // Always show and enable t-res after settlement
                    let tResBtn = document.getElementById('t-res');
                    if (tResBtn) {
                        tResBtn.style.display = 'inline-block';
                        tResBtn.disabled = false;
                        tResBtn.title = 'Build Residential';
                    }
                    Controller.updateUI();
                    console.log('Settlement complete!');
                    
                    // Check progression to unlock industrial immediately after settlement
                    this.checkProgression();
                }, 100);
            },
            
            isValid(gx, gy, tool) {
                // All zones are 1x1 per documentation (RES, COM, IND, ROAD, WELL)
                let sz = 1;
                // Only special buildings like CHIEF, PALACE, GRANARY are 2x2
                if(tool === 'CHIEF' || tool === 'PALACE' || tool === 'GRANARY' || tool === 'BASKET' || tool === 'POTTERY') sz = 2;
                
                if(gx<0 || gy<0 || gx+sz>CFG.W || gy+sz>CFG.H) return false;
                
                // Check for water, existing zones, roads, buildings - hard blocks
                for(let x=gx; x<gx+sz; x++) {
                    for(let y=gy; y<gy+sz; y++) { 
                        let tile = this.tiles[x][y];
                        let t = tile.type; 
                        if(t=='WATER'||t=='DEEP'||t=='RIVER'||t=='STONE') return false;
                        
                        // Stone deposits block most buildings (industrial can override)
                        if(tile.stoneDeposit && tool !== 'IND') return false;
                        
                        // Check for existing zone or building on tile (RES uses tile.zone system)
                        if(tile.zone || tile.building) return false;
                        
                        // Check for roads (can't build on roads)
                        if(tile.road) return false;
                    }
                }
                
                // Check for building overlap (COM/IND/WELL/CHIEF etc use blds array)
                for(let b of this.blds) { 
                    // COM and IND are 1x1 per documentation, WELL is 1x1, others are 2x2
                    let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                    if(gx<b.x+bz && gx+sz>b.x && gy<b.y+bz && gy+sz>b.y) return false; 
                }
                
                return true;
            },
            build(t, gx, gy) {
                try {
                    console.log('build() called:', {tool: t, x: gx, y: gy});
                    
                    // Record player action for AI learning
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        let action = 'BUILD_' + (t === 'RES' ? 'RES' : t === 'IND' ? 'IND' : t === 'COM' ? 'COM' : t === 'WELL' ? 'WELL' : t === 'ROAD' ? 'ROAD' : 'OTHER');
                        QLearningAI.recordPlayerAction(action);
                    }
                    
                    // BULLDOZER: Remove zones or buildings
                    if(t === 'BULL') {
                    if(this.simcityMode && this.res < CFG.COST.BULL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < 1) return Controller.toast("Need Food");
                    
                    // Clear zone and building from tile
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        if(this.simcityMode) this.res -= CFG.COST.BULL;
                        else this.food -= 1;
                        Controller.toast("Zone Cleared");
                    }
                    // Check for buildings - COM/IND/WELL are 1x1, others are 2x2
                    else {
                        let hit = -1;
                        for (let i = 0; i < this.blds.length; i++) { 
                            let b = this.blds[i]; 
                            let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2; 
                            if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                                hit = i; 
                                break; 
                            } 
                        }
                        if (hit !== -1) { 
                            this.blds.splice(hit, 1); 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Demolished"); 
                        }
                        else if (this.tiles[gx][gy].road) { 
                            this.tiles[gx][gy].road = false; 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Road Removed"); 
                        }
                    }
                    this.recalc();
                    return;
                }
                
                // ROADS
                if (t == 'ROAD') {
                    if(this.simcityMode && this.res < CFG.COST.ROAD) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < CFG.COST.ROAD) return Controller.toast("Need Food");
                    
                    if (this.tiles[gx][gy].type == 'WATER' || this.tiles[gx][gy].type == 'DEEP' || this.tiles[gx][gy].type == 'RIVER' || this.tiles[gx][gy].type == 'STONE') return;
                    if (this.tiles[gx][gy].stoneDeposit) return Controller.toast("Can't build road on stone deposit");
                    this.tiles[gx][gy].road = true; 
                    this.tiles[gx][gy].tree = false;
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.roadTileCount = (this.roadTileCount || 0) + 1; // Track road count for workforce
                    
                    if(this.simcityMode) this.res -= CFG.COST.ROAD;
                    else this.food -= CFG.COST.ROAD;
                    this.recalc();
                    return;
                }
                
                // WELLS (keep as instant building)
                if(t === 'WELL') {
                    if(this.simcityMode && this.res < CFG.COST.WELL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < CFG.COST.WELL) return Controller.toast("Need Food");
                    
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    this.tiles[gx][gy].tree = false;
                    this.blds.push({ t: 'WELL', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    if(this.simcityMode) this.res -= CFG.COST.WELL;
                    else this.food -= CFG.COST.WELL;
                    this.recalc();
                    return;
                }
                
                // CHIEF'S HUT (special 2x2 building with culture bonus)
                if(t === 'CHIEF') {
                    if(this.food < CFG.CHIEF_COST) return Controller.toast(`Need ${CFG.CHIEF_COST} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 2x2 area
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'CHIEF', x: gx, y: gy });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.CHIEF_COST;
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    Controller.toast("ğŸ›ï¸ Chief's Hut built! +Culture Bonus in 50-tile radius");
                    this.recalc();
                    return;
                }
                
                // STORAGE BUILDINGS (reduce food spoilage)
                if(t === 'BASKET') {
                    if(this.pop < CFG.BUILDINGS.BASKET.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.BASKET.cost) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'BASKET', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.BASKET.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ§º Basket built! +${CFG.BUILDINGS.BASKET.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'POTTERY') {
                    if(this.pop < CFG.BUILDINGS.POTTERY.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.POTTERY.cost) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'POTTERY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.POTTERY.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸº Pottery built! +${CFG.BUILDINGS.POTTERY.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'GRANARY') {
                    if(this.pop < CFG.BUILDINGS.GRANARY.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.GRANARY.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.GRANARY.cost) return Controller.toast(`Need ${CFG.BUILDINGS.GRANARY.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'GRANARY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.GRANARY.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ›ï¸ Granary built! +${CFG.BUILDINGS.GRANARY.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'PALACE') {
                    if(this.pop < CFG.BUILDINGS.PALACE.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.PALACE.cost) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'PALACE', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.PALACE.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ° Palace built! +${CFG.BUILDINGS.PALACE.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                // INDUSTRIAL BUILDING (1x1 - Hunting Ground, Hunting Pit, etc.)
                if(t === 'IND') {
                    // Get selected industrial level from Controller
                    let selectedLevel = Controller.selectedIndustrialLevel || 1;
                    let levelConfig = CFG.INDUSTRIAL_LEVELS[selectedLevel];
                    
                    if(!levelConfig) {
                        return Controller.toast("Invalid industrial level!");
                    }
                    
                    // Check if level is unlocked
                    if(!PROGRESSION.unlockedIndustrialLevels.includes(selectedLevel)) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(selectedLevel, this);
                        return Controller.toast(info.text);
                    }
                    
                    // Check resource costs
                    if(this.food < levelConfig.food) return Controller.toast(`Need ${levelConfig.food} Food`);
                    if(this.wood < levelConfig.wood) return Controller.toast(`Need ${levelConfig.wood} Wood`);
                    if(levelConfig.stone > 0 && this.stone < levelConfig.stone) return Controller.toast(`Need ${levelConfig.stone} Stone`);
                    if(levelConfig.metal > 0 && this.metal < levelConfig.metal) return Controller.toast(`Need ${levelConfig.metal} Metal`);
                    
                    // Validate 1x1 spot
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    
                    // Check for stone deposit bonus (single tile)
                    let hasStoneDeposit = tile.stoneDeposit ? true : false;
                    let totalMetal = hasStoneDeposit ? tile.stoneDeposit.metal : 0;
                    
                    // Check for animal bonus - IND on animal = food production bonus
                    let hasAnimalBonus = tile.animal ? true : false;
                    
                    // Validate tile type
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // Clear tree and stone deposit (1x1)
                    tile.tree = false;
                    if(tile.stoneDeposit) {
                        tile.stoneDeposit = null;
                    }
                    
                    // Create 1x1 industrial building with level and variant support
                    this.blds.push({ 
                        t: 'IND', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: 1.0, 
                        age: 0, 
                        pop: 0,             // Workers assigned to this building
                        onDeposit: hasStoneDeposit,
                        animalBonus: hasAnimalBonus,  // Track if built on animal for food bonus
                        desirability: 0.5,  // Start at medium
                        variant: 1          // Start at Low variant
                    });
                    
                    // Clear animal if present
                    if(tile.animal) tile.animal = null;
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct costs
                    this.food -= levelConfig.food;
                    this.wood -= levelConfig.wood;
                    if(levelConfig.stone > 0) this.stone -= levelConfig.stone;
                    if(levelConfig.metal > 0) this.metal -= levelConfig.metal;
                    
                    // Give metal bonus if built on deposits (NERFED - much smaller amounts now)
                    if(hasStoneDeposit) {
                        this.metal += totalMetal;
                        Controller.toast(`â›ï¸ ${levelConfig.name} on deposit! +${totalMetal} metal`);
                    } else if(hasAnimalBonus) {
                        let foodRate = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.ANIMAL_FOOD_RATE : 10;
                        Controller.toast(`ğŸ¦Œ ${levelConfig.name} on hunting grounds! +${foodRate} food/year bonus!`);
                    } else {
                        Controller.toast(`ğŸ­ ${levelConfig.name} built! Capacity: ${levelConfig.capacity} workers`);
                    }
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.recalc();
                    return;
                }
                
                // COMMERCIAL (Level 1 = Campfire, Level 2 = Fire Pit)
                if(t === 'COM') {
                    // Get selected commercial level (default to 1)
                    let selectedLevel = Controller.selectedCommercialLevel || 1;
                    let levelCost = selectedLevel === 1 ? CFG.LEVEL_1_COSTS.COMMERCIAL : CFG.LEVEL_2_COSTS.COMMERCIAL;
                    
                    // Check resource costs (food + wood based per documentation)
                    if(this.food < levelCost.food) {
                        return Controller.toast(`Need ${levelCost.food} Food for Commercial L${selectedLevel}`);
                    }
                    if(this.wood < levelCost.wood) {
                        return Controller.toast(`Need ${levelCost.wood} Wood for Commercial L${selectedLevel}`);
                    }
                    
                    // Validate 1x1 spot
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CHECK FOR TREE BONUS - COM on tree = wood collection bonus
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let hasTreeBonus = tile.tree ? true : false;
                    
                    // Clear tree if present (1x1)
                    tile.tree = false;
                    
                    // Place 1x1 commercial zone
                    this.blds.push({ 
                        t: 'COM', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: 1.0, 
                        age: 0,
                        pop: 0,         // Workers assigned to this building
                        variant: 1,  // Start at Low activity
                        treeBonus: hasTreeBonus  // Track if built on tree for wood bonus
                    });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resource costs
                    this.food -= levelCost.food;
                    this.wood -= levelCost.wood;
                    
                    let comName = selectedLevel === 1 ? 'Campfire' : 'Fire Pit';
                    if(hasTreeBonus) {
                        let woodRate = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.TREE_WOOD_RATE : 5;
                        Controller.toast(`ğŸŒ² ${comName} on forest! +${woodRate} wood/year bonus!`);
                    } else {
                        Controller.toast(`ğŸª ${comName} built! (-${levelCost.food} food, -${levelCost.wood} wood)`);
                    }
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 3);
                    
                    this.recalc();
                    return;
                }
                
                // RESIDENTIAL ZONING (new zone-based system with level selection)
                if(t === 'RES') {
                    console.log('RES building block reached!');
                    
                    // First check if we're in city mode
                    if(this.gameState !== 'CITY') {
                        return Controller.toast("âš ï¸ Must settle first! Click ğŸ›ï¸ button to settle.");
                    }
                    
                    console.log('isValid check:', this.isValid(gx, gy, t));
                    if (!this.isValid(gx, gy, t)) {
                        // More detailed error message
                        let tile = this.tiles[gx][gy];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') {
                            return Controller.toast("âŒ Can't build on water!");
                        }
                        if(tile.type === 'STONE') {
                            return Controller.toast("âŒ Can't build on stone mountains!");
                        }
                        if(tile.zone || tile.building) {
                            return Controller.toast("âŒ Tile already has a building!");
                        }
                        if(tile.road) {
                            return Controller.toast("âŒ Can't build on roads!");
                        }
                        return Controller.toast("âŒ Invalid Spot");
                    }
                    
                    // Get selected building level (default to highest unlocked level)
                    let selectedLevel = Controller.selectedBuildingLevel;
                    console.log('Selected level:', selectedLevel);
                    if(selectedLevel === undefined || selectedLevel === null) {
                        // Default to Level 1 if unlocked, otherwise Level 0
                        selectedLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    }
                    let levelConfig = CFG.BUILDING_LEVELS[selectedLevel];
                    console.log('Level config:', levelConfig);
                    
                    if(!levelConfig) {
                        return Controller.toast("âŒ Invalid building level!");
                    }
                    
                    console.log('Current resources - Food:', this.food, 'Wood:', this.wood, 'Stone:', this.stone);
                    
                    // Check if player has required resources
                    if(this.food < levelConfig.food) {
                        return Controller.toast(`Need ${levelConfig.food} Food for ${levelConfig.name}`);
                    }
                    if(levelConfig.wood > 0 && this.wood < levelConfig.wood) {
                        return Controller.toast(`Need ${levelConfig.wood} Wood for ${levelConfig.name}`);
                    }
                    if(levelConfig.stone > 0 && this.stone < levelConfig.stone) {
                        return Controller.toast(`Need ${levelConfig.stone} Stone for ${levelConfig.name}`);
                    }
                    
                    // Deduct resources
                    console.log('Deducting resources...');
                    this.food = Number(this.food) - Number(levelConfig.food);
                    if (isNaN(this.food)) this.food = 0;
                    if(levelConfig.wood > 0) this.wood = Number(this.wood) - Number(levelConfig.wood);
                    if(levelConfig.stone > 0) this.stone = Number(this.stone) - Number(levelConfig.stone);
                    console.log('Resources after deduction - Food:', this.food, 'Wood:', this.wood);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CHECK FOR TILE BONUSES - Berry = food, Nomad = population
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let tile = this.tiles[gx][gy];
                    let tileBonus = null;
                    
                    // Berry tile bonus - +food when building RES
                    if(tile.entity && tile.entity.type === 'BERRY') {
                        let bonus = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.BERRY_FOOD_BONUS : 50;
                        this.food += bonus;
                        tileBonus = `ğŸ« Berry bonus! +${bonus} food`;
                    }
                    
                    // Nomad tile bonus - +population when building RES
                    if(tile.entity && tile.entity.type === 'NOMAD') {
                        let bonus = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.NOMAD_POP_BONUS : 2;
                        this.pop += bonus;
                        tileBonus = `ğŸ‘¥ Nomad bonus! +${bonus} population`;
                    }
                    
                    // Create zone with selected level
                    console.log('Creating zone at', gx, gy);
                    this.tiles[gx][gy].zone = 'R';
                    this.tiles[gx][gy].building = {
                        level: selectedLevel,
                        growth: 0,
                        desirability: 1.0,
                        age: 0,
                        lastBirthYear: this.year,
                        pop: 0,
                        capacity: levelConfig.capacity,
                        // Buildings start at variant 1 (Low) for visual variety
                        // Can evolve up/down based on desirability
                        variant: 1
                    };
                    this.tiles[gx][gy].tree = false;
                    this.tiles[gx][gy].entity = null; // Clear berry/nomad after building
                    
                    // Update building populations after creating residential
                    if(typeof assignPopulationToResidential === 'function') {
                        assignPopulationToResidential(this);
                    }
                    
                    // Auto-explore area around new zone for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.markDirty(gx, gy, 1); // Mark for redraw
                    
                    // Show bonus message if applicable
                    if(tileBonus) {
                        Controller.toast(tileBonus);
                        setTimeout(() => Controller.toast(`${levelConfig.name} built! Cap: ${levelConfig.capacity}`), 1000);
                    } else {
                        Controller.toast(`${levelConfig.name} built! Cap: ${levelConfig.capacity}`);
                    }
                    
                    this.recalc();
                    return;
                }
                
                // DEMOLISH: Remove zones, buildings, or roads
                if(t === 'DEMOLISH') {
                    // Check if there's a road to demolish
                    if(this.tiles[gx][gy].road) {
                        this.tiles[gx][gy].road = false;
                        this.roadTileCount = Math.max(0, (this.roadTileCount || 0) - 1);
                        Controller.toast('ğŸ›£ï¸ Road demolished');
                        this.recalc();
                        return;
                    }
                    
                    // Check for buildings in blds array (WELL, COM, IND, CHIEF, etc.)
                    let bldHit = -1;
                    for (let i = 0; i < this.blds.length; i++) {
                        let b = this.blds[i];
                        // COM, IND, WELL are 1x1 per documentation
                        let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                        if (gx >= b.x && gx < b.x + bz && gy >= b.y && gy < b.y + bz) {
                            bldHit = i;
                            break;
                        }
                    }
                    if (bldHit !== -1) {
                        let removedBld = this.blds[bldHit];
                        this.blds.splice(bldHit, 1);
                        Controller.toast(`ğŸ”¨ ${removedBld.t} demolished`);
                        this.recalc();
                        return;
                    }
                    
                    // Check for zoned residential buildings
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        let bld = this.tiles[gx][gy].building;
                        
                        // FLAT 10% SALVAGE RATE for all building levels
                        if(bld && bld.level !== undefined) {
                            let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                            if(levelConfig) {
                                let refundRate = 0.10; // 10% refund for all levels
                                
                                let foodRefund = Math.floor(levelConfig.food * refundRate);
                                let woodRefund = Math.floor(levelConfig.wood * refundRate);
                                let stoneRefund = Math.floor(levelConfig.stone * refundRate);
                                
                                this.food += foodRefund;
                                this.wood += woodRefund;
                                this.stone += stoneRefund;
                                
                                if(foodRefund > 0 || woodRefund > 0 || stoneRefund > 0) {
                                    let refundText = [];
                                    if(foodRefund > 0) refundText.push(`${foodRefund} food`);
                                    if(woodRefund > 0) refundText.push(`${woodRefund} wood`);
                                    if(stoneRefund > 0) refundText.push(`${stoneRefund} stone`);
                                    Controller.toast(`â™»ï¸ Salvaged 10%: ${refundText.join(', ')}`);
                                } else {
                                    Controller.toast(`ğŸ”¨ Demolished (no salvage value)`);
                                }
                            }
                        }
                        
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        this.markDirty(gx, gy, 1);
                        this.recalc();
                    } else {
                        Controller.toast("Nothing to demolish here");
                    }
                }
                } catch(err) {
                    console.error('Build error:', err);
                    Controller.toast('âŒ Build error: ' + err.message);
                }
            },
            bull(gx, gy) {
                // Legacy function - now handled in build()
                // Kept for compatibility
                if (this.res < CFG.COST.BULL && this.simcityMode) return Controller.toast("Need Funds");
                if (this.food < 1 && !this.simcityMode) return Controller.toast("Need Food");
                
                // Check for zones first
                if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                    this.tiles[gx][gy].zone = null;
                    this.tiles[gx][gy].building = null;
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Zone Cleared");
                    this.recalc();
                    return;
                }
                
                // Check for buildings
                let hit = -1;
                for (let i = 0; i < this.blds.length; i++) { 
                    let b = this.blds[i]; 
                    // COM, IND, WELL are 1x1 per documentation
                    let sz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2; 
                    if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                        hit = i; 
                        break; 
                    } 
                }
                if (hit !== -1) { 
                    this.blds.splice(hit, 1); 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Demolished"); 
                }
                else if (this.tiles[gx][gy].road) { 
                    this.tiles[gx][gy].road = false; 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Road Removed"); 
                }
                this.recalc();
            },
            upgradeBuilding(buildingIndex) {
                let b = this.blds[buildingIndex];
                if(!b || b.lvl >= 200) return Controller.toast("Max Level!");
                
                let cost = this.getUpgradeCost(b.lvl);
                
                // In SimCity mode, use funds; in survival mode, use food
                if(this.simcityMode) {
                    if(this.res < cost) return Controller.toast(`Need ${Math.floor(cost)} Funds`);
                    b.lvl++;
                    this.res -= cost;
                } else {
                    if(this.food < cost) return Controller.toast(`Need ${Math.floor(cost)} Food`);
                    b.lvl++;
                    this.food -= cost;
                }
                
                // Buildings in blds array (COM, IND, WELL, CHIEF) don't need special capacity updates
                // Zones handle their own capacity based on era level
                
                Controller.toast(`Upgraded to Level ${b.lvl}!`);
                this.recalc();
            },
            getUpgradeCost(currentLevel) {
                return Math.floor(CFG.UPGRADE.BASE_COST * Math.pow(CFG.UPGRADE.COST_MULTIPLIER, currentLevel - 1));
            },
            getBuildingProduction(building) {
                if(building.t === 'COM') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.COM_PRODUCTION_PER_LEVEL;
                } else if(building.t === 'IND') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.IND_PRODUCTION_PER_LEVEL;
                }
                return 0;
            },
            
            calculateDesirability(x, y, sz) {
                // Calculate desirability score for a location (0.5 to 3.0+)
                let score = 1.0;
                let neighborCount = 0;
                let hasTree = false;
                let hasWater = false;
                let hasChief = false;
                
                // Check neighbors (adjacent residential zones)
                for(let dx = -1; dx <= sz; dx++) {
                    for(let dy = -1; dy <= sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            // Check for zoned residential neighbors
                            let tile = this.tiles[checkX][checkY];
                            if(tile.zone === 'R') neighborCount++;
                            
                            // Check for trees/forest
                            if(tile.tree || tile.type === 'FOREST') hasTree = true;
                        }
                    }
                }
                
                // Check water proximity (within 3 tiles)
                for(let dx = -CFG.DESIRABILITY.WATER_RANGE; dx <= CFG.DESIRABILITY.WATER_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.WATER_RANGE; dy <= CFG.DESIRABILITY.WATER_RANGE + sz; dy++) {
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            let tile = this.tiles[checkX][checkY];
                            if(tile.type === 'WATER' || tile.type === 'RIVER') {
                                hasWater = true;
                            }
                        }
                    }
                }
                
                // Check Chief's Hut proximity (massive bonus within 50 tiles)
                let chiefHuts = this.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(x - chief.x, 2) + Math.pow(y - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChief = true;
                        break;
                    }
                }
                
                // Apply bonuses
                score += neighborCount * CFG.DESIRABILITY.NEIGHBOR_BONUS;
                if(hasTree) score += CFG.DESIRABILITY.TREE_BONUS;
                if(hasWater) score += CFG.DESIRABILITY.WATER_BONUS;
                if(hasChief) score *= CFG.CHIEF_BONUS;  // Multiplier for Chief bonus
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SIMCITY-STYLE: Higher-level building proximity bonuses
                // People WANT to live near nicer buildings (like SimCity land value)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let levelBonusRange = CFG.DESIRABILITY.LEVEL_BONUS_RANGE || 3;
                
                for(let dx = -levelBonusRange; dx <= levelBonusRange + sz; dx++) {
                    for(let dy = -levelBonusRange; dy <= levelBonusRange + sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            let tile = this.tiles[checkX][checkY];
                            
                            // Check residential zones with buildings
                            if(tile.zone === 'R' && tile.building) {
                                let bldLevel = tile.building.level || 1;
                                // Higher level residential = more desirable to live nearby
                                if(bldLevel >= 4) score += CFG.DESIRABILITY.RES_LEVEL_4_BONUS || 0.30;
                                else if(bldLevel >= 3) score += CFG.DESIRABILITY.RES_LEVEL_3_BONUS || 0.20;
                                else if(bldLevel >= 2) score += CFG.DESIRABILITY.RES_LEVEL_2_BONUS || 0.10;
                            }
                            
                            // Check commercial zones
                            if(tile.zone === 'C' && tile.building) {
                                let comLevel = tile.building.level || 1;
                                score += (CFG.DESIRABILITY.COM_LEVEL_BONUS || 0.15) * comLevel;
                            }
                            
                            // Check industrial zones (jobs are attractive!)
                            if(tile.zone === 'I' && tile.building) {
                                let indLevel = tile.building.level || 1;
                                score += (CFG.DESIRABILITY.IND_LEVEL_BONUS || 0.10) * indLevel;
                            }
                        }
                    }
                }
                
                // Also check blds array for COM/IND buildings (they use blds, not tile.zone)
                for(let bld of this.blds) {
                    if(bld.t === 'COM' || bld.t === 'IND') {
                        let dist = Math.abs(x - bld.x) + Math.abs(y - bld.y);
                        if(dist <= levelBonusRange) {
                            if(bld.t === 'COM') {
                                score += (CFG.DESIRABILITY.COM_LEVEL_BONUS || 0.15) * (bld.lvl || 1);
                            } else if(bld.t === 'IND') {
                                score += (CFG.DESIRABILITY.IND_LEVEL_BONUS || 0.10) * (bld.lvl || 1);
                            }
                        }
                    }
                }
                
                // Isolation penalty - check if any buildings within 2 tiles
                let isolated = true;
                for(let dx = -CFG.DESIRABILITY.ISOLATION_RANGE; dx <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.ISOLATION_RANGE; dy <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        
                        // Check for zoned tiles
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            if(this.tiles[checkX][checkY].zone) {
                                isolated = false;
                                break;
                            }
                        }
                        
                        // Check for 2x2 buildings
                        let nearBuilding = this.blds.find(b => 
                            checkX >= b.x && checkX < b.x + 2 &&
                            checkY >= b.y && checkY < b.y + 2
                        );
                        if(nearBuilding) {
                            isolated = false;
                            break;
                        }
                    }
                    if(!isolated) break;
                }
                
                if(isolated) score -= CFG.DESIRABILITY.ISOLATION_PENALTY;
                
                return Math.max(0.5, score);
            },
            recalc() {
                let wSup=50, jobs=0, housing=0, comJobs=0, indJobs=0;
                
                // JIT HINT: Monomorphic array access pattern
                const tilesArray = this.tiles;
                const bldsArray = this.blds;
                const eraCount = CFG.ERAS.length;
                
                // Calculate zoned residential capacity AND average desirability
                let totalDesirability = 0;
                let zoneCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x]; // Cache array access
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Count neighboring residential zones for clustering bonus
                            let neighbors = 0;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    if(dx === 0 && dy === 0) continue;
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                                        if(tilesArray[nx][ny].zone === 'R') neighbors++;
                                    }
                                }
                            }
                            
                            // Growth penalty for isolated houses, bonus for grouped
                            // 0 neighbors = 0.3x (very slow), 1 = 0.5x, 2 = 0.8x, 3 = 1x, 4+ = 1.5x
                            let clusterMultiplier = 1.0;
                            if(neighbors === 0) clusterMultiplier = 0.3;
                            else if(neighbors === 1) clusterMultiplier = 0.5;
                            else if(neighbors === 2) clusterMultiplier = 0.8;
                            else if(neighbors === 3) clusterMultiplier = 1.0;
                            else clusterMultiplier = 1.5;
                            
                            // Use building level from BUILDING_LEVELS config
                            let buildingLevel = bld.level || 0;
                            let levelConfig = CFG.BUILDING_LEVELS[buildingLevel];
                            if(levelConfig) {
                                let baseCapacity = levelConfig.capacity;
                                
                                // Level 1 buildings always have 20 capacity (population varies 0-20 based on desirability)
                                // Housing capacity = max people that CAN live there
                                if(buildingLevel === 1) {
                                    housing += baseCapacity; // Always 20 for Level 1
                                } else {
                                    // Other levels use desirability multiplier
                                    let desirabilityBonus = Math.max(1.0, (bld.desirability || 1.0) * 1.5);
                                    let finalCapacity = Math.floor(baseCapacity * desirabilityBonus);
                                    housing += finalCapacity;
                                }
                                
                                totalDesirability += bld.desirability || 1.0;
                                zoneCount++;
                            }
                        }
                    }
                }
                
                this.blds.forEach(b => {
                    b.conn = false; 
                    // COM/IND/WELL are 1x1 per documentation, others are 2x2
                    let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                    
                    // Check road connection
                    for (let x=b.x-1; x<b.x+sz+1; x++) {
                        for (let y=b.y-1; y<b.y+sz+1; y++) { 
                            if (x>=0 && x<CFG.W && y>=0 && y<CFG.H && this.tiles[x][y].road) {
                                b.conn = true;
                            }
                        }
                    }
                    
                    // Calculate building efficiency (organic growth)
                    let eff = 1.0;
                    
                    // NON-RESIDENTIAL: Use efficiency system
                    if(!b.conn) {
                        eff *= CFG.EFFICIENCY.NO_ROAD_PENALTY;
                    }
                    
                    if(b.waterProximity) {
                        eff += b.waterProximity * CFG.EFFICIENCY.WATER_BONUS_MAX;
                    } else {
                        eff *= 0.7;
                    }
                    
                    if(b.t === 'IND' && b.forestProximity) {
                        eff += CFG.EFFICIENCY.FOREST_BONUS;
                    }
                    
                    if(b.age > 50 && !b.conn) {
                        eff *= Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, 1 - (b.age - 50) * CFG.EFFICIENCY.DECAY_RATE);
                    }
                    
                    b.efficiency = Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, Math.min(3.0, eff));
                    
                    // Apply efficiency to calculations
                    if (b.t=='WELL') {
                        wSup += Math.floor(200 * (1 + (b.lvl - 1) * 0.5) * b.efficiency);
                    } else if (b.t=='COM') {
                        comJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    } else if (b.t=='IND') {
                        indJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    }
                    
                    b.age++;
                });
                
                jobs = comJobs + indJobs;
                this.eff = (jobs>0) ? Math.min(1.0, this.pop/jobs) : 1.0;
                
                // CACHE housing capacity AND avg desirability to avoid recalculating 40k tiles every turn
                this.housingCap = housing;
                this.avgDesirability = zoneCount > 0 ? totalDesirability / zoneCount : 1.0;
                this.zoneCount = zoneCount;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // POPULATION ASSIGNMENT - Distribute population to all buildings
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(typeof assignPopulationToResidential === 'function') {
                    assignPopulationToResidential(this);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKFORCE CALCULATION - Assign workers to infrastructure
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                let comCount = this.blds.filter(b => b.t === 'COM').length;
                let indCount = this.blds.filter(b => b.t === 'IND').length;
                
                // Use cached road count (updated when roads placed/removed) - avoids 62,500 tile loop!
                let roadTileCount = this.roadTileCount || 0;
                
                // Calculate workforce needs (with null checks for early game)
                let wellsNeeded = wellCount * (CFG.WORKFORCE ? CFG.WORKFORCE.WELL_WORKERS : 2);
                let roadsNeeded = Math.ceil(roadTileCount / 5) * (CFG.WORKFORCE && CFG.WORKFORCE.ROAD_WORKERS !== undefined ? CFG.WORKFORCE.ROAD_WORKERS : 1);
                let comNeeded = comCount * (CFG.WORKFORCE ? CFG.WORKFORCE.COMMERCIAL_WORKERS : 3);
                let totalNeeded = wellsNeeded + roadsNeeded + comNeeded;
                
                // Total workforce = residential population
                let totalWorkforce = this.pop;
                
                // Assign workers (priority: Wells > Roads > Commercial > Gathering)
                let wellWorkers = Math.min(wellsNeeded, totalWorkforce);
                let remaining = totalWorkforce - wellWorkers;
                
                let roadWorkers = Math.min(roadsNeeded, remaining);
                remaining -= roadWorkers;
                
                let comWorkers = Math.min(comNeeded, remaining);
                remaining -= comWorkers;
                
                let gatherers = remaining; // Everyone else gathers/hunts
                
                // Store workforce data
                this.workforce = {
                    total: totalWorkforce,
                    wellWorkers: wellWorkers,
                    roadWorkers: roadWorkers,
                    comWorkers: comWorkers,
                    gatherers: gatherers,
                    wellsNeeded: wellsNeeded,
                    roadsNeeded: roadsNeeded,
                    comNeeded: comNeeded,
                    shortage: totalNeeded - totalWorkforce
                };
                
                // Calculate how many wells are actually staffed
                let staffedWells = Math.floor(wellWorkers / (CFG.WORKFORCE ? CFG.WORKFORCE.WELL_WORKERS : 2));
                
                // Water calculation: only STAFFED wells provide water
                this.waterCap = staffedWells * (CFG.WATER ? CFG.WATER.WELL_CAPACITY : 100);
                // WELLS ARE ALWAYS REQUIRED - 1 well per 100 people minimum
                let waterNeeded = Math.max(1, Math.ceil(this.pop / 100)); // At least 1 well always needed
                this.water = staffedWells - waterNeeded; // Staffed wells vs need
                
                // Store counts for UI
                this.wellCount = wellCount;
                this.staffedWells = staffedWells;
                this.roadTileCount = roadTileCount;
                this.housingCap = housing;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NEEDS CALCULATION - Determine what people are missing
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                this.calculateNeeds();
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // LEVEL UNLOCK CHECK - Unlock higher building levels based on population
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                PROGRESSION.updateUnlockedLevels(this);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // POPULATION ASSIGNMENT - Distribute population to residential buildings
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(typeof assignPopulationToResidential === 'function') {
                    assignPopulationToResidential(this);
                }
                
                Controller.updateUI();
            },
            
            // Calculate needs satisfaction for all categories
            calculateNeeds() {
                let pop = this.pop || 0;
                if(pop === 0) {
                    this.needs.overall = 1.0;
                    return;
                }
                
                // HOUSING: Do we have enough homes?
                let housingNeed = pop;
                let housingHave = this.housingCap || 0;
                this.needs.housing = {
                    have: housingHave,
                    need: housingNeed,
                    satisfied: Math.min(1.0, housingHave / Math.max(1, housingNeed)),
                    shortage: Math.max(0, housingNeed - housingHave)
                };
                
                // WATER: Do we have enough wells?
                // Under 100 pop: No wells needed (nomadic gathering from streams)
                // 100+ pop: 1 well per 100 people (floor division)
                let waterNeed = pop < 100 ? 0 : Math.floor(pop / 100);
                let waterHave = this.staffedWells || 0;
                this.needs.water = {
                    have: waterHave,
                    need: waterNeed,
                    satisfied: waterNeed === 0 ? 1.0 : Math.min(1.0, waterHave / Math.max(1, waterNeed)), // Always satisfied if 0 needed
                    shortage: Math.max(0, waterNeed - waterHave)
                };
                
                // FOOD: Do we have food surplus?
                let foodConsumption = pop * (CFG.CONSTANTS ? CFG.CONSTANTS.FOOD_PER_PERSON : 0.2);
                let foodHave = this.food || 0;
                this.needs.food = {
                    have: foodHave,
                    need: foodConsumption * 10, // Need 10 years of food for full satisfaction
                    satisfied: Math.min(1.0, foodHave / Math.max(1, foodConsumption * 10)),
                    shortage: foodHave < foodConsumption ? Math.ceil(foodConsumption - foodHave) : 0
                };
                
                // JOBS: Do we have enough commercial/industrial?
                let jobsNeed = Math.ceil(pop * 0.5); // 50% of population wants jobs beyond gathering
                let jobsHave = 0;
                this.blds.forEach(b => {
                    if(b.t === 'COM') jobsHave += 20 * (b.lvl || 1);
                    if(b.t === 'IND') jobsHave += 30 * (b.lvl || 1);
                });
                this.needs.jobs = {
                    have: jobsHave,
                    need: jobsNeed,
                    satisfied: jobsNeed > 0 ? Math.min(1.0, jobsHave / jobsNeed) : 1.0,
                    shortage: Math.max(0, jobsNeed - jobsHave)
                };
                
                // PATHS: Do we have road coverage?
                let pathsNeed = Math.ceil(this.zoneCount * 2); // 2 road tiles per residential zone
                let pathsHave = this.roadTileCount || 0;
                this.needs.paths = {
                    have: pathsHave,
                    need: pathsNeed,
                    satisfied: pathsNeed > 0 ? Math.min(1.0, pathsHave / pathsNeed) : 1.0,
                    shortage: Math.max(0, pathsNeed - pathsHave)
                };
                
                // OVERALL SATISFACTION (weighted average)
                // Housing and Food are critical (weight 2), others weight 1
                let totalWeight = 8;
                this.needs.overall = (
                    this.needs.housing.satisfied * 2 +
                    this.needs.water.satisfied * 2 +
                    this.needs.food.satisfied * 2 +
                    this.needs.jobs.satisfied * 1 +
                    this.needs.paths.satisfied * 1
                ) / totalWeight;
            },
            
            // Generate yearly announcement about what people need
            generateNeedsAnnouncement() {
                if(!this.simcityMode && this.gameState !== 'CITY') return null;
                if(this.pop < 5) return null; // Don't spam for tiny settlements
                
                let missing = [];
                let icons = {
                    housing: 'ğŸ ',
                    water: 'ğŸ’§',
                    food: 'ğŸŒ¾',
                    jobs: 'ğŸ’¼',
                    paths: 'ğŸ›¤ï¸'
                };
                
                // Check each need
                if(this.needs.housing.satisfied < 0.9) {
                    missing.push(`${icons.housing} Housing (${this.needs.housing.shortage} homeless)`);
                }
                if(this.needs.water.satisfied < 0.9) {
                    missing.push(`${icons.water} Wells (need ${this.needs.water.shortage} more)`);
                }
                if(this.needs.food.satisfied < 0.5) {
                    missing.push(`${icons.food} Food reserves low`);
                }
                if(this.needs.jobs.satisfied < 0.7 && this.pop > 20) {
                    missing.push(`${icons.jobs} Jobs (${this.needs.jobs.shortage} unemployed)`);
                }
                if(this.needs.paths.satisfied < 0.5 && this.zoneCount > 3) {
                    missing.push(`${icons.paths} Paths (${this.needs.paths.shortage} tiles needed)`);
                }
                
                if(missing.length === 0) {
                    // All needs met - prosperity message every 10 years
                    if(this.year % 10 === 0) {
                        return `âœ¨ Year ${this.year}: Your people are prosperous! (${Math.floor(this.needs.overall * 100)}% satisfaction)`;
                    }
                    return null;
                }
                
                return `âš ï¸ Year ${this.year}: Your people need: ${missing.join(', ')}`;
            },
            
            // Calculate income based on population, desirability, and needs satisfaction
            calculateIncome() {
                let baseIncome = 0;
                let pop = this.pop || 0;
                
                // Base income per person (people generate value by existing)
                let incomePerPerson = 0.5; // Base income per person per year
                
                // Desirability multiplier (wealthy areas = more spending)
                let desirabilityMult = Math.max(0.5, Math.min(2.0, this.avgDesirability || 1.0));
                
                // Needs satisfaction multiplier (unhappy people = less productive)
                let satisfactionMult = Math.max(0.3, this.needs.overall || 1.0);
                
                // Population income (base economy)
                baseIncome = pop * incomePerPerson * desirabilityMult * satisfactionMult;
                
                // Commercial building income (boosted by population & satisfaction)
                this.blds.forEach(b => {
                    if(b.t === 'COM') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Commercial income scales with local population density
                        let popBonus = Math.min(2.0, 1.0 + (pop / 500)); // Up to 2x at 500 pop
                        baseIncome += buildingBase * b.efficiency * satisfactionMult * popBonus;
                    }
                    if(b.t === 'IND') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Industrial provides 50% income (rest is food production)
                        baseIncome += buildingBase * 0.5 * b.efficiency * satisfactionMult;
                    }
                });
                
                return Math.floor(baseIncome);
            },
            endTurn() {
                try {
                    // Record player action for AI learning
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        QLearningAI.recordPlayerAction('PASS_YEAR');
                    }
                    
                    this.year++;
                    
                    // CRITICAL: Recalculate workforce FIRST before any production/consumption
                    this.recalc();
                    
                    // Process player pathfinding
                    this.processPath();
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NOTE: Level 0 buildings removed - Level 0 is WANDER epoch only
                // All building starts at Level 1 (Settlement) now
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // LEVEL 1 RESIDENTIAL UPKEEP & ABANDONED TIMER
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Upkeep is simple: 0.5 wood per building per year (very low)
                // Only abandoned buildings (5+ years empty) have higher upkeep
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let level1UpkeepTotal = 0;
                let level1Count = 0;
                let abandonedCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building && tile.building.level === 1) {
                            let bld = tile.building;
                            level1Count++;
                            
                            // Initialize empty years tracker if not exists
                            if(bld.emptyYears === undefined) bld.emptyYears = 0;
                            
                            // Check if building is abandoned (variant 0 AND empty for 5+ years)
                            let isAbandoned = bld.variant === 0 && bld.emptyYears >= 5;
                            
                            if(isAbandoned) {
                                // Abandoned: higher upkeep (1 wood)
                                level1UpkeepTotal += 1;
                            } else {
                                // Normal upkeep: 0.5 wood per building
                                level1UpkeepTotal += 0.5;
                                
                                // Track empty years for abandonment
                                let hasOccupancy = this.pop > 0; // Any population means buildings are in use
                                if(!hasOccupancy) {
                                    bld.emptyYears++;
                                } else {
                                    bld.emptyYears = 0;
                                }
                            }
                            
                            // Check for abandoned (5 years with 0 population in settlement)
                            if(bld.emptyYears >= 5 && bld.variant !== 0 && this.pop === 0) {
                                bld.variant = 0; // Force to Abandoned variant
                                abandonedCount++;
                                this.markDirty(x, y, 1);
                            }
                        }
                    }
                }
                
                // Round upkeep to nearest whole number
                level1UpkeepTotal = Math.ceil(level1UpkeepTotal);
                
                // Deduct wood upkeep (silently - only warn on shortage)
                if(level1UpkeepTotal > 0) {
                    if(this.wood >= level1UpkeepTotal) {
                        this.wood -= level1UpkeepTotal;
                    } else {
                        // Not enough wood
                        this.wood = 0;
                    }
                }
                
                if(abandonedCount > 0) {
                    Controller.toast(`ğŸ’€ ${abandonedCount} settlement${abandonedCount > 1 ? 's' : ''} abandoned due to neglect!`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKFORCE GATHERING - Unassigned workers gather/hunt food AND wood
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Workers not assigned to infrastructure (wells, roads, commercial)
                // automatically gather food AND wood. This is the main resource source before
                // Industrial zones are built in Epoch 2.
                // Scaled by gatheringMultiplier (based on initial settlement population)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(this.workforce && this.workforce.gatherers > 0 && CFG.WORKFORCE) {
                    let baseFood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5);
                    let gathererFood = baseFood * (this.gatheringMultiplier || 1.0);
                    gathererFood = isNaN(gathererFood) ? 0 : gathererFood;
                    this.food = Number(this.food) || 0;
                    this.food += gathererFood;
                    
                    // WOOD PRODUCTION: Gatherers also collect wood
                    // Using config rate, scaled by gathering multiplier
                    let baseWood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_WOOD_RATE || 3.0);
                    let gathererWood = baseWood * (this.gatheringMultiplier || 1.0);
                    gathererWood = isNaN(gathererWood) ? 0 : gathererWood;
                    this.wood = Number(this.wood) || 0;
                    this.wood += gathererWood;
                    
                    // Warn if no gatherers due to infrastructure demand
                    if(this.workforce.shortage > 0) {
                        Controller.toast(`âš ï¸ Worker shortage! ${this.workforce.shortage} more needed. ${this.workforce.gatherers} gathering.`);
                    } else if(this.workforce.gatherers > 0 && this.pop < 20) {
                        // Show production details for early game
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`ğŸŒ¾ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood${multiplierText}`);
                    } else if(this.workforce.gatherers > 10 && Math.random() < 0.2) {
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`ğŸŒ¾ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood${multiplierText}`);
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ROAD DECAY - Unmaintained roads decay over time
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // If not enough road workers, roads provide no desirability bonus
                if(this.workforce && this.workforce.roadWorkers < this.workforce.roadsNeeded) {
                    let unmaintainedRoads = Math.ceil((this.workforce.roadsNeeded - this.workforce.roadWorkers) * 5);
                    if(unmaintainedRoads > 10 && Math.random() < 0.3) {
                        Controller.toast(`âš ï¸ ${unmaintainedRoads} road tiles unmaintained! Desirability reduced.`);
                    }
                }
                
                // AUTO-EVOLUTION: Update all zoned buildings
                const tilesArray = this.tiles;
                const popTotal = this.pop;
                const growthThreshold = CFG.GROWTH_THRESHOLD;
                const decayThreshold = CFG.DECAY_THRESHOLD;
                
                // Use cached housing capacity from recalc() - don't recalculate 40k tiles!
                let housingCap = this.housingCap || 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x];
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Age the zone (only every 10 years to slow progression)
                            if(!bld.age) bld.age = 0;
                            if(!bld.lastBirthYear) bld.lastBirthYear = this.year;
                            if(this.year % 10 === 0) bld.age++;
                            
                            // Calculate desirability
                            bld.desirability = this.calculateDesirability(x, y, 1);
                            
                            // NATURAL POPULATION BOOM: Every 10 years, zones generate bonus population
                            let yearsSinceBirth = this.year - bld.lastBirthYear;
                            if(yearsSinceBirth >= 10 && bld.desirability >= 1.0) {
                                // Calculate boom size: 1-2 base, +1 for high desirability, +1 for high level
                                let boomSize = 1 + Math.floor(Math.random() * 2);
                                if(bld.desirability >= 1.5) boomSize++;
                                if(bld.level >= 4) boomSize++;
                                
                                this.pop += boomSize;
                                bld.lastBirthYear = this.year;
                                
                                // Update building populations after population boom
                                if(typeof assignPopulationToResidential === 'function') {
                                    assignPopulationToResidential(this);
                                }
                                
                                if(Math.random() < 0.3) { // Only show some messages to avoid spam
                                    Controller.toast(`ğŸ‘¶ Population boom! +${boomSize} from established settlement`);
                                }
                            }
                            
                            // NOTE: maxLevel no longer used - building LEVEL only changes via player action
                            // Variant state (appearance) changes automatically based on desirability
                            
                            // Growth rate based on desirability - CHANGES VARIANT STATE, NOT LEVEL
                            // Level (zone tier) only changes when player builds/bulldozes
                            // Variant (0=Abandoned, 1=Low, 2=Medium, 3=High) changes based on desirability
                            if(!bld.variant) bld.variant = 1; // Default to Low variant
                            if(!bld.growth) bld.growth = 0;
                            
                            // Determine target variant based on desirability
                            let targetVariant = 1; // Default Low
                            if(bld.desirability < 0.1) targetVariant = 0; // Abandoned
                            else if(bld.desirability < 0.4) targetVariant = 1; // Low
                            else if(bld.desirability < 0.7) targetVariant = 2; // Medium
                            else targetVariant = 3; // High
                            
                            // Gradually move toward target variant
                            if(bld.variant < targetVariant) {
                                // Growing: desirability supports higher variant
                                let growthSpeed = 0.02; // Base (50 years to upgrade)
                                if(bld.desirability >= 1.0) growthSpeed = 0.04; // Faster (25 years)
                                if(bld.desirability >= 1.5) growthSpeed = 0.08; // Even faster (12.5 years)
                                if(bld.desirability >= 2.0) growthSpeed = 0.15; // Fast (6-7 years)
                                
                                bld.growth += growthSpeed;
                                
                                // Gathering logic: increase food production at medium/high variants
                                if(bld.variant >= 2) {
                                    let gatherBonus = 1.0;
                                    if(bld.variant === 2) gatherBonus = 1.25; // Medium
                                    if(bld.variant >= 3) gatherBonus = 1.5; // High
                                    this.food += gatherBonus;
                                }
                                
                                if(bld.growth >= 1.0) {
                                    bld.variant = Math.min(bld.variant + 1, 3); // Max variant is 3
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`ğŸ  Building upgraded to ${variantName}!`);
                                        }
                                    }
                                }
                            } else if(bld.variant > targetVariant && bld.variant > 0) {
                                // Decaying: desirability doesn't support current variant
                                bld.growth -= 0.05;
                                if(bld.growth <= -1.0) {
                                    bld.variant = Math.max(bld.variant - 1, 0); // Min variant is 0
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`ğŸ“‰ Building declined to ${variantName}`);
                                        }
                                    }
                                }
                            }
                            
                            // NOTE: Buildings player PAID FOR are not downgraded.
                            // The maxLevel only limits natural GROWTH, not existing buildings.
                            // This prevents frustration from losing expensive buildings.
                        }
                    }
                }
                
                // SIMCITY MODE - Modern city management
                if(this.simcityMode) {
                    // Use cached values from recalc() - PERFORMANCE FIX (no 40k tile iteration!)
                    let housingCap = this.housingCap || 0;
                    let avgDesirability = this.avgDesirability || 1.0;
                    let zoneCount = this.zoneCount || 0;
                    let jobs = 0;
                    let foodProduction = 0;
                    let woodProduction = 0;
                    
                    // Calculate jobs, food, and wood from buildings
                    // TILE BONUSES apply for strategic placement
                    this.blds.forEach(b => {
                        if(b.t === 'COM') {
                            jobs += Math.floor(100 * b.lvl * b.efficiency);
                            // Tree bonus: COM on tree = extra wood/year
                            if(b.treeBonus) {
                                let woodRate = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.TREE_WOOD_RATE : 5;
                                woodProduction += woodRate * b.lvl;
                            }
                        }
                        else if(b.t === 'IND') {
                            jobs += Math.floor(100 * b.lvl * b.efficiency);
                            foodProduction += Math.floor(50 * b.lvl * b.efficiency); // Industry still produces food
                            // Animal bonus: IND on animal = extra food/year
                            if(b.animalBonus) {
                                let foodRate = CFG.TILE_BONUSES ? CFG.TILE_BONUSES.ANIMAL_FOOD_RATE : 10;
                                foodProduction += foodRate * b.lvl;
                            }
                        }
                    });
                    
                    // Apply wood production from tree bonus
                    if(woodProduction > 0) {
                        this.wood = Number(this.wood) || 0;
                        this.wood += woodProduction;
                    }
                    
                    // Food remains relevant - population health
                    // Wealthier areas (high desirability) consume more food per person
                    
                    let foodNeeded = this.pop * (CFG.PRODUCTION.SIMCITY_FOOD_PER_PERSON || 0.1) * (avgDesirability > 1.5 ? (CFG.DESIRABILITY.WEALTH_FOOD_MULTIPLIER || 1.2) : 1.0);
                    foodNeeded = isNaN(foodNeeded) ? 0 : foodNeeded;
                    foodProduction = isNaN(foodProduction) ? 0 : foodProduction;
                    this.food = Number(this.food) || 0;
                    this.food += foodProduction;
                    this.food -= foodNeeded;
                    
                    // Starvation - population shrinks without food
                    if(this.food < 0) {
                        let starvation = Math.ceil(Math.abs(this.food) * (CFG.PRODUCTION.STARVATION_RATE || 0.1));
                        this.pop -= starvation;
                        this.pop = Math.max(0, this.pop);
                        this.food = 0;
                        Controller.toast(`âš ï¸ ${starvation} people starved! Need more Industrial!`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver('LEVEL1');
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver('LEVEL1');
                        return;
                    }
                    
                    // WATER SYSTEM: Wells are critical for survival
                    // Each well supports 100 people. No wells = death after 1 year
                    // Insufficient wells = population dies off from dehydration
                    let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                    let waterCapacity = wellCount * 100; // Each well supports 100 people
                    
                    if(wellCount === 0 && this.pop > 0) {
                        // NO WELLS AT ALL - instant death after 1 year
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // Die after 1 year with no wells
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(wellCount > 0 && this.pop > waterCapacity) {
                        // NOT ENOUGH WELLS - some people die of dehydration
                        let waterShortage = this.pop - waterCapacity;
                        let dehydrationDeaths = Math.ceil(waterShortage * 0.5); // 50% of those without water die
                        this.pop -= dehydrationDeaths;
                        this.pop = Math.max(1, this.pop);
                        Controller.toast(`ğŸ’€ WATER SHORTAGE! ${dehydrationDeaths} people died of thirst! Need more wells! (${wellCount} wells support ${waterCapacity} people)`);
                        
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                        this.yearsWithoutWell = 0;
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Population growth based on balance (see-saw)
                    let targetPop = Math.min(housingCap, jobs);
                    if(this.pop < targetPop && this.food > foodNeeded * 2) {
                        let growth = Math.floor((targetPop - this.pop) * CFG.PRODUCTION.SIMCITY_POPULATION_GROWTH_RATE);
                        this.pop += Math.max(1, growth);
                        this.pop = Math.min(this.pop, targetPop);
                    } else if(this.pop > housingCap) {
                        // BRUTAL OVERPOPULATION - homeless people are a massive drain
                        let homeless = this.pop - housingCap;
                        
                        // DISEASE: 25% of homeless die every year from overcrowding, disease, crime
                        let deaths = Math.ceil(homeless * 0.25);
                        this.pop -= deaths;
                        
                        // Economic collapse from chaos - 20% loss
                        let econLoss = Math.ceil(this.res * 0.20);
                        this.res = Math.max(0, this.res - econLoss);
                        
                        // Food waste and theft
                        let foodLoss = Math.ceil(this.food * 0.15);
                        this.food = Math.max(0, this.food - foodLoss);
                        
                        if(deaths > 10) {
                            Controller.toast(`â˜ ï¸ OVERCROWDING! ${deaths} homeless died! $${econLoss} economic collapse!`);
                        }
                    }
                    
                    // Income from buildings (NOW INTERDEPENDENT!)
                    // Uses new calculateIncome() which factors in population, desirability, and needs
                    let incR = this.calculateIncome();
                    
                    let maint = this.blds.length * 2;
                    this.res = Math.max(0, this.res + incR - maint);
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    this.recalc();
                    Controller.updateUI();
                    return;
                }
                
                // EPOCH 0 (Paleolithic) - BRUTAL SURVIVAL ECONOMY
                if(this.age === 0) {
                    // --- BRUTAL ECONOMY ---
                    
                    // 1. FOOD SPOILAGE (The Rot)
                    // Base capacity is just what people can carry/store without infrastructure
                    let storageCap = CFG.CONSTANTS.BASE_STORAGE;
                    this.blds.forEach(b => {
                        if(b.t === 'BASKET') storageCap += CFG.BUILDINGS.BASKET.cap;
                        if(b.t === 'POTTERY') storageCap += CFG.BUILDINGS.POTTERY.cap;
                        if(b.t === 'GRANARY') storageCap += CFG.BUILDINGS.GRANARY.cap;
                        if(b.t === 'PALACE') storageCap += CFG.BUILDINGS.PALACE.cap;
                    });

                    // If you have more food than storage, it rots FAST
                    if(this.food > storageCap) {
                        let rot = Math.floor((this.food - storageCap) * CFG.CONSTANTS.BASE_SPOILAGE);
                        this.food = Math.max(0, this.food - rot);
                        if(rot > 100 && Math.random() < 0.3) {
                            Controller.toast(`ğŸ‚ ${rot} food rotted! Need storage buildings!`);
                        }
                    }
                    
                    // 2. PRODUCTION & CONSUMPTION
                    let housingCap = this.housingCap || 0;
                    let homeless = Math.max(0, this.pop - housingCap);
                    let housed = this.pop - homeless;
                    
                    // Calculate average zone level for food production scaling
                    let totalLevel = 0;
                    let zoneCount = 0;
                    for(let x = 0; x < CFG.W; x++) {
                        for(let y = 0; y < CFG.H; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                let buildingLevel = tile.building.level || 1;
                                totalLevel += buildingLevel;
                                // Use level-specific capacity from BUILDING_LEVELS config
                                let levelConfig = CFG.BUILDING_LEVELS[buildingLevel - 1] || CFG.BUILDING_LEVELS[0];
                                zoneCount++;
                            }
                        }
                    }
                    let avgLevel = zoneCount > 0 ? totalLevel / zoneCount : 1;
                    
                    // Food production scales with civilization level (better tools, farming, etc.)
                    // Level 1: 1.0x, Level 3: 1.5x, Level 5: 2.0x, Level 8: 3.0x
                    let techMultiplier = 1.0 + (avgLevel - 1) * 0.3;
                    
                    // Food consumption scales FASTER than production (luxury goods, waste)
                    // Level 1: 1.0x, Level 3: 2.0x, Level 5: 3.5x, Level 8: 6.0x
                    let consumptionMultiplier = 1.0 + (avgLevel - 1) * 0.7;
                    
                    // ONLY HOUSED PEOPLE PRODUCE FOOD
                    let gathered = housed * CFG.PRODUCTION.PERSON_HUNTS * CFG.CONSTANTS.BASE_PROD * techMultiplier;
                    
                    // EVERYONE EATS, consumption scales faster than production
                    let housedConsumption = housed * CFG.CONSTANTS.FOOD_PER_PERSON * consumptionMultiplier;
                    let homelessConsumption = homeless * CFG.CONSTANTS.FOOD_PER_PERSON * 2.0; // Homeless eat DOUBLE
                    let eaten = housedConsumption + homelessConsumption;
                    
                    // Add hunting grounds production
                    let industrialCount = 0;
                    this.blds.forEach(b => {
                        if(b.t === 'IND' && PROGRESSION.stage >= 2 && b.forestProximity) {
                            // Check if built on STONE tiles (quarry mode)
                            let isQuarry = false;
                            let stoneMined = 0;
                            let metalExtracted = 0;
                            
                            for(let dx = 0; dx < 2; dx++) {
                                for(let dy = 0; dy < 2; dy++) {
                                    let tile = this.tiles[b.x + dx]?.[b.y + dy];
                                    if(tile && tile.type === 'STONE' && tile.resource && tile.resource.amount > 0) {
                                        isQuarry = true;
                                        // Mine stone from deposit
                                        let mineAmount = Math.min(100, tile.resource.amount);
                                        tile.resource.amount -= mineAmount;
                                        stoneMined += mineAmount;
                                        metalExtracted += mineAmount * tile.resource.metal_yield;
                                        
                                        // Notify when deposit depleted
                                        if(tile.resource.amount <= 0) {
                                            Controller.toast(`â›ï¸ Quarry stone deposit depleted!`);
                                        }
                                    }
                                }
                            }
                            
                            if(isQuarry) {
                                // Quarry mode: mine stone and extract metal
                                this.stone += stoneMined;
                                this.metal += metalExtracted;
                            } else {
                                // Hunting grounds mode: produce food
                                gathered += CFG.PRODUCTION.INDUSTRIAL_FOOD_PER_TURN;
                            }
                            industrialCount++;
                        }
                    });
                    
                    this.food += gathered;
                    this.food -= eaten;
                    
                    // 3. BRUTAL OVERPOPULATION (Disease, starvation, crime)
                    if(homeless > 0) {
                        let overcrowdingPct = homeless / this.pop; // 0.0 to 1.0
                        
                        // 1. CRIME & THEFT (Immediate Resource Drain)
                        // Desperate people steal food. 
                        // You lose 10% of your TOTAL stockpile per year.
                        let stolenFood = Math.ceil(this.food * 0.10); 
                        this.food = Math.max(0, this.food - stolenFood);

                        // 2. EXPOSURE (Constant Death)
                        // Living without shelter kills 15% of the homeless every turn.
                        let exposureDeaths = Math.ceil(homeless * 0.15);
                        this.pop -= exposureDeaths;

                        // 3. THE PLAGUE (The Civilization Killer)
                        // The chance of outbreak = 2x % of population that is homeless.
                        // If 20% are homeless, you have a 40% chance of Plague every turn.
                        if(Math.random() < (overcrowdingPct * 2)) {
                             // Plague kills 30% of EVERYONE (housed and homeless)
                             let plagueDeaths = Math.ceil(this.pop * 0.30);
                             this.pop -= plagueDeaths;
                             
                             // Economic Crash
                             let lostFunds = Math.ceil(this.res * 0.50);
                             this.res -= lostFunds;

                             Controller.toast(`â˜ ï¸ PLAGUE OUTBREAK! ${plagueDeaths} dead! Economy Collapsed!`);
                        } else {
                             // Just a warning if no plague this turn
                             if(exposureDeaths > 0) {
                                Controller.toast(`âš ï¸ Homeless: -${exposureDeaths} dead, -${stolenFood} food stolen.`);
                             }
                        }
                    }
                    
                    // 4. CHECK CAPACITY - use cached value from recalc() for PERFORMANCE
                    housingCap = this.housingCap || 0;
                    
                    // 4. STARVATION (THE DEATH SPIRAL)
                    if(this.food < 0) {
                        this.food = 0;
                        let deaths = Math.ceil(this.pop * CFG.CONSTANTS.STARVATION_DEATH);
                        this.pop = Math.max(0, this.pop - deaths);
                        Controller.toast(`ğŸ’€ FAMINE! ${deaths} people starved to death!`);
                    }
                    
                    // 5. WATER SHORTAGE - POPULATION ALWAYS DEPENDS ON FRESH WATER
                    // Calculate how many wells are needed - at least 1 well always required!
                    let wellsNeeded = Math.max(1, Math.ceil(this.pop / 100)); // 1 well per 100 people, minimum 1
                    let totalWellCount = this.blds.filter(b => b.t === 'WELL').length;
                    let staffedWells = this.staffedWells || 0;
                    
                    // Track years without ANY wells
                    if(totalWellCount === 0 && this.pop > 0) {
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // After 1 year with NO wells at all = instant death
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Even with wells, check if they're staffed
                    let wellShortage = Math.max(0, wellsNeeded - staffedWells);
                    
                    if(wellShortage > 0 && totalWellCount > 0) {
                        // Has wells but not enough or not staffed - people die
                        let baseDeathRate = 0.30; // 30% base annual death rate without enough water
                        let shortageMultiplier = wellShortage / Math.max(1, wellsNeeded);
                        let deathRate = Math.min(0.80, baseDeathRate * (1 + shortageMultiplier)); // Up to 80%
                        
                        let waterDeaths = Math.ceil(this.pop * deathRate);
                        this.pop = Math.max(0, this.pop - waterDeaths);
                        
                        Controller.toast(`ğŸ’€ WATER SHORTAGE! ${waterDeaths} died of thirst! Need ${wellShortage} more staffed wells! (${staffedWells}/${wellsNeeded})`);
                        
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(staffedWells > 0 && Math.random() < 0.1) {
                        // Occasional reminder that water is critical
                        Controller.toast(`ğŸ’§ Water secured: ${staffedWells} wells serving ${this.pop} people.`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver('LEVEL1');
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver('LEVEL1');
                        return;
                    }
                    
                    // 5. GROWTH LOGIC (Only if surplus exists AND under capacity)
                    else if(this.food > eaten * 1.5 && this.pop < housingCap) {
                        // Slow, realistic growth - 5% per year if well-fed
                        let growth = Math.max(1, Math.ceil(this.pop * 0.05));
                        this.pop = Math.min(this.pop + growth, housingCap);
                        if(growth > 1 && Math.random() < 0.3) {
                            Controller.toast(`ğŸ‘¶ ${growth} new tribe members born!`);
                        }
                    }
                    
                    // 6. CAPACITY WARNINGS
                    let industrialCapacity = industrialCount * CFG.PRODUCTION.INDUSTRIAL_SUPPORTS_POPULATION;
                    if(this.pop > industrialCapacity && industrialCount > 0) {
                        Controller.toast(`âš ï¸ Need more Hunting Grounds! (${industrialCount} supports ${industrialCapacity} pop)`);
                    }
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    // Check for industrial unlock
                    this.checkProgression();
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NaN PROTECTION - Ensure all resources are valid numbers
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(isNaN(this.food) || this.food === undefined || this.food === null) {
                    console.warn('âš ï¸ Food was NaN, resetting to 0');
                    this.food = 0;
                }
                if(isNaN(this.wood) || this.wood === undefined || this.wood === null) {
                    console.warn('âš ï¸ Wood was NaN, resetting to 0');
                    this.wood = 0;
                }
                if(isNaN(this.pop) || this.pop === undefined || this.pop === null) {
                    console.warn('âš ï¸ Pop was NaN, resetting to 0');
                    this.pop = 0;
                }
                if(isNaN(this.metal) || this.metal === undefined || this.metal === null) {
                    this.metal = 0;
                }
                if(isNaN(this.stone) || this.stone === undefined || this.stone === null) {
                    this.stone = 0;
                }
                
                this.recalc();
                Controller.updateUI();
                } catch(error) {
                    console.error('Error in endTurn:', error);
                    Controller.toast('Error processing turn!');
                }
            },
            toggleOrdinance() {
                if (this.ordinance) return;
                if (this.res < CFG.COST.ORD) return Controller.toast("Need Funds");
                this.res -= CFG.COST.ORD; this.ordinance = true; this.ordEnd = this.year + 20;
                Controller.toast("Act Enacted"); Controller.updateUI();
            }
        };

        const Controller = {
            cam: { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM }, 
            mx: 0, my: 0, tool: 'PAN', drag: false, last: {x:0, y:0},
            selectedBuildingLevel: 1, // Default to Level 1 Settlement (first buildable level)
            
            // Format numbers with M/B/T/Q suffixes
            formatNum(num) {
                if(num >= 1000000000000000) return (num/1000000000000000).toFixed(1) + 'Q'; // Quadrillion
                if(num >= 1000000000000) return (num/1000000000000).toFixed(1) + 'T'; // Trillion
                if(num >= 1000000000) return (num/1000000000).toFixed(1) + 'B'; // Billion
                if(num >= 1000000) return (num/1000000).toFixed(1) + 'M'; // Million
                if(num >= 1000) return (num/1000).toFixed(1) + 'K'; // Thousand
                return num.toString();
            },
            
            init() {
                // Capture console logs to technical log
                this.captureConsoleLogs();
                
                try {
                    console.log('Initializing Renderer...');
                    Renderer.init(); 
                    console.log('Initializing Game...');
                    Game.init(123);
                    console.log('Game initialized successfully');
                    // DELAY RENDER TO PREVENT 0-WIDTH BUG
                    setTimeout(() => {
                        console.log('Starting render loop...');
                        Renderer.resize();
                        let c = Renderer.cvs;
                        
                        // Keyboard controls for player movement (always available)
                        window.onkeydown = (e) => {
                            // DEBUG: Press 'B' to test build residential at player position
                            if(e.key === 'b' || e.key === 'B') {
                                if(Game.gameState === 'CITY' && Game.player) {
                                    console.log('=== DEBUG BUILD TEST ===');
                                    console.log('Attempting to build at player position:', Game.player.x, Game.player.y);
                                    console.log('Current tool:', this.tool);
                                    console.log('Selected level:', this.selectedBuildingLevel);
                                    Game.build('RES', Game.player.x, Game.player.y);
                                    e.preventDefault();
                                    return;
                                }
                            }
                            
                            // Settle shortcut (only in WANDER mode)
                            if((e.key === 'Enter' || e.key === ' ') && Game.gameState === 'WANDER') { 
                                Game.settleHere(); 
                                e.preventDefault(); 
                                return;
                            }
                            
                            if(e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') { Game.movePlayer(0, -1); e.preventDefault(); }
                            else if(e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') { Game.movePlayer(0, 1); e.preventDefault(); }
                            else if(e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') { Game.movePlayer(-1, 0); e.preventDefault(); }
                            else if(e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') { Game.movePlayer(1, 0); e.preventDefault(); }
                            // Diagonals
                            else if(e.key === 'q' || e.key === 'Q') { Game.movePlayer(-1, -1); e.preventDefault(); }
                            else if(e.key === 'e' || e.key === 'E') { Game.movePlayer(1, -1); e.preventDefault(); }
                            else if(e.key === 'z' || e.key === 'Z') { Game.movePlayer(-1, 1); e.preventDefault(); }
                            else if(e.key === 'c' || e.key === 'C') { Game.movePlayer(1, 1); e.preventDefault(); }
                        };
                        
                        c.onmousedown=e=>{ 
                            // Left click: build if tool selected, otherwise move/attack
                            if (e.button==0) {
                                console.log('Mouse down - Tool:', this.tool, 'Position:', this.mx, this.my);
                                if(this.tool !== 'NONE' && this.tool !== 'PAN') {
                                    // Building mode - available once settled
                                    console.log('Building mode detected, calling click()');
                                    this.click();
                                } else {
                                    // Click to move player or attack animals (works in both WANDER and CITY modes)
                                    if(Game.player) {
                                        // Check if clicking on an animal - instant kill
                                        let animalIndex = Game.animals.findIndex(a => a.x === this.mx && a.y === this.my);
                                        if(animalIndex !== -1) {
                                            // Trigger bash animation
                                            if(Game.player) Game.player.bashTime = performance.now();
                                            
                                            // Move to animal position
                                            Game.movePlayerToTile(this.mx, this.my);
                                            
                                            let animal = Game.animals[animalIndex];
                                            let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                                            let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                                            
                                            // HERD DANGER: Check if other animals are on same tile or adjacent
                                            let nearbyAnimals = Game.animals.filter((a, idx) => {
                                                if(idx === animalIndex) return false; // Skip self
                                                let dx = Math.abs(a.x - animal.x);
                                                let dy = Math.abs(a.y - animal.y);
                                                return dx <= 1 && dy <= 1; // Same tile or adjacent
                                            });
                                            
                                            let isHerd = nearbyAnimals.length > 0;
                                            let herdDamage = 0;
                                            
                                            if(isHerd && Game.gameState === 'WANDER') {
                                                // Herd attack - costs 1-3 population
                                                herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                                                Game.pop = Math.max(0, Game.pop - herdDamage);
                                                Controller.toast(`âš ï¸ Attacked by herd! Lost ${herdDamage} population! (${Game.pop} remaining)`);
                                                
                                                if(Game.pop === 0) {
                                                    Controller.toast("ğŸ’€ Your tribe has perished!");
                                                    // Game over logic could go here
                                                    Controller.updateUI();
                                                    return;
                                                }
                                            }
                                            
                                            if(Game.gameState === 'WANDER') {
                                                let totalInventory = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                                                let spaceAvailable = Game.inventory.capacity - totalInventory;
                                                
                                                // Build message with herd context
                                                let herdMsg = isHerd ? ` (Herd cost: ${herdDamage} pop)` : ' (Safe hunt!)';
                                                
                                                if(spaceAvailable >= config.foodReward) {
                                                    Game.inventory.food += config.foodReward;
                                                    Game.totalFoodCollected += config.foodReward;
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! +${config.foodReward} Food${herdMsg} ğŸ–`);
                                                } else if(spaceAvailable > 0) {
                                                    Game.inventory.food += spaceAvailable;
                                                    Game.totalFoodCollected += spaceAvailable;
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! +${spaceAvailable}/${config.foodReward} Food${herdMsg}`);
                                                } else {
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! Food lost - Inventory Full!${herdMsg}`);
                                                }
                                            } else {
                                                Game.food += config.foodReward;
                                                Controller.toast(`ğŸ¯ ${animalName} killed! +${config.foodReward} Food ğŸ–`);
                                            }
                                            
                                            Game.animals.splice(animalIndex, 1);
                                            Game.checkProgression();
                                            Controller.updateUI();
                                        } else {
                                            // Normal movement
                                            Game.movePlayerToTile(this.mx, this.my);
                                        }
                                    }
                                }
                            }
                            // Middle click or right click: pan camera
                            else if(e.button==1 || e.button==2) {
                                this.drag=true; 
                                this.last={x:e.clientX, y:e.clientY}; 
                                document.body.style.cursor='grabbing';
                            }
                        };
                        window.onmouseup=()=>{ this.drag=false; document.body.style.cursor='default'; };
                        window.onmousemove=e=>{
                            if (this.drag) {
                                this.cam.x -= (e.clientX-this.last.x)/this.cam.z; this.cam.y -= (e.clientY-this.last.y)/this.cam.z;
                                this.cam.x = Math.max(0, Math.min(6400, this.cam.x)); this.cam.y = Math.max(0, Math.min(6400, this.cam.y));
                                this.last={x:e.clientX, y:e.clientY};
                            }
                            let r=c.getBoundingClientRect();
                            let wx=(e.clientX-r.left-Renderer.w/2)/this.cam.z+this.cam.x; let wy=(e.clientY-r.top-Renderer.h/2)/this.cam.z+this.cam.y;
                            this.mx=Math.floor(wx/CFG.TILE); this.my=Math.floor(wy/CFG.TILE);
                            document.getElementById('debug').innerText=`Pos: ${this.mx}, ${this.my}`;
                        };
                        c.onwheel=e=>{ e.preventDefault(); let f=e.deltaY<0?CFG.ZOOM.STEP:1/CFG.ZOOM.STEP; this.cam.z=Math.max(CFG.ZOOM.MIN, Math.min(CFG.ZOOM.MAX, this.cam.z*f)); }, {passive:false};
                        const loop=()=> { 
                            try {
                                // Process player pathfinding automatically
                                if(Game.pathQueue && Game.pathQueue.length > 0) {
                                    Game.processPath();
                                }
                                
                                // AI autoplay
                                Game.aiUpdate();
                                
                                // Update building evolution states (every 60 frames = ~1 second)
                                Game.updateBuildingEvolution();
                                
                                // Render
                                Renderer.draw(this.cam);
                            } catch(err) {
                                console.error('Game loop error:', err);
                                // Continue running even if there's an error
                            }
                            requestAnimationFrame(loop); 
                        }; 
                        console.log('Starting animation loop...');
                        loop();
                    }, 200);
                } catch(e){
                    console.error('Initialization error:', e);
                    Controller.toast('ERROR: ' + e.message);
                }
            },
            click() {
                let gx=this.mx, gy=this.my;
                console.log('Click handler - Tool:', this.tool, 'Position:', gx, gy);
                if (this.tool!='NONE' && this.tool!='PAN') {
                    // Auto-settle UX: If trying to build Residential while still in WANDER, attempt to settle
                    if (this.tool === 'RES' && typeof Game !== 'undefined' && Game.gameState !== 'CITY') {
                        console.log('Attempting auto-settle before building RES...');
                        Controller.toast('ğŸ›ï¸ Settling so you can build...');
                        if (typeof Game.settleHere === 'function') {
                            Game.settleHere();
                            // If settlement succeeded, proceed to build
                            if (Game.gameState === 'CITY') {
                                console.log('Auto-settle succeeded, placing RES');
                                Game.build(this.tool, gx, gy);
                            } else {
                                console.log('Auto-settle failed due to requirements');
                                Controller.toast('âš ï¸ Settle first: Need water nearby + basic resources');
                            }
                            return;
                        }
                    }
                    console.log('Calling Game.build with:', this.tool, gx, gy);
                    Game.build(this.tool, gx, gy);
                } else {
                    console.log('Tool is NONE or PAN, not building');
                }
            },
            setTool(t) { 
                // Check if button is disabled
                let btnId = 't-' + t.toLowerCase();
                let btn = document.getElementById(btnId);
                if(btn && btn.disabled) {
                    Controller.toast(btn.title || 'ğŸ”’ This building is locked');
                    return;
                }
                
                this.tool=t; 
                document.querySelectorAll('.build-btn').forEach(b => b.classList.remove('active')); 
                let b=document.getElementById('b-'+t.toLowerCase()); 
                if(b) b.classList.add('active'); 
            },
            openBuildingMenu() {
                console.log('=== openBuildingMenu called ===');
                // Set default selection to Level 1 (first buildable level)
                if(this.selectedBuildingLevel === undefined || this.selectedBuildingLevel === 0) {
                    this.selectedBuildingLevel = 1;
                }
                
                // Dynamically generate building cards from BUILDING_DB
                let grid = document.getElementById('building-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedLevels.includes(levelNum);
                    let isSelected = this.selectedBuildingLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'ğŸ ';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectBuildingLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    
                    // Show unlock requirements if locked
                    let unlockText = '';
                    if(!isUnlocked && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(Controller.formatNum(req.pop) + ' pop');
                        if(req.buildings) {
                            parts.push(req.buildings.count + 'x ' + req.buildings.type + ' L' + req.buildings.level);
                        }
                        unlockText = 'ğŸ”’ ' + parts.join(' + ');
                        costText = unlockText;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${icon}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">Cap: ${Controller.formatNum(building.capacity)}</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('building-menu-panel').style.display = 'block';
            },
            closeBuildingMenu() {
                document.getElementById('building-menu-panel').style.display = 'none';
            },
            
            // Industrial menu functions
            openIndustrialMenu() {
                console.log('=== openIndustrialMenu called ===');
                // Set default selection to Level 1
                if(this.selectedIndustrialLevel === undefined || this.selectedIndustrialLevel === 0) {
                    this.selectedIndustrialLevel = 1;
                }
                
                // Dynamically generate industrial cards from BUILDING_DB
                let grid = document.getElementById('industrial-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('INDUSTRIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedIndustrialLevels.includes(levelNum);
                    let isSelected = this.selectedIndustrialLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'ğŸ­';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-ind-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectIndustrialLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    if(!isUnlocked) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(levelNum, Game);
                        costText = info.text;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${icon}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">Cap: ${building.capacity} workers</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('industrial-menu-panel').style.display = 'block';
            },
            closeIndustrialMenu() {
                document.getElementById('industrial-menu-panel').style.display = 'none';
            },
            selectIndustrialLevel(level) {
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.selectedIndustrialLevel = level;
                
                // Update card styling
                document.querySelectorAll('#industrial-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                let card = document.getElementById('card-ind-level-' + level);
                if(card) card.classList.add('selected');
                
                Controller.toast(`Selected: ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            confirmIndustrialSelection() {
                let level = this.selectedIndustrialLevel || 1;
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.closeIndustrialMenu();
                this.setTool('IND');
                Controller.toast(`ğŸ­ Click to place ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ROADS MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedRoadLevel: 1,
            
            openRoadMenu() {
                console.log('=== openRoadMenu called ===');
                this.selectedRoadLevel = 1;
                this.updateRoadUnlocks();
                document.getElementById('road-menu-panel').style.display = 'block';
            },
            closeRoadMenu() {
                document.getElementById('road-menu-panel').style.display = 'none';
            },
            updateRoadUnlocks() {
                // Only Path (level 1) is unlocked for now
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) {
                        card.classList.remove('selected');
                        if(i === 1) {
                            card.classList.remove('level-locked');
                        } else {
                            card.classList.add('level-locked');
                        }
                    }
                }
                let card1 = document.getElementById('card-road-1');
                if(card1) card1.classList.add('selected');
            },
            selectRoadLevel(level) {
                if(level !== 1) {
                    Controller.toast('ğŸ”’ Locked! Only Path is available.');
                    return;
                }
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) card.classList.remove('selected');
                }
                let card = document.getElementById('card-road-' + level);
                if(card) card.classList.add('selected');
                this.selectedRoadLevel = level;
                Controller.toast('Selected: Path');
            },
            confirmRoadSelection() {
                this.closeRoadMenu();
                this.setTool('ROAD');
                Controller.toast('ğŸ›£ï¸ Click to place Path ($5)');
            },
            
            updateNeedsWarning() {
                // Only show in SimCity mode and if population is reasonable
                if(!Game.simcityMode || Game.pop < 5) {
                    document.getElementById('needs-warning-panel').style.display = 'none';
                    return;
                }
                
                let panel = document.getElementById('needs-warning-panel');
                let needsList = document.getElementById('needs-list');
                let satisfactionBar = document.getElementById('satisfaction-bar');
                
                let warnings = [];
                let colors = {
                    housing: '#FF6B6B',     // Red
                    water: '#4ECDC4',       // Teal
                    food: '#FFD93D',        // Yellow
                    jobs: '#6BCF7F',        // Green
                    paths: '#A78BFA'        // Purple
                };
                
                // Check each need
                if(Game.needs.housing.satisfied < 0.5) {
                    warnings.push(`ğŸ  Housing CRITICAL (${Game.needs.housing.shortage} homeless)`);
                } else if(Game.needs.housing.satisfied < 0.8) {
                    warnings.push(`ğŸ  Housing needed (${Game.needs.housing.shortage} shortage)`);
                }
                
                if(Game.needs.water.satisfied < 0.5 && Game.pop >= 10) {
                    warnings.push(`ğŸ’§ Water CRITICAL (need ${Game.needs.water.shortage} wells)`);
                } else if(Game.needs.water.satisfied < 0.8 && Game.pop >= 10) {
                    warnings.push(`ğŸ’§ Water needed (${Game.needs.water.shortage} wells)`);
                }
                
                if(Game.needs.food.satisfied < 0.3) {
                    warnings.push(`ğŸŒ¾ Food CRITICAL - reserves low!`);
                } else if(Game.needs.food.satisfied < 0.6) {
                    warnings.push(`ğŸŒ¾ Food low - build industry`);
                }
                
                if(Game.needs.jobs.satisfied < 0.7 && Game.pop > 20) {
                    warnings.push(`ğŸ’¼ Jobs needed (${Game.needs.jobs.shortage} unemployed)`);
                }
                
                if(Game.needs.paths.satisfied < 0.5 && Game.zoneCount > 3) {
                    warnings.push(`ğŸ›¤ï¸ Paths needed (${Game.needs.paths.shortage} tiles)`);
                }
                
                // If no warnings, show satisfaction message
                if(warnings.length === 0) {
                    needsList.innerHTML = `<span style="color: #6BCF7F;">âœ“ All needs met!</span>`;
                    panel.style.border = '2px solid #6BCF7F';
                    panel.style.boxShadow = '0 8px 25px rgba(107,207,127,0.3)';
                } else {
                    needsList.innerHTML = warnings.map(w => `<div>â€¢ ${w}</div>`).join('');
                    panel.style.border = '2px solid #FF6B6B';
                    panel.style.boxShadow = '0 8px 25px rgba(255,107,107,0.3)';
                }
                
                // Update satisfaction bar
                let satisfaction = Game.needs.overall || 1.0;
                let satPercent = Math.floor(satisfaction * 100);
                satisfactionBar.style.width = (satisfaction * 100) + '%';
                satisfactionBar.textContent = satPercent + '%';
                
                // Color code the bar
                if(satisfaction >= 0.8) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #6BCF7F 0%, #4CAF50 100%)';
                } else if(satisfaction >= 0.5) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FFD93D 0%, #FFA726 100%)';
                } else {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FF6B6B 0%, #C62828 100%)';
                }
                
                panel.style.display = 'block';
            },
            updateBuildingUnlocks() {
                let pop = Game.pop;
                
                // Level 0 removed - WANDER epoch only, no building placement
                
                // Level 1 (Pit) - Always unlocked (first buildable level)
                let card1 = document.getElementById('card-level-1');
                card1.classList.remove('level-locked');
                card1.querySelector('.level-cost').textContent = 'Cost: 100 Food + 100 Wood';
                
                // Level 2 (Leather Tent) - Unlock at 50 pop
                let card2 = document.getElementById('card-level-2');
                if(pop >= 50) {
                    card2.classList.remove('level-locked');
                    card2.querySelector('.level-cost').textContent = 'Cost: 300 Food + 300 Wood';
                } else {
                    card2.classList.add('level-locked');
                    card2.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 50 Population';
                }
                
                // Level 3 (Mud Brick) - Unlock at 200 pop
                let card3 = document.getElementById('card-level-3');
                if(pop >= 200) {
                    card3.classList.remove('level-locked');
                    card3.querySelector('.level-cost').textContent = 'Cost: 900 Food + 900 Wood';
                } else {
                    card3.classList.add('level-locked');
                    card3.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 200 Population';
                }
                
                // Level 4 (Stone House) - Unlock at 500 pop
                let card4 = document.getElementById('card-level-4');
                if(pop >= 500) {
                    card4.classList.remove('level-locked');
                    card4.querySelector('.level-cost').textContent = 'Cost: 300 Food + 50 Wood + 100 Stone';
                } else {
                    card4.classList.add('level-locked');
                    card4.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 500 Population';
                }
                
                // Auto-select highest unlocked level
                let highestUnlocked = 0;
                if(pop >= 500) highestUnlocked = 4;
                else if(pop >= 200) highestUnlocked = 3;
                else if(pop >= 50) highestUnlocked = 2;
                else if(pop >= 10) highestUnlocked = 1;
                
                // If current selection is locked, switch to highest unlocked
                if(this.selectedBuildingLevel > highestUnlocked) {
                    this.selectBuildingLevel(highestUnlocked);
                }
            },
            selectBuildingLevel(level) {
                // Check if this level is locked
                let card = document.getElementById('card-level-' + level);
                if(!card) {
                    console.error('Card not found for level:', level);
                    return;
                }
                if(card.classList.contains('level-locked')) {
                    // Get actual unlock requirements from BUILDING_DB
                    let building = CFG.BUILDING_DB['RES_' + level];
                    if(building && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(`${Controller.formatNum(req.pop)} population`);
                        if(req.buildings) {
                            parts.push(`${req.buildings.count}x ${req.buildings.type} L${req.buildings.level}`);
                        }
                        Controller.toast(`ğŸ”’ Locked! Need: ${parts.join(' + ')}`);
                    } else {
                        Controller.toast(`ğŸ”’ This level is locked`);
                    }
                    return;
                }
                
                // Remove selected class from all cards (only levels 1-4 exist)
                for(let i = 1; i <= 4; i++) {
                    let c = document.getElementById('card-level-' + i);
                    if(c) c.classList.remove('selected');
                }
                // Add selected class to chosen card
                card.classList.add('selected');
                this.selectedBuildingLevel = level;
            },
            confirmBuildingSelection() {
                let levelConfig = CFG.BUILDING_LEVELS[this.selectedBuildingLevel];
                console.log('confirmBuildingSelection: Level', this.selectedBuildingLevel, 'Config:', levelConfig);
                this.closeBuildingMenu();
                this.tool = 'RES';
                console.log('Tool set to RES, current tool value:', this.tool);
                
                // Highlight the residential button to show it's active
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                let resBtn = document.getElementById('t-res');
                if(resBtn) {
                    resBtn.classList.add('active');
                    console.log('Residential button activated, tool set to RES');
                } else {
                    console.error('t-res button not found!');
                }
                
                Controller.toast(`Ready to build: ${levelConfig.name} (Capacity: ${levelConfig.capacity})`);
                
                // TEST: Try to build immediately at player position as a test
                if(Game.player) {
                    console.log('TEST: Attempting to build at player position:', Game.player.x, Game.player.y);
                }
            },
            setBuildingLevel(level) {
                this.selectedBuildingLevel = level;
                let levelConfig = CFG.BUILDING_LEVELS[level];
                Controller.toast(`Selected: ${levelConfig.name} (Cap: ${levelConfig.capacity})`);
            },
            toggleView() { 
                // Cycle through view modes: NORMAL -> DESIRABILITY -> BIRDSEYE -> POL -> NORMAL
                let modes = ['NORMAL', 'DESIRABILITY', 'BIRDSEYE', 'POL'];
                let currentIndex = modes.indexOf(Game.vm);
                Game.vm = modes[(currentIndex + 1) % modes.length];
                
                let btn = document.getElementById('btn-view');
                let icons = { 'NORMAL': 'ğŸ‘ï¸', 'DESIRABILITY': 'ğŸ”¥', 'BIRDSEYE': 'ğŸ¨', 'POL': 'â˜¢ï¸' };
                let titles = { 'NORMAL': 'Normal View', 'DESIRABILITY': 'Desirability Heatmap', 'BIRDSEYE': 'Birds Eye View (No UI)', 'POL': 'Pollution View' };
                btn.innerText = icons[Game.vm];
                btn.title = titles[Game.vm];
                Controller.toast(`View: ${titles[Game.vm]}`);
            },
            toggleAI() {
                // Use external AI module's toggle function
                let enabled = AI.toggle();
                
                // Update game state for compatibility
                Game.aiEnabled = enabled;
                
                // Update UI
                let btn = document.getElementById('btn-ai');
                btn.innerText = 'ğŸ¤–';
                btn.title = enabled ? 'AI Autoplay: ON' : 'Toggle AI Autoplay';
                btn.style.background = enabled ? '#4CAF50' : '';
                Controller.toast(enabled ? 'ğŸ¤– AI Autoplay Enabled' : 'ğŸ¤– AI Autoplay Disabled');
            },
            toggleBuildPanel() {
                let sidebar = document.getElementById('sidebar');
                if(sidebar.style.display === 'none' || sidebar.style.display === '') {
                    sidebar.style.display = 'block';
                    document.getElementById('btn-build').style.background = '#4CAF50';
                } else {
                    sidebar.style.display = 'none';
                    document.getElementById('btn-build').style.background = '#444';
                }
            },
            showCityUI() {
                console.log('=== showCityUI START ===');
                console.log('Game.gameState:', Game.gameState);
                
                // Force CITY mode
                Game.gameState = 'CITY';
                console.log('Forced gameState to CITY');
                
                // Hide wander mode buttons
                try {
                    let settleBtn = document.getElementById('btn-settle');
                    if(settleBtn) {
                        settleBtn.style.display = 'none';
                        console.log('Hid settlement button');
                    }
                } catch(e) {
                    console.error('Error hiding settlement button:', e);
                }
                
                // Show build tools
                console.log('Showing build tools...');
                try {
                    let elements = {
                        't-road': document.getElementById('t-road'),
                        't-well': document.getElementById('t-well'),
                        't-demolish': document.getElementById('t-demolish'),
                        't-res': document.getElementById('t-res'),
                        't-com': document.getElementById('t-com'),
                        't-ind': document.getElementById('t-ind'),
                        't-chief': document.getElementById('t-chief'),
                        't-basket': document.getElementById('t-basket'),
                        't-pottery': document.getElementById('t-pottery'),
                        't-granary': document.getElementById('t-granary'),
                        't-palace': document.getElementById('t-palace'),
                        'sep1': document.getElementById('sep1'),
                        'sep2': document.getElementById('sep2'),
                        'btn-turn': document.getElementById('btn-turn'),
                        'btn-view': document.getElementById('btn-view')
                    };
                    for(let id in elements) {
                        if(elements[id]) {
                            elements[id].style.display = 'inline-block';
                            // Special: always enable t-res in city mode
                            if(id === 't-res') {
                                elements[id].disabled = false;
                                elements[id].style.display = 'inline-block';
                                elements[id].title = 'Build Residential';
                            }
                            console.log('Showed:', id);
                        } else {
                            console.error('Element not found:', id);
                        }
                    }
                } catch(e) {
                    console.error('Error showing build tools:', e);
                }
                
                console.log('Build tools shown');
                
                // Initialize building level selector (default to highest unlocked level)
                if(Controller.selectedBuildingLevel === undefined) {
                    Controller.selectedBuildingLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    console.log('Set default building level to', Controller.selectedBuildingLevel);
                }
                
                console.log('Checking progression locks...');
                
                // Check progression and disable locked buildings
                // Industrial is unlocked at stage 2 (after settlement triggers stage 1 â†’ 2 transition)
                let industrialUnlocked = PROGRESSION.stage >= 2;
                let simcityUnlocked = Game.simcityMode;
                
                // Commercial (campfire) - unlocked after first residential zone at epoch 1
                let btnCom = document.getElementById('t-com');
                btnCom.disabled = false; // Always available in city mode
                btnCom.title = 'Build campfire to unlock commerce';
                
                // Industrial (Hunting Ground) - always available in city mode (after settlement)
                let btnInd = document.getElementById('t-ind');
                // In CITY mode, industrial is always unlocked
                btnInd.disabled = false;
                btnInd.title = 'Build hunting ground (1000 food + 1000 wood)';
                
                // Chief's Hut - requires simcity mode
                let btnChief = document.getElementById('t-chief');
                if(!simcityUnlocked) {
                    btnChief.disabled = true;
                    btnChief.title = `ğŸ”’ LOCKED: Build campfire first (${CFG.PRODUCTION.SIMCITY_MODE_UNLOCK_COST} food)`;
                } else {
                    btnChief.disabled = false;
                    btnChief.title = "Chief's Hut (10,000 food)";
                }
                
                // Storage buildings - require simcity mode
                let btnBasket = document.getElementById('t-basket');
                let btnPottery = document.getElementById('t-pottery');
                let btnGranary = document.getElementById('t-granary');
                let btnPalace = document.getElementById('t-palace');
                
                if(!simcityUnlocked) {
                    btnBasket.disabled = true;
                    btnBasket.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnPottery.disabled = true;
                    btnPottery.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnGranary.disabled = true;
                    btnGranary.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnPalace.disabled = true;
                    btnPalace.title = `ğŸ”’ LOCKED: Build campfire first`;
                } else {
                    btnBasket.disabled = false;
                    btnBasket.title = 'Basket (500 food) - +25 storage';
                    btnPottery.disabled = false;
                    btnPottery.title = 'Pottery (5,000 food) - +100 storage';
                    btnGranary.disabled = false;
                    btnGranary.title = 'Granary (50,000 food) - +500 storage';
                    btnPalace.disabled = false;
                    btnPalace.title = 'Palace (250,000 food) - +2,500 storage';
                }
                
                // Show city stats
                document.getElementById('stat-year').style.display = 'flex';
                document.getElementById('stat-water').style.display = 'flex';
                document.getElementById('stat-funds').style.display = 'flex';
                
                // Show camera control arrows (if they exist)
                let camUp = document.getElementById('cam-up');
                let camDown = document.getElementById('cam-down');
                let camLeft = document.getElementById('cam-left');
                let camRight = document.getElementById('cam-right');
                if (camUp) camUp.style.display = 'block';
                if (camDown) camDown.style.display = 'block';
                if (camLeft) camLeft.style.display = 'block';
                if (camRight) camRight.style.display = 'block';
                
                console.log('showCityUI() complete');
                
                // Visual confirmation
                setTimeout(() => {
                    Controller.toast('ğŸ—ï¸ City Build Mode Active! Click Residential to start building.');
                }, 200);
            },
            formatNumber(num) {
                // Use the same formatter as formatNum for consistency
                return this.formatNum(num);
            },
            updateUI() {
                // Show population differently in WANDER vs CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}`;
                } else {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}/${this.formatNumber(Game.housingCap)}`;
                }
                document.getElementById('v-res').innerText = this.formatNumber(Math.floor(Game.res));
                
                // Show inventory food in WANDER mode, regular food in CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-food').innerText = `${this.formatNumber(Math.floor(Game.inventory.food))}/${this.formatNumber(Game.inventory.capacity)}`;
                    document.getElementById('v-wood').innerText = Math.floor(Game.inventory.wood);
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show inventory metal/stone (from active collection) + pocket (passive finds)
                    let wanderMetal = Math.floor(Game.inventory.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let wanderStone = Math.floor(Game.inventory.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    document.getElementById('v-metal').innerText = wanderMetal;
                    document.getElementById('v-stone').innerText = wanderStone;
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    // Show total inventory
                    let totalInv = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                    document.getElementById('v-inventory').innerText = `${Math.floor(totalInv)}/${Game.inventory.capacity}`;
                    document.getElementById('stat-inventory').style.display = 'flex';
                    
                    // Show thirst indicator in WANDER mode
                    document.getElementById('stat-thirst').style.display = 'flex';
                    let thirstEl = document.getElementById('v-thirst');
                    let thirst = Game.thirst || 100;
                    thirstEl.innerText = thirst;
                    // Color code thirst level
                    if(thirst > 50) thirstEl.style.color = '#29B6F6'; // Blue - good
                    else if(thirst > 25) thirstEl.style.color = '#FFA726'; // Orange - warning
                    else thirstEl.style.color = '#E53935'; // Red - critical
                } else {
                    document.getElementById('v-food').innerText = this.formatNumber(Math.floor(Game.food));
                    // Show wood in CITY mode (needed for upkeep)
                    document.getElementById('v-wood').innerText = Math.floor(Game.wood);
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show metal and stone (from inventory + pocket)
                    let totalMetal = Math.floor(Game.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let totalStone = Math.floor(Game.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    
                    document.getElementById('v-metal').innerText = totalMetal;
                    document.getElementById('v-stone').innerText = totalStone;
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    document.getElementById('stat-inventory').style.display = 'none';
                    document.getElementById('stat-thirst').style.display = 'none'; // Hide thirst in CITY mode
                }

                let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                let comCount = Game.blds.filter(b => b.t === 'COM').length;
                let indCount = Game.blds.filter(b => b.t === 'IND').length;
                
                // Update water display using staffed wells from workforce system
                let staffedWells = Game.staffedWells || 0;
                let totalWells = Game.wellCount || wellCount;
                let waterNeeded = Math.ceil(Game.pop / 100); // 1 staffed well per 100 people
                let waterStatus = `${staffedWells}/${waterNeeded}`;
                if(staffedWells < waterNeeded) waterStatus = `âš ï¸ ${waterStatus}`;
                if(totalWells > staffedWells) waterStatus += ` (${totalWells - staffedWells} unstaffed)`;
                document.getElementById('v-wat').innerText = waterStatus;
                
                document.getElementById('v-nomad').innerText = Game.nomadsFound;
                document.getElementById('v-year').innerText = Game.year;
                
                // Update workforce display (only in CITY mode)
                if(Game.gameState === 'CITY' && Game.workforce) {
                    let wf = Game.workforce;
                    let workforceEl = document.getElementById('v-workforce');
                    if(workforceEl) {
                        let status = `ğŸ‘· ${wf.gatherers} gathering`;
                        if(wf.shortage > 0) {
                            status = `âš ï¸ ${wf.shortage} workers short! ${wf.gatherers} gathering`;
                        }
                        workforceEl.innerText = status;
                        document.getElementById('stat-workforce').style.display = 'flex';
                    }
                } else {
                    let workforceEl = document.getElementById('stat-workforce');
                    if(workforceEl) workforceEl.style.display = 'none';
                }
                
                // Update health display - HIDE in Epoch 0 (population IS health)
                // Health display removed - player health is now tied to population
                
                // Dynamic contextual guidance based on game state
                if(PROGRESSION.stage === 0) {
                    // Exploration phase - keep it open-ended
                    document.getElementById('v-epoch').innerText = `ğŸŒ EXPLORING THE WORLD`;
                } else if(PROGRESSION.stage === 1) {
                    // Settlement phase - simple status
                    document.getElementById('v-epoch').innerText = `ğŸ•ï¸ BUILDING SETTLEMENT`;
                } else if(PROGRESSION.stage === 2 && Game.age === 0) {
                    // Paleolithic - simple status
                    document.getElementById('v-epoch').innerText = `ğŸ¹ PALEOLITHIC AGE`;
                } else {
                    // Advanced ages - just show current age
                    let ageName = AGES[Game.age].n;
                    document.getElementById('v-epoch').innerText = `âš”ï¸ ${ageName.toUpperCase()} AGE`;
                }
                
                // UPDATE NEEDS WARNING PANEL
                this.updateNeedsWarning();
                
                // Update RCI demand meters (SimCity-style interdependent balance)
                if(Game.gameState === 'CITY') {
                    document.getElementById('rci-meters').style.display = 'block';
                    
                    // Use centralized RCI calculation (shared with AI)
                    let rci = Game.calculateRCIDemand();
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    
                    // Update the visual bars
                    let rBar = document.getElementById('r-bar-fill');
                    let cBar = document.getElementById('c-bar-fill');
                    let iBar = document.getElementById('i-bar-fill');
                    
                    if(rBar) rBar.style.height = rci.r + '%';
                    if(cBar) cBar.style.height = rci.c + '%';
                    if(iBar) iBar.style.height = rci.i + '%';
                    
                    // Update tooltip with counts
                    let tooltip = document.getElementById('rci-tooltip');
                    if(tooltip) {
                        tooltip.innerText = `R:${resCount} C:${comCount} I:${indCount}`;
                    }
                } else {
                    document.getElementById('rci-meters').style.display = 'none';
                }
            },
            currentLogView: 'player',
            captureConsoleLogs() {
                // Store original console methods
                const originalLog = console.log;
                const originalError = console.error;
                const originalWarn = console.warn;
                const originalInfo = console.info;
                
                // Initialize technical log if needed
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Override console.log
                console.log = function(...args) {
                    originalLog.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [LOG] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.error - Enhanced with auto-toast for critical errors
                console.error = function(...args) {
                    originalError.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [ERROR] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                    
                    // AUTO-ALERT: Flash toast RED immediately on any error
                    // This ensures testers/AI notice when something breaks
                    if(typeof Controller !== 'undefined' && Controller.toast) {
                        Controller.toast(`âš ï¸ ERROR: ${msg.substring(0, 80)}...`, true);
                    }
                    
                    // Optional: Auto-open log modal on critical errors (uncomment to enable)
                    // if(typeof Controller !== 'undefined' && Controller.showLog) {
                    //     Controller.showLog();
                    //     Controller.switchLog('technical');
                    // }
                };
                
                // Override console.warn
                console.warn = function(...args) {
                    originalWarn.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [WARN] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.info
                console.info = function(...args) {
                    originalInfo.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [INFO] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
            },
            toast(m, isError = false) { 
                let t = document.getElementById('toast'); 
                t.innerText = m; 
                t.style.opacity = 1; 
                if(isError) t.style.background = '#F44336';
                else t.style.background = 'rgba(0,0,0,0.85)';
                setTimeout(() => t.style.opacity = 0, 2000); 
                
                // Initialize logs if needed
                if(!Game.playerLog) Game.playerLog = [];
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Add to player log (user-friendly messages)
                let timestamp = `[Y${Game.year || 0}]`;
                Game.playerLog.push(`${timestamp} ${m}`);
                if(Game.playerLog.length > 200) Game.playerLog.shift();
                
                // Add to technical log with more detail
                let techTimestamp = new Date().toLocaleTimeString();
                Game.technicalLog.push(`[${techTimestamp}] ${m}`);
                if(Game.technicalLog.length > 500) Game.technicalLog.shift();
            },
            switchLog(type) {
                this.currentLogView = type;
                let playerBtn = document.getElementById('btn-player-log');
                let techBtn = document.getElementById('btn-technical-log');
                
                if(type === 'player') {
                    playerBtn.style.background = '#4CAF50';
                    playerBtn.style.fontWeight = 'bold';
                    techBtn.style.background = '#333';
                    techBtn.style.fontWeight = 'normal';
                } else {
                    playerBtn.style.background = '#333';
                    playerBtn.style.fontWeight = 'normal';
                    techBtn.style.background = '#4CAF50';
                    techBtn.style.fontWeight = 'bold';
                }
                
                this.updateLogDisplay();
            },
            updateLogDisplay() {
                let content = document.getElementById('log-content');
                if(this.currentLogView === 'player') {
                    if(!Game.playerLog || Game.playerLog.length === 0) {
                        content.innerText = 'No player events logged yet.';
                    } else {
                        content.innerText = Game.playerLog.join('\n');
                    }
                } else {
                    if(!Game.technicalLog || Game.technicalLog.length === 0) {
                        content.innerText = 'No technical events logged yet.';
                    } else {
                        content.innerText = Game.technicalLog.join('\n');
                    }
                }
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
            },
            copyLog() {
                let content = document.getElementById('log-content');
                let text = content.innerText;
                
                navigator.clipboard.writeText(text).then(() => {
                    this.toast('ğŸ“‹ Log copied to clipboard!');
                }).catch(err => {
                    // Fallback for older browsers
                    let textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        this.toast('ğŸ“‹ Log copied to clipboard!');
                    } catch(err) {
                        this.toast('âŒ Failed to copy log', true);
                    }
                    document.body.removeChild(textarea);
                });
            },
            showLog() {
                this.updateLogDisplay();
                document.getElementById('log-modal').style.display = 'flex';
            },
            hideLog() {
                document.getElementById('log-modal').style.display = 'none';
            },
            reset() {
                try {
                    console.log('Resetting game...');
                    // Set camera and tool
                    this.cam = { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM };
                    this.tool = 'PAN';
                    // Reset progression
                    PROGRESSION.reset();
                    // Reset game state
                    if (typeof Game === 'object') {
                        Game.gameState = 'WANDER';
                        Game.simcityMode = false;
                        Game.gatheringMultiplier = 1.0;
                        Game.age = 0;
                        Game.pop = 4;
                        Game.food = 0;
                        Game.wood = 0;
                        Game.metal = 0;
                        Game.stone = 0;
                        Game.res = 0;
                        Game.year = 0;
                        Game.nomadsFound = 0;
                        Game.totalFoodCollected = 0;
                        Game.housingCap = 0;
                        Game.blds = [];
                        Game.animals = [];
                        Game.pathQueue = [];
                        Game.player = null;
                        Game.inventory = { food: 0, wood: 0, metal: 0, stone: 0, capacity: CFG.INVENTORY.BACKPACK_BASE };
                        Game.pocket = { metal: 0, stone: 0 };
                    }
                    // Re-initialize game
                    Game.init(Math.floor(Math.random() * 999999));
                    // Hide all city building buttons (with null checks)
                    const hideElement = (id) => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = 'none';
                    };
                    const showElement = (id, display = 'inline-block') => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = display;
                    };
                    hideElement('t-res');
                    hideElement('t-com');
                    hideElement('t-ind');
                    hideElement('t-road');
                    hideElement('t-well');
                    hideElement('t-chief');
                    hideElement('t-basket');
                    hideElement('t-pottery');
                    hideElement('t-granary');
                    hideElement('t-palace');
                    hideElement('t-demolish');
                    hideElement('sep1');
                    hideElement('sep2');
                    hideElement('btn-turn');
                    hideElement('btn-view');
                    hideElement('t-bull');
                    hideElement('stat-funds');
                    hideElement('stat-water');
                    hideElement('stat-nomad');
                    hideElement('stat-year');
                    hideElement('stat-workforce');
                    hideElement('cam-up');
                    hideElement('cam-down');
                    hideElement('cam-left');
                    hideElement('cam-right');
                    hideElement('building-menu-panel');
                    hideElement('rci-meters');
                    // Show wander mode buttons
                    showElement('btn-settle');
                    this.updateUI();
                    console.log('Game reset complete!');
                } catch(err) {
                    console.error('Reset error:', err);
                    // Force page reload as fallback
                    location.reload();
                }
            },
            
            showStatsMenu() {
                try {
                    this.updateStatsMenu();
                    let menu = document.getElementById('stats-menu');
                    let overlay = document.getElementById('stats-overlay');
                    if(menu && overlay) {
                        menu.style.display = 'block';
                        overlay.style.display = 'block';
                    } else {
                        console.error('Stats menu elements not found!', {menu, overlay});
                        this.toast('âŒ Stats menu not available', true);
                    }
                } catch(e) {
                    console.error('Error showing stats menu:', e);
                    this.toast('âŒ Error opening stats', true);
                }
            },
            
            hideStatsMenu() {
                document.getElementById('stats-menu').style.display = 'none';
                document.getElementById('stats-overlay').style.display = 'none';
            },
            
            updateStatsMenu() {
                let html = '';
                
                // Time & Progress Stats
                html += '<div style="margin-bottom:10px;"><strong style="color:#81C784;">â±ï¸ Progress</strong></div>';
                html += `<div>Year: ${Game.year || 0}</div>`;
                html += `<div>Turns Played: ${Game.turn || 0}</div>`;
                html += `<div>Game Mode: ${Game.gameState}</div>`;
                
                // Population Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#FF7043;">ğŸ‘¥ Population</strong></div>';
                    html += `<div>Total Population: ${this.formatNumber(Game.pop)}</div>`;
                    html += `<div>Population Capacity: ${this.formatNumber(Game.popCap)}</div>`;
                    
                    let resBuildings = Game.blds.filter(b => b.t === 'RES');
                    let avgLevel = resBuildings.length > 0 ? (resBuildings.reduce((sum, b) => sum + b.lvl, 0) / resBuildings.length).toFixed(1) : 0;
                    html += `<div>Residential Buildings: ${resBuildings.length}</div>`;
                    html += `<div>Average Res Level: ${avgLevel}</div>`;
                }
                
                // Resource Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#4CAF50;">ğŸŒ¾ Resources</strong></div>';
                html += `<div>Food Collected: ${this.formatNumber(Game.totalFoodCollected)}</div>`;
                if(Game.gameState === 'WANDER') {
                    html += `<div>Nomads Found: ${Game.nomadsFound || 0}</div>`;
                    html += `<div>Inventory Used: ${Math.floor((Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone))}/${Game.inventory.capacity}</div>`;
                }
                
                // Building Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#2196F3;">ğŸ—ï¸ Buildings</strong></div>';
                    let resCount = Game.blds.filter(b => b.t === 'RES').length;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                    
                    html += `<div>Residential: ${resCount}</div>`;
                    html += `<div>Commercial: ${comCount}</div>`;
                    html += `<div>Industrial: ${indCount}</div>`;
                    html += `<div>Wells: ${wellCount}</div>`;
                    html += `<div>Total Buildings: ${Game.blds.length}</div>`;
                }
                
                // Unlocks Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#9C27B0;">ğŸ”“ Progress</strong></div>';
                html += `<div>Unlocked Res Levels: ${PROGRESSION.unlockedLevels.length}</div>`;
                html += `<div>Highest Unlocked: Level ${Math.max(...PROGRESSION.unlockedLevels, 0)}</div>`;
                
                document.getElementById('stats-content').innerHTML = html;
            },
            saveMap() {
                let saveData = {
                    version: '28.0',
                    game: {
                        tiles: Game.tiles,
                        blds: Game.blds,
                        res: Game.res,
                        food: Game.food,
                        water: Game.water,
                        pop: Game.pop,
                        year: Game.year,
                        age: Game.age,
                        player: Game.player,
                        wolves: Game.wolves,
                        nomadsFound: Game.nomadsFound
                    },
                    progression: {
                        stage: PROGRESSION.stage,
                        nomadsFound: PROGRESSION.nomadsFound,
                        settlementYear: PROGRESSION.settlementYear
                    },
                    camera: {
                        x: this.cam.x,
                        y: this.cam.y,
                        z: this.cam.z
                    }
                };
                let d = JSON.stringify(saveData);
                let blob = new Blob([d], {type: 'application/json'});
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a'); a.href = url; a.download = 'civilzones_save.json'; a.click();
                this.toast('Game Saved!');
            },
            loadMap() { document.getElementById('file-input').click(); },
            
            zoomIn() {
                this.cam.z = Math.min(CFG.ZOOM.MAX, this.cam.z * CFG.ZOOM.STEP);
            },
            
            zoomOut() {
                this.cam.z = Math.max(CFG.ZOOM.MIN, this.cam.z / CFG.ZOOM.STEP);
            },
            
            moveCameraUp() {
                this.cam.y -= CFG.TILE * 5;
            },
            
            moveCameraDown() {
                this.cam.y += CFG.TILE * 5;
            },
            
            moveCameraLeft() {
                this.cam.x -= CFG.TILE * 5;
            },
            
            moveCameraRight() {
                this.cam.x += CFG.TILE * 5;
            },
            
            showSettlementUI() {
                // Show building tools (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-road'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-well'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-res'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-com'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep1'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-funds'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-water'); if(el) el.style.display = 'flex';
                el = document.getElementById('btn-turn'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-year'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-nomad'); if(el) el.style.display = 'flex';
                console.log('Settlement UI shown - Pass Turn button should be visible');
                this.updateUI();
            },
            
            showIndustrialUI() {
                // Enable Industrial/Hunting Ground button (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-ind'); 
                if(el) { el.style.display = 'inline-block'; el.disabled = false; el.title = 'Build hunting ground'; }
                el = document.getElementById('t-basket'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-pottery'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-granary'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-palace'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-chief'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-demolish'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep2'); if(el) el.style.display = 'inline-block';
                console.log('Industrial UI shown - Industrial button should be visible');
                this.updateUI();
            },
            
                showSimCityUI() {
                // Enable all storage and special buildings (with null checks)
                let btnChief = document.getElementById('t-chief');
                if (btnChief) {
                    btnChief.disabled = false;
                    btnChief.title = "Chief's Hut (10,000 food)";
                }
                
                let btnBasket = document.getElementById('t-basket');
                if (btnBasket) {
                    btnBasket.disabled = false;
                    btnBasket.title = 'Basket (500 food) - +25 storage';
                }
                
                let btnPottery = document.getElementById('t-pottery');
                if (btnPottery) {
                    btnPottery.disabled = false;
                    btnPottery.title = 'Pottery (5,000 food) - +100 storage';
                }
                
                let btnGranary = document.getElementById('t-granary');
                if (btnGranary) {
                    btnGranary.disabled = false;
                    btnGranary.title = 'Granary (50,000 food) - +500 storage';
                }
                
                let btnPalace = document.getElementById('t-palace');
                if (btnPalace) {
                    btnPalace.disabled = false;
                    btnPalace.title = 'Palace (250,000 food) - +2,500 storage';
                }
                
                // Show all building tools when SimCity mode unlocks
                let elem;
                elem = document.getElementById('t-res'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-com'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-ind'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-chief'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-road'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-well'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-bull'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep1'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep2'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('stat-funds'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-water'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-year'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('btn-view'); if (elem) elem.style.display = 'inline-block';
                
                // Update button texts for SimCity mode
                let tRes = document.getElementById('t-res'); if (tRes) tRes.innerHTML = 'ğŸ  Residence ($50)';
                let tCom = document.getElementById('t-com'); if (tCom) tCom.innerHTML = 'ğŸ¢ Commercial ($75)';
                let tInd = document.getElementById('t-ind'); if (tInd) tInd.innerHTML = 'ğŸ­ Industrial ($500)';
                
                this.updateUI();
            }
        };

        // Game Over overlay helpers - Newspaper Article Style
        Controller.showGameOver = function(reason) {
            var panel = document.getElementById('gameover-screen');
            var dateEl = document.getElementById('newspaper-date');
            var headline = document.getElementById('newspaper-headline');
            var subheadline = document.getElementById('newspaper-subheadline');
            var body = document.getElementById('newspaper-body');
            var stats = document.getElementById('newspaper-stats');
            
            // Get today's date formatted
            var today = new Date();
            var months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            var dateStr = months[today.getMonth()] + ' ' + today.getDate() + ', ' + today.getFullYear();
            if(dateEl) dateEl.textContent = dateStr;
            
            // Gather game state
            var pop = Game.pop || 0;
            var food = Math.floor(Game.food || (Game.inventory ? Game.inventory.food : 0) || 0);
            var wood = Math.floor(Game.wood || (Game.inventory ? Game.inventory.wood : 0) || 0);
            var gameState = Game.gameState || 'WANDER';
            var year = Game.year || 0;
            
            // Level 0 (WANDER) - Archaeological discovery article
            if(gameState === 'WANDER' || reason === 'HUNTING') {
                var fossilCount = Math.max(1, pop);
                var siteAge = '2.' + Math.floor(Math.random()*9) + ' million';
                // Vary headlines
                var headlines = [
                    'Ancient Hominid Remains Discovered in Remote Valley',
                    'Fossilized Hunter-Gatherers Unearthed at Excavation Site',
                    'Pre-Historic Human Ancestors Found After ' + siteAge + ' Years',
                    'Archaeological Team Uncovers Early Human Settlement Attempt',
                    'Nomadic Tribe Fossils Reveal Harsh Prehistoric Reality'
                ];
                // Vary based on population
                var popDesc;
                if(fossilCount === 1) popDesc = 'a solitary individual';
                else if(fossilCount <= 3) popDesc = 'a small family group of ' + fossilCount;
                else if(fossilCount <= 10) popDesc = 'a band of ' + fossilCount + ' individuals';
                else if(fossilCount <= 50) popDesc = 'a tribe of ' + fossilCount + ' members';
                else popDesc = 'a large clan numbering ' + fossilCount + ' individuals';
                // Food context
                var foodContext;
                if(food <= 0) foodContext = 'with no food stores remaining, suggesting starvation';
                else if(food < 20) foodContext = 'with only ' + food + ' units of preserved food nearbyâ€”barely enough for survival';
                else if(food < 100) foodContext = 'alongside ' + food + ' units of stored provisions';
                else foodContext = 'with substantial food reserves of ' + food + ' units, indicating capable foragers';
                // Wood/tools context
                var woodContext;
                if(wood <= 0) woodContext = 'No wooden implements were recovered';
                else if(wood < 10) woodContext = 'A few crude wooden tools (' + wood + ' pieces) were found';
                else if(wood < 50) woodContext = 'Evidence of ' + wood + ' wooden implements suggests basic tool use';
                else woodContext = 'An impressive cache of ' + wood + ' wooden items indicates advanced craftsmanship';
                // Death cause context
                var deathCause;
                if(reason === 'HUNTING') {
                    deathCause = 'Skeletal trauma patterns suggest the group perished during a hunting expedition gone wrong. Large animal bones nearby indicate a dangerous prey encounter.';
                } else if(reason === 'THIRST') {
                    deathCause = 'Analysis of the bone structure reveals severe dehydration. The group appears to have wandered too far from water sources during a prolonged drought, unable to find rivers or lakes in time.';
                } else if(food <= 0) {
                    deathCause = 'The absence of food remains and evidence of malnutrition in the bones suggests this group succumbed to starvation during a harsh season.';
                } else {
                    deathCause = 'The circumstances of their demise remain unclear, though the harsh environment of the Pleistocene era claimed countless such groups.';
                }
                // Professor names for article quote
                var professors = [
                    'Sarah Chen', 'Michael Oduya', 'Elena Vasquez', 'James Thornton',
                    'Fatima Al-Hassan', 'Robert Kimura', 'Catherine Dubois', 'Henrik Larsson',
                    'Priya Nair', 'Luca Romano', 'Ava MÃ¼ller', 'Santiago Perez',
                    'Yara Haddad', 'Wei Zhang', 'Nina Petrova', 'Omar Farouk',
                    'Isabella Rossi', 'Jonas Berg', 'Maya Singh', 'Lucas Silva'
                ];
                var prof = professors[Math.floor(Math.random()*professors.length)];
                
                // Draw fossil illustration
                var canvas = document.getElementById('fossil-illustration');
                if(canvas && canvas.getContext) {
                    var ctx = canvas.getContext('2d');
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    
                    // Background dirt/sediment texture
                    ctx.fillStyle = '#D4C4A8';
                    ctx.fillRect(0,0,280,140);
                    for(var i=0; i<50; i++) {
                        ctx.fillStyle = ['#C9B896','#BFA97E','#E0D4BC','#A89878'][Math.floor(Math.random()*4)];
                        ctx.beginPath();
                        ctx.arc(Math.random()*280, Math.random()*140, Math.random()*8+2, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Randomize which bones to show (20+ variations)
                    var variant = Math.floor(Math.random()*20);
                    var boneColor = '#F5F0E0';
                    var boneShade = '#D8D0BC';
                    var crackColor = '#A09080';
                    
                    // Draw partial skull (most variants)
                    if(variant !== 5 && variant !== 12) {
                        var skullX = 40 + (variant % 3) * 10;
                        var skullY = 50 + (variant % 2) * 15;
                        // Skull dome
                        ctx.beginPath();
                        ctx.ellipse(skullX, skullY, 28, 22, 0.2, 0, Math.PI * 1.8);
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Eye socket
                        ctx.beginPath();
                        ctx.ellipse(skullX + 8, skullY + 8, 7, 9, 0.1, 0, 2*Math.PI);
                        ctx.fillStyle = '#B0A090';
                        ctx.fill();
                        // Cracks
                        ctx.strokeStyle = crackColor;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(skullX - 10, skullY - 5);
                        ctx.lineTo(skullX + 5, skullY + 3);
                        ctx.lineTo(skullX + 2, skullY + 15);
                        ctx.stroke();
                    }
                    
                    // Draw spine/vertebrae
                    if(variant % 3 !== 2) {
                        var spineX = 100 + (variant % 4) * 8;
                        for(var v = 0; v < 5 + (variant % 3); v++) {
                            ctx.beginPath();
                            ctx.ellipse(spineX + v * 14, 75 + Math.sin(v)*5, 8, 6, 0.3, 0, 2*Math.PI);
                            ctx.fillStyle = boneColor;
                            ctx.fill();
                            ctx.strokeStyle = boneShade;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Draw ribs
                    if(variant % 4 !== 3) {
                        var ribX = 120 + (variant % 3) * 15;
                        var ribY = 35;
                        ctx.strokeStyle = boneColor;
                        ctx.lineWidth = 4;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw femur/leg bone
                    if(variant % 2 === 0) {
                        var femurX = 200 + (variant % 5) * 8;
                        var femurY = 30 + (variant % 3) * 10;
                        ctx.save();
                        ctx.translate(femurX, femurY);
                        ctx.rotate(0.4 + (variant % 4) * 0.2);
                        // Shaft
                        ctx.fillStyle = boneColor;
                        ctx.fillRect(-5, 0, 10, 70);
                        // Joint ends
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 12, 10, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(0, 70, 10, 8, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(-5, 0, 10, 70);
                        ctx.restore();
                    }
                    
                    // Draw hand bones (scattered)
                    if(variant > 7) {
                        var handX = 230 + (variant % 4) * 10;
                        var handY = 90 - (variant % 3) * 15;
                        for(var f = 0; f < 4; f++) {
                            ctx.fillStyle = boneColor;
                            ctx.save();
                            ctx.translate(handX + f * 8, handY);
                            ctx.rotate(-0.2 + f * 0.15);
                            ctx.fillRect(-2, 0, 4, 18);
                            ctx.beginPath();
                            ctx.arc(0, 0, 4, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    
                    // Draw pelvis fragment
                    if(variant % 5 === 0 || variant > 15) {
                        var pelvisX = 180;
                        var pelvisY = 100;
                        ctx.beginPath();
                        ctx.moveTo(pelvisX, pelvisY);
                        ctx.quadraticCurveTo(pelvisX + 30, pelvisY - 20, pelvisX + 50, pelvisY + 5);
                        ctx.quadraticCurveTo(pelvisX + 35, pelvisY + 15, pelvisX + 10, pelvisY + 10);
                        ctx.closePath();
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.stroke();
                    }
                    
                    // Add some scattered small bone fragments
                    for(var b = 0; b < 3 + (variant % 4); b++) {
                        ctx.fillStyle = boneColor;
                        ctx.beginPath();
                        var fx = 50 + Math.random() * 200;
                        var fy = 100 + Math.random() * 30;
                        ctx.ellipse(fx, fy, 4 + Math.random()*6, 3 + Math.random()*4, Math.random()*Math.PI, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Caption label
                    ctx.fillStyle = '#443322';
                    ctx.font = 'italic 10px Georgia';
                    ctx.fillText('Fig. 1: Excavation site photograph', 10, 132);
                }
                if(headline) headline.textContent = headlines[Math.floor(Math.random()*headlines.length)];
                if(subheadline) subheadline.textContent = 'Researchers document ' + popDesc + ' who never established permanent settlement';
                if(body) body.innerHTML = '<p><strong>EAST AFRICAN RIFT VALLEY</strong> â€” An international team of paleoanthropologists has announced the discovery of ' + popDesc + ' dating back approximately ' + siteAge + ' years.</p>' +
                    '<p>The remains were found ' + foodContext + '. ' + woodContext + ', providing valuable insight into early human material culture.</p>' +
                    '<p>"These ancestors never made the crucial transition to permanent settlement," noted Professor ' + prof + ', lead researcher on the excavation. "They represent the countless groups who wandered but never found the right conditions to establish lasting communities."</p>' +
                    '<p>' + deathCause + '</p>' +
                    '<p>This discovery adds to our understanding of the tremendous challenges faced by early <strong>hominids</strong>, where survival was never guaranteed and most lineages ended without descendants.</p>';
                if(stats) stats.innerHTML = '<strong>ğŸ“‹ EXCAVATION DATA:</strong><br>' +
                    'â€¢ Fossils recovered: ' + fossilCount + '<br>' +
                    'â€¢ Food remains: ' + food + ' units<br>' +
                    'â€¢ Wooden artifacts: ' + wood + ' pieces<br>' +
                    'â€¢ Site age: ~' + siteAge + ' years<br>' +
                    'â€¢ Settlement status: <span style="color:#8B0000;">Never established</span>';
            }
            // Level 1+ (CITY) - Historical collapse article
            else {
                // Count buildings by type AND level
                var resBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='RES';}) : [];
                var comBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='COM';}) : [];
                var indBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='IND';}) : [];
                var wellCount = Game.blds ? Game.blds.filter(function(b){return b.t==='WELL';}).length : 0;
                var roadCount = Game.blds ? Game.blds.filter(function(b){return b.t==='ROAD';}).length : 0;
                
                var resCount = resBlds.length;
                var comCount = comBlds.length;
                var indCount = indBlds.length;
                var totalZones = resCount + comCount + indCount;
                
                // Get descriptive names for building types
                var getResDescription = function(blds) {
                    if(blds.length === 0) return 'no residential structures';
                    // Most buildings will be level 1 (Pit Class) early game
                    var names = [];
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    if(lvl1 > 0) names.push(lvl1 + ' Pit dwelling' + (lvl1 > 1 ? 's' : '') + ' (simple straw-lined earth pits where families huddled for warmth)');
                    if(lvl2 > 0) names.push(lvl2 + ' GrubenhÃ¤user (semi-subterranean pit houses with basic roofing)');
                    return names.join(', ') || blds.length + ' residential structures';
                };
                
                var getComDescription = function(blds) {
                    if(blds.length === 0) return 'no commercial areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Campfire' + (lvl1 > 1 ? 's' : '') + ' (communal gathering spots where tribes traded goods and shared stories)');
                    if(lvl2 > 0) names.push(lvl2 + ' Fire Pit' + (lvl2 > 1 ? 's' : '') + ' (larger communal areas for trade and ceremony)');
                    return names.join(', ') || blds.length + ' commercial areas';
                };
                
                var getIndDescription = function(blds) {
                    if(blds.length === 0) return 'no food production areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : '') + ' (designated areas where hunters tracked and trapped wild game)');
                    if(lvl2 > 0) names.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : '') + ' (deep pits dug to trap larger prey)');
                    return names.join(', ') || blds.length + ' hunting areas';
                };
                
                // Short versions for stats
                var getResShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Pit' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Grubenhaus' + (lvl2 > 1 ? 'er' : ''));
                    return parts.join(', ');
                };
                
                var getComShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Campfire' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Fire Pit' + (lvl2 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                var getIndShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                // Water needs calculation (1 well per 100 population)
                var wellsNeeded = Math.max(1, Math.ceil(pop / 100));
                
                // Settlement size description
                var sizeDesc;
                if(pop <= 20) sizeDesc = 'a tiny hamlet';
                else if(pop <= 100) sizeDesc = 'a small village';
                else if(pop <= 500) sizeDesc = 'a growing settlement';
                else if(pop <= 2000) sizeDesc = 'a thriving community';
                else sizeDesc = 'a substantial town';
                
                // Failure analysis
                var failureReason;
                if(reason === 'NO_WATER') {
                    failureReason = 'Skeletal analysis reveals catastrophic dehydration as the primary cause of death. The settlement existed for over two years without any permanent water infrastructureâ€”a fatal oversight. Bone analysis shows progressive signs of water stress, malnutrition, and ultimately mass mortality during what appears to have been a severe drought season.';
                } else if(food <= 0) {
                    failureReason = 'Archaeological evidence strongly suggests famine as the primary cause of collapse. Grain stores were found completely empty, and skeletal remains show signs of severe malnutrition.';
                } else if(wellCount === 0 && pop > 50) {
                    failureReason = 'The absence of any water infrastructure proved fatal. Without wells, the growing population could not sustain itself through dry seasons.';
                } else if(indCount === 0 && pop > 30) {
                    failureReason = 'No hunting grounds or food production facilities were established. The settlement relied entirely on foraged food, an unsustainable strategy for a permanent community.';
                } else {
                    failureReason = 'Poor resource management and inadequate planning appear to have doomed this early settlement. Early humans who succeeded were those who learned to think ahead.';
                }
                
                var headlines2 = [
                    'Ancient Settlement Collapse Reveals Harsh Lessons of Early Civilization',
                    'Failed Neolithic Village Discovered: "They Didn\'t Plan Ahead"',
                    'Archaeologists Uncover Tragic End of ' + sizeDesc.charAt(0).toUpperCase() + sizeDesc.slice(1),
                    'Early Human Settlement Found Abandoned After Apparent Collapse',
                    '"Planning Was Everything": Ruins Tell Story of Prehistoric Failure'
                ];
                
                if(reason === 'NO_WATER') {
                    headlines2 = [
                        'Mass Dehydration Wiped Out Ancient Settlement, Study Confirms',
                        'No Wells, No Water, No Survivors: Prehistoric Village\'s Fatal Flaw',
                        'Settlement Died of Thirst: "Water Was Everything," Say Archaeologists',
                        'Archaeological Evidence Shows Entire Community Perished From Lack of Water',
                        'Two Years Without Wells Proved Fatal for Early Human Settlement'
                    ];
                }
                
                if(headline) headline.textContent = headlines2[Math.floor(Math.random()*headlines2.length)];
                if(subheadline) subheadline.textContent = 'Excavation of ' + sizeDesc + ' (' + pop + ' inhabitants) shows why early humans needed foresight to survive';
                
                // Build descriptive body text
                var resDesc = getResDescription(resBlds);
                var comDesc = getComDescription(comBlds);
                var indDesc = getIndDescription(indBlds);
                
                if(body) body.innerHTML = '<p><strong>FERTILE CRESCENT REGION</strong> â€” Researchers have completed their analysis of ' + sizeDesc + ' that housed approximately ' + pop + ' people before its sudden collapse in Year ' + year + ' of the settlement\'s existence.</p>' +
                    '<p>The excavation revealed ' + resDesc + '. ' + (comCount > 0 ? 'For trade and social gatherings, the community had established ' + comDesc + '. ' : 'No evidence of organized trade or social gathering spots was found. ') + (indCount > 0 ? 'Food was procured through ' + indDesc + '.' : 'Remarkably, no organized food production was ever establishedâ€”the settlement relied entirely on opportunistic foraging.') + '</p>' +
                    '<p>' + (wellCount > 0 ? 'Water infrastructure consisted of ' + wellCount + ' well' + (wellCount > 1 ? 's' : '') + ', requiring ' + wellsNeeded + ' to adequately serve the population.' : 'Notably, no permanent water infrastructure was ever constructedâ€”a critical oversight that may have contributed to the settlement\'s demise.') + '</p>' +
                    '<p>' + failureReason + '</p>' +
                    '<p>"The difference between the groups that survived and those that perished often came down to planning," explained Dr. ' + ['Henrik Larsson','Fatima Al-Hassan','Robert Kimura','Catherine Dubois'][Math.floor(Math.random()*4)] + '. "Those who thought seasons ahead, who built reserves, who prepared for hardshipâ€”they became our ancestors. The others... became archaeology."</p>' +
                    '<p>This settlement joins thousands of similar failed attempts across the prehistoric world, each a testament to the razor-thin margin between survival and extinction that defined early human existence.</p>';
                    
                if(stats) stats.innerHTML = '<strong>ğŸ“‹ SETTLEMENT SURVEY:</strong><br>' +
                    'â€¢ Peak population: ' + pop + '<br>' +
                    'â€¢ Years survived: ' + year + '<br>' +
                    'â€¢ Dwellings: ' + (getResShort(resBlds) || 'None') + '<br>' +
                    'â€¢ Trade spots: ' + (getComShort(comBlds) || 'None') + '<br>' +
                    'â€¢ Food production: ' + (getIndShort(indBlds) || 'None') + '<br>' +
                    'â€¢ Water wells: ' + wellCount + ' built / ' + wellsNeeded + ' needed<br>' +
                    'â€¢ Food at collapse: ' + food + ' units<br>' +
                    (reason === 'NO_WATER' ? 'â€¢ Years without water: ' + (Game.yearsWithoutWell || 2) + '<br>' : '') +
                    'â€¢ Verdict: <span style="color:#8B0000;">' + (reason === 'NO_WATER' ? 'Death by dehydration' : 'Insufficient planning') + '</span>';
            }
            
            if (panel) panel.style.display = 'flex';
        };

        document.addEventListener('DOMContentLoaded', function() {
            var btn = document.getElementById('btn-newgame');
            if (btn) {
                btn.onclick = function() {
                    var panel = document.getElementById('gameover-screen');
                    if (panel) panel.style.display = 'none';
                    if (typeof Controller.reset === 'function') Controller.reset();
                };
            }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PATCH: Integrate Pass Year button updates with Controller lifecycle
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function() {
            // Patch window.startNewGame to update Pass Year buttons
            var origStartNewGame = window.startNewGame;
            window.startNewGame = function() {
                if (origStartNewGame) origStartNewGame();
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.updateUI to update Pass Year buttons
            var origUpdateUI = Controller.updateUI;
            Controller.updateUI = function() {
                if (origUpdateUI) origUpdateUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showSettlementUI to update Pass Year buttons
            var origShowSettlementUI = Controller.showSettlementUI;
            Controller.showSettlementUI = function() {
                if (origShowSettlementUI) origShowSettlementUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showCityUI to update Pass Year buttons  
            if (Controller.showCityUI) {
                var origShowCityUI = Controller.showCityUI;
                Controller.showCityUI = function() {
                    if (origShowCityUI) origShowCityUI.call(this);
                    if (typeof updatePassYearButton === 'function') updatePassYearButton();
                };
            }
        })();
        
        document.getElementById('file-input').onchange=e=>{ 
            let r=new FileReader(); 
            r.onload=ev=>{ 
                try {
                    let saveData=JSON.parse(ev.target.result);
                    if(saveData.version && saveData.game) {
                        Object.assign(Game, saveData.game);
                        Object.assign(PROGRESSION, saveData.progression);
                        Controller.cam = saveData.camera;
                        
                        // Restore UI state based on progression
                        if(PROGRESSION.stage >= 1) {
                            Controller.showSettlementUI();
                        }
                        
                        Game.recalc();
                        Controller.updateUI();
                        Controller.toast("Game Loaded!");
                    } else {
                        Controller.toast("Invalid save file!");
                    }
                } catch(err) {
                    Controller.toast("Failed to load!");
                    console.error(err);
                }
            }; 
            r.readAsText(e.target.files[0]); 
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Q-LEARNING AI - Learns to play the game through reinforcement learning
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        var QLearningAI = {
            // Hyperparameters (TUNED FOR FASTER LEARNING)
            learningRate: 0.35,     // How quickly we update Q-values (was 0.25, now faster)
            discountFactor: 0.85,   // How much we value future rewards (lower = more immediate focus)
            explorationRate: 0.5,   // Start with 50% exploration (was 0.8, too random)
            explorationDecay: 0.95, // Decay exploration each episode (was 0.98, faster now)
            minExploration: 0.05,   // Minimum exploration rate (was 0.1, can go lower)
            
            // Q-table: state -> action -> value
            qTable: {},
            
            // Training stats
            episode: 0,
            totalReward: 0,
            episodeRewards: [],
            bestScore: 0,
            gamesPlayed: 0,
            isTraining: false,
            trainingSpeed: 10, // 1 = normal, 10 = fast, 100 = ultra fast (default matches dropdown)
            isResetting: false, // Prevent multiple simultaneous resets
            lastExploredCount: 0,
            
            // === LEARNING ANALYTICS ===
            citiesBuilt: 0,         // Times AI successfully settled
            bestPopulation: 0,      // Highest population reached EVER (career stat)
            thisEpisodeBestPop: 0,  // Highest population THIS RUN (resets each game)
            bestSurvivalYears: 0,   // Longest city survival
            balancedCities: 0,      // Cities with all 3 zone types balanced
            smartSettlements: 0,    // Settlements near resources (animals/berries)
            rewardHistory: [],      // Last 20 episode rewards for graph
            
            // === PERMANENT CAREER SCORE (CHESS-LIKE ELO) ===
            // This score PERSISTS across all games and affects AI decision-making
            // Dying without progress PERMANENTLY hurts this score
            careerScore: 1000,          // Starting ELO-like rating (1000 = baseline)
            careerHighScore: 1000,      // All-time best career score
            careerPopRecord: 0,         // All-time best population achieved
            careerGamesPlayed: 0,       // Total games ever played
            careerTotalDeaths: 0,       // Total deaths (shameful!)
            careerSuccessfulCities: 0,  // Cities that reached 100+ pop
            careerMilestones: {         // Track major achievements
                reached100: false,
                reached1000: false,
                reached10000: false,
                reached100000: false,
                reached1M: false,
                reached2M: false
            },
            thisGameStartScore: 1000,   // Score when this game started (for delta calc)
            
            // === DEATH MEMORY SYSTEM ===
            // Remember what killed us and DON'T DO THAT AGAIN
            deathMemory: {
                lastDeathCause: null,       // 'WATER_CRISIS', 'FOOD_CRISIS', 'NO_WELLS', 'NO_RES', 'OVERPOP', etc.
                lastDeathPop: 0,            // Population when died
                lastDeathYear: 0,           // Year when died
                lastDeathBuildings: {},     // Building counts when died
                recentDeaths: [],           // Last 10 death causes for pattern detection
                deathCauseCounts: {         // Track how many times each cause killed us
                    WATER_CRISIS: 0,
                    FOOD_CRISIS: 0,
                    NO_WELLS: 0,
                    NO_RES: 0,
                    OVERPOP: 0,
                    UNKNOWN: 0
                },
                // === LESSONS LEARNED ===
                // Explicit rules derived from death patterns
                lessons: {
                    // Minimum wells per pop (starts at 1:30, tightens with deaths)
                    minWellRatio: 30,
                    // Minimum capacity buffer (starts at 1.2x, increases with deaths)
                    minCapacityBuffer: 1.2,
                    // Minimum food per person (starts at 2, increases with deaths)
                    minFoodPerPop: 2,
                    // Build wells BEFORE this population threshold (learned)
                    buildWellBeforePop: 25,
                    // Always have at least this many wells
                    minWells: 1,
                    // Always have at least this many RES
                    minRes: 1
                }
            },
            
            // === CURRICULUM LEARNING ===
            // Phase 1: Learn to survive WANDER (drink water, gather food)
            // Phase 2: Learn to settle successfully
            // Phase 3: Learn to build balanced cities
            learningPhase: 1,       // Current curriculum phase
            phase1Threshold: 10,    // Settle 10 times to move to phase 2
            phase2Threshold: 5,     // Build 5 balanced cities to move to phase 3
            
            // === IMITATION LEARNING (Watch & Learn from Player) ===
            isWatching: false,          // Is AI watching player?
            playerDemonstrations: [],    // Records of player actions
            watchStartState: null,       // State when watching started
            lastRecordedAction: null,    // Prevent duplicate recordings
            lastRecordTime: 0,          // Timestamp of last recording
            watchModeStats: {           // Track what AI is learning
                totalActions: 0,
                moveToNomad: 0,
                moveToBerry: 0,
                moveToWater: 0,
                moveToTree: 0,
                wander: 0,
                settle: 0,
                builds: 0
            },
            
            // === BASELINE STRATEGY TRACKING ===
            wanderStartPop: 0,          // Population when wander phase started
            wanderTurnsWithoutGrowth: 0, // Turns without nomad gain
            lastWanderPop: 0,           // Last population in wander mode
            cityPhase: 0,               // 0=initial, 1=first_res_well, 2=wait_year, 3=roads, 4=growth
            cityStartYear: 0,           // Year when city mode started
            lastCityYear: 0,            // Track years passed
            
            // Actions the AI can take (expanded with movement context)
            actions: [
                // WANDER mode actions
                'SETTLE', 'WANDER', 'MOVE_TO_NOMAD', 'MOVE_TO_BERRY', 'MOVE_TO_WATER', 'MOVE_TO_TREE',
                // CITY mode actions  
                'BUILD_RES', 'BUILD_WELL', 'PASS_YEAR', 'BUILD_IND', 'BUILD_COM', 'BUILD_ROAD', 'WAIT'
            ],
            
            // Get discretized state representation
            getState: function() {
                // Track population in WANDER mode too! AI needs to know nomad count
                if(!Game) return 'WANDER_P0';
                
                let pop = Game.pop || 0;
                let popBucket = Math.min(10, Math.floor(pop / 5)); // 0-10 (tracks 0-50 nomads in groups of 5)
                
                if(Game.gameState === 'WANDER') {
                    // Include food and wood status for settling decisions
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    let thirst = Game.thirst || 100;
                    let foodOK = food >= 100 ? 1 : 0;
                    let woodOK = wood >= 25 ? 1 : 0;
                    let thirstOK = thirst >= 50 ? 1 : 0;
                    
                    // Check for nearby resources (radius 5)
                    let nearNomad = 0, nearBerry = 0, nearWater = 0, nearTree = 0;
                    if(Game.player && Game.tiles) {
                        let px = Game.player.x, py = Game.player.y;
                        for(let dx = -5; dx <= 5; dx++) {
                            for(let dy = -5; dy <= 5; dy++) {
                                let x = px + dx, y = py + dy;
                                if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                    let tile = Game.tiles[x][y];
                                    if(tile.entity) {
                                        if(tile.entity.type === 'NOMAD') nearNomad = 1;
                                        if(tile.entity.type === 'BERRY') nearBerry = 1;
                                    }
                                    if(tile.type === 'WATER' || tile.type === 'RIVER') nearWater = 1;
                                    if(tile.tree) nearTree = 1;
                                }
                            }
                        }
                    }
                    
                    // Enhanced state includes nearby resource flags
                    return `WANDER_P${popBucket}_F${foodOK}_W${woodOK}_T${thirstOK}_N${nearNomad}_B${nearBerry}_WA${nearWater}_TR${nearTree}`;
                }
                
                // CITY mode - detailed state
                let foodBucket = Math.min(5, Math.floor((Game.food || 0) / 100)); // 0-5
                let woodBucket = Math.min(5, Math.floor((Game.wood || 0) / 50)); // 0-5
                let wellCount = Math.min(3, Game.wellCount || 0); // 0-3
                let resCount = Math.min(5, Game.zoneCount || 0); // Use zoneCount for residential
                let indCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0);
                let comCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0);
                let roadCount = Math.min(5, Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0);
                let hasWaterCrisis = (Game.wellCount === 0 && Game.pop > 5) ? 1 : 0;
                let hasFoodCrisis = (Game.food < Game.pop * 2) ? 1 : 0;
                
                return `P${popBucket}F${foodBucket}W${woodBucket}WL${wellCount}R${resCount}I${indCount}C${comCount}RD${roadCount}WC${hasWaterCrisis}FC${hasFoodCrisis}`;
            },

            // Count explored tiles around player (small radius for cheap signal)
            localExploredCount: function(radius = 3) {
                if(!Game || !Game.player || !Game.tiles) return 0;
                let cx = Game.player.x, cy = Game.player.y;
                let count = 0;
                for(let x = cx - radius; x <= cx + radius; x++) {
                    for(let y = cy - radius; y <= cy + radius; y++) {
                        if(x>=0 && y>=0 && x < Game.tiles.length && y < Game.tiles[0].length) {
                            let t = Game.tiles[x][y];
                            if(t && t.explored) count++;
                        }
                    }
                }
                return count;
            },
            
            // Get Q-value for state-action pair
            getQ: function(state, action) {
                if(!this.qTable[state]) this.qTable[state] = {};
                if(this.qTable[state][action] === undefined) this.qTable[state][action] = 0;
                return this.qTable[state][action];
            },
            
            // Update Q-value
            updateQ: function(state, action, reward, nextState) {
                let currentQ = this.getQ(state, action);
                let maxNextQ = Math.max(...this.actions.map(a => this.getQ(nextState, a)));
                let newQ = currentQ + this.learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
                
                if(!this.qTable[state]) this.qTable[state] = {};
                this.qTable[state][action] = newQ;
            },
            
            // Choose action using epsilon-greedy policy - POPULATION MAXIMIZER BASELINE
            // Strategy: Get maximum population as fast as possible
            // WANDER: If not gaining nomads, settle immediately (with minimum resources)
            // CITY: 1 RES + 1 WELL â†’ Wait 1 year â†’ Roads â†’ Balanced growth
            // Ratios: 1 RES per COM, 5 RES per IND, 1 WELL per 40 pop
            chooseAction: function(state) {
                // 1. WANDER MODE - AGGRESSIVE SETTLING STRATEGY
                // Goal: Don't waste time. If we're not gaining nomads, settle NOW.
                if (Game && Game.gameState === 'WANDER') {
                    const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                    let pop = Game.pop || 0;
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    
                    // Initialize tracking on first call
                    if (this.wanderStartPop === 0) {
                        this.wanderStartPop = pop;
                        this.lastWanderPop = pop;
                        this.wanderTurnsWithoutGrowth = 0;
                    }
                    
                    // Track if we're gaining nomads
                    if (pop > this.lastWanderPop) {
                        this.wanderTurnsWithoutGrowth = 0; // Reset counter - we're growing!
                        this.lastWanderPop = pop;
                    } else {
                        this.wanderTurnsWithoutGrowth++;
                    }
                    
                    // Check minimum requirements to settle
                    let hasEnoughFood = food >= REQ.MIN_FOOD;
                    let hasEnoughWood = wood >= REQ.MIN_WOOD;
                    let hasMinPop = pop >= REQ.MIN_POP;
                    let canSettle = hasEnoughFood && hasEnoughWood && hasMinPop;
                    
                    // SETTLE IMMEDIATELY IF:
                    // 1. We have resources AND haven't gained nomads in 10+ turns (stagnating)
                    // 2. We have good resources (200+ food, 50+ wood, 5+ pop)
                    // 3. We have excellent population (10+) with basic resources
                    let isStagnating = this.wanderTurnsWithoutGrowth >= 10;
                    let hasGoodResources = food >= 200 && wood >= 50 && pop >= 5;
                    let hasExcellentPop = pop >= 10;
                    
                    if (canSettle && (isStagnating || hasGoodResources || hasExcellentPop)) {
                        // Reset tracking for next run
                        this.wanderStartPop = 0;
                        this.wanderTurnsWithoutGrowth = 0;
                        this.lastWanderPop = 0;
                        this.cityPhase = 0; // Reset city phase
                        return 'SETTLE';
                    }
                    
                    // Keep wandering to gather nomads, food, and wood
                    return 'WANDER';
                }
                
                // 2. CITY MODE - AGGRESSIVE EXPANSION STRATEGY
                // NO MORE WAITING - BUILD IMMEDIATELY AND CONTINUOUSLY
                // LEARN FROM DEATH - Check death memory to avoid past mistakes!
                if (Game && Game.gameState === 'CITY') {
                    // Count all buildings - ALWAYS count from blds array for accuracy!
                    let blds = Game.blds || [];
                    let wellCount = blds.filter(b => b.t === 'WELL').length;
                    let resCount = blds.filter(b => b.t === 'RES').length;
                    let indCount = blds.filter(b => b.t === 'IND').length;
                    let comCount = blds.filter(b => b.t === 'COM').length;
                    let roadCount = blds.filter(b => b.t === 'ROAD').length;
                    let pop = Game.pop || 0;
                    let wood = Game.wood || 0;
                    let food = Game.food || 0;
                    let year = Game.year || 0;
                    
                    // WORKFORCE AWARENESS - Check how many gatherers we have
                    let workforce = Game.workforce || {};
                    let gatherers = workforce.gatherers || 0;
                    let totalWorkers = workforce.total || pop;
                    let gathererRatio = totalWorkers > 0 ? gatherers / totalWorkers : 0;
                    
                    // Resource generation rates (roughly)
                    let foodPerYear = gatherers * 1.5; // GATHERER_FOOD_RATE
                    let woodPerYear = gatherers * 3.0; // GATHERER_WOOD_RATE
                    
                    // Get costs from config - USE CORRECT VALUES
                    let resCost = { food: 100, wood: 100 }; // Level 1 Pit
                    if(CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1]) {
                        resCost = { food: CFG.BUILDING_LEVELS[1].food, wood: CFG.BUILDING_LEVELS[1].wood };
                    }
                    let wellCost = CFG.COST ? CFG.COST.WELL : 50;
                    let roadCost = CFG.COST ? CFG.COST.ROAD : 5;
                    let comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                    let indCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.INDUSTRIAL ? CFG.LEVEL_1_COSTS.INDUSTRIAL : { food: 200, wood: 200 };
                    
                    // Check what we can afford
                    let canBuildRes = food >= resCost.food && wood >= resCost.wood;
                    let canBuildWell = food >= wellCost;
                    let canBuildRoad = food >= roadCost;
                    let canBuildCom = food >= comCost.food && wood >= comCost.wood;
                    
                    // === RESOURCE GATHERING MODE ===
                    // If we're low on resources and can't build anything critical, wait for gatherers
                    let needsResources = !canBuildRes && !canBuildWell;
                    if(needsResources && gatherers > 0) {
                        // We have gatherers but not enough resources - let them work
                        if(this.stepCount % 30 === 1) {
                            this.log('â³ Waiting for ' + gatherers + ' gatherers to collect resources (food +' + foodPerYear.toFixed(0) + ', wood +' + woodPerYear.toFixed(0) + '/yr)');
                        }
                        return 'PASS_YEAR';
                    }
                    let canBuildInd = food >= indCost.food && wood >= indCost.wood;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // DEATH MEMORY - LEARN FROM PAST MISTAKES
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let lastDeath = this.deathMemory.lastDeathCause;
                    let deathCounts = this.deathMemory.deathCauseCounts;
                    let lessons = this.deathMemory.lessons || {};
                    
                    // Calculate urgency based on death history
                    let wellUrgency = 1.0;
                    let resUrgency = 1.0;
                    let comUrgency = 1.0;
                    
                    // If we've died from water crisis, PRIORITIZE WELLS
                    let waterDeaths = (deathCounts.NO_WELLS || 0) + (deathCounts.WATER_CRISIS || 0);
                    if(waterDeaths > 0) {
                        wellUrgency = 2.0 + waterDeaths * 0.5;
                        if(this.stepCount % 50 === 1) {
                            this.log('ğŸ§  LESSON: Died from water ' + waterDeaths + ' times. Well priority: ' + wellUrgency.toFixed(1) + 'x');
                        }
                    }
                    
                    // If we've died from food crisis, build more COM/IND
                    if((deathCounts.FOOD_CRISIS || 0) > 0) {
                        comUrgency = 1.5 + deathCounts.FOOD_CRISIS * 0.3;
                    }
                    
                    // If we've died from no residential, prioritize RES
                    if((deathCounts.NO_RES || 0) > 0) {
                        resUrgency = 1.5 + deathCounts.NO_RES * 0.3;
                    }
                    
                    // If we've died from overpopulation, be more aggressive with RES
                    if((deathCounts.OVERPOP || 0) > 0) {
                        resUrgency = Math.max(resUrgency, 1.5 + deathCounts.OVERPOP * 0.4);
                    }
                    
                    // === APPLY LEARNED LESSONS ===
                    // These are hard rules derived from repeated deaths
                    let learnedWellRatio = lessons.minWellRatio || 30;
                    let learnedCapBuffer = lessons.minCapacityBuffer || 1.2;
                    let learnedMinWells = lessons.minWells || 1;
                    let learnedMinRes = lessons.minRes || 1;
                    
                    // Debug logging with workforce and lessons
                    if(this.stepCount % 20 === 1) {
                        console.log('ğŸ™ï¸ CITY STATUS: Pop=' + pop + ' Res=' + resCount + ' Well=' + wellCount + 
                                   ' | Food=' + food + ' Wood=' + wood + 
                                   ' | Gatherers=' + gatherers + '/' + totalWorkers + ' (+' + foodPerYear.toFixed(0) + 'F +' + woodPerYear.toFixed(0) + 'W/yr)' +
                                   ' | Lessons: wellRatio=' + learnedWellRatio);
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PRIORITY BUILDING - Using LEARNED LESSONS!
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // LESSON: Always have minimum wells (learned from deaths)
                    if(wellCount < learnedMinWells && canBuildWell) {
                        this.log('ğŸ“š APPLYING LESSON: Need at least ' + learnedMinWells + ' wells (have ' + wellCount + ')');
                        return 'BUILD_WELL';
                    }
                    
                    // LESSON: Always have minimum RES (learned from deaths)
                    if(resCount < learnedMinRes && canBuildRes) {
                        this.log('ğŸ“š APPLYING LESSON: Need at least ' + learnedMinRes + ' RES (have ' + resCount + ')');
                        return 'BUILD_RES';
                    }
                    
                    // === WATER CRISIS PREVENTION (USING LEARNED WELL RATIO) ===
                    // Use the LEARNED ratio from deaths, not a fixed value!
                    let wellsNeeded = Math.max(learnedMinWells, Math.ceil(pop / learnedWellRatio));
                    
                    // CRITICAL: Under-welled based on learned ratio!
                    let popPerCurrentWell = wellCount > 0 ? pop / wellCount : pop;
                    if(popPerCurrentWell > 50 && pop > 20) {
                        if(canBuildWell) {
                            this.log('ğŸš¨ WATER CRISIS: ' + Math.round(popPerCurrentWell) + ' pop per well! Building emergency well!');
                            return 'BUILD_WELL';
                        } else {
                            this.log('ğŸš¨ WATER CRISIS: Need well but can\'t afford (food:' + food + '/' + wellCost + ')');
                        }
                    }
                    
                    if(wellCount < wellsNeeded && canBuildWell) {
                        this.log('ğŸ’§ Need more wells: have ' + wellCount + ' need ' + wellsNeeded + ' (1 per ' + popPerWell + ' pop)');
                        return 'BUILD_WELL';
                    }
                    
                    // Extra well buffer if we've died from water before
                    if(wellUrgency > 1.5 && wellCount < wellsNeeded + 1 && canBuildWell) {
                        this.log('ğŸ’§ Building EXTRA well (learned from past deaths)');
                        return 'BUILD_WELL';
                    }
                    
                    // === CAPACITY EXPANSION (USING LEARNED BUFFER!) ===
                    // Each RES holds ~20 people. Need room to grow!
                    let currentCapacity = resCount * 20;
                    let capacityUsed = currentCapacity > 0 ? (pop / currentCapacity) : 1;
                    
                    // CRITICAL: Population exceeds capacity! This causes deaths!
                    if(capacityUsed > 1.0) {
                        if(canBuildRes) {
                            this.log('ğŸš¨ CRITICAL OVERPOP: ' + pop + ' pop but only ' + currentCapacity + ' capacity! Building RES!');
                            return 'BUILD_RES';
                        } else {
                            this.log('ğŸš¨ CRITICAL OVERPOP: Need RES but can\'t afford (food:' + food + '/' + resCost.food + ' wood:' + wood + '/' + resCost.wood + ')');
                            // Pass year to get resources ASAP
                            return 'PASS_YEAR';
                        }
                    }
                    
                    // LESSON: Need capacity BUFFER based on past overpop deaths
                    // If learnedCapBuffer is 1.5, we need 50% more capacity than current pop
                    let neededCapacity = pop * learnedCapBuffer;
                    if(currentCapacity < neededCapacity && canBuildRes) {
                        this.log('ğŸ“š APPLYING LESSON: Need ' + Math.round(neededCapacity) + ' capacity (have ' + currentCapacity + ', buffer ' + (learnedCapBuffer*100).toFixed(0) + '%)');
                        return 'BUILD_RES';
                    }
                    
                    // Also build if under minimum RES count
                    if(resCount < Math.max(3, learnedMinRes) && canBuildRes) {
                        this.log('ğŸ˜ï¸ Building RES (need minimum ' + Math.max(3, learnedMinRes) + ', have ' + resCount + ')');
                        return 'BUILD_RES';
                    }
                    
                    // === FOOD PRODUCTION (if we've died from starvation) ===
                    if(comUrgency > 1.2 && comCount < resCount && canBuildCom) {
                        this.log('ğŸª Building COM for food (learned from starvation)');
                        return 'BUILD_COM';
                    }
                    
                    // === INFRASTRUCTURE ===
                    // Roads boost everything - need at least 1 per building
                    let totalBuildings = resCount + wellCount + comCount + indCount;
                    if(roadCount < totalBuildings && canBuildRoad) {
                        return 'BUILD_ROAD';
                    }
                    
                    // === ECONOMY ===
                    // Commercial - need jobs! 1 per 2 RES minimum
                    if(comCount < Math.ceil(resCount / 2) && resCount >= 2 && canBuildCom) {
                        this.log('ğŸª Building commercial for jobs');
                        return 'BUILD_COM';
                    }
                    
                    // Industrial - production! 1 per 4 RES
                    if(indCount < Math.ceil(resCount / 4) && resCount >= 4 && canBuildInd) {
                        this.log('ğŸ­ Building industrial for production');
                        return 'BUILD_IND';
                    }
                    
                    // === MORE ROADS FOR GROWTH ===
                    if(roadCount < totalBuildings * 2 && canBuildRoad) {
                        return 'BUILD_ROAD';
                    }
                    
                    // === KEEP EXPANDING ===
                    // If we have resources and room in priorities, expand residential
                    if(canBuildRes) {
                        return 'BUILD_RES';
                    }
                    
                    // If we have some food, build a road (cheap infrastructure)
                    if(canBuildRoad) {
                        return 'BUILD_ROAD';
                    }
                    
                    // === PASS YEAR TO GENERATE RESOURCES ===
                    // Only pass year if we literally can't afford anything
                    return 'PASS_YEAR';
                }
                
                // === SMART EXPLORATION ===
                // Don't just pick random actions - weight towards useful ones
                // SAFETY: This code should only run if WANDER/CITY blocks didn't return
                // Log a warning if we get here unexpectedly
                if(Game && (Game.gameState === 'CITY' || Game.gameState === 'WANDER')) {
                    console.warn('âš ï¸ chooseAction: Fell through to exploration code! State:', Game.gameState);
                }
                
                if(Math.random() < this.explorationRate) {
                    // ALWAYS check game state - never return wrong action type
                    if(Game && Game.gameState === 'CITY') {
                        let cityActions = ['BUILD_RES', 'BUILD_WELL', 'BUILD_ROAD', 'BUILD_COM', 'BUILD_IND', 'PASS_YEAR'];
                        // Weight towards building over passing
                        let weights = [30, 25, 15, 10, 10, 10]; // RES and WELL most important
                        let totalWeight = weights.reduce((a,b) => a+b, 0);
                        let rand = Math.random() * totalWeight;
                        let cumulative = 0;
                        for(let i = 0; i < cityActions.length; i++) {
                            cumulative += weights[i];
                            if(rand < cumulative) return cityActions[i];
                        }
                        return 'BUILD_RES'; // Default to building residential
                    } else if(Game && Game.gameState === 'WANDER') {
                        // In WANDER mode, explore movement/settling
                        let wanderActions = ['WANDER', 'MOVE_TO_NOMAD', 'MOVE_TO_BERRY', 'MOVE_TO_WATER', 'SETTLE'];
                        return wanderActions[Math.floor(Math.random() * wanderActions.length)];
                    }
                    // Unknown state - default to PASS_YEAR (safe)
                    return 'PASS_YEAR';
                }
                
                // Exploitation: best known action - BUT FILTER BY GAME STATE!
                // Don't let CITY mode choose WANDER actions or vice versa
                let validActions = this.actions;
                if(Game && Game.gameState === 'CITY') {
                    // Only city-building actions when settled
                    validActions = ['BUILD_RES', 'BUILD_WELL', 'PASS_YEAR', 'BUILD_IND', 'BUILD_COM', 'BUILD_ROAD'];
                } else if(Game && Game.gameState === 'WANDER') {
                    // Only wandering/settling actions pre-settlement
                    validActions = ['SETTLE', 'WANDER', 'MOVE_TO_NOMAD', 'MOVE_TO_BERRY', 'MOVE_TO_WATER', 'MOVE_TO_TREE'];
                }
                
                let bestAction = validActions[0];
                let bestValue = this.getQ(state, bestAction);
                for(let action of validActions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                return bestAction;
            },
            
            // Execute an action in the game
            executeAction: function(action) {
                // SAFETY: Never execute WANDER actions in CITY mode!
                if(Game.gameState === 'CITY' && (action === 'WANDER' || action === 'MOVE_TO_NOMAD' || 
                   action === 'MOVE_TO_BERRY' || action === 'MOVE_TO_WATER' || action === 'MOVE_TO_TREE')) {
                    console.warn('âš ï¸ Blocked WANDER action in CITY mode! Passing year instead.');
                    Game.endTurn();
                    return true;
                }
                
                if(Game.gameState === 'WANDER') {
                    if(!Game.player) return false;
                    
                    // If action is SETTLE, try to settle near water
                    if(action === 'SETTLE') {
                        // First check if we're near water, if not move toward water
                        const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                        let nearWater = false;
                        let waterDir = null;
                        
                        for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                            for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                                let x = Game.player.x + dx;
                                let y = Game.player.y + dy;
                                if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                    let tile = Game.tiles[x][y];
                                    if(tile && (tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP')) {
                                        nearWater = true;
                                        waterDir = {dx: dx, dy: dy}; // Remember direction to water
                                        break;
                                    }
                                }
                            }
                            if(nearWater) break;
                        }
                        
                        if(nearWater) {
                            // We're near water - settle!
                            Game.settleHere();
                            return true;
                        }
                        
                        // Not near water - just try to settle anyway (SimCity style - no water required!)
                        // The settleHere function will give bonuses for good locations
                        Game.settleHere();
                        return true;
                    }
                    
                    // WANDER action: hunt nomads, grab resources, explore, find water
                    const radius = 8;
                    let nomadTarget = null;
                    let berryTarget = null;
                    let woodTarget = null;
                    let waterTarget = null;
                    let animalTarget = null;
                    
                    // Check thirst level - prioritize water if low
                    let thirst = Game.thirst || 100;
                    let needsWater = thirst < 50;
                    
                    // Debug: log that we're in WANDER executeAction
                    console.log('ğŸš¶ WANDER execute: action=', action, 'pos=', Game.player.x, Game.player.y, 'food=', Game.inventory.food, 'thirst=', thirst);
                    
                    if(Game.tiles) {
                        for(let r = 1; r <= radius; r++) {
                            for(let dx = -r; dx <= r; dx++) {
                                for(let dy = -r; dy <= r; dy++) {
                                    const tx = Game.player.x + dx;
                                    const ty = Game.player.y + dy;
                                    if(tx<0 || ty<0 || tx>=Game.tiles.length || ty>=Game.tiles[0].length) continue;
                                    const tile = Game.tiles[tx][ty];
                                    if(!tile) continue;
                                    // Hunt friendly nomads for population - PRIORITY 1
                                    if(!nomadTarget && tile.entity && tile.entity.type === 'NOMAD' && tile.entity.is_hostile === false) {
                                        nomadTarget = {x: tx, y: ty};
                                    }
                                    // Grab berries for food
                                    if(!berryTarget && tile.entity && tile.entity.type === 'BERRY' && tile.entity.amount > 0) {
                                        berryTarget = {x: tx, y: ty};
                                    }
                                    // Look for animals near settlement spots (for Industrial placement)
                                    if(!animalTarget && tile.animal) {
                                        animalTarget = {x: tx, y: ty};
                                    }
                                    // Chop trees for wood (needed to settle)
                                    if(!woodTarget && tile.tree && Game.inventory && Game.inventory.wood < 50) {
                                        woodTarget = {x: tx, y: ty};
                                    }
                                    // Look for water (needed for settlement)
                                    if(!waterTarget && (tile.type === 'WATER' || tile.type === 'RIVER')) {
                                        waterTarget = {x: tx, y: ty};
                                    }
                                }
                            }
                        }
                    }
                    
                    // Priority depends on thirst level:
                    // If thirsty: water FIRST, then nomads > berries > wood
                    // If not thirsty: nomads > berries > wood > water (for settling)
                    let target;
                    if(needsWater && waterTarget) {
                        target = waterTarget; // URGENT: find water or die!
                        console.log('ğŸ’§ THIRSTY! Seeking water at', waterTarget.x, waterTarget.y);
                    } else {
                        target = nomadTarget || berryTarget || animalTarget || woodTarget || waterTarget;
                    }
                    if(target) {
                        const stepX = Math.sign(target.x - Game.player.x);
                        const stepY = Math.sign(target.y - Game.player.y);
                        console.log('ğŸ¯ Moving toward target at', target.x, target.y, '| step:', stepX, stepY);
                        if(Math.abs(target.x - Game.player.x) >= Math.abs(target.y - Game.player.y)) {
                            Game.movePlayer(stepX, 0);
                        } else {
                            Game.movePlayer(0, stepY);
                        }
                        return true;
                    }
                    
                    // Explore unexplored tiles
                    const dirs = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                    const unexplored = [];
                    for(const d of dirs) {
                        const nx = Game.player.x + d.dx;
                        const ny = Game.player.y + d.dy;
                        if(nx<0 || ny<0 || nx>=Game.tiles.length || ny>=Game.tiles[0].length) continue;
                        const t = Game.tiles[nx][ny];
                        if(!t) continue;
                        if(!t.explored && t.type !== 'WATER' && t.type !== 'DEEP' && t.type !== 'RIVER' && t.type !== 'STONE') {
                            unexplored.push(d);
                        }
                    }
                    if(unexplored.length > 0) {
                        const pick = unexplored[Math.floor(Math.random() * unexplored.length)];
                        console.log('ğŸ” Exploring:', pick.dx, pick.dy);
                        Game.movePlayer(pick.dx, pick.dy);
                        return true;
                    }
                    
                    // Fallback: random movement to any walkable tile
                    const walkable = [];
                    for(const d of dirs) {
                        const nx = Game.player.x + d.dx;
                        const ny = Game.player.y + d.dy;
                        if(nx<0 || ny<0 || nx>=Game.tiles.length || ny>=Game.tiles[0].length) continue;
                        const t = Game.tiles[nx][ny];
                        if(t && t.type !== 'WATER' && t.type !== 'DEEP' && t.type !== 'RIVER' && t.type !== 'STONE') {
                            walkable.push(d);
                        }
                    }
                    if(walkable.length > 0) {
                        const pick = walkable[Math.floor(Math.random() * walkable.length)];
                        console.log('ğŸš¶ Random walk:', pick.dx, pick.dy);
                        Game.movePlayer(pick.dx, pick.dy);
                        return true;
                    }
                    
                    // Last resort: any direction (might fail)
                    console.log('âš ï¸ No walkable tiles found!');
                    const dir = dirs[Math.floor(Math.random() * dirs.length)];
                    Game.movePlayer(dir.dx, dir.dy);
                    return true;
                }
                
                // Find a valid position to build
                var findBuildSpot = function(zoneType) {
                    // In CITY mode, find center from existing buildings or use map center
                    let centerX, centerY;
                    
                    if(Game.gameState === 'CITY') {
                        // Find center of existing buildings
                        if(Game.blds && Game.blds.length > 0) {
                            let sumX = 0, sumY = 0, count = 0;
                            for(let b of Game.blds) {
                                sumX += b.x;
                                sumY += b.y;
                                count++;
                            }
                            centerX = Math.floor(sumX / count);
                            centerY = Math.floor(sumY / count);
                        } else {
                            // No buildings yet, use map center
                            centerX = Math.floor(CFG.W / 2);
                            centerY = Math.floor(CFG.H / 2);
                        }
                    } else if(Game && Game.player) {
                        centerX = Game.player.x;
                        centerY = Game.player.y;
                    } else {
                        centerX = Math.floor(CFG.W / 2);
                        centerY = Math.floor(CFG.H / 2);
                    }
                    
                    // Search outward from center
                    const maxR = 15;
                    for(let r = 1; r <= maxR; r++) {
                        for(let dx = -r; dx <= r; dx++) {
                            for(let dy = -r; dy <= r; dy++) {
                                const x = centerX + dx;
                                const y = centerY + dy;
                                if(x<0 || y<0 || x>=CFG.W || y>=CFG.H) continue;
                                const tile = Game.tiles[x][y];
                                if(!tile) continue;
                                if(tile.type !== 'WATER' && tile.type !== 'DEEP' && tile.type !== 'RIVER' && 
                                   tile.type !== 'STONE' && !tile.stoneDeposit && !tile.zone) {
                                    return {x, y};
                                }
                            }
                        }
                    }
                    // Fallback: random search
                    for(var attempts = 0; attempts < 50; attempts++) {
                        var x = Math.floor(Math.random() * CFG.W);
                        var y = Math.floor(Math.random() * CFG.H);
                        var tile = Game.tiles[x][y];
                        if(tile && tile.type !== 'WATER' && tile.type !== 'DEEP' && tile.type !== 'RIVER' && 
                           tile.type !== 'STONE' && !tile.stoneDeposit && !tile.zone) {
                            return {x: x, y: y};
                        }
                    }
                    return null;
                };
                
                var spot;
                
                // Debug: Log what we're trying to do in CITY mode
                if(Game.gameState === 'CITY' && this.stepCount % 20 === 1) {
                    console.log('ğŸ™ï¸ CITY ACTION:', action, '| Food:', Game.food, 'Wood:', Game.wood, 'Pop:', Game.pop);
                }
                
                switch(action) {
                    case 'BUILD_RES':
                        spot = findBuildSpot();
                        // Get residential cost from config (Level 1 = 100 food, 100 wood)
                        var resCost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1] ? CFG.BUILDING_LEVELS[1] : { food: 100, wood: 100 };
                        console.log('ğŸ  BUILD_RES: spot=', spot, 'need food:', resCost.food, 'have:', Game.food, 'need wood:', resCost.wood, 'have:', Game.wood);
                        if(spot && Game.food >= resCost.food && Game.wood >= resCost.wood) {
                            Controller.selectedBuildingLevel = 1; // Set level before building
                            Game.build('RES', spot.x, spot.y);
                            console.log('âœ… Built RES at', spot.x, spot.y);
                            return true;
                        } else {
                            console.log('âŒ Cannot build RES - no spot or insufficient resources');
                            // If we can't build, pass year to get resources
                            Game.endTurn();
                            return true;
                        }
                        break;
                        
                    case 'BUILD_IND':
                        spot = findBuildSpot();
                        // Industrial Level 1 - use LEVEL_1_COSTS (200 food, 200 wood)
                        var indCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.INDUSTRIAL ? CFG.LEVEL_1_COSTS.INDUSTRIAL : { food: 200, wood: 200 };
                        if(spot && Game.food >= indCost.food && Game.wood >= indCost.wood) {
                            Controller.selectedIndustrialLevel = 1;
                            Game.build('IND', spot.x, spot.y);
                            return true;
                        } else {
                            // Can't afford, pass year
                            Game.endTurn();
                            return true;
                        }
                        break;
                        
                    case 'BUILD_COM':
                        spot = findBuildSpot();
                        // Commercial Level 1 = Campfire (200 food, 200 wood per LEVEL_1_COSTS)
                        var comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                        if(spot && Game.food >= comCost.food && Game.wood >= comCost.wood) {
                            Controller.selectedCommercialLevel = 1;
                            Game.build('COM', spot.x, spot.y);
                            return true;
                        } else {
                            Game.endTurn();
                            return true;
                        }
                        break;
                        
                    case 'BUILD_WELL':
                        spot = findBuildSpot();
                        // Well cost from config
                        var wellCost = CFG.COST && CFG.COST.WELL ? CFG.COST.WELL : 50;
                        console.log('ğŸš° BUILD_WELL: spot=', spot, 'need:', wellCost, 'have:', Game.food);
                        if(spot && Game.food >= wellCost) {
                            Game.build('WELL', spot.x, spot.y);
                            console.log('âœ… Built WELL at', spot.x, spot.y);
                            return true;
                        } else {
                            console.log('âŒ Cannot build WELL');
                            Game.endTurn();
                            return true;
                        }
                        break;
                        
                    case 'BUILD_ROAD':
                        spot = findBuildSpot();
                        // Road cost from config
                        var roadCost = CFG.COST && CFG.COST.ROAD ? CFG.COST.ROAD : 5;
                        if(spot && Game.food >= roadCost) {
                            Game.build('ROAD', spot.x, spot.y);
                            return true;
                        } else {
                            Game.endTurn();
                            return true;
                        }
                        break;
                        
                    case 'PASS_YEAR':
                        Game.endTurn();
                        return true;
                        
                    case 'WAIT':
                        // Do nothing this step - but advance the game
                        Game.endTurn();
                        return true;
                }
                
                // If we get here, action wasn't handled - pass year as fallback
                console.log('âš ï¸ Unhandled action:', action, '- passing year');
                Game.endTurn();
                return true;
            },
            
            // Calculate reward based on game state change - 2 MILLION POPULATION GOAL
            // EXPONENTIAL REWARDS - Small populations get almost nothing
            // FAILURE = ZERO POINTS - No exploitation!
            calculateReward: function(prevState, currentState, action) {
                let reward = 0;
                let actualPop = Game.pop || 0;
                let prevPop = this.lastKnownPop || actualPop;
                
                // Track population changes
                this.lastKnownPop = actualPop;
                
                // Track best pop THIS EPISODE (for career progress tracking)
                if(actualPop > this.thisEpisodeBestPop) {
                    this.thisEpisodeBestPop = actualPop;
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // EXPONENTIAL REWARD SYSTEM
                // Under 20 pop: Almost ZERO reward (learn to survive first)
                // 20-100 pop: Small rewards (foundation building)
                // 100+ pop: Exponential growth (real progress!)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // DEATH = ONLY PENALTIES, NO REWARDS
                var gameOverPanel = document.getElementById('gameover-screen');
                if(gameOverPanel && gameOverPanel.style.display === 'flex') {
                    // FAILURE: Calculate penalty based on what went wrong
                    let deathPenalty = -50; // Base penalty
                    
                    // Get building counts for death analysis
                    let blds = Game.blds || [];
                    let wellCount = blds.filter(b => b.t === 'WELL').length;
                    let resCount = blds.filter(b => b.t === 'RES').length;
                    let comCount = blds.filter(b => b.t === 'COM').length;
                    let indCount = blds.filter(b => b.t === 'IND').length;
                    
                    // Analyze death cause and update memory
                    let deathCause = 'UNKNOWN';
                    if(wellCount === 0 && actualPop > 5) {
                        deathCause = 'NO_WELLS';
                        deathPenalty -= 100;
                        this.deathMemory.deathCauseCounts.NO_WELLS++;
                        this.log('ğŸ’€ DEATH: NO WELLS!');
                    } else if(Game.food < -100) {
                        deathCause = 'FOOD_CRISIS';
                        deathPenalty -= 80;
                        this.deathMemory.deathCauseCounts.FOOD_CRISIS++;
                        this.log('ğŸ’€ DEATH: STARVATION!');
                    } else if(wellCount < Math.ceil(actualPop / 30)) {
                        deathCause = 'WATER_CRISIS';
                        deathPenalty -= 90;
                        this.deathMemory.deathCauseCounts.WATER_CRISIS++;
                        this.log('ğŸ’€ DEATH: WATER CRISIS!');
                    } else if(resCount === 0 && actualPop > 0) {
                        deathCause = 'NO_RES';
                        deathPenalty -= 70;
                        this.deathMemory.deathCauseCounts.NO_RES++;
                        this.log('ğŸ’€ DEATH: NO RESIDENTIAL!');
                    } else if(resCount > 0 && actualPop > resCount * 25) {
                        deathCause = 'OVERPOP';
                        deathPenalty -= 60;
                        this.deathMemory.deathCauseCounts.OVERPOP++;
                        this.log('ğŸ’€ DEATH: OVERPOPULATION!');
                    } else {
                        this.deathMemory.deathCauseCounts.UNKNOWN++;
                    }
                    
                    // Store death info
                    this.deathMemory.lastDeathCause = deathCause;
                    this.deathMemory.lastDeathPop = actualPop;
                    this.deathMemory.lastDeathYear = Game.year || 0;
                    this.deathMemory.lastDeathBuildings = { res: resCount, well: wellCount, com: comCount, ind: indCount };
                    };
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // UPDATE LESSONS LEARNED - Make rules stricter after each death!
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if(!this.deathMemory.lessons) {
                        this.deathMemory.lessons = {
                            minWellRatio: 30,
                            minCapacityBuffer: 1.2,
                            minFoodPerPop: 2,
                            buildWellBeforePop: 25,
                            minWells: 1,
                            minRes: 1
                        };
                    }
                    let lessons = this.deathMemory.lessons;
                    
                    // Learn from water deaths - tighten well ratio
                    if(deathCause === 'NO_WELLS' || deathCause === 'WATER_CRISIS') {
                        lessons.minWellRatio = Math.max(10, lessons.minWellRatio - 3); // Tighter ratio each death
                        lessons.minWells = Math.min(5, lessons.minWells + 1); // Need more minimum wells
                        if(actualPop > 0 && wellCount > 0) {
                            // Learn: needed a well before this pop level
                            let popPerWell = actualPop / wellCount;
                            lessons.buildWellBeforePop = Math.min(lessons.buildWellBeforePop, Math.floor(popPerWell * 0.7));
                        }
                        this.log('ğŸ“š LESSON LEARNED: Need 1 well per ' + lessons.minWellRatio + ' pop (was 30). Min wells: ' + lessons.minWells);
                    }
                    
                    // Learn from overpopulation - need more capacity buffer
                    if(deathCause === 'OVERPOP' || deathCause === 'NO_RES') {
                        lessons.minCapacityBuffer = Math.min(2.0, lessons.minCapacityBuffer + 0.2); // Need more buffer
                        lessons.minRes = Math.min(5, lessons.minRes + 1); // Need more minimum RES
                        this.log('ğŸ“š LESSON LEARNED: Need ' + (lessons.minCapacityBuffer * 100).toFixed(0) + '% capacity buffer. Min RES: ' + lessons.minRes);
                    }
                    
                    // Learn from starvation - need more food production
                    if(deathCause === 'FOOD_CRISIS') {
                        lessons.minFoodPerPop = Math.min(10, lessons.minFoodPerPop + 1);
                        this.log('ğŸ“š LESSON LEARNED: Need ' + lessons.minFoodPerPop + ' food per pop minimum');
                    }
                    
                    // Add to recent deaths (keep last 10)
                    this.deathMemory.recentDeaths.unshift(deathCause);
                    if(this.deathMemory.recentDeaths.length > 10) {
                        this.deathMemory.recentDeaths.pop();
                    }
                    
                    // Log the death pattern
                    this.log('ğŸ“Š Death pattern: ' + this.deathMemory.recentDeaths.slice(0, 5).join(' â†’ '));
                    
                    // Extra penalty for REPEATING the same mistake
                    let repeatCount = this.deathMemory.recentDeaths.filter(d => d === deathCause).length;
                    if(repeatCount > 1) {
                        let repeatPenalty = repeatCount * 50; // Reduced from 100
                        deathPenalty -= repeatPenalty;
                        this.log('ğŸ” REPEATED MISTAKE! Same cause ' + repeatCount + ' times! Extra penalty: -' + repeatPenalty);
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PERMANENT CAREER SCORE UPDATE ON DEATH
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    this.careerTotalDeaths++;
                    this.careerGamesPlayed++;
                    
                    // Calculate score change based on progress made THIS GAME
                    // thisEpisodeBestPop tracks the highest pop we achieved THIS run (not at death moment)
                    let thisRunBestPop = this.thisEpisodeBestPop || 0;
                    let madeProgress = thisRunBestPop > 10; // Did we grow at all?
                    let madeGoodProgress = thisRunBestPop > 50; // Did we reach a decent size?
                    let reachedNewMilestone = false;
                    
                    // Update OVERALL best population (career stat)
                    if(thisRunBestPop > this.bestPopulation) {
                        this.bestPopulation = thisRunBestPop;
                    }
                    
                    // Check for new career milestones (use thisRunBestPop for this run)
                    if(thisRunBestPop >= 100 && !this.careerMilestones.reached100) {
                        this.careerMilestones.reached100 = true;
                        reachedNewMilestone = true;
                        this.careerScore += 50;
                        this.log('ğŸ† CAREER MILESTONE: 100 population! +50 career points');
                    }
                    if(thisRunBestPop >= 1000 && !this.careerMilestones.reached1000) {
                        this.careerMilestones.reached1000 = true;
                        reachedNewMilestone = true;
                        this.careerScore += 100;
                        this.log('ğŸ† CAREER MILESTONE: 1,000 population! +100 career points');
                    }
                    if(thisRunBestPop >= 10000 && !this.careerMilestones.reached10000) {
                        this.careerMilestones.reached10000 = true;
                        reachedNewMilestone = true;
                        this.careerScore += 250;
                        this.log('ğŸ† CAREER MILESTONE: 10,000 population! +250 career points');
                    }
                    if(thisRunBestPop >= 100000 && !this.careerMilestones.reached100000) {
                        this.careerMilestones.reached100000 = true;
                        reachedNewMilestone = true;
                        this.careerScore += 500;
                        this.log('ğŸ† CAREER MILESTONE: 100,000 population! +500 career points');
                    }
                    if(thisRunBestPop >= 1000000 && !this.careerMilestones.reached1M) {
                        this.careerMilestones.reached1M = true;
                        reachedNewMilestone = true;
                        this.careerScore += 1000;
                        this.log('ğŸ† CAREER MILESTONE: 1 MILLION population! +1000 career points');
                    }
                    if(thisRunBestPop >= 2000000 && !this.careerMilestones.reached2M) {
                        this.careerMilestones.reached2M = true;
                        reachedNewMilestone = true;
                        this.careerScore += 5000;
                        this.log('ğŸ‘‘ ULTIMATE ACHIEVEMENT: 2 MILLION population! +5000 career points');
                    }
                    
                    // Update career pop record
                    if(thisRunBestPop > this.careerPopRecord) {
                        this.careerPopRecord = thisRunBestPop;
                        this.careerScore += Math.floor(thisRunBestPop / 100); // Bonus for new record
                    }
                    
                    // DEATH PENALTY TO CAREER - LESS HARSH, MORE LEARNING-FOCUSED
                    // Only penalize if we TRULY made no progress (didn't even reach 10 pop)
                    if(!madeProgress && !reachedNewMilestone) {
                        // Died without building anything = small penalty
                        // Learning phase - don't punish too hard, AI needs to experiment
                        let careerPenalty = Math.min(20, Math.floor(this.careerScore * 0.02)); // Only 2% or 20 max
                        this.careerScore = Math.max(100, this.careerScore - careerPenalty);
                        this.log('ğŸ’€ Early death (pop < 10). Career -' + careerPenalty + ' (now: ' + this.careerScore + ')');
                    }
                    // No penalty for making progress but dying - that's how you learn!
                    // The reward system already penalized the run, no need to double-penalize career
                    
                    // Success bonus for reaching milestones
                    if(madeGoodProgress) {
                        this.careerSuccessfulCities++;
                        // Small career bonus for surviving to 50+ pop
                        let survivalBonus = Math.floor(thisRunBestPop / 50); // +1 per 50 pop
                        this.careerScore += survivalBonus;
                        this.log('ğŸ’ª Survived to ' + thisRunBestPop + ' pop! Career +' + survivalBonus);
                    }
                    
                    // Update career high score
                    if(this.careerScore > this.careerHighScore) {
                        this.careerHighScore = this.careerScore;
                    }
                    
                    // SAVE CAREER IMMEDIATELY
                    this.saveBrain();
                    this.updateTrainingUI();
                    
                    return deathPenalty;
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // EXPONENTIAL REWARD SYSTEM - Only reward SUSTAINABLE growth!
                // Under 20 pop: ZERO reward (not sustainable yet)
                // 20+ pop: Exponential rewards based on population
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // ZERO REWARD for populations under 20 - not sustainable
                if(actualPop < 20) {
                    // Only give tiny reward for settling to encourage getting started
                    if(action === 'SETTLE' && Game.gameState === 'CITY') {
                        reward = 5; // Minimal - just to get settled
                    }
                    // No other rewards - AI must learn to reach sustainable 20+ pop
                    return reward;
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SUSTAINABLE POPULATION REWARDS (20+ pop)
                // Uses exponential formula: reward = pop^1.5 / 100
                // 20 pop = 0.89 points
                // 50 pop = 3.5 points  
                // 100 pop = 10 points
                // 500 pop = 111 points
                // 1000 pop = 316 points
                // 10000 pop = 10,000 points
                // 100000 pop = 316,227 points
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Base exponential reward for maintaining population
                let sustainableReward = Math.pow(actualPop, 1.5) / 100;
                reward += sustainableReward;
                
                // BONUS for population GROWTH (not just maintaining)
                if(actualPop > prevPop && prevPop >= 20) {
                    let growthBonus = Math.pow(actualPop - prevPop, 1.3) * 10;
                    reward += growthBonus;
                }
                
                // PENALTY for population LOSS
                if(actualPop < prevPop) {
                    let lossAmount = prevPop - actualPop;
                    let lossPenalty = Math.pow(lossAmount, 1.5) * 5;
                    reward -= lossPenalty;
                }
                
                // MILESTONE BONUSES - Only at major thresholds
                if(actualPop >= 100 && prevPop < 100) reward += 100;
                if(actualPop >= 500 && prevPop < 500) reward += 500;
                if(actualPop >= 1000 && prevPop < 1000) reward += 1000;
                if(actualPop >= 5000 && prevPop < 5000) reward += 5000;
                if(actualPop >= 10000 && prevPop < 10000) reward += 10000;
                if(actualPop >= 100000 && prevPop < 100000) reward += 100000;
                if(actualPop >= 1000000 && prevPop < 1000000) reward += 1000000;
                
                // Track building counts for infrastructure check
                let blds = Game.blds || [];
                let wellCount = blds.filter(b => b.t === 'WELL').length;
                let resCount = blds.filter(b => b.t === 'RES').length;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // INFRASTRUCTURE PENALTIES - Punish poor planning, not failing to build
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // WELL CHECK - Must have adequate water infrastructure
                let wellsNeeded = Math.max(1, Math.ceil(actualPop / 30));
                if(wellCount < wellsNeeded) {
                    reward -= (wellsNeeded - wellCount) * 20; // Penalty per missing well
                }
                
                // CAPACITY CHECK - Must have room to grow
                let currentCapacity = resCount * 20;
                if(actualPop > currentCapacity * 0.9) {
                    reward -= 20; // Penalty for being near capacity
                }
                
                // CRISIS PENALTIES
                if(currentState.includes('WC1')) reward -= 50; // Water crisis
                if(currentState.includes('FC1')) reward -= 30; // Food crisis
                
                return reward;
            },
            
            // Run one step of training
            step: function() {
                try {
                    if(!this.isTraining || this.isResetting) return; // Skip if resetting
                    
                    // Track steps per episode for timeout
                    if(!this.stepCount) this.stepCount = 0;
                    this.stepCount++;
                    
                    var prevState = this.getState();
                    var action = this.chooseAction(prevState);
                    
                    // SAFETY: Double-check action matches game state!
                    // If we're in CITY mode but got a WANDER action, force a CITY action
                    if(Game.gameState === 'CITY') {
                        let wanderActions = ['WANDER', 'MOVE_TO_NOMAD', 'MOVE_TO_BERRY', 'MOVE_TO_WATER', 'MOVE_TO_TREE', 'SETTLE'];
                        if(wanderActions.includes(action)) {
                            console.warn('ğŸš« STEP: Blocked ' + action + ' in CITY mode! Forcing BUILD_RES');
                            action = 'BUILD_RES'; // Force a city action
                        }
                    }
                    
                    // Debug log every 50 steps
                    if(this.stepCount % 50 === 1) {
                        console.log('ğŸ¤– Step', this.stepCount, '| State:', prevState, '| Action:', action, '| GameState:', Game.gameState, '| Pop:', Game.pop);
                    }
                    
                    // Execute action
                    var success = this.executeAction(action);
                    
                    // Get new state and reward
                    var currentState = this.getState();
                    var reward = this.calculateReward(prevState, currentState, action);
                    
                    // Update Q-table
                    this.updateQ(prevState, action, reward, currentState);
                    
                    this.totalReward += reward;
                    
                    // Update live stats every 10 steps
                    if(this.stepCount % 10 === 0) {
                        this.updateLiveStats(currentState, action);
                    }
                    
                    // Check for game over (multiple conditions)
                    var gameOverPanel = document.getElementById('gameover-screen');
                    var panelVisible = gameOverPanel && (gameOverPanel.style.display === 'flex' || gameOverPanel.style.display === 'block');
                    var noPop = (Game.pop !== undefined && Game.pop <= 0 && Game.gameState === 'CITY');
                    var tooManyYears = (Game.year > 200); // Allow longer games
                    var tooManySteps = (this.stepCount > 1000); // Reduced from 5000 - games shouldn't take this long
                    
                    var isGameOver = panelVisible || noPop || tooManyYears || tooManySteps;
                    
                    if(isGameOver && !this.isResetting) {
                        this.log('ğŸ›‘ DEATH: pop=' + Game.pop + ', yr=' + Game.year + ', steps=' + this.stepCount);
                        this.stepCount = 0;
                        this.endEpisode();
                    }
                } catch(err) {
                    console.error('AI step error:', err);
                    // Don't let errors kill training
                }
            },
            
            // Log to the AI panel
            log: function(msg) {
                var logEl = document.getElementById('ai-log');
                if(logEl) {
                    var time = new Date().toLocaleTimeString();
                    logEl.innerHTML = '[' + time + '] ' + msg + '<br>' + logEl.innerHTML;
                    // Keep only last 50 lines
                    var lines = logEl.innerHTML.split('<br>');
                    if(lines.length > 50) {
                        logEl.innerHTML = lines.slice(0, 50).join('<br>');
                    }
                }
                console.log('ğŸ¤– ' + msg);
            },
            
            // Update live stats display
            updateLiveStats: function(state, action) {
                var stateEl = document.getElementById('ai-current-state');
                var actionEl = document.getElementById('ai-current-action');
                var stepEl = document.getElementById('ai-step-count');
                var popEl = document.getElementById('ai-current-pop');
                
                if(stateEl) stateEl.textContent = 'State: ' + (state || '--');
                if(actionEl) actionEl.textContent = 'Action: ' + (action || '--');
                if(stepEl) stepEl.textContent = 'Steps: ' + (this.stepCount || 0);
                if(popEl) popEl.textContent = 'Pop: ' + (Game.pop || 0) + ' | Food: ' + Math.floor(Game.food || 0) + ' | Yr: ' + (Game.year || 0);
            },
            
            // End current episode and start new one
            endEpisode: function() {
                if(this.isResetting) {
                    return; // Already resetting, skip
                }
                this.isResetting = true;
                this.stepCount = 0;

                this.episode++;
                this.gamesPlayed++;
                this.episodeRewards.push(this.totalReward);

                if(this.totalReward > this.bestScore) {
                    this.bestScore = this.totalReward;
                }
                
                // === RESET BASELINE STRATEGY TRACKING ===
                this.wanderStartPop = 0;
                this.wanderTurnsWithoutGrowth = 0;
                this.lastWanderPop = 0;
                this.cityPhase = 0;
                this.cityStartYear = 0;
                this.lastCityYear = 0;

                // === TRACK LEARNING ANALYTICS ===
                // Track if AI built a city
                if(Game.gameState === 'CITY') {
                    this.citiesBuilt++;
                    
                    // Track best population
                    if(Game.pop > this.bestPopulation) {
                        this.bestPopulation = Game.pop;
                    }
                    
                    // Track best survival years
                    if(Game.year > this.bestSurvivalYears) {
                        this.bestSurvivalYears = Game.year;
                    }
                    
                    // Track balanced cities (all 3 zone types)
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                    if(resCount > 0 && comCount > 0 && indCount > 0) {
                        this.balancedCities++;
                    }
                }
                
                // === CURRICULUM PHASE ADVANCEMENT ===
                let oldPhase = this.learningPhase;
                if(this.learningPhase === 1 && this.citiesBuilt >= this.phase1Threshold) {
                    this.learningPhase = 2;
                    this.log('ğŸ“ PHASE 2: Learning city building!');
                }
                if(this.learningPhase === 2 && this.balancedCities >= this.phase2Threshold) {
                    this.learningPhase = 3;
                    this.log('ğŸ“ PHASE 3: Mastering balanced cities!');
                }
                
                // Track reward history for graph (keep last 20)
                this.rewardHistory.push(this.totalReward);
                if(this.rewardHistory.length > 20) {
                    this.rewardHistory.shift();
                }
                
                // Draw reward graph
                this.drawRewardGraph();

                // Decay exploration rate
                this.explorationRate = Math.max(this.minExploration, this.explorationRate * this.explorationDecay);

                // Log progress
                this.log('ğŸ® Ep ' + this.episode + ': R=' + this.totalReward.toFixed(0) + ', Best=' + this.bestScore.toFixed(0));

                // --- Persistent logging ---
                try {
                    let sessionId = localStorage.getItem('civilzones_ai_session_id');
                    if(!sessionId) {
                        sessionId = 'sess_' + Date.now() + '_' + Math.floor(Math.random()*1000000);
                        localStorage.setItem('civilzones_ai_session_id', sessionId);
                    }
                    let log = JSON.parse(localStorage.getItem('civilzones_ai_log') || '[]');
                    log.push({
                        session: sessionId,
                        episode: this.episode,
                        reward: this.totalReward,
                        bestScore: this.bestScore,
                        explorationRate: this.explorationRate,
                        statesLearned: Object.keys(this.qTable).length,
                        timestamp: new Date().toISOString()
                    });
                    localStorage.setItem('civilzones_ai_log', JSON.stringify(log));
                } catch(e) { console.warn('AI log error', e); }

                // Update UI
                this.updateTrainingUI();

                // Reset for next episode
                this.totalReward = 0;
                this.thisEpisodeBestPop = 0; // Reset this episode's best pop tracker
                this.lastKnownPop = 0; // Reset pop tracking

                // Start new game immediately (no setTimeout race conditions)
                this.forceResetGame();
                this.isResetting = false;
            },
            
            // Force reset game without any dialogs or page reloads
            forceResetGame: function() {
                try {
                    console.log('ğŸ”„ forceResetGame starting...');
                    
                    // Hide game over screen
                    var gameOverPanel = document.getElementById('gameover-screen');
                    if(gameOverPanel) gameOverPanel.style.display = 'none';
                    
                    // Direct game state reset
                    if(typeof Game !== 'undefined') {
                        // Re-init with new seed - this will reset everything including player
                        Game.init(Math.floor(Math.random() * 999999));
                        
                        console.log('ğŸ”„ Game.init complete. Player:', Game.player ? 'OK at ' + Game.player.x + ',' + Game.player.y : 'NULL');
                        console.log('ğŸ”„ Tiles:', Game.tiles ? Game.tiles.length + 'x' + (Game.tiles[0] ? Game.tiles[0].length : 0) : 'NULL');
                        
                        // Force camera to player position (Game.init sets this, but ensure it)
                        if(typeof Controller !== 'undefined' && Game.player) {
                            Controller.cam.x = Game.player.x * CFG.TILE;
                            Controller.cam.y = Game.player.y * CFG.TILE;
                            Controller.cam.z = CFG.CAMERA.START_ZOOM || 1;
                            console.log('ğŸ”„ Camera set to:', Controller.cam.x, Controller.cam.y);
                        }
                        
                        // Force explore starting area (in case spawnPlayer missed it)
                        if(Game.player && Game.exploreArea) {
                            Game.exploreArea(Game.player.x, Game.player.y, 5);
                        }
                    }
                    
                    // Reset progression
                    if(typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) {
                        PROGRESSION.reset();
                    }
                    
                    // Update UI
                    if(typeof Controller !== 'undefined' && Controller.updateUI) {
                        Controller.updateUI();
                    }
                    
                    // Force a render refresh
                    if(typeof Renderer !== 'undefined' && Renderer.resize) {
                        Renderer.resize();
                    }
                    
                    console.log('ğŸ”„ forceResetGame complete!');
                    
                } catch(err) {
                    console.error('Force reset error:', err);
                    // DO NOT reload page - just continue
                }
            },
            
            // Start training
            startTraining: function() {
                var self = this;
                this.isTraining = true;
                this.isResetting = false;
                this.stepCount = 0;
                this.loopCounter = 0;
                this.errorCount = 0;
                this.log('â–¶ï¸ Training STARTED at speed ' + this.trainingSpeed + 'x');
                
                // Clear any existing intervals
                if(this.trainingIntervalId) clearInterval(this.trainingIntervalId);
                
                // The main training interval - NEVER stops unless user clicks stop
                this.trainingIntervalId = setInterval(function() {
                    try {
                        if(!self.isTraining) {
                            return; // Don't clear interval, just skip
                        }
                        
                        self.loopCounter++;
                        
                        // Skip steps while resetting
                        if(self.isResetting) {
                            return; // Let reset complete
                        }
                        
                        // Run steps with error protection
                        for(var i = 0; i < self.trainingSpeed; i++) {
                            try {
                                self.step();
                            } catch(stepErr) {
                                self.errorCount++;
                                if(self.errorCount < 10) {
                                    console.error('Step error:', stepErr);
                                }
                            }
                        }
                        
                        // Periodic status log
                        if(self.loopCounter % 600 === 0) { // Every ~10 seconds
                            self.log('ğŸ’“ Running: Ep=' + self.episode + ', Loop=' + self.loopCounter + ', Errors=' + self.errorCount);
                        }
                        
                    } catch(loopErr) {
                        console.error('Loop error:', loopErr);
                        self.errorCount++;
                    }
                }, 16);
                
                this.updateTrainingUI();
            },
            
            // Stop training
            stopTraining: function() {
                this.isTraining = false;
                if(this.trainingIntervalId) {
                    clearInterval(this.trainingIntervalId);
                    this.trainingIntervalId = null;
                }
                this.log('â¹ï¸ STOPPED - ' + this.episode + ' episodes, ' + this.errorCount + ' errors');
                this.updateTrainingUI();
            },
            
            // Export stats to file
            exportStats: function() {
                var stats = {
                    totalEpisodes: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    statesLearned: Object.keys(this.qTable).length,
                    recentRewards: this.episodeRewards.slice(-100),
                    avgReward: this.episodeRewards.length > 0 ? 
                        (this.episodeRewards.reduce(function(a,b){return a+b;}, 0) / this.episodeRewards.length).toFixed(2) : 0,
                    exportDate: new Date().toISOString()
                };
                
                var blob = new Blob([JSON.stringify(stats, null, 2)], {type: 'application/json'});
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.download = 'ai_training_stats_' + this.episode + '_episodes.json';
                a.click();
                URL.revokeObjectURL(url);
                this.log('ğŸ“Š Stats exported!');
            },
            
            // Save Q-table to localStorage
            saveBrain: function() {
                let data = {
                    qTable: this.qTable,
                    episode: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    episodeRewards: this.episodeRewards.slice(-100), // Keep last 100
                    // PERMANENT CAREER DATA
                    careerScore: this.careerScore,
                    careerHighScore: this.careerHighScore,
                    careerPopRecord: this.careerPopRecord,
                    careerGamesPlayed: this.careerGamesPlayed,
                    careerTotalDeaths: this.careerTotalDeaths,
                    careerSuccessfulCities: this.careerSuccessfulCities,
                    careerMilestones: this.careerMilestones,
                    // DEATH MEMORY - Remember what killed us!
                    deathMemory: this.deathMemory
                };
                localStorage.setItem('civilzones_ai_brain', JSON.stringify(data));
                let lessons = this.deathMemory.lessons || {};
                console.log('ğŸ§  AI Brain Saved! Career:', this.careerScore, 'Lessons:', lessons);
                Controller.toast('ğŸ§  Brain Saved! Lessons: 1 well per ' + (lessons.minWellRatio || 30) + ' pop, ' + (lessons.minCapacityBuffer * 100 || 120) + '% capacity buffer');
            },
            
            // Load Q-table from localStorage
            loadBrain: function() {
                let saved = localStorage.getItem('civilzones_ai_brain');
                if(saved) {
                    let data = JSON.parse(saved);
                    this.qTable = data.qTable || {};
                    this.episode = data.episode || 0;
                    this.bestScore = data.bestScore || 0;
                    this.explorationRate = data.explorationRate || 0.1;
                    this.episodeRewards = data.episodeRewards || [];
                    // LOAD PERMANENT CAREER DATA
                    this.careerScore = data.careerScore || 1000;
                    this.careerHighScore = data.careerHighScore || 1000;
                    this.careerPopRecord = data.careerPopRecord || 0;
                    this.careerGamesPlayed = data.careerGamesPlayed || 0;
                    this.careerTotalDeaths = data.careerTotalDeaths || 0;
                    this.careerSuccessfulCities = data.careerSuccessfulCities || 0;
                    this.careerMilestones = data.careerMilestones || {};
                    this.thisGameStartScore = this.careerScore;
                    // LOAD DEATH MEMORY
                    if(data.deathMemory) {
                        this.deathMemory = data.deathMemory;
                    }
                    let lessons = this.deathMemory.lessons || {};
                    console.log('ğŸ§  AI Brain Loaded! Career:', this.careerScore, 'Lessons:', lessons);
                    Controller.toast('ğŸ§  Loaded! Lessons: 1 well/' + (lessons.minWellRatio || 30) + 'pop, ' + ((lessons.minCapacityBuffer || 1.2) * 100).toFixed(0) + '% buffer');
                    this.updateTrainingUI();
                    return true;
                }
                return false;
            },
            
            // Reset AI brain (preserves career + death memory by default, full reset option)
            resetBrain: function(fullReset) {
                // Save career data AND death memory before reset
                let savedCareer = {
                    careerScore: this.careerScore,
                    careerHighScore: this.careerHighScore,
                    careerPopRecord: this.careerPopRecord,
                    careerGamesPlayed: this.careerGamesPlayed,
                    careerTotalDeaths: this.careerTotalDeaths,
                    careerSuccessfulCities: this.careerSuccessfulCities,
                    careerMilestones: this.careerMilestones,
                    deathMemory: this.deathMemory // PRESERVE DEATH MEMORY!
                };
                
                this.qTable = {};
                this.episode = 0;
                this.totalReward = 0;
                this.episodeRewards = [];
                this.bestScore = 0;
                this.explorationRate = 1.0;
                this.playerDemonstrations = [];
                
                if(fullReset) {
                    // FULL RESET - career and death memory wiped
                    this.careerScore = 1000;
                    this.careerHighScore = 1000;
                    this.careerPopRecord = 0;
                    this.careerGamesPlayed = 0;
                    this.careerTotalDeaths = 0;
                    this.careerSuccessfulCities = 0;
                    this.careerMilestones = {};
                    // Reset death memory too
                    this.deathMemory = {
                        lastDeathCause: null,
                        lastDeathPop: 0,
                        lastDeathYear: 0,
                        lastDeathBuildings: {},
                        recentDeaths: [],
                        deathCauseCounts: {
                            WATER_CRISIS: 0, FOOD_CRISIS: 0, NO_WELLS: 0,
                            NO_RES: 0, OVERPOP: 0, UNKNOWN: 0
                        }
                    };
                    localStorage.removeItem('civilzones_ai_brain');
                    console.log('ğŸ§  AI Brain FULLY Reset! Career + death memory wiped!');
                    Controller.toast('ğŸ§  AI Brain FULLY Reset! All memories wiped!');
                } else {
                    // Keep career data AND death memory (only reset learning)
                    Object.assign(this, savedCareer);
                    this.thisGameStartScore = this.careerScore;
                    localStorage.setItem('civilzones_ai_brain', JSON.stringify(savedCareer));
                    console.log('ğŸ§  AI Learning Reset! Career preserved:', this.careerScore, 'Deaths remembered:', this.deathMemory.deathCauseCounts);
                    Controller.toast('ğŸ§  Learning Reset! Still remember ' + this.careerTotalDeaths + ' deaths');
                }
                this.updateTrainingUI();
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // IMITATION LEARNING - AI learns from watching the player
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Start watching player
            startWatching: function() {
                this.isWatching = true;
                this.watchStartState = this.getState();
                this.playerDemonstrations = [];
                this.log('ğŸ‘ï¸ AI is now WATCHING you play! It will learn from your actions.');
                Controller.toast('ğŸ‘ï¸ AI is watching and learning from you!');
                this.updateWatchUI();
            },
            
            // Stop watching and learn from demonstrations
            stopWatching: function() {
                if(!this.isWatching) return;
                
                this.isWatching = false;
                let demos = this.playerDemonstrations.length;
                
                if(demos > 0) {
                    // Learn from player demonstrations with high learning rate
                    let learnedCount = 0;
                    let uniqueStates = new Set();
                    
                    for(let demo of this.playerDemonstrations) {
                        // Give high Q-value to player's chosen actions
                        if(!this.qTable[demo.state]) this.qTable[demo.state] = {};
                        
                        // Set the action the player chose to a high positive value
                        let currentQ = this.qTable[demo.state][demo.action] || 0;
                        // Boost player actions significantly - they know best!
                        this.qTable[demo.state][demo.action] = Math.max(currentQ, demo.reward + 50);
                        
                        // Also apply Q-learning update for state transitions
                        if(demo.nextState && demo.nextState !== demo.state) {
                            this.updateQ(demo.state, demo.action, demo.reward, demo.nextState);
                        }
                        
                        uniqueStates.add(demo.state);
                        learnedCount++;
                    }
                    
                    // Show detailed learning stats
                    let stats = this.watchModeStats;
                    let summaryParts = [];
                    if(stats.moveToNomad > 0) summaryParts.push(`${stats.moveToNomad} nomad hunts`);
                    if(stats.moveToBerry > 0) summaryParts.push(`${stats.moveToBerry} berry grabs`);
                    if(stats.moveToWater > 0) summaryParts.push(`${stats.moveToWater} water trips`);
                    if(stats.moveToTree > 0) summaryParts.push(`${stats.moveToTree} tree chops`);
                    if(stats.settle > 0) summaryParts.push(`${stats.settle} settlements`);
                    if(stats.builds > 0) summaryParts.push(`${stats.builds} buildings`);
                    
                    let summary = summaryParts.length > 0 ? summaryParts.join(', ') : 'exploration';
                    
                    this.log(`ğŸ“ Learned ${learnedCount} actions across ${uniqueStates.size} unique states!`);
                    this.log(`ğŸ“Š Behaviors: ${summary}`);
                    Controller.toast(`ğŸ“ AI learned ${learnedCount} actions! (${uniqueStates.size} states)`);
                    
                    // Decrease exploration rate since we have player knowledge now
                    this.explorationRate = Math.max(this.minExploration, this.explorationRate * 0.8);
                    
                    // Save the brain with new knowledge
                    this.saveBrain();
                } else {
                    this.log('ğŸ‘ï¸ Stopped watching (no actions recorded)');
                    Controller.toast('ğŸ‘ï¸ Stopped watching - no actions to learn from');
                }
                
                // Reset watch mode stats for next session
                this.watchModeStats = {
                    totalActions: 0,
                    moveToNomad: 0,
                    moveToBerry: 0,
                    moveToWater: 0,
                    moveToTree: 0,
                    wander: 0,
                    settle: 0,
                    builds: 0
                };
                
                this.updateWatchUI();
            },
            
            // Record a player action (called when player does something)
            recordPlayerAction: function(action) {
                if(!this.isWatching) return;
                
                // Debounce rapid movement actions (don't record every single step)
                let now = Date.now();
                if(action.startsWith('MOVE_') || action === 'WANDER') {
                    if(this.lastRecordedAction === action && (now - this.lastRecordTime) < 200) {
                        return; // Skip duplicate movement within 200ms
                    }
                }
                this.lastRecordedAction = action;
                this.lastRecordTime = now;
                
                let state = this.getState();
                let prevState = this.watchStartState || state;
                
                // Calculate contextual reward based on action and game state
                let reward = 5; // Base reward for any player action
                
                // === WANDER MODE REWARDS - Learning to explore efficiently ===
                if(Game.gameState === 'WANDER') {
                    let thirst = Game.thirst || 100;
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    
                    // Moving to water when thirsty is VERY smart
                    if(action === 'MOVE_TO_WATER') {
                        reward += thirst < 50 ? 40 : 15; // Extra if actually thirsty
                        this.watchModeStats.moveToWater++;
                    }
                    // Recruiting nomads is always good
                    if(action === 'MOVE_TO_NOMAD') {
                        reward += 25;
                        this.watchModeStats.moveToNomad++;
                    }
                    // Gathering food when needed
                    if(action === 'MOVE_TO_BERRY') {
                        reward += food < 100 ? 30 : 10;
                        this.watchModeStats.moveToBerry++;
                    }
                    // Chopping trees when wood needed
                    if(action === 'MOVE_TO_TREE') {
                        reward += wood < 50 ? 20 : 8;
                        this.watchModeStats.moveToTree++;
                    }
                    // General exploration
                    if(action === 'WANDER') {
                        reward += 3;
                        this.watchModeStats.wander++;
                    }
                    // Settling is the big goal
                    if(action === 'SETTLE') {
                        reward += 50;
                        this.watchModeStats.settle++;
                    }
                }
                
                // === CITY MODE REWARDS - Learning to build cities ===
                if(Game.gameState === 'CITY') {
                    let pop = Game.pop || 0;
                    let wellCount = Game.wellCount || 0;
                    
                    // Building wells when needed
                    if(action === 'BUILD_WELL') {
                        let wellsNeeded = Math.ceil(pop / 100);
                        reward += wellCount < wellsNeeded ? 35 : 15;
                        this.watchModeStats.builds++;
                    }
                    // Building housing
                    if(action === 'BUILD_RES') {
                        reward += 20;
                        this.watchModeStats.builds++;
                    }
                    // Building roads for connectivity
                    if(action === 'BUILD_ROAD') {
                        reward += 15;
                        this.watchModeStats.builds++;
                    }
                    // Building commerce/industry
                    if(action === 'BUILD_IND' || action === 'BUILD_COM') {
                        reward += 18;
                        this.watchModeStats.builds++;
                    }
                    // Passing year
                    if(action === 'PASS_YEAR') {
                        reward += 5;
                    }
                }
                
                this.watchModeStats.totalActions++;
                
                this.playerDemonstrations.push({
                    state: prevState,
                    action: action,
                    nextState: state,
                    reward: reward,
                    timestamp: now
                });
                
                this.watchStartState = state;
                
                // Log with more detail
                console.log(`ğŸ‘ï¸ Recorded: ${action} (reward: ${reward}) in state: ${prevState.substring(0, 30)}...`);
                
                // Update watch UI counter
                this.updateWatchUI();
            },
            
            // Update watch UI
            updateWatchUI: function() {
                let btn = document.getElementById('ai-watch-btn');
                if(btn) {
                    btn.textContent = this.isWatching ? 'â¹ï¸ Stop Watching' : 'ğŸ‘ï¸ Watch Me';
                    btn.style.background = this.isWatching ? '#e74c3c' : '#9b59b6';
                }
                let countEl = document.getElementById('ai-demo-count');
                if(countEl) countEl.textContent = this.playerDemonstrations.length;
            },
            
            // Update training UI panel
            updateTrainingUI: function() {
                let panel = document.getElementById('ai-training-panel');
                if(!panel) return;
                
                let avgReward = this.episodeRewards.length > 0 
                    ? (this.episodeRewards.slice(-20).reduce((a,b) => a+b, 0) / Math.min(20, this.episodeRewards.length)).toFixed(1)
                    : 0;
                
                document.getElementById('ai-episode').textContent = this.episode;
                document.getElementById('ai-best-score').textContent = this.bestScore.toFixed(1);
                document.getElementById('ai-avg-reward').textContent = avgReward;
                document.getElementById('ai-exploration').textContent = (this.explorationRate * 100).toFixed(1) + '%';
                document.getElementById('ai-states').textContent = Object.keys(this.qTable).length;
                
                // === UPDATE CAREER SCORE DISPLAY ===
                let careerScoreEl = document.getElementById('ai-career-score');
                let careerHighEl = document.getElementById('ai-career-high');
                let careerPopEl = document.getElementById('ai-career-pop-record');
                let careerGamesEl = document.getElementById('ai-career-games');
                let careerDeathsEl = document.getElementById('ai-career-deaths');
                let careerSuccessEl = document.getElementById('ai-career-successes');
                
                if(careerScoreEl) {
                    careerScoreEl.textContent = this.careerScore;
                    // Color based on score health
                    if(this.careerScore >= this.thisGameStartScore) {
                        careerScoreEl.style.color = '#4CAF50'; // Green - improving
                    } else if(this.careerScore < 500) {
                        careerScoreEl.style.color = '#e74c3c'; // Red - in danger
                    } else {
                        careerScoreEl.style.color = '#ffd700'; // Gold - normal
                    }
                }
                if(careerHighEl) careerHighEl.textContent = this.careerHighScore;
                if(careerPopEl) careerPopEl.textContent = this.careerPopRecord.toLocaleString();
                if(careerGamesEl) careerGamesEl.textContent = this.careerGamesPlayed;
                if(careerDeathsEl) careerDeathsEl.textContent = this.careerTotalDeaths;
                if(careerSuccessEl) careerSuccessEl.textContent = this.careerSuccessfulCities;
                
                // Update learning analytics
                let citiesEl = document.getElementById('ai-cities-built');
                let bestPopEl = document.getElementById('ai-best-pop');
                let bestYearEl = document.getElementById('ai-best-year');
                let rciEl = document.getElementById('ai-rci-balance');
                let smartEl = document.getElementById('ai-settled-near-res');
                
                if(citiesEl) citiesEl.textContent = 'Cities Built: ' + this.citiesBuilt;
                if(bestPopEl) bestPopEl.textContent = 'Best Population: ' + this.bestPopulation;
                if(bestYearEl) bestYearEl.textContent = 'Best Survival: ' + this.bestSurvivalYears + ' years';
                if(rciEl) rciEl.textContent = 'Balanced Cities: ' + this.balancedCities;
                if(smartEl) smartEl.textContent = 'Smart Settlements: ' + this.smartSettlements;
                
                // === UPDATE DEATH MEMORY DISPLAY ===
                let dc = this.deathMemory.deathCauseCounts;
                let waterEl = document.getElementById('ai-death-water');
                let foodEl = document.getElementById('ai-death-food');
                let housingEl = document.getElementById('ai-death-housing');
                let overpopEl = document.getElementById('ai-death-overpop');
                let lastEl = document.getElementById('ai-death-last');
                
                if(waterEl) waterEl.innerHTML = 'ğŸ’§ Water Crisis: <span style="color:#3498db;">' + (dc.NO_WELLS + dc.WATER_CRISIS) + '</span>';
                if(foodEl) foodEl.innerHTML = 'ğŸŒ¾ Food Crisis: <span style="color:#f1c40f;">' + dc.FOOD_CRISIS + '</span>';
                if(housingEl) housingEl.innerHTML = 'ğŸ  No Housing: <span style="color:#e67e22;">' + dc.NO_RES + '</span>';
                if(overpopEl) overpopEl.innerHTML = 'ğŸ“ˆ Overpopulation: <span style="color:#9b59b6;">' + dc.OVERPOP + '</span>';
                
                if(lastEl) {
                    let lastDeath = this.deathMemory.lastDeathCause;
                    if(lastDeath) {
                        lastEl.innerHTML = 'âš ï¸ Last: <span style="color:#e74c3c;font-weight:500;">' + lastDeath + '</span> @ pop ' + this.deathMemory.lastDeathPop;
                    } else {
                        lastEl.innerHTML = 'Last death: none yet';
                    }
                }
                
                // Update curriculum phase banner
                let phaseBanner = document.getElementById('ai-phase-banner');
                if(phaseBanner) {
                    let phase = this.learningPhase || 1;
                    if(phase === 1) {
                        phaseBanner.style.background = '#2e7d32';
                        phaseBanner.innerHTML = 'ğŸ“ Phase 1: Learning Survival (' + this.citiesBuilt + '/' + this.phase1Threshold + ' cities)';
                    } else if(phase === 2) {
                        phaseBanner.style.background = '#1565c0';
                        phaseBanner.innerHTML = 'ğŸ—ï¸ Phase 2: Building Cities (' + this.balancedCities + '/' + this.phase2Threshold + ' balanced)';
                    } else {
                        phaseBanner.style.background = '#6a1b9a';
                        phaseBanner.innerHTML = 'ğŸ‘‘ Phase 3: Mastering Balance!';
                    }
                }
                
                let btn = document.getElementById('ai-train-btn');
                if(btn) btn.textContent = this.isTraining ? 'â¹ï¸ Stop' : 'â–¶ï¸ Train';
            },
            
            // Draw reward trend graph
            drawRewardGraph: function() {
                let canvas = document.getElementById('ai-reward-graph');
                if(!canvas || !canvas.getContext) return;
                let ctx = canvas.getContext('2d');
                let w = canvas.width;
                let h = canvas.height;
                
                // Clear
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);
                
                if(this.rewardHistory.length < 2) return;
                
                // Find min/max
                let minR = Math.min(...this.rewardHistory, 0);
                let maxR = Math.max(...this.rewardHistory, 100);
                let range = maxR - minR || 1;
                
                // Draw zero line
                let zeroY = h - ((0 - minR) / range) * h;
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(w, zeroY);
                ctx.stroke();
                
                // Draw line graph
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#4CAF50';
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            
            // Get best action for current state (for display)
            getBestAction: function() {
                let state = this.getState();
                let bestAction = this.actions[0];
                let bestValue = this.getQ(state, bestAction);
                
                for(let action of this.actions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                
                return {action: bestAction, value: bestValue.toFixed(2)};
            }
        };
        
        // Try to load saved brain on startup
        setTimeout(() => QLearningAI.loadBrain(), 1000);

        window.onload=()=>{
            try {
                Controller.init();
            } catch(err) {
                console.error('Failed to initialize:', err);
                document.getElementById('toast').innerText = 'Initialization Error! Check console (F12)';
                document.getElementById('toast').style.opacity = '1';
            }
        };
    </script>

</body></html>