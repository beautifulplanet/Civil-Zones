<!DOCTYPE html>
<!-- saved from url=(0087)file:///C:/Users/Elite/Documents/My%20Made%20Games/CitGame%20Early%20version/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Civil Zones v1 - Stone Age Civilization</title>
    <style>
        :root {
            --bg: #000; --text: #eee; --panel: #222; --border: #444;
            --c-res: #4fc3f7; --c-com: #ffd54f; --c-ind: #ff7043; --c-wat: #00e5ff; --c-road: #8d6e63; --c-bull: #e57373;
            --accent: #4CAF50; --accent-hover: #66BB6A; --text-primary: #f0f0f0; --text-secondary: #b0b0b0; --text-muted: #888;
        }
        /* Google Font loaded locally to avoid internet dependency */
        /* @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap'); */
        html, body { margin: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #8B5CF6 0%, #3B82F6 50%, #10B981 100%); color: var(--text); font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; overflow: hidden; display: flex; flex-direction: column; user-select: none; }
        
        #menubar { height: 70px; background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%); display: flex; align-items: center; padding: 0 25px; gap: 12px; border-bottom: 2px solid rgba(76, 175, 80, 0.3); z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.7), 0 2px 10px rgba(76, 175, 80, 0.2); }
        #viewport { flex-grow: 1; background: linear-gradient(180deg, #8B5CF6 0%, #3B82F6 50%, #10B981 100%); position: relative; overflow: hidden; display: flex; }
        #sidebar { width: 280px; background: #1a1a1a; border-right: 2px solid #444; overflow-y: auto; padding: 15px; display: none; z-index: 50; }
        #canvas-container { flex-grow: 1; position: relative; }
        canvas { display: block; width: 100%; height: 100%; }
        #dashboard { 
            height: auto; 
            min-height: 80px;
            background: linear-gradient(180deg, #1a1a1a 0%, #222 100%); 
            border-top: 2px solid var(--accent); 
            display: flex; 
            align-items: center; 
            padding: 12px 30px; 
            justify-content: space-between; 
            gap: 20px;
            z-index: 100;
            box-shadow: 0 -2px 15px rgba(0,0,0,0.5);
        }

        .btn { 
            padding: 12px 16px; 
            border: 2px solid #3a3a3a; 
            background: linear-gradient(135deg, #2d2d2d 0%, #232323 100%); 
            color: #e0e0e0; 
            cursor: pointer; 
            font-weight: 600; 
            border-radius: 8px; 
            font-family: 'Segoe UI', sans-serif;
            font-size: 20px; 
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 3px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
            white-space: nowrap;
            position: relative;
            overflow: hidden;
            min-width: 50px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }
        .btn:hover::before {
            left: 100%;
        }
        .btn:hover { 
            background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%); 
            border-color: var(--accent); 
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4), 0 0 20px rgba(76, 175, 80, 0.2);
        }
        .btn.active { 
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%) !important; 
            border-color: #66BB6A; 
            color: #fff; 
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.7), 0 4px 15px rgba(76, 175, 80, 0.5), inset 0 2px 8px rgba(0,0,0,0.3);
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }
        .btn:disabled { 
            opacity: 0.3; 
            cursor: not-allowed; 
            background: linear-gradient(135deg, #252525 0%, #1a1a1a 100%); 
            color: #555;
            border-color: #333;
        }
        .btn:disabled:hover { 
            background: linear-gradient(135deg, #252525 0%, #1a1a1a 100%); 
            color: #555;
            transform: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        /* Building Level Selector Panel */
        #building-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 50%, #1e1e1e 100%); 
            border: 3px solid var(--accent); 
            border-radius: 16px; 
            padding: 25px; 
            display: none; 
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9), 0 0 100px rgba(76, 175, 80, 0.2);
            min-width: 500px;
            max-width: 90vw;
            max-height: 85vh;
            backdrop-filter: blur(10px);
        }
        #industrial-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 50%, #1e1e1e 100%); 
            border: 3px solid #E53935; 
            border-radius: 16px; 
            padding: 25px; 
            display: none; 
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9), 0 0 100px rgba(229, 57, 53, 0.2);
            min-width: 500px;
            max-width: 90vw;
            max-height: 85vh;
            backdrop-filter: blur(10px);
        }
        #industrial-menu-panel .menu-title {
            font-size: 22px;
            font-weight: 800;
            color: #E53935;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #E53935;
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #industrial-menu-panel .level-card.selected {
            background: linear-gradient(135deg, rgba(229, 57, 53, 0.3) 0%, rgba(198, 40, 40, 0.2) 100%);
            border-color: #EF5350;
            box-shadow: 0 0 20px rgba(229, 57, 53, 0.6);
        }
        /* Roads Menu Panel */
        #road-menu-panel { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: linear-gradient(135deg, #1a1a1a 0%, #252525 50%, #1e1e1e 100%); 
            border: 3px solid var(--c-road); 
            border-radius: 16px; 
            padding: 25px; 
            display: none; 
            z-index: 1001;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9), 0 0 100px rgba(141, 110, 99, 0.3);
            min-width: 500px;
            max-width: 90vw;
            max-height: 85vh;
            backdrop-filter: blur(10px);
        }
        #road-menu-panel .menu-title {
            font-size: 22px;
            font-weight: 800;
            color: var(--c-road);
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid var(--c-road);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #road-menu-panel .level-card.selected {
            background: linear-gradient(135deg, rgba(141, 110, 99, 0.3) 0%, rgba(109, 76, 65, 0.2) 100%);
            border-color: #A1887F;
            box-shadow: 0 0 20px rgba(141, 110, 99, 0.6);
        }
        #building-menu-panel .menu-title {
            font-size: 22px;
            font-weight: 800;
            color: var(--accent);
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 20px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 15px;
            padding-right: 20px;
        }
        .level-grid::-webkit-scrollbar {
            width: 12px;
        }
        .level-grid::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 6px;
        }
        .level-grid::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 6px;
        }
        .level-card {
            background: linear-gradient(135deg, #2d2d2d 0%, #232323 100%);
            border: 2px solid #3a3a3a;
            border-radius: 12px;
            padding: 18px 14px;
            cursor: pointer;
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
            min-height: 140px;
        }
        .level-card:hover {
            background: linear-gradient(135deg, #3a3a3a 0%, #2d2d2d 100%);
            border-color: var(--accent);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }
        .level-card.selected {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.3) 0%, rgba(56, 142, 60, 0.2) 100%);
            border-color: #66BB6A;
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.6);
            transform: scale(1.03);
            border-width: 3px;
        }
        .level-card.level-locked {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(70%);
        }
        .level-card.level-locked:hover {
            transform: none;
            box-shadow: none;
            border-color: #333;
        }
        .level-card.level-locked .level-cost {
            color: #FF5252;
            font-size: 11px;
        }
        .level-card .level-icon {
            font-size: 42px;
            text-align: center;
            margin-bottom: 8px;
        }
        .level-card .level-number {
            position: absolute;
            top: 6px;
            left: 8px;
            font-size: 14px;
            color: #888;
            font-weight: bold;
        }
        .level-card .level-name {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 6px;
            line-height: 1.3;
            min-height: 36px;
        }
        .level-card .level-stats {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 6px;
        }
        .level-card .level-cost {
            font-size: 12px;
            color: #FFD700;
            text-align: center;
            font-weight: 600;
            padding-top: 6px;
            border-top: 1px solid #333;
        }
        .menu-close-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        .menu-close-btn:hover {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            transform: rotate(90deg) scale(1.1);
        }
        
        .build-category { margin-bottom: 20px; }
        .category-title { color: #4CAF50; font-weight: bold; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #333; }
        .build-btn { width: 100%; padding: 12px; margin-bottom: 8px; border: 1px solid #555; background: #2a2a2a; color: #ccc; cursor: pointer; font-weight: bold; border-radius: 4px; font-family: sans-serif; text-align: left; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
        .build-btn:hover { background: #3a3a3a; border-color: #777; }
        .build-btn.active { background: #4CAF50; border-color: #66BB6A; color: #fff; }
        .build-btn .cost { font-size: 11px; color: #999; }
        .build-btn.active .cost { color: #E8F5E9; }

        .b-res { border-bottom: 3px solid var(--c-res); } .b-com { border-bottom: 3px solid var(--c-com); }
        .b-ind { border-bottom: 3px solid var(--c-ind); } .b-wat { border-bottom: 3px solid var(--c-wat); } .b-road { border-bottom: 3px solid var(--c-road); }

        .stat { 
            display: flex; 
            flex-direction: column; 
            margin-right: 8px;
            padding: 8px 14px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            transition: background 0.2s ease;
        }
        .stat:hover {
            background: rgba(255,255,255,0.08);
        }
        .lbl { 
            font-size: 10px; 
            color: #888; 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-bottom: 2px;
        }
        .val { 
            font-size: 20px; 
            font-weight: 700;
            letter-spacing: -0.3px;
        }
        
        #toast { 
            position: absolute; 
            top: 85px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: linear-gradient(135deg, rgba(0,0,0,0.96) 0%, rgba(30,30,30,0.96) 100%); 
            border: 3px solid var(--accent); 
            color: #fff; 
            padding: 20px 50px; 
            border-radius: 50px; 
            opacity: 0; 
            transition: opacity 0.3s ease, transform 0.3s ease; 
            pointer-events: none; 
            z-index: 300; 
            font-family: 'Segoe UI', sans-serif;
            font-weight: 700; 
            font-size: 16px;
            box-shadow: 0 6px 30px rgba(0,0,0,0.9), 0 0 50px rgba(76, 175, 80, 0.4), inset 0 1px 0 rgba(255,255,255,0.1);
            letter-spacing: 0.5px;
        }
        #debug { 
            position: absolute; 
            bottom: 10px; 
            right: 10px; 
            font-size: 11px; 
            color: var(--text-muted); 
            pointer-events: none; 
            z-index: 101;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        #file-input { display: none; }
        
        /* Tooltip System */
        .btn[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(30,30,30,0.95) 100%);
            color: #fff;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            white-space: nowrap;
            margin-bottom: 8px;
            pointer-events: none;
            z-index: 1000;
            border: 2px solid var(--accent);
            box-shadow: 0 4px 15px rgba(0,0,0,0.8), 0 0 20px rgba(76, 175, 80, 0.3);
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .btn[title]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--accent);
            margin-bottom: 2px;
            pointer-events: none;
            z-index: 1001;
        }
        
        /* Camera control arrows */
        .camera-arrow { position: absolute; background: rgba(68, 68, 68, 0.8); border: 2px solid #555; color: #fff; font-size: 24px; width: 50px; height: 50px; display: none; cursor: pointer; z-index: 150; border-radius: 8px; transition: all 0.2s; }
        .camera-arrow:hover { background: rgba(102, 102, 102, 0.9); border-color: #888; transform: scale(1.1); }
        .camera-arrow:active { background: rgba(76, 175, 80, 0.9); }
        #cam-up { top: 60px; left: 50%; transform: translateX(-50%); }
        #cam-down { bottom: 90px; left: 50%; transform: translateX(-50%); }
        #cam-left { top: 50%; left: 10px; transform: translateY(-50%); }
        #cam-right { top: 50%; right: 10px; transform: translateY(-50%); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LORE POPUP SYSTEM - Pokemon/Cartoon Style Event Illustrations
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #lore-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5000;
            background: linear-gradient(145deg, #2a1a0a 0%, #1a1205 50%, #0f0a03 100%);
            border: 6px solid #d4a85a;
            border-radius: 20px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            box-shadow: 
                0 0 60px rgba(212, 168, 90, 0.4),
                0 15px 40px rgba(0,0,0,0.8),
                inset 0 2px 0 rgba(255,255,255,0.1);
            animation: lorePopIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
        }
        @keyframes lorePopIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        #lore-popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.75);
            z-index: 4999;
            backdrop-filter: blur(4px);
        }
        .lore-illustration {
            width: 100%;
            height: 200px;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 50%, #7DB87D 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border-bottom: 4px solid #d4a85a;
        }
        .lore-illustration canvas {
            width: 100%;
            height: 100%;
        }
        .lore-content {
            padding: 25px;
            text-align: center;
        }
        .lore-title {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 15px;
            font-family: 'Georgia', serif;
        }
        .lore-text {
            font-size: 16px;
            color: #e8dcc8;
            line-height: 1.7;
            font-style: italic;
            margin-bottom: 20px;
        }
        .lore-close-btn {
            padding: 12px 35px;
            background: linear-gradient(180deg, #4CAF50 0%, #388E3C 100%);
            border: 3px solid #66BB6A;
            border-radius: 30px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        .lore-close-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        .lore-toggle-btn {
            background: linear-gradient(180deg, #9C27B0 0%, #7B1FA2 100%);
            border-color: #BA68C8;
        }
        .lore-toggle-btn.active {
            background: linear-gradient(180deg, #E040FB 0%, #AA00FF 100%) !important;
            border-color: #EA80FC !important;
            box-shadow: 0 0 20px rgba(234, 128, 252, 0.6);
        }
    </style>
</head>
<body oncontextmenu="return false;" style="cursor: default;">

    <!-- LORE POPUP MODAL -->
    <div id="lore-popup-overlay" onclick="Controller.closeLorePopup()"></div>
    <div id="lore-popup">
        <div class="lore-illustration">
            <canvas id="lore-canvas" width="500" height="200"></canvas>
        </div>
        <div class="lore-content">
            <div class="lore-title" id="lore-title">The Journey Begins</div>
            <div class="lore-text" id="lore-text">Early man had a dream...</div>
            <button class="lore-close-btn" onclick="Controller.closeLorePopup()">Continue Journey</button>
        </div>
    </div>

    <button id="btn-lore" class="btn lore-toggle-btn" style="position:absolute;top:8px;right:160px;z-index:1000;" onclick="Controller.toggleLore()" title="Toggle Story/Lore Mode">ğŸ“–</button>
    <button id="btn-log" class="btn" style="position:absolute;top:8px;right:8px;z-index:1000;" onclick="Controller.showLog()" title="View Game Log">ğŸ“œ Log</button>
    <button id="btn-ai" class="btn" style="position:absolute;top:8px;right:80px;z-index:1000;" onclick="var p=document.getElementById('ai-training-panel');p.style.display=p.style.display==='none'?'block':'none';QLearningAI.updateTrainingUI();" title="Q-Learning AI">ğŸ¤– AI</button>
    <!-- FLOATING HARD STOP BUTTON - Always visible when AI is running -->
    <button id="ai-hard-stop" onclick="QLearningAI.hardStop()" style="display:none;position:fixed;top:50%;left:10px;transform:translateY(-50%);z-index:9999;padding:15px 20px;background:#f44336;color:#fff;border:3px solid #fff;border-radius:12px;cursor:pointer;font-weight:bold;font-size:16px;box-shadow:0 4px 20px rgba(244,67,54,0.6);animation:pulse-stop 1.5s infinite;" title="Emergency Stop - Stops all AI activity">â¹ï¸ STOP AI</button>
    <style>
        @keyframes pulse-stop {
            0%, 100% { box-shadow: 0 4px 20px rgba(244,67,54,0.6); }
            50% { box-shadow: 0 4px 30px rgba(244,67,54,0.9); transform: translateY(-50%) scale(1.05); }
        }
    </style>
    <!-- Debug Buttons -->
    <button id="btn-debug-pop" class="btn" style="position:absolute;top:8px;right:160px;z-index:1000;background:#9C27B0;border-color:#BA68C8;" onclick="Game.debugAddPopulation(1000)" title="Debug: +1000 Population">ğŸ‘¥+1k</button>
    <button id="btn-debug-res" class="btn" style="position:absolute;top:8px;right:235px;z-index:1000;background:#FF5722;border-color:#FF8A65;" onclick="Game.debugAddResources(1000)" title="Debug: +1000 All Resources">ğŸ“¦+1k</button>
    <!-- Game Log Modal -->
    <div id="log-modal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:10000;align-items:center;justify-content:center;">
        <div onclick="event.stopPropagation();" style="background:#222;color:#fff;padding:24px 32px;max-width:800px;width:90vw;max-height:85vh;overflow:hidden;border-radius:8px;box-shadow:0 4px 32px #000;position:relative;display:flex;flex-direction:column;">
            <button onclick="Controller.hideLog()" style="position:absolute;top:8px;right:8px;font-size:1.5em;background:none;border:none;color:#fff;cursor:pointer;z-index:1;">âœ–</button>
            <h2 style="margin:0 0 12px 0;">Game Logs</h2>
            <div style="display:flex;gap:8px;margin-bottom:12px;">
                <button onclick="Controller.switchLog(&#39;player&#39;)" id="btn-player-log" style="padding:8px 16px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">Player Log</button>
                <button onclick="Controller.switchLog(&#39;technical&#39;)" id="btn-technical-log" style="padding:8px 16px;background:#333;color:#fff;border:none;border-radius:4px;cursor:pointer;">Technical Log</button>
                <button onclick="Controller.copyLog()" style="padding:8px 16px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;margin-left:auto;">ğŸ“‹ Copy</button>
            </div>
            <pre id="log-content" style="white-space:pre-wrap;word-wrap:break-word;font-family:monospace;font-size:0.85em;background:#181818;padding:12px;border-radius:6px;overflow-y:auto;flex:1;margin:0;"></pre>
        </div>
    </div>

    <!-- AI Training Panel -->
    <div id="ai-training-panel" style="position: fixed; bottom: 10px; right: 10px; background: rgba(20, 20, 30, 0.95); color: rgb(255, 255, 255); padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; z-index: 9000; border: 2px solid rgb(74, 158, 255); min-width: 280px; display: block;">
        <div style="font-weight:bold;font-size:14px;margin-bottom:5px;color:#4a9eff;">ğŸ¤– Q-Learning AI</div>
        <div id="ai-version-label" style="color:#FFD700;font-size:11px;margin-bottom:8px;padding:4px 8px;background:#2a2a3a;border-radius:4px;border:1px solid #FFD700;">Loading AI version...</div>
        <!-- Curriculum Phase Banner -->
        <div id="ai-phase-banner" style="background: rgb(21, 101, 192); padding: 6px; border-radius: 4px; text-align: center; margin-bottom: 8px; font-weight: bold;">ğŸ—ï¸ Phase 2: Building Cities (0/5 balanced)</div>
        <div style="display:grid;grid-template-columns:auto 1fr;gap:5px 10px;margin-bottom:10px;">
            <span style="color:#888;">Episode:</span><span id="ai-episode">11989</span>
            <span style="color:#888;">Best Score:</span><span id="ai-best-score" style="color:#4CAF50;">130762.8</span>
            <span style="color:#888;">Avg Reward:</span><span id="ai-avg-reward">32527.5</span>
            <span style="color:#888;">Exploration:</span><span id="ai-exploration">10.0%</span>
            <span style="color:#888;">States:</span><span id="ai-states">154</span>
            <span style="color:#888;">Demos:</span><span id="ai-demo-count" style="color:#9b59b6;">0</span>
        </div>
        <!-- Playbook Status -->
        <div id="ai-playbook-status" style="padding:5px;margin:5px 0;background:#1a1a2a;border-radius:4px;font-size:10px;">
            <span style="color:#9b59b6;">ğŸ“š Playbook:</span>
            <span id="ai-playbook-count" style="color:#fff;">No playbooks saved</span>
            <button onclick="localStorage.removeItem('ai_playbooks');QLearningAI.savedPlaybooks=[];QLearningAI.log('ğŸ—‘ï¸ Playbooks cleared');Controller.toast('Playbooks cleared!')" style="padding:2px 6px;background:#f44336;color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:9px;margin-left:5px;">Clear</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;">
            <button id="ai-train-btn" onclick="QLearningAI.isTraining ? QLearningAI.stopTraining() : QLearningAI.startTraining()" style="padding:6px 12px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">â¹ï¸ Stop</button>
            <button id="ai-watch-btn" onclick="QLearningAI.isWatching ? QLearningAI.stopWatching() : QLearningAI.startWatching()" style="padding:6px 10px;background:#9b59b6;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">ğŸ‘ï¸ Watch Me</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.replayBestRun()" style="padding:6px 10px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="Replay the best recorded run">ğŸ”„ Replay Best</button>
            <button onclick="QLearningAI.showWisdom()" style="padding:6px 10px;background:#FF9800;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="View learned rules and patterns">ğŸ§  Wisdom</button>
            <button onclick="QLearningAI.softReset()" style="padding:6px 10px;background:#f44336;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="Reset but keep best patterns">â™»ï¸ Soft Reset</button>
        </div>
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.showPlaytestReport()" style="padding:6px 10px;background:#00BCD4;color:#fff;border:none;border-radius:4px;cursor:pointer;" title="View bugs, exploits, balance">ğŸ› Report</button>
            <button onclick="QLearningAI.exportStats()" style="padding:6px 10px;background:#9C27B0;color:#fff;border:none;border-radius:4px;cursor:pointer;">ğŸ“Š Export</button>
        </div>
        <!-- FILE-BASED Q-TABLE SAVE/LOAD -->
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;">
            <button onclick="QLearningAI.saveBrainToFile()" style="padding:6px 10px;background:#6366F1;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Download Q-table as JSON file">ğŸ“¥ Save AI</button>
            <button onclick="document.getElementById('qtable-file-input').click()" style="padding:6px 10px;background:#8B5CF6;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Load Q-table from JSON file">ğŸ“¤ Load AI</button>
            <input type="file" id="qtable-file-input" accept=".json" style="display:none" onchange="QLearningAI.loadBrainFromFile(this.files[0])">
            <button onclick="QLearningAI.clearMemory(true)" style="padding:6px 10px;background:#FF5722;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Clear memory to reduce RAM usage">ğŸ§¹ Clear RAM</button>
        </div>
        <!-- MEMORY STATS -->
        <div id="ai-memory-stats" style="margin-top:5px;padding:5px;background:#1a1a2a;border-radius:4px;font-size:10px;border:1px solid #555;">
            <span style="color:#888;">ğŸ’¾ Memory:</span>
            <span id="ai-mem-states" style="color:#fff;">0 states</span>
            <span style="color:#888;"> | </span>
            <span id="ai-mem-mb" style="color:#4CAF50;">0MB</span>
        </div>
        <!-- EXPLORATION TEST MODE -->
        <div style="display:flex;gap:5px;flex-wrap:wrap;margin-top:5px;align-items:center;">
            <button id="ai-explore-btn" onclick="QLearningAI.toggleExplorationTest()" style="padding:6px 10px;background:#E91E63;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="Test map collection - tracks death chance per tile">ğŸ—ºï¸ Explore Test</button>
            <button onclick="QLearningAI.showExplorationReport()" style="padding:6px 10px;background:#607D8B;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;" title="View exploration statistics">ğŸ“ˆ Explore Stats</button>
        </div>
        <!-- Exploration Test Status -->
        <div id="ai-explore-status" style="display:none;margin-top:5px;padding:6px;background:#311B2B;border-radius:4px;font-size:10px;border:1px solid #E91E63;">
            <div style="color:#E91E63;font-weight:bold;">ğŸ—ºï¸ EXPLORATION TEST ACTIVE</div>
            <div id="ai-explore-tiles">Tiles: 0/0 (0%)</div>
            <div id="ai-explore-resources">Resources: 0 collected</div>
            <div id="ai-explore-deaths">Deaths: 0 | Avg Steps/Death: --</div>
            <div id="ai-explore-danger">Danger/Tile: --</div>
        </div>
        <div style="margin-top:8px;font-size:10px;color:#666;">
            Speed: <select id="ai-speed" onchange="QLearningAI.trainingSpeed=parseFloat(this.value);QLearningAI.frameSkipCounter=0;" style="background:#333;color:#fff;border:1px solid #555;padding:2px;">
                <option value="0.05">0.05x (Debug)</option>
                <option value="0.1">0.1x (Crawl)</option>
                <option value="0.25">0.25x (Watch)</option>
                <option value="1">1x (Slow)</option>
                <option value="5">5x</option>
                <option value="10" selected="">10x (Normal)</option>
                <option value="50">50x (Fast)</option>
                <option value="100">100x (Ultra)</option>
            </select>
        </div>
        <!-- Live Stats -->
        <div id="ai-live-stats" style="margin-top:8px;padding:8px;background:#1a1a2a;border-radius:4px;font-size:10px;">
            <div style="color:#4a9eff;margin-bottom:4px;">ğŸ“Š Live Stats:</div>
            <div id="ai-current-state" style="color:#aaa;">State: WANDER_P0_F1_W1</div>
            <div id="ai-current-action" style="color:#aaa;">Action: WANDER</div>
            <div id="ai-step-count" style="color:#aaa;">Steps: 1850</div>
            <div id="ai-current-pop" style="color:#aaa;">Pop: 4 | Food: 0 | Yr: 0</div>
        </div>
        <!-- Learning Progress -->
        <div id="ai-learning-progress" style="margin-top:8px;padding:8px;background:#1a2a1a;border-radius:4px;font-size:10px;">
            <div style="color:#4CAF50;margin-bottom:4px;">ğŸ“ˆ Learning Progress:</div>
            <div id="ai-cities-built" style="color:#aaa;">Cities Built: 863</div>
            <div id="ai-best-pop" style="color:#aaa;">Best Population: 15</div>
            <div id="ai-best-year" style="color:#aaa;">Best Survival: 1 years</div>
            <div id="ai-rci-balance" style="color:#aaa;">Balanced Cities: 0</div>
            <div id="ai-settled-near-res" style="color:#aaa;">Smart Settlements: 2211778</div>
        </div>
        <!-- Learning Curve (Mini Graph) -->
        <div style="margin-top:8px;">
            <div style="color:#4a9eff;font-size:10px;margin-bottom:2px;">ğŸ“‰ Reward Trend (last 20):</div>
            <canvas id="ai-reward-graph" width="200" height="40" style="background:#111;border-radius:4px;width:100%;"></canvas>
        </div>
        <!-- Log Window -->
        <div style="margin-top:8px;">
            <div style="color:#4a9eff;font-size:10px;margin-bottom:2px;">ğŸ“œ Training Log:</div>
            <div id="ai-log" style="background:#111;padding:6px;border-radius:4px;height:80px;overflow-y:auto;font-size:9px;color:#0f0;">[9:12:04 PM] ğŸ’“ Running: Ep=11989, Loop=1722600, Errors=0<br>[9:12:00 PM] ğŸ® Ep 11989: R=9002, Best=130763<br>[9:12:00 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:11:54 PM] ğŸ’“ Running: Ep=11988, Loop=1722000, Errors=0<br>[9:11:45 PM] ğŸ’“ Running: Ep=11988, Loop=1721400, Errors=0<br>[9:11:43 PM] ğŸ® Ep 11988: R=61893, Best=130763<br>[9:11:43 PM] ğŸ›‘ DEATH: pop=7, yr=0, steps=5001<br>[9:11:34 PM] ğŸ’“ Running: Ep=11987, Loop=1720800, Errors=0<br>[9:11:26 PM] ğŸ® Ep 11987: R=1149, Best=130763<br>[9:11:26 PM] ğŸ›‘ DEATH: pop=5, yr=1, steps=88<br>[9:11:26 PM] ğŸ® Ep 11986: R=9004, Best=130763<br>[9:11:26 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:11:24 PM] ğŸ’“ Running: Ep=11985, Loop=1720200, Errors=0<br>[9:11:14 PM] ğŸ’“ Running: Ep=11985, Loop=1719600, Errors=0<br>[9:11:09 PM] ğŸ® Ep 11985: R=67424, Best=130763<br>[9:11:09 PM] ğŸ›‘ DEATH: pop=13, yr=0, steps=5001<br>[9:11:04 PM] ğŸ’“ Running: Ep=11984, Loop=1719000, Errors=0<br>[9:10:55 PM] ğŸ’“ Running: Ep=11984, Loop=1718400, Errors=0<br>[9:10:52 PM] ğŸ® Ep 11984: R=9028, Best=130763<br>[9:10:52 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:10:43 PM] ğŸ’“ Running: Ep=11983, Loop=1717800, Errors=0<br>[9:10:35 PM] ğŸ® Ep 11983: R=9002, Best=130763<br>[9:10:35 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:10:33 PM] ğŸ’“ Running: Ep=11982, Loop=1717200, Errors=0<br>[9:10:24 PM] ğŸ’“ Running: Ep=11982, Loop=1716600, Errors=0<br>[9:10:19 PM] ğŸ® Ep 11982: R=109688, Best=130763<br>[9:10:19 PM] ğŸ›‘ DEATH: pop=5, yr=0, steps=5001<br>[9:10:14 PM] ğŸ’“ Running: Ep=11981, Loop=1716000, Errors=0<br>[9:10:04 PM] ğŸ’“ Running: Ep=11981, Loop=1715400, Errors=0<br>[9:10:02 PM] ğŸ® Ep 11981: R=9010, Best=130763<br>[9:10:02 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:09:54 PM] ğŸ’“ Running: Ep=11980, Loop=1714800, Errors=0<br>[9:09:46 PM] ğŸ® Ep 11980: R=69898, Best=130763<br>[9:09:46 PM] ğŸ›‘ DEATH: pop=5, yr=0, steps=5001<br>[9:09:44 PM] ğŸ’“ Running: Ep=11979, Loop=1714200, Errors=0<br>[9:09:34 PM] ğŸ’“ Running: Ep=11979, Loop=1713600, Errors=0<br>[9:09:29 PM] ğŸ® Ep 11979: R=9002, Best=130763<br>[9:09:29 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:09:24 PM] ğŸ’“ Running: Ep=11978, Loop=1713000, Errors=0<br>[9:09:15 PM] ğŸ’“ Running: Ep=11978, Loop=1712400, Errors=0<br>[9:09:13 PM] ğŸ® Ep 11978: R=994, Best=130763<br>[9:09:13 PM] ğŸ›‘ DEATH: pop=5, yr=1, steps=74<br>[9:09:12 PM] ğŸ® Ep 11977: R=59874, Best=130763<br>[9:09:12 PM] ğŸ›‘ DEATH: pop=5, yr=0, steps=5001<br>[9:09:04 PM] ğŸ’“ Running: Ep=11976, Loop=1711800, Errors=0<br>[9:08:56 PM] ğŸ® Ep 11976: R=9002, Best=130763<br>[9:08:56 PM] ğŸ›‘ DEATH: pop=4, yr=0, steps=5001<br>[9:08:54 PM] ğŸ’“ Running: Ep=11975, Loop=1711200, Errors=0<br>[9:08:44 PM] ğŸ’“ Running: Ep=11975, Loop=1710600, Errors=0<br>[9:08:39 PM] ğŸ® Ep 11975: R=9002, Best=130763</div>
        </div>
    </div>

    <div id="toast" style="opacity: 0; background: rgba(0, 0, 0, 0.85);">â›°ï¸ Stone deposit blocking path.</div>

    <div id="gameover-screen" style="display: none; position: fixed; top: 0px; left: 0px; width: 100vw; height: 100vh; background: rgba(30, 25, 20, 0.97); z-index: 9999; justify-content: center; align-items: center; flex-direction: column; font-family: serif; overflow-y: auto; padding: 20px 0px;">
        <div id="newspaper-article" style="max-width:700px; background:#F5F0E1; color:#222; padding:40px 50px; margin:20px; border-radius:4px; box-shadow:0 10px 40px rgba(0,0,0,0.5); border:1px solid #D4C9B0; position:relative;">
            <!-- Newspaper Header -->
            <div style="text-align:center; border-bottom:3px double #333; padding-bottom:15px; margin-bottom:20px;">
                <div style="font-size:0.75em; color:#666; letter-spacing:4px; text-transform:uppercase;">The Prehistoric Times</div>
                <div id="newspaper-date" style="font-size:0.85em; color:#888; margin-top:5px;">December 28, 2025</div>
            </div>
            <!-- Fossil Illustration -->
            <div style="display:flex; justify-content:center; align-items:center; margin-bottom:10px;">
                <canvas id="fossil-illustration" width="280" height="140" style="background:#E8DCC8; border:2px solid #998; border-radius:8px; margin-bottom:10px;"></canvas>
            </div>
            <!-- Headline -->
            <h1 id="newspaper-headline" style="font-family:&#39;Times New Roman&#39;,serif; font-size:2.2em; font-weight:900; text-align:center; line-height:1.2; margin:0 0 15px 0; color:#111;">Settlement Died of Thirst: "Water Was Everything," Say Archaeologists</h1>
            <!-- Subheadline -->
            <div id="newspaper-subheadline" style="font-family:&#39;Times New Roman&#39;,serif; font-size:1.1em; font-style:italic; text-align:center; color:#444; margin-bottom:20px; padding-bottom:15px; border-bottom:1px solid #ccc;">Excavation of a tiny hamlet (5 inhabitants) shows why early humans needed foresight to survive</div>
            <!-- Article Body -->
            <div id="newspaper-body" style="font-family:Georgia,serif; font-size:1em; line-height:1.7; color:#333; text-align:justify; column-count:1;"><p><strong>FERTILE CRESCENT REGION</strong> â€” Researchers have completed their analysis of a tiny hamlet that housed approximately 5 people before its sudden collapse in Year 1 of the settlement's existence.</p><p>The excavation revealed no residential structures. No evidence of organized trade or social gathering spots was found. Remarkably, no organized food production was ever establishedâ€”the settlement relied entirely on opportunistic foraging.</p><p>Notably, no permanent water infrastructure was ever constructedâ€”a critical oversight that may have contributed to the settlement's demise.</p><p>Skeletal analysis reveals catastrophic dehydration as the primary cause of death. The settlement existed for over two years without any permanent water infrastructureâ€”a fatal oversight. Bone analysis shows progressive signs of water stress, malnutrition, and ultimately mass mortality during what appears to have been a severe drought season.</p><p>"The difference between the groups that survived and those that perished often came down to planning," explained Dr. Catherine Dubois. "Those who thought seasons ahead, who built reserves, who prepared for hardshipâ€”they became our ancestors. The others... became archaeology."</p><p>This settlement joins thousands of similar failed attempts across the prehistoric world, each a testament to the razor-thin margin between survival and extinction that defined early human existence.</p></div>
            <!-- Stats Box -->
            <div id="newspaper-stats" style="margin-top:25px; padding:15px; background:#EDE8D9; border:1px solid #ccc; border-radius:3px; font-family:&#39;Courier New&#39;,monospace; font-size:0.9em;"><strong>ğŸ“‹ SETTLEMENT SURVEY:</strong><br>â€¢ Peak population: 5<br>â€¢ Years survived: 1<br>â€¢ Dwellings: None<br>â€¢ Trade spots: None<br>â€¢ Food production: None<br>â€¢ Water wells: 0 built / 1 needed<br>â€¢ Food at collapse: 22 units<br>â€¢ Years without water: 312<br>â€¢ Verdict: <span style="color:#8B0000;">Death by dehydration</span></div>
            <!-- New Game Button -->
            <div style="text-align:center; margin-top:30px;">
                <button id="btn-newgame-gameover" onclick="Controller.reset(); document.getElementById('gameover-screen').style.display='none';" style="font-size:1.2em; padding:15px 40px; background:#8B4513; color:#F5F0E1; border:none; border-radius:6px; font-family:serif; font-weight:bold; cursor:pointer; box-shadow:0 3px 10px rgba(0,0,0,0.3); transition:background 0.2s;">Try Again</button>
            </div>
        </div>
    </div>

    <div id="menubar" style="display: flex !important; visibility: visible !important;">
        <div style="font-weight:900; font-size:18px; margin-right:15px; font-family:sans-serif;">CIVIL ZONES <span style="color:var(--c-res)">v1</span></div>
            <script>
            // Show/hide both Pass Year buttons based on level
            function updatePassYearButton() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                // Show if in CITY mode (settled)
                var show = (typeof Game !== 'undefined' && Game.gameState === 'CITY');
                if (btn2) btn2.style.display = show ? 'inline-block' : 'none';
            }

            // Unified Pass Year click handler
            function handlePassYearClick() {
                if (typeof Game !== 'undefined' && typeof Game.endTurn === 'function') {
                    Game.endTurn();
                    if (typeof Controller !== 'undefined' && typeof Controller.updateUI === 'function') {
                        Controller.updateUI();
                    }
                    updatePassYearButton();
                }
            }

            // Hook up both Pass Year buttons when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                var btn2 = document.getElementById('btn-pass-year-dash');
                if (btn2) btn2.addEventListener('click', handlePassYearClick);
                
                // Initial update after short delay to ensure Game is initialized
                setTimeout(function() {
                    updatePassYearButton();
                    // Update AI version label
                    if(typeof AI !== 'undefined' && AI.updateVersionLabel) {
                        AI.updateVersionLabel();
                    }
                }, 100);
            });
            </script>
        <button class="btn" id="t-pan" onclick="Controller.setTool(&#39;PAN&#39;)" title="Pan Camera">âœ‹</button>
        <button class="btn b-road" id="t-road" onclick="Controller.openRoadMenu()" style="display: inline-block;" title="Build Roads">ğŸ›£ï¸</button>
        <button class="btn b-wat" id="t-well" onclick="Game.smartBuildWell()" style="display: inline-block;" title="Build Well (WANDER: 25 food + 50 wood | CITY: 20 food)">ğŸ’§</button>
        <div id="sep1" style="width: 1px; height: 24px; background: rgb(85, 85, 85); display: inline-block;"></div>
        <button class="btn" id="t-demolish" onclick="Controller.setTool(&#39;DEMOLISH&#39;)" style="display: inline-block;" title="Demolish Building">ğŸ”¨</button>
        <button class="btn b-res" id="t-res" onclick="Controller.openBuildingMenu()" style="display: inline-block;" title="Build Residential">ğŸ—ï¸</button>
        <button class="btn b-com" id="t-com" onclick="Controller.openCommercialMenu()" style="display: inline-block;" title="Build Pebble Traders Post">ğŸ¢</button>
        <button class="btn b-ind" id="t-ind" onclick="Controller.openIndustrialMenu()" style="display: inline-block;" title="Build hunting ground">ğŸ­</button>
        <button class="btn b-storage" id="t-storage" onclick="Controller.openStorageMenu()" style="display: inline-block;" title="Build Storage Pits">ğŸ•³ï¸</button>
        <button class="btn b-special" id="t-special" onclick="Controller.openSpecialMenu()" style="display: inline-block;" title="Special Buildings">â­</button>
        <button class="btn b-milestone" id="t-milestone" onclick="Controller.openMilestoneMenu()" style="display: inline-block;" title="Milestone Buildings (unlock new tiers)">ğŸ›ï¸</button>
        <button class="btn b-exchange" id="t-exchange" onclick="Controller.exchangeGold()" style="display: inline-block; background: #FFD700; color: #000;" title="Exchange 5,000 Metal for 1 Gold">ğŸ’°</button>
        <div id="sep2" style="width: 1px; height: 24px; background: rgb(85, 85, 85); display: inline-block;"></div>
        <button class="btn" id="btn-settle" onclick="console.log(&#39;Settlement button clicked!&#39;); Game.settleHere();" style="background: rgb(76, 175, 80); border-color: rgb(129, 199, 132); display: none;" title="Start Settlement">ğŸ›ï¸</button>
        <button class="btn" id="btn-turn" onclick="Game.endTurn()" style="display: inline-block;" title="Pass Turn">â­ï¸</button>
        <div style="flex-grow:1;"></div>
        <button class="btn" id="btn-view" onclick="Controller.toggleView()" style="display: inline-block;" title="Toggle View Mode">ğŸ‘ï¸</button>
        <button class="btn" onclick="Controller.saveMap()" title="Save Game">ğŸ’¾</button>
        <button class="btn" onclick="Controller.loadMap()" title="Load Game">ğŸ“‚</button>
        <button class="btn" onclick="Controller.zoomIn()" title="Zoom In">ğŸ”+</button>
        <button class="btn" onclick="Controller.zoomOut()" title="Zoom Out">ğŸ”-</button>
        <button class="btn" id="btn-ai" onclick="Controller.toggleAI()" title="Toggle AI Autoplay">ğŸ¤–</button>
        <button class="btn" onclick="Controller.reset()" title="New Game">ğŸ”„</button>
    </div>

    <!-- Building Menu Panel -->
    <div id="building-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeBuildingMenu()">Ã—</button>
        <div class="menu-title">ğŸ—ï¸ Choose Building Type</div>
        <div class="level-grid" id="building-level-grid">
            <!-- Dynamically populated by Controller.openBuildingMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Buildings evolve through 4 states based on desirability. Higher levels = more capacity &amp; bonuses!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmBuildingSelection()" style="background: #4CAF50; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Industrial Menu Panel -->
    <div id="industrial-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeIndustrialMenu()">Ã—</button>
        <div class="menu-title">ğŸ­ Choose Industrial Type</div>
        <div class="level-grid" id="industrial-level-grid">
            <!-- Dynamically populated by Controller.openIndustrialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Industrial buildings produce resources and provide jobs for your population!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmIndustrialSelection()" style="background: #E53935; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Storage Menu Panel -->
    <div id="storage-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1a1a2e; border:2px solid #8B4513; border-radius:12px; padding:20px; z-index:1001; min-width:500px; box-shadow:0 0 30px rgba(139,69,19,0.3);">
        <button class="menu-close-btn" onclick="Controller.closeStorageMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">Ã—</button>
        <div class="menu-title" style="color:#8B4513; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">ğŸ•³ï¸ Storage Pits</div>
        <div class="level-grid" id="storage-level-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:10px;">
            <!-- Dynamically populated by Controller.openStorageMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Storage pits increase capacity for specific resources by 10,000 each!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmStorageSelection()" style="background: #8B4513; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Special Buildings Menu Panel -->
    <div id="special-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1a1a2e; border:2px solid #FFD700; border-radius:12px; padding:20px; z-index:1001; min-width:500px; box-shadow:0 0 30px rgba(255,215,0,0.3);">
        <button class="menu-close-btn" onclick="Controller.closeSpecialMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">Ã—</button>
        <div class="menu-title" style="color:#FFD700; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">â­ Special Buildings</div>
        <div class="level-grid" id="special-level-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:10px;">
            <!-- Dynamically populated by Controller.openSpecialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Special buildings provide unique bonuses to your settlement!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmSpecialSelection()" style="background: #FFD700; color: #000; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Commercial Menu Panel -->
    <div id="commercial-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1a1a2e; border:2px solid #4a9eff; border-radius:12px; padding:20px; z-index:1001; min-width:400px; box-shadow:0 0 30px rgba(74,158,255,0.3);">
        <button class="menu-close-btn" onclick="Controller.closeCommercialMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">Ã—</button>
        <div class="menu-title" style="color:#4a9eff; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">ğŸª Choose Commercial Type</div>
        <div class="level-grid" id="commercial-level-grid" style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px;">
            <!-- Dynamically populated by Controller.openCommercialMenu() -->
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Commercial buildings generate income and improve desirability!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmCommercialSelection()" style="background: #4a9eff; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Milestone Menu Panel -->
    <div id="milestone-menu-panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1a1a2e; border:2px solid #FFD700; border-radius:12px; padding:20px; z-index:1001; min-width:550px; box-shadow:0 0 30px rgba(255,215,0,0.3);">
        <button class="menu-close-btn" onclick="Controller.closeMilestoneMenu()" style="position:absolute;top:10px;right:10px;background:none;border:none;color:#fff;font-size:24px;cursor:pointer;">Ã—</button>
        <div class="menu-title" style="color:#FFD700; font-size:20px; font-weight:bold; text-align:center; margin-bottom:15px;">ğŸ›ï¸ Milestone Buildings</div>
        <div style="text-align: center; margin-bottom: 15px; font-size: 12px; color: #aaa;">
            Milestone buildings unlock new building tiers! They require Gold, which can be exchanged for Metal.
        </div>
        <div class="level-grid" id="milestone-level-grid" style="display:grid; grid-template-columns:repeat(2,1fr); gap:15px;">
            <!-- Dynamically populated by Controller.openMilestoneMenu() -->
        </div>
        <div style="text-align: center; margin-top: 15px; padding: 10px; background: #2a2a4a; border-radius: 8px;">
            <div style="font-size: 12px; color: #FFD700; margin-bottom: 5px;">ğŸ’° Gold Exchange</div>
            <div style="font-size: 11px; color: #aaa;">5,000 Metal = 1 Gold</div>
            <div style="font-size: 13px; color: #fff; margin-top: 5px;">
                Current Metal: <span id="milestone-metal-display" style="color:#78909C;">0</span> | 
                Current Gold: <span id="milestone-gold-display" style="color:#FFD700;">0</span>
            </div>
            <button class="btn" onclick="Controller.exchangeGold()" style="background: #FFD700; color: #000; padding: 8px 20px; font-size: 12px; margin-top: 10px;">ğŸ’° Exchange Metal for Gold</button>
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="btn" onclick="Controller.confirmMilestoneSelection()" style="background: #FFD700; color: #000; padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <!-- Roads Menu Panel -->
    <div id="road-menu-panel">
        <button class="menu-close-btn" onclick="Controller.closeRoadMenu()">Ã—</button>
        <div class="menu-title">ğŸ›£ï¸ Choose Road Type</div>
        <div class="level-grid" id="road-level-grid">
            <!-- Level 1: Path -->
            <div class="level-card selected" id="card-road-1" onclick="Controller.selectRoadLevel(1)">
                <div class="level-icon">ğŸš¶</div>
                <div class="level-name">Path</div>
                <div class="level-stats">Level 1 â€¢ Basic footpath</div>
                <div class="level-cost">Cost: $5</div>
            </div>
            <!-- Level 2: Road (Locked) -->
            <div class="level-card level-locked" id="card-road-2" onclick="Controller.selectRoadLevel(2)">
                <div class="level-icon">ğŸ›¤ï¸</div>
                <div class="level-name">Road</div>
                <div class="level-stats">Level 2 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
            <!-- Level 3: (Locked) -->
            <div class="level-card level-locked" id="card-road-3" onclick="Controller.selectRoadLevel(3)">
                <div class="level-icon">ğŸš—</div>
                <div class="level-name">Paved Road</div>
                <div class="level-stats">Level 3 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
            <!-- Level 4: (Locked) -->
            <div class="level-card level-locked" id="card-road-4" onclick="Controller.selectRoadLevel(4)">
                <div class="level-icon">ğŸï¸</div>
                <div class="level-name">Highway</div>
                <div class="level-stats">Level 4 â€¢ Coming Soon</div>
                <div class="level-cost">ğŸ”’ Locked</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
            ğŸ’¡ Roads improve desirability and connect your buildings!
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button class="btn" onclick="Controller.confirmRoadSelection()" style="background: var(--c-road); padding: 10px 30px; font-size: 14px;">âœ“ Build Selected</button>
        </div>
    </div>

    <div id="viewport"><canvas id="cvs" width="1014" height="749"></canvas><div id="debug">Pos: 103, 116</div></div>

    <div id="dashboard">
        <button class="btn" id="btn-newgame" onclick="window.startNewGame()" style="background:#1976D2; color:#fff; margin-right:16px;">ğŸ†• New Game</button>
        <button class="btn" id="btn-pass-year-dash" style="display: none; background: rgb(56, 142, 60); color: rgb(255, 255, 255); margin-right: 16px;" title="Pass Year">â© Pass Year</button>
        <div style="display:flex; align-items:center; flex-wrap:wrap; gap:4px;">
            <div class="stat"><span class="lbl">Population</span><span class="val" id="v-pop" style="color:var(--c-res)">4</span></div>
            <div class="stat"><span class="lbl">Food</span><span class="val" id="v-food" style="color:#4CAF50">280/450</span></div>
            <div class="stat" id="stat-wood" style="display: flex;"><span class="lbl">Wood</span><span class="val" id="v-wood" style="color:#A86838">158</span></div>
            <div class="stat" id="stat-metal" style="display: flex;"><span class="lbl">Metal</span><span class="val" id="v-metal" style="color:#78909C">0</span></div>
            <div class="stat" id="stat-stone" style="display: flex;"><span class="lbl">Stone</span><span class="val" id="v-stone" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-inventory" style="display: flex;"><span class="lbl">Total Inventory</span><span class="val" id="v-inventory" style="color:#64B5F6">438/450</span></div>
            <div class="stat" id="stat-year" style="display: flex;"><span class="lbl">Year</span><span class="val" id="v-year" style="color:#9E9E9E">0</span></div>
            <div class="stat" id="stat-geology" style="display: none;"><span class="lbl">Climate</span><span class="val" id="v-geology" style="color:#4FC3F7">ğŸŒ Warm Interglacial</span></div>
            <div class="stat" id="stat-nomad" style="display: flex;"><span class="lbl">Nomads Found</span><span class="val" id="v-nomad" style="color:#FFA726">0</span></div>
            <div class="stat" id="stat-thirst" style="display: flex;"><span class="lbl">ğŸ’§ Thirst</span><span class="val" id="v-thirst" style="color: rgb(41, 182, 246);">87</span></div>
            <div class="stat" id="stat-wander-wells" style="display: none;"><span class="lbl">ğŸ•³ï¸ Water Pits</span><span class="val" id="v-wander-wells" style="color:#29B6F6">0</span></div>
            <div class="stat" id="stat-water" style="display: flex;"><span class="lbl">ğŸ’§ Water</span><span class="val" id="v-wat" style="color:var(--c-wat)">âš ï¸ 0/1</span></div>
            <div class="stat" id="stat-wells" style="display: none;" title="Wells provide water for 100 people each."><span class="lbl">ğŸ•³ï¸ Wells</span><span class="val" id="v-wells" style="color:#29B6F6">0 built</span></div>
            <div class="stat" id="stat-workforce" style="display: none;"><span class="lbl">Workforce</span><span class="val" id="v-workforce" style="color:#AB47BC">ğŸ‘· 5 gathering</span></div>
            <div class="stat" id="stat-funds" style="display: flex;"><span class="lbl">Gold</span><span class="val" id="v-res" style="color:var(--c-com)">0</span></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
            <div class="val" id="v-epoch" style="font-size:14px; font-weight:600;">ğŸŒ EXPLORING THE WORLD</div>
            <!-- RCI Demand Indicator (SimCity-style) -->
            <div id="rci-meters" style="display: none; margin-top: 4px; background: rgba(0, 0, 0, 0.6); padding: 8px 12px; border-radius: 6px; border: 1px solid rgb(68, 68, 68);">
                <div style="display:flex; gap:6px; align-items:flex-end; height:60px;">
                    <!-- Residential Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="r-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(46, 125, 50), rgb(76, 175, 80)); transition: height 0.3s; height: 40%;"></div>
                        </div>
                        <span style="color:#4caf50; font-weight:bold; font-size:11px; margin-top:2px;">R</span>
                    </div>
                    <!-- Commercial Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="c-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(21, 101, 192), rgb(66, 165, 245)); transition: height 0.3s; height: 90%;"></div>
                        </div>
                        <span style="color:#42a5f5; font-weight:bold; font-size:11px; margin-top:2px;">C</span>
                    </div>
                    <!-- Industrial Bar -->
                    <div style="display:flex; flex-direction:column; align-items:center; height:100%;">
                        <div style="flex:1; width:18px; background:#222; border:1px solid #444; border-radius:2px; display:flex; flex-direction:column-reverse; overflow:hidden;">
                            <div id="i-bar-fill" style="width: 100%; background: linear-gradient(to top, rgb(230, 81, 0), rgb(255, 152, 0)); transition: height 0.3s; height: 80%;"></div>
                        </div>
                        <span style="color:#ff9800; font-weight:bold; font-size:11px; margin-top:2px;">I</span>
                    </div>
                </div>
                <div id="rci-tooltip" style="font-size:9px; color:#888; text-align:center; margin-top:4px;">R:1 C:0 I:0</div>
            </div>
        </div>
        <div style="display:flex; align-items:center; gap:10px;">
            <button onclick="Controller.showStatsMenu()" style="background:#333; color:#ccc; border:1px solid #555; padding:6px 12px; border-radius:4px; font-size:12px; font-weight:500; cursor:pointer;">ğŸ“Š Stats</button>
            <span style="font-size:11px; color:#666;">Click to Move</span>
        </div>
    </div>

    <!-- Stats Menu Popup -->
    <div id="stats-menu" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#2a2a2a; border:2px solid #555; border-radius:8px; padding:25px; max-width:500px; min-width:400px; z-index:1000; color:white;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="margin:0; color:#4CAF50;">ğŸ“Š Game Statistics</h3>
            <button onclick="Controller.hideStatsMenu()" style="background:none; border:none; color:#fff; font-size:18px; cursor:pointer;">Ã—</button>
        </div>
        <div id="stats-content" style="line-height:1.8; font-size:14px;">
            <!-- Stats will be populated by JavaScript -->
        </div>
    </div>
    <div id="stats-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999;" onclick="Controller.hideStatsMenu()"></div>

    <!-- New Game Confirmation Modal -->
    <div id="newgame-confirm-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.8); z-index:10000; align-items:center; justify-content:center;">
        <div onclick="event.stopPropagation();" style="background:linear-gradient(135deg, #1a1a1a 0%, #252525 100%); border:3px solid #E53935; border-radius:12px; padding:30px; max-width:450px; width:85vw; box-shadow:0 10px 40px rgba(0,0,0,0.9); color:#fff; text-align:center;">
            <div style="font-size:48px; margin-bottom:15px;">âš ï¸</div>
            <h2 style="margin:0 0 15px 0; color:#E53935; font-size:24px;">Start New Game?</h2>
            <p style="margin:0 0 25px 0; color:#ccc; font-size:16px; line-height:1.5;">All current progress will be permanently lost!<br>This action cannot be undone.</p>
            <div style="display:flex; gap:15px; justify-content:center;">
                <button onclick="window.confirmNewGame()" style="padding:12px 30px; background:linear-gradient(135deg, #E53935 0%, #C62828 100%); color:#fff; border:2px solid #EF5350; border-radius:8px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s;" onmouseover="this.style.transform=&#39;scale(1.05)&#39;" onmouseout="this.style.transform=&#39;scale(1)&#39;">
                    âœ“ Yes, Start Over
                </button>
                <button onclick="window.cancelNewGame()" style="padding:12px 30px; background:linear-gradient(135deg, #2d2d2d 0%, #232323 100%); color:#fff; border:2px solid #4CAF50; border-radius:8px; font-size:16px; font-weight:700; cursor:pointer; transition:all 0.2s;" onmouseover="this.style.transform=&#39;scale(1.05)&#39;" onmouseout="this.style.transform=&#39;scale(1)&#39;">
                    âœ— Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- NEEDS WARNING PANEL -->
    <div id="needs-warning-panel" style="position: fixed; bottom: 20px; right: 20px; background: rgba(20,20,20,0.95); border: 2px solid #FF6B6B; border-radius: 10px; padding: 15px; width: 300px; font-size: 13px; display: none; z-index: 100; box-shadow: 0 8px 25px rgba(255,107,107,0.3);">
        <div style="color: #FF6B6B; font-weight: bold; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
            âš ï¸ RESIDENTS NEED:
        </div>
        <div id="needs-list" style="color: #FFF; line-height: 1.6;">
            <!-- Populated by updateNeedsWarning() -->
        </div>
        <div id="satisfaction-meter" style="margin-top: 10px; background: #333; height: 20px; border-radius: 4px; overflow: hidden; border: 1px solid #555;">
            <div id="satisfaction-bar" style="background: linear-gradient(90deg, #FF6B6B 0%, #FFD93D 50%, #6BCF7F 100%); height: 100%; width: 100%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: #000; font-size: 10px; font-weight: bold;">
                50%
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".json">

    <!-- External AI Module -->
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/ai.js"></script>
        <script src="./CitGame v48.0 - Historical Zoning Simulator_files/assign_population.js"></script>

        <script>
        window.startNewGame = function() {
            // Show custom confirmation modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) {
                modal.style.display = 'flex';
            } else {
                // Fallback if modal not found - just confirm directly
                if(confirm('Start a new game? All progress will be lost!')) {
                    window.confirmNewGame();
                }
            }
        };
        
        window.confirmNewGame = function() {
            // Hide modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
            
            // Reset progression and all game state
            if (typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) PROGRESSION.reset();
            // Re-initialize the game with a new seed
            if (typeof Game.init === 'function') {
                Game.init(Math.floor(Math.random()*100000));
            }
            // Reset camera and UI
            Controller.cam.x = CFG.CAMERA.START_X;
            Controller.cam.y = CFG.CAMERA.START_Y;
            Controller.cam.z = CFG.CAMERA.START_ZOOM;
            Controller.updateUI();
            Controller.toast('ğŸ†• New game started!');
            
            // Reset lore tracking for new game
            Game.loreSeen = {};
            
            // Show game start lore after a brief delay
            setTimeout(() => {
                if(Game.loreEnabled) {
                    Controller.showLoreEvent('GAME_START');
                }
            }, 500);
        };
        
        window.cancelNewGame = function() {
            // Just hide the modal
            var modal = document.getElementById('newgame-confirm-modal');
            if (modal) modal.style.display = 'none';
        };
        </script>

    <script>
        /* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
           â•‘                      CITGAME v48.0 - EVOLUTION SYSTEM              â•‘
           â•‘                   Historical City Building Simulator               â•‘
           â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           
           CODE STRUCTURE:
           ===============
           1. CONFIG MODULE       - Game constants and configuration
           2. PROGRESSION MODULE  - Unlock system and advancement
           3. TERRAIN MODULE      - Perlin noise map generation
           4. ENTITIES MODULE     - Berries, nomads, animals, player
           5. GAME MODULE         - Core game logic, building, turns
           6. RENDERER MODULE     - Canvas drawing and visual effects
           7. CONTROLLER MODULE   - UI updates and input handling
           8. INITIALIZATION      - Game startup and event listeners
           
           NAVIGATION GUIDE:
           =================
           - Press Ctrl+F and search for "MODULE" to jump between sections
           - Each major function has a comment header explaining its purpose
           - Key systems: Building (line ~3200), AI (line ~2658), Rendering (line ~3600)
           
           BALANCE REFERENCE (see GAME_BALANCE.txt for full details):
           ============================================================
           Level 1 Cost: 100 Food + 100 Wood
           Level 1 Upkeep: 1 wood/year (occupied), 2 wood/year (empty)
           Level 1 Abandoned Timer: 5 years empty
           Animals: 1064 total (50% Deer, 35% Bison, 15% Mammoth)
           Nomads: 1200 total (83% friendly, 17% hostile)
           Inventory: 150 base + 100/nomad | Pocket: 1000 max
           Herd Danger: Adjacent animals cost 1-3 pop to kill
           
           WORKFORCE SYSTEM:
           =================
           Workers auto-assigned: Roads(1/5tiles) > Commercial(3) > Gathering
           Well: Serves 100 people water (no workers needed)
           Road: 1 worker per 5 tiles â†’ maintains desirability bonus
           Commercial: 3 workers â†’ operates the building
           Gatherers: 0.5 food/year per unassigned worker
        */

        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ MODULE 1: CONFIG - Game Configuration & Constants                 â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // All game settings, costs, and balance values are defined here.
        // Modify these values to change game difficulty and behavior.
        // !! IMPORTANT: When changing values here, also update GAME_BALANCE.txt !!
        
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘                    CITGAME v40.0 - MASTER CONFIGURATION                       â•‘
        // â•‘                                                                               â•‘
        // â•‘  This CFG object contains ALL game balance variables. When modifying game     â•‘
        // â•‘  mechanics, update values here and in GAME_BALANCE.txt for documentation.     â•‘
        // â•‘                                                                               â•‘
        // â•‘  EPOCH SYSTEM:                                                                â•‘
        // â•‘  - Epoch 0 (WANDER): Survival phase - explore, gather, recruit nomads         â•‘
        // â•‘  - Epoch 1 (PIT AGE): Subsistence phase - build settlements, manage labor     â•‘
        // â•‘  - Epoch 2 (TENTS): Advanced phase - commercial, granaries (LOCKED)           â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const CFG = {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // I. GLOBAL RULES (The Physics Engine)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === MAP & RENDERING ===
            TILE: 48,           // Tile size in pixels for rendering
            W: 250,             // Map width in tiles (250x250 = 62,500 tiles)
            H: 250,             // Map height in tiles
            
            // === INVENTORY SYSTEM ===
            // Backpack: Holds Food & Wood, scales with population
            // Sack (Rare): Holds Stone & Metal, fixed capacity
            INVENTORY: {
                BACKPACK_BASE: 150,         // Starting backpack capacity
                BACKPACK_PER_POP: 100,      // Additional capacity per population
                SACK_CAPACITY: 1000,        // Fixed rare item storage (Stone & Metal)
                OVERFLOW_DELETE: true       // Overflow items are deleted instantly
            },
            
            // === VISUAL STATES ===
            // Buildings change appearance based on occupancy percentage
            // 0=Abandoned (0%, 10yrs), 1=Light (1-30%), 2=Medium (31-80%), 3=Extreme (81-100%)
            VISUAL_STATES: {
                ABANDONED_YEARS: 10,        // Years at 0 occupancy before abandoned
                LIGHT_MAX: 0.30,            // 1-30% occupancy
                MEDIUM_MAX: 0.80,           // 31-80% occupancy
                EXTREME_MIN: 0.81           // 81-100% occupancy
            },
            
            // === BULLDOZE MECHANIC ===
            BULLDOZE_REFUND: 0.10,          // 10% of construction cost returned
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PRE-FIRE AGE BUILDING SYSTEM
            // Theme: First people who discovered fire, no boats yet
            // Structure: 3 Levels Ã— 3 Density States for each zone type
            // Density affects: Income, Production, Appearance, Name
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            PRE_FIRE_AGE: {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESIDENTIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Level 1: Low Density (Tree Houses)
                // Level 2: Medium Density (Ground Shelters)  
                // Level 3: High Density (Communal Structures)
                RESIDENTIAL: {
                    1: {
                        name: 'Tree Shelter',
                        description: 'Primitive shelter in the trees, safe from predators',
                        baseCost: { food: 100, wood: 100, stone: 0 },
                        baseCapacity: 5,
                        baseIncome: 1,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Attempted Treehouse', 
                                icon: 'ğŸŒ³',
                                popRange: [1, 2],
                                incomeMultiplier: 0.5,
                                description: 'A few branches tied together, barely shelter'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Treebranch House', 
                                icon: 'ğŸ•ï¸',
                                popRange: [3, 4],
                                incomeMultiplier: 1.0,
                                description: 'Woven branches form a proper platform'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Sturdy Tree Nest', 
                                icon: 'ğŸ›–',
                                popRange: [5, 5],
                                incomeMultiplier: 1.5,
                                description: 'A well-built elevated dwelling'
                            }
                        ]
                    },
                    2: {
                        name: 'Ground Pit',
                        description: 'Dug-out shelter with branch covering',
                        baseCost: { food: 300, wood: 300, stone: 50 },
                        baseCapacity: 15,
                        baseIncome: 3,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Shallow Scrape', 
                                icon: 'ğŸ•³ï¸',
                                popRange: [1, 5],
                                incomeMultiplier: 0.5,
                                description: 'Just a depression in the ground'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Covered Pit', 
                                icon: 'ğŸšï¸',
                                popRange: [6, 10],
                                incomeMultiplier: 1.0,
                                description: 'A proper pit with branch roof'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Pit Dwelling', 
                                icon: 'ğŸ ',
                                popRange: [11, 15],
                                incomeMultiplier: 1.5,
                                description: 'Stone-lined pit with sturdy roof'
                            }
                        ]
                    },
                    3: {
                        name: 'Communal Lodge',
                        description: 'Large shared shelter for extended family groups',
                        baseCost: { food: 900, wood: 900, stone: 200 },
                        baseCapacity: 40,
                        baseIncome: 8,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Gathering Lean-To', 
                                icon: 'ğŸ•ï¸',
                                popRange: [1, 15],
                                incomeMultiplier: 0.5,
                                description: 'Simple shared shelter'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Family Longhouse', 
                                icon: 'ğŸ›–',
                                popRange: [16, 30],
                                incomeMultiplier: 1.0,
                                description: 'Multiple families under one roof'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Clan Lodge', 
                                icon: 'ğŸ˜ï¸',
                                popRange: [31, 40],
                                incomeMultiplier: 1.5,
                                description: 'Prosperous communal dwelling'
                            }
                        ]
                    }
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMMERCIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Level 1: Low Density (Simple Trading)
                // Level 2: Medium Density (Established Trading)
                // Level 3: High Density (Trading Hub)
                COMMERCIAL: {
                    1: {
                        name: 'Pebble Traders Post',
                        description: 'Simple spot for exchanging goods',
                        baseCost: { food: 200, wood: 200, stone: 0 },
                        baseProduction: 5,
                        baseWorkers: 2,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Pebble Pile', 
                                icon: 'ğŸª¨',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'A few pebbles mark the trading spot'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Trading Pebble Post', 
                                icon: 'ğŸª',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Recognizable trading location'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Busy Barter Spot', 
                                icon: 'ğŸª',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Popular gathering for trade'
                            }
                        ]
                    },
                    2: {
                        name: 'Tiny Fire Exchange',
                        description: 'Communal fire where stories and goods are exchanged',
                        baseCost: { food: 500, wood: 500, stone: 100 },
                        baseProduction: 15,
                        baseWorkers: 5,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Smoky Embers', 
                                icon: 'ğŸ’¨',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Dying fire, few visitors'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Warming Fire', 
                                icon: 'ğŸ”¥',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Steady fire draws regular crowd'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Great Gathering Fire', 
                                icon: 'ğŸ•ï¸',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Roaring fire, center of activity'
                            }
                        ]
                    },
                    3: {
                        name: 'Beaver Trade Post',
                        description: 'Sacred space where leaders discuss and trade',
                        baseCost: { food: 1500, wood: 1500, stone: 500 },
                        baseProduction: 40,
                        baseWorkers: 12,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Abandoned Circle', 
                                icon: 'â­•',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Empty stone circle'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Council Ring', 
                                icon: 'ğŸ—¿',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Regular gatherings held here'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Sacred Assembly', 
                                icon: 'ğŸ›ï¸',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Center of tribal governance'
                            }
                        ]
                    }
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDUSTRIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Level 1: Low Density (Hunting)
                // Level 2: Medium Density (Gathering/Processing)
                // Level 3: High Density (Production)
                INDUSTRIAL: {
                    1: {
                        name: 'Bird Hunting Range',
                        description: 'Area for hunting small birds with rocks',
                        baseCost: { food: 200, wood: 200, stone: 0 },
                        baseProduction: 10,
                        baseWorkers: 3,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Sparse Hunting Path', 
                                icon: 'ğŸª¶',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Few birds, poor pickings'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Bird Hunting Range', 
                                icon: 'ğŸ¦…',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Good hunting grounds'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Prime Fowling Grounds', 
                                icon: 'ğŸ¯',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Rich bird population'
                            }
                        ]
                    },
                    2: {
                        name: 'Grub Digging Pit',
                        description: 'Digging area for insects, roots, and small prey',
                        baseCost: { food: 500, wood: 500, stone: 100 },
                        baseProduction: 25,
                        baseWorkers: 6,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Scratched Earth', 
                                icon: 'ğŸ•³ï¸',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Barely productive soil'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Grub Digging Pit', 
                                icon: 'ğŸª±',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Reliable source of protein'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Bountiful Foraging Pit', 
                                icon: 'ğŸ–',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Rich in edible finds'
                            }
                        ]
                    },
                    3: {
                        name: 'Stone Knapping Site',
                        description: 'Area for making primitive tools from stone',
                        baseCost: { food: 1500, wood: 1500, stone: 500 },
                        baseProduction: 60,
                        baseWorkers: 15,
                        densityStates: [
                            { 
                                id: 'LOW', 
                                name: 'Scattered Flakes', 
                                icon: 'ğŸª¨',
                                activityRange: [0, 0.3],
                                productionMultiplier: 0.5,
                                description: 'Abandoned tool-making spot'
                            },
                            { 
                                id: 'MEDIUM', 
                                name: 'Stone Knapping Site', 
                                icon: 'âš’ï¸',
                                activityRange: [0.31, 0.7],
                                productionMultiplier: 1.0,
                                description: 'Active tool production'
                            },
                            { 
                                id: 'HIGH', 
                                name: 'Master Flint Workshop', 
                                icon: 'ğŸ”¨',
                                activityRange: [0.71, 1.0],
                                productionMultiplier: 1.5,
                                description: 'Expert tool crafting center'
                            }
                        ]
                    }
                }
            },
            
            // Helper function to get density state based on population/activity
            getDensityState(zoneType, level, fillPercent) {
                const config = this.PRE_FIRE_AGE[zoneType]?.[level];
                if (!config) return null;
                
                for (let i = config.densityStates.length - 1; i >= 0; i--) {
                    const state = config.densityStates[i];
                    const range = state.popRange || state.activityRange;
                    if (fillPercent >= range[0]) {
                        return { ...state, index: i };
                    }
                }
                return { ...config.densityStates[0], index: 0 };
            },
            
            // === PERFORMANCE OPTIMIZATION ===
            PERF: {
                SPATIAL_GRID_SIZE: 10,
                PARTICLE_POOL_SIZE: 100,
                ENABLE_OFFSCREEN_CACHE: true,
                DIRTY_RECT_RENDERING: true
            },
            
            // === TERRAIN & BUILDING COLORS ===
            COLORS: {
                // Terrain colors - Yoshi's Island soft pastels
                DEEP: "#5890E8", WATER: "#78C8FF", RIVER: "#A0DCFF", SAND: "#FFE8A0", 
                GRASS: "#78E878", FOREST: "#40B040", EARTH: "#E8A860", ROCK: "#B8B8C8", SNOW: "#F8F8FF", 
                STONE: "#A0A0B0",
                // Building colors - friendly bright tones
                ROAD: "#D8A050", RES: "#FF78A8", COM: "#FFD878", IND: "#B888E8", WELL: "#68D8FF",
                BASKET: "#F8A868", POTTERY: "#E8B860", GRANARY: "#D8B078", PALACE: "#FFE078", CHIEF: "#E8B068",
                CLAN_CHIEF: "#FFD700", DOCK: "#4A8BC2",
                // UI colors
                OK: "rgba(255,255,255,0.4)", NO: "rgba(248,88,88,0.85)"
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // II. EPOCH 0: THE WANDERER (Survival Phase)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === MOVEMENT & EXPLORATION ===
            PLAYER: { 
                START_HEALTH: 3,            // Initial health (population = health in Epoch 0)
                VISION_RADIUS: 3            // Fog of war reveal radius
            },
            
            // === MOVEMENT FOOD COST ===
            // Walking costs food - 1 food per 15 tiles per population
            MOVEMENT: {
                STEPS_PER_FOOD: 15,         // Every 15 steps costs food
                FOOD_PER_PERSON: 1          // 1 food consumed per person per 15 steps
            },
            
            // === FOREST TILE ===
            // Passive step: +1 Wood (Scavenging)
            FOREST: {
                WOOD_PER_STEP: 1            // Wood gained when stepping on forest
            },
            
            // === OPEN GROUND ===
            // Passive step: 0.01% chance for rare find
            OPEN_GROUND: {
                RARE_FIND_CHANCE: 0.01,     // 1% chance per step
                METAL_CHANCE: 0.5,          // 50% metal, 50% stone if rare find
                FIND_AMOUNT: 1              // +1 Metal or +1 Stone
            },
            
            // === LORE EVENTS - Story mode messages for first-time events ===
            LORE_EVENTS: {
                GAME_START: {
                    title: 'The Dream',
                    text: 'Early man had a dream one night... a vision of something greater than mere survival. He saw his descendants building, thriving, creating. And so, with nothing but hope and hunger, he left his people and began to wander...',
                    illustration: 'wanderer'
                },
                FIRST_WELL: {
                    title: 'Fresh Water!',
                    text: 'Digging far enough revealed what the wise ones spoke of - underground rivers! Fresh water bubbled up from the earth. No longer would the tribe be slaves to rivers and lakes. Now they could make water appear wherever they chose!',
                    illustration: 'well'
                },
                FIRST_RESIDENTIAL: {
                    title: 'A Proper Shelter',
                    text: 'Now THIS is proper living! No more sleeping under stars with wolves howling. Four walls and a roof - what luxury! The tribe looked upon their creation with pride. "We are no longer wanderers," they declared. "We are SETTLERS."',
                    illustration: 'hut'
                },
                FIRST_HUNTING_GROUND: {
                    title: 'The Hunting Grounds',
                    text: 'The wise hunter knows: chase the deer, catch one meal. Let the deer come to you, catch a hundred! And so the first hunting ground was established - a place where prey would wander in, never to wander out.',
                    illustration: 'hunting'
                },
                FIRST_ROAD: {
                    title: 'The Beaten Path',
                    text: 'Why walk through thorns when you can walk on dirt? The tribe\'s smartest member (whose name has been lost to time, but was probably "Ook" or "Ug") packed down the earth to make travel easier. Revolutionary!',
                    illustration: 'road'
                },
                FIRST_KILL: {
                    title: 'The First Hunt',
                    text: 'Blood! Meat! VICTORY! The beast fell before the tribe\'s mighty hunter. Tonight they would feast, and tomorrow... they would hunt again. The way of the predator had begun.',
                    illustration: 'hunt_success'
                },
                FIRST_SETTLEMENT: {
                    title: 'A Settlement is Born',
                    text: 'No more wandering. No more running. This patch of earth... THIS belongs to us! The tribe drove stakes into the ground and declared themselves FOUNDERS. History was about to begin.',
                    illustration: 'settlement'
                },
                FIRST_STORAGE: {
                    title: 'The Storage Pit',
                    text: 'The brilliant idea came from watching squirrels hide nuts. "What if WE buried our food?" And lo, the storage pit was invented. Now surplus wouldn\'t rot in the sun - it would rot underground! Progress!',
                    illustration: 'storage'
                },
                FIRST_COMMERCIAL: {
                    title: 'Trading Post',
                    text: 'One day, Ook had three fish. Ug had three berries. Both wanted variety. After much grunting and gesturing, they discovered TRADE! The economy was born, and Ook\'s descendants would one day invent taxes.',
                    illustration: 'trading'
                },
                FIRST_NOMAD: {
                    title: 'A Stranger Approaches',
                    text: 'From the mist emerged another... a fellow wanderer! Heart pounding, spear raised, our ancestor faced a choice. Friend or foe? The stranger raised a hand in peace. Today, the tribe grows stronger.',
                    illustration: 'nomad'
                },
                FIRST_TURTLE: {
                    title: 'Beach Bounty',
                    text: 'Upon the sandy shores, a strange shelled creature waddled slowly. "What manner of rock moves on its own?" wondered the hunter. Turns out, it was delicious. The beach would never go hungry again.',
                    illustration: 'turtle'
                },
                FLOOD_WARNING: {
                    title: 'The Waters Rise',
                    text: 'The elders spoke of this - the great waters that swallow the land. "Build high," they warned. "The sea remembers, and the sea returns." Perhaps it was time to seek higher ground...',
                    illustration: 'flood'
                },
                FIRST_BERRY: {
                    title: 'The Berry Bush',
                    text: 'Red and plump, the berries glistened in the sun. The hungry wanderer reached out... Would they bring life or death? 90% of the time, it\'s fine! The other 10%... well, that\'s how we learned which ones NOT to eat.',
                    illustration: 'berry'
                }
            },
            
            // === BERRY BUSH ===
            BERRIES: { 
                SPAWN_COUNT: 400,           // Number of berry bushes on map
                FOOD_VALUE: 10,             // Food gained (90% chance)
                POISON_CHANCE: 0.10,        // 10% chance of poison
                POISON_DAMAGE: 1            // -1 Pop if poisoned
            },
            
            // === ANIMALS (Deer/Bison/Mammoth/Turtle) ===
            // Pack Logic: If touching another animal, -1 Pop
            // Wolves are separate entity type (always cost pop, fixed reward)
            ANIMALS: { 
                SPAWN_COUNT: 1064,          // Total animals on map (excluding wolves)
                PACK_DAMAGE: 1,             // -1 Pop if in pack (adjacent to another)
                TYPES: [
                    { name: 'DEER', hitToKill: 2, foodReward: [1, 30], popCost: 0, color: '#C89858', speed: 1, spawnRate: 0.45, terrain: ['GRASS', 'FOREST'] },
                    { name: 'BISON', hitToKill: 3, foodReward: [5, 30], popCost: 0, color: '#A06830', speed: 0.5, spawnRate: 0.30, terrain: ['GRASS', 'FOREST'] },
                    { name: 'MAMMOTH', hitToKill: 5, foodReward: [15, 30], popCost: 0, color: '#806040', speed: 0.3, spawnRate: 0.10, terrain: ['GRASS', 'FOREST'] },
                    { name: 'TURTLE', hitToKill: 1, foodReward: [3, 15], popCost: 0, color: '#4A7A4A', speed: 0.1, spawnRate: 0.15, terrain: ['SAND'] }
                ],
                BEACH_SPAWN_COUNT: 150      // Extra turtles spawned only on beaches
            },
            
            // === NOMADS ===
            // 84% Friendly: +1 Pop, +Map Reveal, Loot
            // 16% Hostile: Ambush (-1 to -3 Pop)
            NOMAD: { 
                SPAWN_COUNT: 1500,          // Total nomads on map (increased)
                HOSTILE_CHANCE: 0.33,       // 33% hostile (increased)
                FRIENDLY_POP_BONUS: 1,      // +1 Pop from friendly
                HOSTILE_DAMAGE: [1, 3],     // -1 to -3 Pop from hostile
                LOOT_RANGES: {              // Loot from friendly nomads
                    FOOD: [5, 30],
                    WOOD: [5, 30],
                    METAL: [0, 10],
                    STONE: [0, 5]           // No stone loot per spec (0-10 metal only)
                }
            },
            
            // === SETTLEMENT TRANSITION REQUIREMENTS ===
            // To unlock "Found Settlement" button (Epoch 0 â†’ Epoch 1)
            SETTLEMENT_REQUIREMENTS: {
                MIN_POP: 2,                 // Population >= 2 (player + 1 nomad)
                MIN_FOOD: 100,              // Food >= 100
                MIN_WOOD: 25,               // Wood >= 25 (lowered to allow quick start)
                WATER_DISTANCE: 5           // Must be <= 5 tiles from fresh water
            },
            
            // === SETTLEMENT BONUSES (for recruiting before settling) ===
            SETTLEMENT_BONUS: {
                THRESHOLD_50: 0.10,         // 50 people = +10% inventory bonus
                THRESHOLD_100: 0.20,        // 100 people = +20%
                THRESHOLD_150: 0.30,        // 150 people = +30%
                THRESHOLD_200: 0.40         // 200 people = +40% (max)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // III. EPOCH 1: THE PIT AGE (Subsistence Phase)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === BUILDING COSTS (Construction) ===
            BUILDING_COSTS: {
                MUD_PIT: { food: 100, wood: 100, stone: 0 },
                DIRT_ROAD: { food: 5, wood: 5, stone: 0 },
                WATER_WELL: { food: 50, wood: 200, stone: 5 },
                HUNTING_GROUND: { food: 500, wood: 100, stone: 0 }
            },
            
            // === BUILDING UPKEEP (Per Year) ===
            BUILDING_UPKEEP: {
                MUD_PIT: { wood: 1 },
                DIRT_ROAD: { wood: 0 },
                WATER_WELL: { wood: 0 },
                HUNTING_GROUND: { wood: 5 }
            },
            
            // === BUILDING LABOR COSTS (Workers) ===
            BUILDING_LABOR: {
                MUD_PIT: 0,                 // No workers needed
                DIRT_ROAD: 1,               // 1 worker per road tile
                WATER_WELL: 0,              // No workers needed - wells work automatically
                HUNTING_GROUND_MIN: 20,     // Minimum 20 workers
                HUNTING_GROUND_MAX: 100     // Maximum 100 workers
            },
            
            // === BUILDING CAPACITIES & STATS ===
            BUILDING_STATS: {
                MUD_PIT: {
                    capacity: 20,           // Max 20 people per Mud Pit
                    efficiency: 0.50,       // 50% efficiency (high consumption)
                    growth_light: 0.01,     // +1% growth at light occupancy
                    growth_extreme: 0.05    // +5% growth at extreme occupancy
                },
                WATER_WELL: {
                    capacity: 500           // Each well serves 500 people
                },
                HUNTING_GROUND: {
                    range_walk: 7,          // Range without roads
                    range_road: 17,         // Range with roads (doubles + 3)
                    unlock_residences: 20,  // OR 20 residences built
                    unlock_pop: 100         // OR 100 population
                }
            },
            
            // === DIRT ROAD EFFECT ===
            ROAD: {
                MOVEMENT_MULTIPLIER: 2      // Doubles movement range for services
            },
            
            // === LOCKED BUILDINGS (Epoch 2+) ===
            LOCKED_EPOCH1: ['COMMERCIAL', 'GRANARY'],
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // IV. EPOCH 1: THREATS & CRISES (The Math of Death)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            CRISES: {
                // STARVATION: Food < 0
                STARVATION: {
                    trigger: 'FOOD_NEGATIVE',
                    death_rate: 0.20        // Instant loss of 20% Population
                },
                
                // THIRST: Pop > (Wells * 100)
                THIRST: {
                    trigger: 'INSUFFICIENT_WATER',
                    death_rate: 0.10        // Instant loss of 10% Population
                },
                
                // LABOR COLLAPSE: Workers Needed > Pop
                LABOR_COLLAPSE: {
                    trigger: 'INSUFFICIENT_LABOR',
                    effect: 'SHUTDOWN'      // Roads lose bonus, Wells stop
                },
                
                // ABANDONMENT: Occupancy == 0 for 10 years
                ABANDONMENT: {
                    trigger: 'EMPTY_10_YEARS',
                    upkeep_multiplier: 2    // Double upkeep or repair cost
                },
                
                // ROT: Food > Storage Cap
                ROT: {
                    trigger: 'OVER_STORAGE',
                    spoilage_rate: 0.30     // Lose 30% of surplus food per year
                },
                
                // OVERPOPULATION: Pop > Housing Cap
                OVERPOPULATION: {
                    trigger: 'OVER_HOUSING',
                    theft_rate: 0.05,       // Homeless steal 5% of food
                    plague_kill: 0.30       // Plague kills 30% of total Pop
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // V. EPOCH 2 TRANSITION REQUIREMENTS (The Boss Fight)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            EPOCH2_REQUIREMENTS: {
                POPULATION: 500,            // 500+ people
                INDUSTRY: 10,               // 10 Hunting Grounds built
                FOOD: 20000,                // 20,000 food stockpile
                WOOD: 10000,                // 10,000 wood stockpile
                STONE: 100,                 // 100 stone (scavenged)
                METAL: 100                  // 100 metal (scavenged)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LEGACY CONFIGURATION (For backward compatibility)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            COST: { RES:100, COM:250, IND:500, WELL:50, BULL:1, ROAD:5 },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILDING DATABASE - Unified data-driven building system
            // All buildings defined in one place for easy expansion
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // === LEVEL 1 RESIDENTIAL GATHERING RATES (per your docs) ===
            LEVEL_1_GATHER: {
                HOMELESS: { food: 3, wood: 3, stone: 0, metal: 0 },
                MUD_PIT: { food: 6, wood: 6, stone: 0, metal: 0 },      // 3 base + 3 bonus
                STRAW_PIT: { food: 7, wood: 7, stone: 0, metal: 0 },    // Mud + 1
                LARGE_STRAW_PIT: { food: 8, wood: 8, stonePerPerson: 1, metalPerPerson: 1 }  // Mud + 2 + per person bonus
            },
            
            // === LEVEL 1 ZONE COSTS ===
            LEVEL_1_COSTS: {
                PATH: 5,                                                // $5 per path
                COMMERCIAL: { wood: 200, food: 200 },                   // Campfire
                INDUSTRIAL: { wood: 200, food: 200 }                    // Hunting Grounds
            },
            
            // === LEVEL 2 ZONE COSTS ===
            LEVEL_2_COSTS: {
                RESIDENTIAL: { wood: 10000, food: 10000 },              // Grub Class
                COMMERCIAL: { wood: 10000, food: 10000 },               // Fire Pit
                INDUSTRIAL: { wood: 10000, food: 10000 },               // Water Industry
                DOCK: { wood: 100000, food: 10000 }                     // One-time special structure
            },
            
            // === LEVEL 2 PROGRESSION ===
            LEVEL_2_REQ: {
                POP: 2000,
                DOCK_BONUS: 0.05                                        // +5% output when connected
            },
            
            // === LEVEL 3 PROGRESSION ===
            LEVEL_3_REQ: {
                POP: 10000,
                MINE_COST: { wood: 1000000, food: 1000000 }
            },
            
            // === OVERPOPULATION PENALTY ===
            OVERPOP: {
                YEARS_BEFORE_PENALTY: 10,
                FIRST_PENALTY: 0.50,                                    // -50% after 10 years
                MAX_PENALTY: 0.80,                                      // Up to -80%
                MIN_POPULATION: 3                                       // Never below 3
            },
            
            // === ABANDONMENT ===
            ABANDON: {
                ZONE_YEARS: 20,                                         // Zone disappears after 20 years empty
                HOMELESS_DEATH_YEARS: 5                                 // Homeless die after 5 years
            },
            
            BUILDING_DB: {
                /*
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                UNIVERSAL UNLOCK SYSTEM - Reference Guide
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                Each building can have an `unlockReq` object with ANY combination of:
                
                â€¢ pop: number              â†’ Minimum population (e.g., pop: 5000)
                â€¢ resources: { res: n }    â†’ Must have X resource in stock
                                             (e.g., resources: { wood: 500, stone: 200 })
                â€¢ buildings: { ... }       â†’ Must have built specific buildings:
                    - type + level + count â†’ { type: 'IND', level: 2, count: 5 }
                    - type + count         â†’ { type: 'COM', count: 3 }
                    - category + count     â†’ { category: 'RESIDENTIAL', count: 10 }
                    - id + count           â†’ { id: 'WELL', count: 1 }
                    - Array for multiple   â†’ [{ type: 'IND', count: 2 }, { type: 'COM', count: 1 }]
                â€¢ year: number             â†’ Must reach Year X
                â€¢ level: number            â†’ Must be at Civilization Level X
                â€¢ tech: string[]           â†’ Must have researched technologies (future)
                â€¢ achievements: string[]   â†’ Must have earned achievements (future)
                
                EXAMPLES:
                â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Simple: just population
                unlockReq: { pop: 2000 }
                
                // Medium: population + resources
                unlockReq: { pop: 5000, resources: { wood: 1000, stone: 500 } }
                
                // Complex: pop + resources + buildings
                unlockReq: { 
                    pop: 10000, 
                    resources: { food: 5000 },
                    buildings: { type: 'IND', level: 2, count: 3 }
                }
                
                // Multi-building gate
                unlockReq: {
                    pop: 50000,
                    buildings: [
                        { type: 'IND', level: 3, count: 2 },
                        { type: 'COM', level: 2, count: 5 }
                    ]
                }
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                */
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESIDENTIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Pre-Fire Age Theme: First people who just discovered fire
                // 3 Levels Ã— 3 Density States (Low/Medium/High income based on population)
                // Lifespan: Low=20yr, Medium=+5% (21yr), High=+10% (22yr)
                // Overcrowding: +5 extra pop allowed, but if full >1 year, lose population
                'RES_1': {
                    id: 'RES_1', category: 'RESIDENTIAL', level: 1, name: 'Tree Shelter',
                    cost: { food: 100, wood: 100, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 15, overflowCapacity: 20,
                    upkeep: { wood: 1, food: 1 },
                    baseIncome: 1,
                    baseLifespan: 20, // years
                    // Density states: population determines income class and lifespan bonus
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Nest', icon: 'ğŸª¹', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 5, name: 'Small Nest', icon: 'ğŸªº', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 6, max: 10, name: 'Tree Platform', icon: 'ğŸŒ³', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 11, max: 15, name: 'Sturdy Treehouse', icon: 'ğŸ•ï¸', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 2 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 2 }
                    ],
                    variants: [
                        { name: 'Abandoned Nest', icon: 'ğŸª¹', bonusMult: 0 },
                        { name: 'Small Nest', icon: 'ğŸªº', bonusMult: 0.5 },
                        { name: 'Tree Platform', icon: 'ğŸŒ³', bonusMult: 1.0 },
                        { name: 'Sturdy Treehouse', icon: 'ğŸ•ï¸', bonusMult: 1.5 }
                    ],
                    unlockReq: { pop: 0 } // Always available with resources
                },
                'RES_2': {
                    id: 'RES_2', category: 'RESIDENTIAL', level: 2, name: 'Ground Pit',
                    cost: { food: 300, wood: 300, stone: 50, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 25, overflowCapacity: 30,
                    upkeep: { wood: 2, food: 2 },
                    baseIncome: 3,
                    baseLifespan: 20,
                    // Density states: population determines income class
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Collapsed Pit', icon: 'ğŸ•³ï¸', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 8, name: 'Shallow Scrape', icon: 'â¬›', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 9, max: 17, name: 'Dug Pit', icon: 'ğŸŸ«', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 18, max: 25, name: 'Covered Pit Dwelling', icon: 'ğŸ ', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 5 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 1 }
                    ],
                    variants: [
                        { name: 'Collapsed Pit', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Shallow Scrape', icon: 'â¬›', bonusMult: 0.5 },
                        { name: 'Dug Pit', icon: 'ğŸŸ«', bonusMult: 1.0 },
                        { name: 'Covered Pit Dwelling', icon: 'ğŸ ', bonusMult: 1.5 }
                    ],
                    unlockReq: { pop: 50 }
                },
                'RES_3': {
                    id: 'RES_3', category: 'RESIDENTIAL', level: 3, name: 'Ground Cave',
                    cost: { food: 900, wood: 900, stone: 200, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 60, overflowCapacity: 65,
                    upkeep: { wood: 3, food: 3 },
                    baseIncome: 8,
                    baseLifespan: 20,
                    // Density states: population determines income class
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Collapsed Cave', icon: 'ğŸª¨', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 20, name: 'Small Cave', icon: 'ğŸ•³ï¸', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 21, max: 40, name: 'Deep Cave', icon: 'â›°ï¸', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 1 },
                        { min: 41, max: 60, name: 'Cave Complex', icon: 'ğŸ”ï¸', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 2 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 12 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 12 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 3 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 1 }
                    ],
                    variants: [
                        { name: 'Collapsed Cave', icon: 'ğŸª¨', bonusMult: 0 },
                        { name: 'Small Cave', icon: 'ğŸ•³ï¸', bonusMult: 0.5 },
                        { name: 'Deep Cave', icon: 'â›°ï¸', bonusMult: 1.0 },
                        { name: 'Cave Complex', icon: 'ğŸ”ï¸', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        pop: 200, 
                        buildings: { type: 'COM', level: 1, count: 2 } 
                    }
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESIDENTIAL LEVEL 4-6 (Clan Chief Unlocked) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Post-Clan Chief Era: Native American themed buildings
                // Requires Clan Chief's Hut to unlock
                'RES_4': {
                    id: 'RES_4', category: 'RESIDENTIAL', level: 4, name: 'Tipi Village',
                    cost: { food: 2000, wood: 2000, stone: 40, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50, overflowCapacity: 55,
                    upkeep: { wood: 4, food: 4 },
                    baseIncome: 16,
                    baseLifespan: 25,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Tipis', icon: 'â›º', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 16, name: 'Small Camp', icon: 'â›º', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 17, max: 33, name: 'Tipi Circle', icon: 'ğŸ•ï¸', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 2 },
                        { min: 34, max: 50, name: 'Tipi Village', icon: 'ğŸª', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 4 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 50 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 5 }
                    ],
                    variants: [
                        { name: 'Abandoned Tipis', icon: 'â›º', bonusMult: 0 },
                        { name: 'Small Camp', icon: 'â›º', bonusMult: 0.5 },
                        { name: 'Tipi Circle', icon: 'ğŸ•ï¸', bonusMult: 1.0 },
                        { name: 'Tipi Village', icon: 'ğŸª', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'RES_5': {
                    id: 'RES_5', category: 'RESIDENTIAL', level: 5, name: 'Log Longhouse',
                    cost: { food: 8000, wood: 8000, stone: 80, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 120, overflowCapacity: 130,
                    upkeep: { wood: 6, food: 6 },
                    baseIncome: 32,
                    baseLifespan: 30,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Ruined Longhouse', icon: 'ğŸšï¸', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 40, name: 'Small Longhouse', icon: 'ğŸ ', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 41, max: 80, name: 'Family Longhouse', icon: 'ğŸ¡', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 3 },
                        { min: 81, max: 120, name: 'Clan Longhouse', icon: 'ğŸ˜ï¸', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 5 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 }
                    ],
                    variants: [
                        { name: 'Ruined Longhouse', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Small Longhouse', icon: 'ğŸ ', bonusMult: 0.5 },
                        { name: 'Family Longhouse', icon: 'ğŸ¡', bonusMult: 1.0 },
                        { name: 'Clan Longhouse', icon: 'ğŸ˜ï¸', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'RES_6': {
                    id: 'RES_6', category: 'RESIDENTIAL', level: 6, name: 'Old Growth Log Compound',
                    cost: { food: 20000, wood: 20000, stone: 100, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 240, overflowCapacity: 260,
                    upkeep: { wood: 10, food: 10 },
                    baseIncome: 64,
                    baseLifespan: 35,
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Compound', icon: 'ğŸšï¸', incomeClass: 'NONE', lifespanBonus: 0 },
                        { min: 1, max: 80, name: 'Small Compound', icon: 'ğŸ˜ï¸', incomeClass: 'LOW', incomeMult: 0.5, lifespanBonus: 0 },
                        { min: 81, max: 160, name: 'Growing Compound', icon: 'ğŸ°', incomeClass: 'MEDIUM', incomeMult: 1.0, lifespanBonus: 4 },
                        { min: 161, max: 240, name: 'Grand Log Compound', icon: 'ğŸ¯', incomeClass: 'HIGH', incomeMult: 1.5, lifespanBonus: 7 }
                    ],
                    benefits: [
                        { type: 'HOUSING', value: 240 },
                        { type: 'GATHER_BONUS', resource: 'wood', value: 80 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 80 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 6 }
                    ],
                    variants: [
                        { name: 'Abandoned Compound', icon: 'ğŸšï¸', bonusMult: 0 },
                        { name: 'Small Compound', icon: 'ğŸ˜ï¸', bonusMult: 0.5 },
                        { name: 'Growing Compound', icon: 'ğŸ°', bonusMult: 1.0 },
                        { name: 'Grand Log Compound', icon: 'ğŸ¯', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDUSTRIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Pre-Fire Age Theme: First people who discovered fire
                // 3 Levels Ã— 3 Density States (activity level affects production)
                'IND_1': {
                    id: 'IND_1', category: 'INDUSTRIAL', level: 1, name: 'Bird Hunting Range',
                    cost: { food: 200, wood: 200, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 10,
                    baseProduction: 10,
                    upkeep: { wood: 1, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 5 },
                        { type: 'DESIRABILITY', radius: 3, value: 0.1 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Range', icon: 'ğŸª¶', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Hunting Path', icon: 'ğŸª¶', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bird Hunting Range', icon: 'ğŸ¦…', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Prime Fowling Grounds', icon: 'ğŸ¯', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Range', icon: 'ğŸª¶', bonusMult: 0 },
                        { name: 'Sparse Hunting Path', icon: 'ğŸª¶', bonusMult: 0.5 },
                        { name: 'Bird Hunting Range', icon: 'ğŸ¦…', bonusMult: 1.0 },
                        { name: 'Prime Fowling Grounds', icon: 'ğŸ¯', bonusMult: 1.5 }
                    ],
                    popUnlock: 2
                },
                'IND_2': {
                    id: 'IND_2', category: 'INDUSTRIAL', level: 2, name: 'Grub Digging Pit',
                    cost: { food: 500, wood: 500, stone: 100, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 25,
                    baseProduction: 25,
                    upkeep: { wood: 2, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 2 },
                        { type: 'DESIRABILITY', radius: 3, value: 0.1 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Filled Hole', icon: 'ğŸ•³ï¸', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Scratched Earth', icon: 'ğŸ•³ï¸', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Grub Digging Pit', icon: 'ğŸª±', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Bountiful Foraging Pit', icon: 'ğŸ–', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Filled Hole', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Scratched Earth', icon: 'ğŸ•³ï¸', bonusMult: 0.5 },
                        { name: 'Grub Digging Pit', icon: 'ğŸª±', bonusMult: 1.0 },
                        { name: 'Bountiful Foraging Pit', icon: 'ğŸ–', bonusMult: 1.5 }
                    ],
                    popUnlock: 50
                },
                'IND_3': {
                    id: 'IND_3', category: 'INDUSTRIAL', level: 3, name: 'Stone Knapping Site',
                    cost: { food: 1500, wood: 1500, stone: 500, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 60,
                    baseProduction: 60,
                    upkeep: { wood: 3, food: 1 },
                    benefits: [
                        { type: 'JOBS', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 15 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 10 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 3 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.15 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Site', icon: 'ğŸª¨', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Scattered Flakes', icon: 'ğŸª¨', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Stone Knapping Site', icon: 'âš’ï¸', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Master Flint Workshop', icon: 'ğŸ”¨', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Site', icon: 'ğŸª¨', bonusMult: 0 },
                        { name: 'Scattered Flakes', icon: 'ğŸª¨', bonusMult: 0.5 },
                        { name: 'Stone Knapping Site', icon: 'âš’ï¸', bonusMult: 1.0 },
                        { name: 'Master Flint Workshop', icon: 'ğŸ”¨', bonusMult: 1.5 }
                    ],
                    popUnlock: 200
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDUSTRIAL LEVEL 4-6 (Clan Chief Unlocked) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Post-Clan Chief Era: Advanced hunting and resource extraction
                'IND_4': {
                    id: 'IND_4', category: 'INDUSTRIAL', level: 4, name: 'Turtle Hunting Ground',
                    cost: { food: 2400, wood: 2400, stone: 48, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20,
                    baseProduction: 50,
                    upkeep: { wood: 4, food: 2 },
                    benefits: [
                        { type: 'JOBS', value: 20 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 30 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 15 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.2 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Grounds', icon: 'ğŸ¢', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Hunting', icon: 'ğŸ¢', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Turtle Hunting Ground', icon: 'ğŸ¯', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Prime Turtle Territory', icon: 'ğŸ†', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Grounds', icon: 'ğŸ¢', bonusMult: 0 },
                        { name: 'Sparse Hunting', icon: 'ğŸ¢', bonusMult: 0.5 },
                        { name: 'Turtle Hunting Ground', icon: 'ğŸ¯', bonusMult: 1.0 },
                        { name: 'Prime Turtle Territory', icon: 'ğŸ†', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'IND_5': {
                    id: 'IND_5', category: 'INDUSTRIAL', level: 5, name: 'Bear Pit',
                    cost: { food: 9600, wood: 9600, stone: 96, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50,
                    baseProduction: 120,
                    upkeep: { wood: 6, food: 3 },
                    benefits: [
                        { type: 'JOBS', value: 50 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 60 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 25 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 8 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.25 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Pit', icon: 'ğŸ»', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Small Bear Trap', icon: 'ğŸ»', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bear Pit', icon: 'âš”ï¸', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Bear Hunting Ground', icon: 'ğŸ¹', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Pit', icon: 'ğŸ»', bonusMult: 0 },
                        { name: 'Small Bear Trap', icon: 'ğŸ»', bonusMult: 0.5 },
                        { name: 'Bear Pit', icon: 'âš”ï¸', bonusMult: 1.0 },
                        { name: 'Great Bear Hunting Ground', icon: 'ğŸ¹', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'IND_6': {
                    id: 'IND_6', category: 'INDUSTRIAL', level: 6, name: 'Buffalo Grounds',
                    cost: { food: 24000, wood: 24000, stone: 120, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 120,
                    baseProduction: 240,
                    upkeep: { wood: 10, food: 5 },
                    benefits: [
                        { type: 'JOBS', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'food', value: 120 },
                        { type: 'GATHER_BONUS', resource: 'stone', value: 40 },
                        { type: 'GATHER_BONUS', resource: 'metal', value: 15 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.3 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Plains', icon: 'ğŸ¦¬', productionMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Herd Grounds', icon: 'ğŸ¦¬', productionMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Buffalo Grounds', icon: 'ğŸ¹', productionMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Buffalo Hunt', icon: 'âš¡', productionMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Plains', icon: 'ğŸ¦¬', bonusMult: 0 },
                        { name: 'Sparse Herd Grounds', icon: 'ğŸ¦¬', bonusMult: 0.5 },
                        { name: 'Buffalo Grounds', icon: 'ğŸ¹', bonusMult: 1.0 },
                        { name: 'Great Buffalo Hunt', icon: 'âš¡', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMMERCIAL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Pre-Fire Age Theme: First people who discovered fire
                // 3 Levels Ã— 3 Density States (activity level affects income)
                'COM_1': {
                    id: 'COM_1', category: 'COMMERCIAL', level: 1, name: 'Trading Post',
                    cost: { food: 150, wood: 150, stone: 0, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 8,
                    baseIncome: 5,
                    upkeep: { wood: 1, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 8 },
                        { type: 'INCOME', value: 5 },
                        { type: 'DESIRABILITY', radius: 4, value: 0.2 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Pile', icon: 'ğŸª¨', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Pebble Pile', icon: 'ğŸª¨', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Trading Pebble Post', icon: 'ğŸ”„', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Busy Barter Spot', icon: 'ğŸ’±', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Pile', icon: 'ğŸª¨', bonusMult: 0 },
                        { name: 'Pebble Pile', icon: 'ğŸª¨', bonusMult: 0.5 },
                        { name: 'Trading Pebble Post', icon: 'ğŸ”„', bonusMult: 1.0 },
                        { name: 'Busy Barter Spot', icon: 'ğŸ’±', bonusMult: 1.5 }
                    ],
                    popUnlock: 10
                },
                'COM_2': {
                    id: 'COM_2', category: 'COMMERCIAL', level: 2, name: 'Campfire Circle',
                    cost: { food: 400, wood: 400, stone: 50, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 20,
                    baseIncome: 15,
                    upkeep: { wood: 2, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 20 },
                        { type: 'INCOME', value: 15 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.3 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Cold Ashes', icon: 'â¬›', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Smoky Embers', icon: 'ğŸŒ«ï¸', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Warming Fire', icon: 'ğŸ”¥', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Gathering Fire', icon: 'ğŸ‡', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Cold Ashes', icon: 'â¬›', bonusMult: 0 },
                        { name: 'Smoky Embers', icon: 'ğŸŒ«ï¸', bonusMult: 0.5 },
                        { name: 'Warming Fire', icon: 'ğŸ”¥', bonusMult: 1.0 },
                        { name: 'Great Gathering Fire', icon: 'ğŸ‡', bonusMult: 1.5 }
                    ],
                    popUnlock: 40
                },
                'COM_3': {
                    id: 'COM_3', category: 'COMMERCIAL', level: 3, name: "Elder's Meeting Ground",
                    cost: { food: 1200, wood: 1200, stone: 200, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 50,
                    baseIncome: 40,
                    upkeep: { wood: 3, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 50 },
                        { type: 'INCOME', value: 40 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.4 },
                        { type: 'CULTURE', value: 5 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Forgotten Circle', icon: 'â­•', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Abandoned Circle', icon: 'â­•', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Council Ring', icon: 'ğŸ”µ', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Sacred Assembly', icon: 'ğŸŒŸ', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Forgotten Circle', icon: 'â­•', bonusMult: 0 },
                        { name: 'Abandoned Circle', icon: 'â­•', bonusMult: 0.5 },
                        { name: 'Council Ring', icon: 'ğŸ”µ', bonusMult: 1.0 },
                        { name: 'Sacred Assembly', icon: 'ğŸŒŸ', bonusMult: 1.5 }
                    ],
                    popUnlock: 150
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMMERCIAL LEVEL 4-6 (Clan Chief Unlocked) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Post-Clan Chief Era: Advanced trading and marketplaces
                'COM_4': {
                    id: 'COM_4', category: 'COMMERCIAL', level: 4, name: 'Barter Barrel',
                    cost: { food: 1600, wood: 1600, stone: 32, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 16,
                    baseIncome: 80,
                    upkeep: { wood: 4, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 16 },
                        { type: 'INCOME', value: 80 },
                        { type: 'DESIRABILITY', radius: 5, value: 0.35 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Barrel', icon: 'ğŸª£', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Sparse Goods', icon: 'ğŸª£', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Barter Barrel', icon: 'ğŸ›¢ï¸', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Bustling Trade Post', icon: 'ğŸ’°', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Barrel', icon: 'ğŸª£', bonusMult: 0 },
                        { name: 'Sparse Goods', icon: 'ğŸª£', bonusMult: 0.5 },
                        { name: 'Barter Barrel', icon: 'ğŸ›¢ï¸', bonusMult: 1.0 },
                        { name: 'Bustling Trade Post', icon: 'ğŸ’°', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 500
                },
                'COM_5': {
                    id: 'COM_5', category: 'COMMERCIAL', level: 5, name: 'Blanket Market',
                    cost: { food: 6400, wood: 6400, stone: 64, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 40,
                    baseIncome: 160,
                    upkeep: { wood: 6, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 40 },
                        { type: 'INCOME', value: 160 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.45 },
                        { type: 'CULTURE', value: 8 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Empty Market', icon: 'ğŸ§º', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Few Blankets', icon: 'ğŸ§º', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Blanket Market', icon: 'ğŸ›ï¸', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Grand Market Fair', icon: 'ğŸª', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Empty Market', icon: 'ğŸ§º', bonusMult: 0 },
                        { name: 'Few Blankets', icon: 'ğŸ§º', bonusMult: 0.5 },
                        { name: 'Blanket Market', icon: 'ğŸ›ï¸', bonusMult: 1.0 },
                        { name: 'Grand Market Fair', icon: 'ğŸª', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 1000
                },
                'COM_6': {
                    id: 'COM_6', category: 'COMMERCIAL', level: 6, name: 'Bear Market',
                    cost: { food: 16000, wood: 16000, stone: 80, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 100,
                    baseIncome: 320,
                    upkeep: { wood: 10, food: 0 },
                    benefits: [
                        { type: 'JOBS', value: 100 },
                        { type: 'INCOME', value: 320 },
                        { type: 'DESIRABILITY', radius: 7, value: 0.55 },
                        { type: 'CULTURE', value: 15 }
                    ],
                    stateThresholds: [
                        { min: 0, max: 0, name: 'Abandoned Market', icon: 'ğŸ»', incomeMult: 0 },
                        { min: 0.01, max: 0.3, name: 'Quiet Trading', icon: 'ğŸ»', incomeMult: 0.5 },
                        { min: 0.31, max: 0.7, name: 'Bear Market', icon: 'ğŸª', incomeMult: 1.0 },
                        { min: 0.71, max: 1.0, name: 'Great Bear Exchange', icon: 'ğŸ›ï¸', incomeMult: 1.5 }
                    ],
                    variants: [
                        { name: 'Abandoned Market', icon: 'ğŸ»', bonusMult: 0 },
                        { name: 'Quiet Trading', icon: 'ğŸ»', bonusMult: 0.5 },
                        { name: 'Bear Market', icon: 'ğŸª', bonusMult: 1.0 },
                        { name: 'Great Bear Exchange', icon: 'ğŸ›ï¸', bonusMult: 1.5 }
                    ],
                    unlockReq: { 
                        buildings: { id: 'CLAN_CHIEF', count: 1 }
                    },
                    popUnlock: 2000
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INFRASTRUCTURE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                'WELL': {
                    id: 'WELL', category: 'INFRASTRUCTURE', level: 1, name: 'Water Well',
                    cost: { food: 50, wood: 200, stone: 5, metal: 0 },
                    size: { w: 1, h: 1 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'WATER', value: 100 },
                        { type: 'DESIRABILITY', radius: 6, value: 0.15 }
                    ],
                    variants: [
                        { name: 'Dry Well', icon: 'ğŸ•³ï¸', bonusMult: 0 },
                        { name: 'Water Well', icon: 'ğŸ’§', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                },
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MILESTONE BUILDINGS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // These are major progression gates that unlock new building tiers
                'CLAN_CHIEF': {
                    id: 'CLAN_CHIEF', category: 'MILESTONE', level: 1, name: "Clan Chief's Hut",
                    description: "The seat of power for your clan. Building this unlocks Level 4-6 buildings.",
                    cost: { food: 100000, wood: 100000, stone: 0, metal: 0, gold: 1 },
                    size: { w: 2, h: 2 }, capacity: 0,
                    upkeep: { wood: 5, food: 5 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 50, value: 2.0 },
                        { type: 'CULTURE', value: 25 },
                        { type: 'UNLOCK_TIER', value: 4 }
                    ],
                    variants: [
                        { name: "Clan Chief's Hut", icon: 'ğŸ›ï¸', bonusMult: 1.0 }
                    ],
                    popUnlock: 0,
                    unlockReq: {
                        pop: 500,
                        resources: { food: 100000, wood: 100000, gold: 1 }
                    }
                },
                'DOCK': {
                    id: 'DOCK', category: 'MILESTONE', level: 2, name: "Trading Dock",
                    description: "A major port for trade. Building this unlocks Level 7+ buildings.",
                    cost: { food: 500000, wood: 500000, stone: 0, metal: 0, gold: 5 },
                    size: { w: 3, h: 2 }, capacity: 0,
                    upkeep: { wood: 15, food: 10 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 60, value: 3.0 },
                        { type: 'CULTURE', value: 50 },
                        { type: 'INCOME', value: 500 },
                        { type: 'UNLOCK_TIER', value: 7 }
                    ],
                    variants: [
                        { name: "Trading Dock", icon: 'âš“', bonusMult: 1.0 }
                    ],
                    popUnlock: 0,
                    unlockReq: {
                        pop: 2000,
                        buildings: { id: 'CLAN_CHIEF', count: 1 },
                        resources: { food: 500000, wood: 500000, gold: 5 }
                    }
                },
                // Legacy CHIEF for backward compatibility
                'CHIEF': {
                    id: 'CHIEF', category: 'SPECIAL', level: 1, name: "Chief's Hut",
                    cost: { food: 10000, wood: 0, stone: 0, metal: 0 },
                    size: { w: 2, h: 2 }, capacity: 0,
                    upkeep: { wood: 0, food: 0 },
                    benefits: [
                        { type: 'DESIRABILITY', radius: 50, value: 2.0 },
                        { type: 'CULTURE', value: 10 }
                    ],
                    variants: [
                        { name: "Chief's Hut", icon: 'ğŸ›ï¸', bonusMult: 1.0 }
                    ],
                    popUnlock: 0
                }
            },
            
            // Gold exchange rate: 5000 metal = 1 gold
            GOLD_EXCHANGE_RATE: 5000,
            
            // Category groupings for menus
            BUILDING_CATEGORIES: {
                RESIDENTIAL: ['RES_1', 'RES_2', 'RES_3', 'RES_4', 'RES_5', 'RES_6'],
                INDUSTRIAL: ['IND_1', 'IND_2', 'IND_3', 'IND_4', 'IND_5', 'IND_6'],
                COMMERCIAL: ['COM_1', 'COM_2', 'COM_3', 'COM_4', 'COM_5', 'COM_6'],
                INFRASTRUCTURE: ['WELL'],
                MILESTONE: ['CLAN_CHIEF', 'DOCK'],
                SPECIAL: ['CHIEF']
            },
            
            // Helper to get building by ID
            getBuilding(id) {
                return this.BUILDING_DB[id] || null;
            },
            
            // Helper to get buildings by category
            getBuildingsByCategory(category) {
                let ids = this.BUILDING_CATEGORIES[category] || [];
                return ids.map(id => this.BUILDING_DB[id]).filter(b => b);
            },
            
            // BACKWARD COMPATIBILITY: Map level number to BUILDING_DB entry
            // Returns building in OLD format for compatibility with existing code
            getResidentialByLevel(level) {
                let building = this.BUILDING_DB['RES_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            getIndustrialByLevel(level) {
                let building = this.BUILDING_DB['IND_' + level];
                if(!building) return null;
                // Return in old format for compatibility
                return {
                    level: building.level,
                    name: building.name,
                    food: building.cost.food,
                    wood: building.cost.wood,
                    stone: building.cost.stone,
                    metal: building.cost.metal,
                    capacity: building.capacity,
                    upkeep: building.upkeep,
                    gatherBonus: this._extractGatherBonus(building),
                    variants: building.variants
                };
            },
            
            // Helper to extract gatherBonus from benefits array
            _extractGatherBonus(building) {
                let bonus = { wood: 0, food: 0, stone: 0, metal: 0 };
                if(!building.benefits) return bonus;
                for(let b of building.benefits) {
                    if(b.type === 'GATHER_BONUS' && b.resource) {
                        bonus[b.resource] = b.value;
                    }
                }
                return bonus;
            },
            
            // ERAS control maximum building level based on population
            // Follows exponential scaling: each level requires ~3x previous population
            ERAS: [
                { name: 'Wanderer', level: 0, popUnlock: 0 },
                { name: 'Settlement', level: 1, popUnlock: 2 },
                { name: 'Village', level: 2, popUnlock: 20 },
                { name: 'Town', level: 3, popUnlock: 100 },
                { name: 'City', level: 4, popUnlock: 500 },
                { name: 'Metro', level: 5, popUnlock: 2000 },
                { name: 'Province', level: 6, popUnlock: 7000 },
                { name: 'Region', level: 7, popUnlock: 20000 },
                { name: 'State', level: 8, popUnlock: 60000 },
                { name: 'Nation', level: 9, popUnlock: 180000 },
                { name: 'Empire', level: 10, popUnlock: 500000 },
                { name: 'Dominion', level: 11, popUnlock: 1400000 },
                { name: 'Realm', level: 12, popUnlock: 4200000 },
                { name: 'Dynasty', level: 13, popUnlock: 13000000 },
                { name: 'Hegemony', level: 14, popUnlock: 38000000 },
                { name: 'Superpower', level: 15, popUnlock: 115000000 },
                { name: 'World Power', level: 16, popUnlock: 345000000 },
                { name: 'Hyperpower', level: 17, popUnlock: 1000000000 },
                { name: 'Civilization', level: 18, popUnlock: 3100000000 },
                { name: 'Eternal', level: 19, popUnlock: 10000000000 }
            ],
            
            // === BUILDING LEVELS (Multi-tier system) - Pre-Fire Age ===
            BUILDING_LEVELS: [
                // Level 0: WANDER epoch - no building
                { level: 0, name: 'Wanderer', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0, overflowCapacity: 0 },
                
                // Level 1: Tree Shelter (capacity 15, overflow 20)
                { level: 1, name: 'Tree Shelter', food: 100, wood: 100, stone: 0, metal: 0, capacity: 15, overflowCapacity: 20,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 2, food: 2, stone: 0, metal: 0 },
                  variants: [
                    { name: 'Abandoned Nest', icon: 'ğŸª¹' },
                    { name: 'Small Nest', icon: 'ğŸªº', bonus: { wood: 0, food: 0 } },
                    { name: 'Tree Platform', icon: 'ğŸŒ³', bonus: { wood: 1, food: 1 } },
                    { name: 'Sturdy Treehouse', icon: 'ğŸ•ï¸', bonus: { wood: 1.5, food: 1.5 } }
                  ]
                },
                // Level 2: Ground Pit (capacity 25, overflow 30)
                { level: 2, name: 'Ground Pit', food: 300, wood: 300, stone: 50, metal: 0, capacity: 25, overflowCapacity: 30,
                  upkeep: { wood: 2, food: 2 },
                  gatherBonus: { wood: 5, food: 5, stone: 1, metal: 0 },
                  variants: [
                    { name: 'Collapsed Pit', icon: 'ğŸ•³ï¸' },
                    { name: 'Shallow Scrape', icon: 'â¬›', bonus: { wood: 0, food: 0 } },
                    { name: 'Dug Pit', icon: 'ğŸŸ«', bonus: { wood: 2, food: 2 } },
                    { name: 'Covered Pit Dwelling', icon: 'ğŸ ', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                // Level 3: Ground Cave (capacity 60, overflow 65)
                { level: 3, name: 'Ground Cave', food: 900, wood: 900, stone: 200, metal: 0, capacity: 60, overflowCapacity: 65,
                  upkeep: { wood: 3, food: 3 },
                  gatherBonus: { wood: 12, food: 12, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Collapsed Cave', icon: 'ğŸª¨' },
                    { name: 'Small Cave', icon: 'ğŸ•³ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Deep Cave', icon: 'â›°ï¸', bonus: { wood: 3, food: 3 } },
                    { name: 'Cave Complex', icon: 'ğŸ”ï¸', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                // Level 4: Log House (overflow +5)
                { level: 4, name: 'Log House', food: 2700, wood: 2700, stone: 0, metal: 0, capacity: 170, overflowCapacity: 175,
                  upkeep: { wood: 4, food: 4 },
                  gatherBonus: { wood: 57, food: 57, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Ruins', icon: 'ğŸšï¸' },
                    { name: 'Wood Shack', icon: 'ğŸ›–', bonus: { wood: 0, food: 0 } },
                    { name: 'Log House', icon: 'ğŸ ', bonus: { wood: 4, food: 4 } },
                    { name: 'Grand Log Hall', icon: 'ğŸ¡', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                // Level 5: Stone Cottage (overflow +5)
                { level: 5, name: 'Stone Cottage', food: 8100, wood: 8100, stone: 0, metal: 0, capacity: 260, overflowCapacity: 265,
                  upkeep: { wood: 5, food: 5 },
                  gatherBonus: { wood: 93, food: 93, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Rubble', icon: 'ğŸª¨' },
                    { name: 'Stone Hut', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Stone Cottage', icon: 'ğŸ¡', bonus: { wood: 5, food: 5 } },
                    { name: 'Stone Manor', icon: 'ğŸ˜ï¸', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                },
                // Level 6: Timber Frame (overflow +5)
                { level: 6, name: 'Timber Frame', food: 24300, wood: 24300, stone: 0, metal: 0, capacity: 370, overflowCapacity: 375,
                  upkeep: { wood: 6, food: 6 },
                  gatherBonus: { wood: 138, food: 138, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Collapsed Frame', icon: 'ğŸšï¸' },
                    { name: 'Basic Frame', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Timber House', icon: 'ğŸ¡', bonus: { wood: 6, food: 6 } },
                    { name: 'Timber Hall', icon: 'ğŸ›ï¸', bonus: { wood: 6.5, food: 6.5 } }
                  ]
                },
                // Level 7: Brick House (overflow +5)
                { level: 7, name: 'Brick House', food: 72900, wood: 72900, stone: 0, metal: 0, capacity: 500, overflowCapacity: 505,
                  upkeep: { wood: 7, food: 7 },
                  gatherBonus: { wood: 192, food: 192, stone: 7, metal: 5 },
                  variants: [
                    { name: 'Crumbling Brick', icon: 'ğŸ§±' },
                    { name: 'Brick Shack', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Brick House', icon: 'ğŸ¡', bonus: { wood: 7, food: 7 } },
                    { name: 'Brick Mansion', icon: 'ğŸ˜ï¸', bonus: { wood: 7.5, food: 7.5 } }
                  ]
                },
                // Level 8: Town House (overflow +5)
                { level: 8, name: 'Town House', food: 218700, wood: 218700, stone: 0, metal: 0, capacity: 650, overflowCapacity: 655,
                  upkeep: { wood: 8, food: 8 },
                  gatherBonus: { wood: 255, food: 255, stone: 8, metal: 6 },
                  variants: [
                    { name: 'Abandoned Town', icon: 'ğŸšï¸' },
                    { name: 'Small Townhouse', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Town House', icon: 'ğŸ¡', bonus: { wood: 8, food: 8 } },
                    { name: 'Grand Townhouse', icon: 'ğŸ›ï¸', bonus: { wood: 8.5, food: 8.5 } }
                  ]
                },
                // Level 9: Villa (overflow +5)
                { level: 9, name: 'Villa', food: 656100, wood: 656100, stone: 0, metal: 0, capacity: 820, overflowCapacity: 825,
                  upkeep: { wood: 9, food: 9 },
                  gatherBonus: { wood: 327, food: 327, stone: 9, metal: 7 },
                  variants: [
                    { name: 'Ruined Villa', icon: 'ğŸšï¸' },
                    { name: 'Simple Villa', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Villa', icon: 'ğŸ¡', bonus: { wood: 9, food: 9 } },
                    { name: 'Grand Villa', icon: 'ğŸ°', bonus: { wood: 9.5, food: 9.5 } }
                  ]
                },
                // Level 10: Estate (overflow +5)
                { level: 10, name: 'Estate', food: 1968300, wood: 1968300, stone: 0, metal: 0, capacity: 1010, overflowCapacity: 1015,
                  upkeep: { wood: 10, food: 10 },
                  gatherBonus: { wood: 408, food: 408, stone: 10, metal: 8 },
                  variants: [
                    { name: 'Ruined Estate', icon: 'ğŸšï¸' },
                    { name: 'Small Estate', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Estate', icon: 'ğŸ¡', bonus: { wood: 10, food: 10 } },
                    { name: 'Grand Estate', icon: 'ğŸ°', bonus: { wood: 10.5, food: 10.5 } }
                  ]
                },
                // Level 11: Manor
                { level: 11, name: 'Manor', food: 5904900, wood: 5904900, stone: 0, metal: 0, capacity: 1220,
                  upkeep: { wood: 11, food: 11 },
                  gatherBonus: { wood: 498, food: 498, stone: 11, metal: 9 },
                  variants: [
                    { name: 'Ruined Manor', icon: 'ğŸšï¸' },
                    { name: 'Small Manor', icon: 'ğŸ ', bonus: { wood: 0, food: 0 } },
                    { name: 'Manor', icon: 'ğŸ›ï¸', bonus: { wood: 11, food: 11 } },
                    { name: 'Grand Manor', icon: 'ğŸ°', bonus: { wood: 11.5, food: 11.5 } }
                  ]
                },
                // Level 12: Palace
                { level: 12, name: 'Palace', food: 17714700, wood: 17714700, stone: 0, metal: 0, capacity: 1450,
                  upkeep: { wood: 12, food: 12 },
                  gatherBonus: { wood: 597, food: 597, stone: 12, metal: 10 },
                  variants: [
                    { name: 'Ruined Palace', icon: 'ğŸšï¸' },
                    { name: 'Small Palace', icon: 'ğŸ›ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Palace', icon: 'ğŸ°', bonus: { wood: 12, food: 12 } },
                    { name: 'Grand Palace', icon: 'ğŸ‘‘', bonus: { wood: 12.5, food: 12.5 } }
                  ]
                },
                // Level 13: Citadel
                { level: 13, name: 'Citadel', food: 53144100, wood: 53144100, stone: 0, metal: 0, capacity: 1700,
                  upkeep: { wood: 13, food: 13 },
                  gatherBonus: { wood: 705, food: 705, stone: 13, metal: 11 },
                  variants: [
                    { name: 'Ruined Citadel', icon: 'ğŸšï¸' },
                    { name: 'Small Citadel', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Citadel', icon: 'ğŸ¯', bonus: { wood: 13, food: 13 } },
                    { name: 'Grand Citadel', icon: 'âš”ï¸', bonus: { wood: 13.5, food: 13.5 } }
                  ]
                },
                // Level 14: Fortress
                { level: 14, name: 'Fortress', food: 159432300, wood: 159432300, stone: 0, metal: 0, capacity: 1970,
                  upkeep: { wood: 14, food: 14 },
                  gatherBonus: { wood: 822, food: 822, stone: 14, metal: 12 },
                  variants: [
                    { name: 'Ruined Fortress', icon: 'ğŸšï¸' },
                    { name: 'Small Fortress', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Fortress', icon: 'ğŸ¯', bonus: { wood: 14, food: 14 } },
                    { name: 'Grand Fortress', icon: 'ğŸ›¡ï¸', bonus: { wood: 14.5, food: 14.5 } }
                  ]
                },
                // Level 15: Castle
                { level: 15, name: 'Castle', food: 478296900, wood: 478296900, stone: 0, metal: 0, capacity: 2260,
                  upkeep: { wood: 15, food: 15 },
                  gatherBonus: { wood: 948, food: 948, stone: 15, metal: 13 },
                  variants: [
                    { name: 'Ruined Castle', icon: 'ğŸšï¸' },
                    { name: 'Small Castle', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Castle', icon: 'ğŸ¯', bonus: { wood: 15, food: 15 } },
                    { name: 'Grand Castle', icon: 'ğŸ‘‘', bonus: { wood: 15.5, food: 15.5 } }
                  ]
                },
                // Level 16: Kingdom
                { level: 16, name: 'Kingdom', food: 1434890700, wood: 1434890700, stone: 0, metal: 0, capacity: 2570,
                  upkeep: { wood: 16, food: 16 },
                  gatherBonus: { wood: 1083, food: 1083, stone: 16, metal: 14 },
                  variants: [
                    { name: 'Fallen Kingdom', icon: 'ğŸšï¸' },
                    { name: 'Small Kingdom', icon: 'ğŸ°', bonus: { wood: 0, food: 0 } },
                    { name: 'Kingdom', icon: 'ğŸ‘‘', bonus: { wood: 16, food: 16 } },
                    { name: 'Grand Kingdom', icon: 'ğŸŒŸ', bonus: { wood: 16.5, food: 16.5 } }
                  ]
                },
                // Level 17: Empire
                { level: 17, name: 'Empire', food: 4304672100, wood: 4304672100, stone: 0, metal: 0, capacity: 2900,
                  upkeep: { wood: 17, food: 17 },
                  gatherBonus: { wood: 1227, food: 1227, stone: 17, metal: 15 },
                  variants: [
                    { name: 'Fallen Empire', icon: 'ğŸšï¸' },
                    { name: 'Small Empire', icon: 'ğŸ‘‘', bonus: { wood: 0, food: 0 } },
                    { name: 'Empire', icon: 'ğŸŒŸ', bonus: { wood: 17, food: 17 } },
                    { name: 'Grand Empire', icon: 'âœ¨', bonus: { wood: 17.5, food: 17.5 } }
                  ]
                },
                // Level 18: Dynasty
                { level: 18, name: 'Dynasty', food: 12914016300, wood: 12914016300, stone: 0, metal: 0, capacity: 3250,
                  upkeep: { wood: 18, food: 18 },
                  gatherBonus: { wood: 1380, food: 1380, stone: 18, metal: 16 },
                  variants: [
                    { name: 'Fallen Dynasty', icon: 'ğŸšï¸' },
                    { name: 'Rising Dynasty', icon: 'ğŸ‘‘', bonus: { wood: 0, food: 0 } },
                    { name: 'Dynasty', icon: 'ğŸŒŸ', bonus: { wood: 18, food: 18 } },
                    { name: 'Eternal Dynasty', icon: 'ğŸ’«', bonus: { wood: 18.5, food: 18.5 } }
                  ]
                },
                // Level 19: Civilization
                { level: 19, name: 'Civilization', food: 38742048900, wood: 38742048900, stone: 0, metal: 0, capacity: 3620,
                  upkeep: { wood: 19, food: 19 },
                  gatherBonus: { wood: 1542, food: 1542, stone: 19, metal: 17 },
                  variants: [
                    { name: 'Lost Civilization', icon: 'ğŸšï¸' },
                    { name: 'Young Civilization', icon: 'ğŸŒŸ', bonus: { wood: 0, food: 0 } },
                    { name: 'Civilization', icon: 'âœ¨', bonus: { wood: 19, food: 19 } },
                    { name: 'Eternal Civilization', icon: 'ğŸŒŒ', bonus: { wood: 19.5, food: 19.5 } }
                  ]
                }
            ],
            
            // === INDUSTRIAL BUILDING LEVELS (4 tiers) ===
            INDUSTRIAL_LEVELS: [
                // Level 0: Placeholder (not buildable)
                { level: 0, name: 'None', food: 0, wood: 0, stone: 0, metal: 0, capacity: 0 },
                
                // Level 1: Hunting Ground
                { level: 1, name: 'Hunting Ground', food: 1000, wood: 1000, stone: 0, metal: 0, capacity: 100,
                  upkeep: { wood: 1, food: 1 },
                  gatherBonus: { wood: 3, food: 3, stone: 3, metal: 1 },
                  variants: [
                    { name: 'Abandoned Hunting Ground', icon: 'ğŸšï¸' },
                    { name: 'Hunting Ground', icon: 'ğŸ¹', bonus: { wood: 0, food: 0 } },
                    { name: 'Active Hunting Ground', icon: 'ğŸ¦Œ', bonus: { wood: 2, food: 2 } },
                    { name: 'Thriving Hunting Ground', icon: 'ğŸ•ï¸', bonus: { wood: 2.5, food: 2.5 } }
                  ]
                },
                
                // Level 2: Hunting Pit
                { level: 2, name: 'Hunting Pit', food: 2000, wood: 2000, stone: 0, metal: 0, capacity: 200,
                  upkeep: { wood: 2, food: 1 },
                  gatherBonus: { wood: 4, food: 4, stone: 4, metal: 2 },
                  variants: [
                    { name: 'Collapsed Hunting Pit', icon: 'ğŸ•³ï¸' },
                    { name: 'Hunting Pit', icon: 'âš”ï¸', bonus: { wood: 0, food: 0 } },
                    { name: 'Deep Hunting Pit', icon: 'ğŸ—¡ï¸', bonus: { wood: 3, food: 3 } },
                    { name: 'Grand Hunting Pit', icon: 'âš”ï¸', bonus: { wood: 3.5, food: 3.5 } }
                  ]
                },
                
                // Level 3: Advanced Hunting Ground
                { level: 3, name: 'Advanced Hunting Ground', food: 3000, wood: 3000, stone: 100, metal: 100, capacity: 300,
                  upkeep: { wood: 3, food: 1 },
                  gatherBonus: { wood: 5, food: 5, stone: 5, metal: 3 },
                  variants: [
                    { name: 'Ruined Advanced Ground', icon: 'ğŸšï¸' },
                    { name: 'Advanced Hunting Ground', icon: 'ğŸ¯', bonus: { wood: 0, food: 0 } },
                    { name: 'Superior Hunting Ground', icon: 'ğŸ¦¬', bonus: { wood: 4, food: 4 } },
                    { name: 'Elite Hunting Ground', icon: 'ğŸ†', bonus: { wood: 4.5, food: 4.5 } }
                  ]
                },
                
                // Level 4: Basic Tannery
                { level: 4, name: 'Basic Tannery', food: 4000, wood: 4000, stone: 500, metal: 500, capacity: 400,
                  upkeep: { wood: 4, food: 1 },
                  gatherBonus: { wood: 6, food: 6, stone: 6, metal: 4 },
                  variants: [
                    { name: 'Abandoned Tannery', icon: 'ğŸšï¸' },
                    { name: 'Basic Tannery', icon: 'ğŸ¥¾', bonus: { wood: 0, food: 0 } },
                    { name: 'Working Tannery', icon: 'ğŸ‘œ', bonus: { wood: 5, food: 5 } },
                    { name: 'Master Tannery', icon: 'ğŸ’', bonus: { wood: 5.5, food: 5.5 } }
                  ]
                }
            ],
            
            ZONE_COST: 50,
            CHIEF_COST: 10000,
            CHIEF_RADIUS: 50,
            CHIEF_BONUS: 2.0,
            GROWTH_THRESHOLD: 1.0,
            DECAY_THRESHOLD: 0.7,
            EFFICIENCY: {
                NO_ROAD_PENALTY: 0.05,
                WATER_BONUS_MAX: 0.5,
                FOREST_BONUS: 0.2,
                DECAY_RATE: 0.02,
                MIN_EFFICIENCY: 0.1
            },
            DESIRABILITY: {
                NEIGHBOR_BONUS: 0.10,
                TREE_BONUS: 0.25,
                WATER_BONUS: 0.50,
                WATER_RANGE: 5,             // Updated to match settlement requirement
                ISOLATION_PENALTY: 0.50,
                ISOLATION_RANGE: 2,
                WEALTH_FOOD_MULTIPLIER: 1.2,
                PATH_BONUS: 0.10, // Path (formerly road)
                WELL_BONUS: 0.15,
                INDUSTRIAL_BONUS: 0.15,
            },
            // === SIMCITY SNES STYLE ZONING BONUSES ===
            // Build anywhere, but smart placement gets bonuses!
            ZONE_BONUSES: {
                // Road Access (critical for all zones)
                ROAD_ACCESS_BONUS: 0.50,        // +50% if adjacent to road
                NO_ROAD_PENALTY: 0.30,          // -70% if no road nearby (within 3 tiles)
                
                // Residential bonuses
                RES_WATER_BONUS: 0.30,          // +30% near water (within 3 tiles)
                RES_TREE_BONUS: 0.20,           // +20% near trees/forest
                RES_CLUSTER_BONUS: 0.10,        // +10% per adjacent residential
                RES_INDUSTRIAL_PENALTY: 0.25,   // -25% if industrial within 2 tiles
                RES_WELL_BONUS: 0.15,           // +15% if well within 3 tiles
                
                // Commercial bonuses (needs customers - residential)
                COM_RES_NEARBY_BONUS: 0.40,     // +40% if 3+ residential within 5 tiles
                COM_ROAD_JUNCTION_BONUS: 0.20,  // +20% if 3+ road tiles adjacent
                COM_INDUSTRIAL_NEARBY: 0.15,    // +15% if industrial within 5 tiles (workers)
                COM_ISOLATION_PENALTY: 0.50,    // -50% if no residential nearby
                
                // Industrial bonuses (needs resources and workers)
                IND_FOREST_BONUS: 0.30,         // +30% near forest (wood source)
                IND_STONE_BONUS: 0.25,          // +25% near stone deposits
                IND_WATER_BONUS: 0.20,          // +20% near water (processing)
                IND_RES_NEARBY_PENALTY: 0.20,   // -20% too close to residential (pollution)
                IND_CLUSTER_BONUS: 0.15,        // +15% per adjacent industrial (efficiency)
                
                // Special building bonuses
                CHIEF_CULTURE_RADIUS: 10,       // Chief's Hut boosts everything in radius
                CHIEF_BONUS: 0.50,              // +50% to nearby buildings
            },
            ZOOM: { MIN: 0.1, MAX: 3, STEP: 1.1 },
            CAMERA: { START_X: 3200, START_Y: 3200, START_ZOOM: 1.0 },
            
            HOUSING: { MUD_HUT_CAPACITY: 20, WARNING_CAPACITY: 55, MAX_CAPACITY: 60, OVERPOPULATION_YEARS: 10, DECAY_TARGET: 30 },
            PRODUCTION: { 
                PERSON_HUNTS: 2, 
                PERSON_EATS: 1, 
                FOOD_TO_GROW: 10, 
                FOOD_FOR_HUT: 50,
                INDUSTRIAL_FOOD_PER_TURN: 100, 
                INDUSTRIAL_SUPPORTS_POPULATION: 200, 
                YEARS_TO_UNLOCK_INDUSTRIAL: 10, 
                INDUSTRIAL_UNLOCK_COST: 100, 
                FOOD_CONSUMPTION_PER_10_POP: 1, 
                INDUSTRIAL_POPULATION_REQUIREMENT: 100, 
                WOLVES_REQUIRED_FOR_INDUSTRIAL: 0, // Removed - wolves no longer in game
                SIMCITY_MODE_UNLOCK_COST: 10000,
                SIMCITY_POPULATION_GROWTH_RATE: 0.15,
                SIMCITY_FOOD_PER_PERSON: 0.1,
                STARVATION_RATE: 0.20,      // Updated: 20% death on starvation
                BASE_GROWTH_RATE: 3
            },
            UPGRADE: {
                BASE_COST: 100,
                COST_MULTIPLIER: 1.5,
                RES_CAPACITY_PER_LEVEL: 20,
                COM_PRODUCTION_PER_LEVEL: 10,
                IND_PRODUCTION_PER_LEVEL: 8
            },
            
            // === WORKFORCE SYSTEM ===
            WORKFORCE: {
                WELL_WORKERS: 0,            // Wells operate automatically (no workers needed)
                ROAD_WORKERS: 0,            // 0 workers per road tile (no upkeep needed)
                COMMERCIAL_WORKERS: 3,      // 3 workers per commercial building
                HUNTING_WORKERS_MIN: 20,    // Min workers for Hunting Ground
                HUNTING_WORKERS_MAX: 100,   // Max workers for Hunting Ground
                GATHERER_FOOD_RATE: 1.5,    // Food per gatherer per year
                GATHERER_WOOD_RATE: 3.0,    // Wood per gatherer per year
                HUNTER_FOOD_RATE: 1.0       // Food per hunter per year
            },
            
            WATER: {
                WELL_CAPACITY: 100,         // Each well serves 100 people
                PER_BUILDING: 0,            // No extra water for buildings under 100 pop
                PER_500_PEOPLE: 500         // 1 well per 500 people (won't trigger under 100)
            },
            
            RESOURCES: {
                WOOD_PER_STEP: 1,           // Wood from forest tiles
                RARE_FIND_CHANCE: 0.0001,   // 0.01% per step on open ground
                LUCKY_FIND_AMOUNT: 1
            },
            
            STONE_DEPOSITS: {
                SPAWN_COUNT: 80,
                MIN_METAL: 1000000,
                MAX_METAL: 10000000
            },
            
            CONSTANTS: {
                BASE_SPOILAGE: 0.30,        // 30% rot per year over capacity
                FOOD_PER_PERSON: 0.2,       // People eat 0.2 food/year (minimal survival)
                BASE_PROD: 1.5,
                STARVATION_DEATH: 0.20,     // 20% instant death when food < 0
                THIRST_DEATH: 0.10,         // 10% instant death when water shortage
                BASE_STORAGE: 5000          // 5000 base storage (was 200)
            },
            
            BUILDINGS: {
                BASKET: { cost: 500, reqPop: 20, cap: 2000, desc: 'ğŸ§º Basket Storage', icon: 'ğŸ§º' },
                POTTERY: { cost: 5000, reqPop: 150, cap: 10000, desc: 'ğŸº Pottery Storage', icon: 'ğŸº' },
                GRANARY: { cost: 50000, reqPop: 1000, cap: 100000, desc: 'ğŸ›ï¸ Granary', icon: 'ğŸ›ï¸', locked: true },
                PALACE: { cost: 250000, reqPop: 5000, cap: 1000000, desc: 'ğŸ° Palace Storage', icon: 'ğŸ°', locked: true }
            },
            
            // Storage Pits - 10k capacity each, costs 2x more for each tier
            STORAGE_PITS: {
                FOOD_PIT: { food: 2000, wood: 10000, stone: 10, cap: 10000, resource: 'food', desc: 'ğŸ•³ï¸ Food Pit', icon: 'ğŸ–' },
                WOOD_PIT: { food: 4000, wood: 20000, stone: 20, cap: 10000, resource: 'wood', desc: 'ğŸ•³ï¸ Wood Pit', icon: 'ğŸªµ' },
                STONE_PIT: { food: 8000, wood: 40000, stone: 40, cap: 10000, resource: 'stone', desc: 'ğŸ•³ï¸ Stone Pit', icon: 'ğŸª¨' },
                METAL_PIT: { food: 16000, wood: 80000, stone: 80, cap: 10000, resource: 'metal', desc: 'ğŸ•³ï¸ Metal Pit', icon: 'âš™ï¸' }
            },
            
            WATER_PROXIMITY: { MAX_DISTANCE: 5, MIN_EFFICIENCY: 0.3 },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GEOLOGICAL ELEVATION & WATER CYCLE SYSTEM
            // Based on 3 million years of Earth's glacial cycles
            // Water rises/falls slowly over centuries, not ticks
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ELEVATION_SYSTEM: {
                ENABLED: true,
                
                // Elevation levels (0-10 scale, 0 = deepest ocean, 10 = highest peak)
                SEA_LEVEL_BASE: 3,              // Starting sea level
                SEA_LEVEL_MIN: 1,               // Ice age minimum (glaciers lock water)
                SEA_LEVEL_MAX: 6,               // Interglacial maximum (ice melts)
                
                // How often water level can change (in game years)
                UPDATE_INTERVAL_YEARS: 100,     // Check every 100 years
                CHANGE_CHANCE: 0.15,            // 15% chance to change each check
                
                // Coastal warning thresholds
                FLOOD_WARNING_MARGIN: 1,        // Warn if elevation <= sea_level + 1
                HIGH_GROUND_BONUS: 2,           // Tiles 2+ above sea level are safe
                
                // Geological periods (based on real paleoclimate data)
                // Each period lasts ~100k years in real time, we compress it
                GEOLOGICAL_PERIODS: [
                    { name: "Warm Interglacial", seaLevel: 5, duration: 20 },   // 20 centuries warm
                    { name: "Cooling Transition", seaLevel: 4, duration: 10 },
                    { name: "Glacial Advance", seaLevel: 3, duration: 30 },     // 30 centuries ice age
                    { name: "Deep Ice Age", seaLevel: 2, duration: 20 },        // Glaciers at maximum
                    { name: "Glacial Retreat", seaLevel: 3, duration: 10 },
                    { name: "Warming Transition", seaLevel: 4, duration: 10 }
                ]
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MAP EXPANSION SYSTEM
            // Tribes can explore outward, but world has finite "flat earth" edge
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            MAP_EXPANSION: {
                ENABLED: true,
                INITIAL_SIZE: 250,              // Starting map size (current)
                MAX_SIZE: 500,                  // Maximum expandable size
                EXPANSION_CHUNKS: 50,           // Tiles added per expansion
                EDGE_BUFFER: 10,                // Distance from edge to trigger warning
                
                // Flat Earth boundary - the world ends here!
                BOUNDARY_MESSAGE: "Your scouts report the land ends in a great void. The elders speak of the World's Edge - beyond lies only darkness and falling stars.",
                EXPANSION_COST: { food: 10000, wood: 5000 } // Cost to scout new territory
            }
        };
        // Historical ages for civilization advancement
        const AGES = [{n:"PALEOLITHIC",p:0,m:1},{n:"NEOLITHIC",p:500,m:1.5},{n:"BRONZE",p:2000,m:2},{n:"IRON",p:5000,m:3}];

        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ MODULE 2: PROGRESSION - Unlock & Advancement System               â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Tracks game progress and manages feature unlocking
        // Stage 0: Exploring â†’ Stage 1: Settlement â†’ Stage 2: Industrial
        
        const PROGRESSION = {
            stage: 0, // 0=exploring, 1=settlement, 2=industrial_unlocked
            nomadsFound: 0,
            berriesNeeded: 5,
            settlementBonus: 0, // Gold comes much later - start with 0
            settlementYear: 0,
            unlockedLevels: [1], // Level 1 is first buildable level (Level 0 = WANDER epoch only)
            unlockedIndustrialLevels: [1], // Industrial levels unlocked (Level 1 always available after industrial unlock)
            unlockedCommercialLevels: [1], // Commercial levels unlocked (Level 1 always available)
            
            reset() {
                this.stage = 0;
                this.nomadsFound = 0;
                this.settlementYear = 0;
                this.unlockedLevels = [1]; // Level 1 is first buildable level
                this.unlockedIndustrialLevels = [1]; // Reset industrial levels
                this.unlockedCommercialLevels = [1]; // Reset commercial levels
            },
            
            // Update unlocked building levels based on population AND building requirements
            updateUnlockedLevels(game) {
                let pop = game.pop || 0;
                let newUnlocks = [1]; // Level 1 always available
                
                // Check each residential building's unlock requirements
                let resBuildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let building of resBuildings) {
                    if(building.level === 1) continue; // Level 1 always unlocked
                    
                    let req = building.unlockReq;
                    if(!req) continue;
                    
                    // Use the universal unlock checker
                    let { met, reasons } = this.checkUnlockRequirements(req, game);
                    
                    if(met && !newUnlocks.includes(building.level)) {
                        newUnlocks.push(building.level);
                    }
                }
                
                // Check for new residential unlocks and notify
                for(let lvl of newUnlocks) {
                    if(!this.unlockedLevels.includes(lvl)) {
                        let building = CFG.BUILDING_DB['RES_' + lvl];
                        if(building) {
                            Controller.toast(`ğŸ‰ UNLOCKED: ${building.name} (Level ${lvl})!`);
                        }
                    }
                }
                
                this.unlockedLevels = newUnlocks;
                
                // Update industrial levels - requires same residential level unlocked
                // Industrial L2 requires Residential L2 unlocked, etc.
                let newIndUnlocks = [1]; // L1 always available
                if(this.unlockedLevels.includes(2)) newIndUnlocks.push(2);
                if(this.unlockedLevels.includes(3)) newIndUnlocks.push(3);
                if(this.unlockedLevels.includes(4)) newIndUnlocks.push(4);
                
                // Notify new industrial unlocks
                for(let lvl of newIndUnlocks) {
                    if(!this.unlockedIndustrialLevels.includes(lvl) && CFG.INDUSTRIAL_LEVELS[lvl]) {
                        Controller.toast(`ğŸ­ INDUSTRIAL UNLOCKED: ${CFG.INDUSTRIAL_LEVELS[lvl].name}!`);
                    }
                }
                
                this.unlockedIndustrialLevels = newIndUnlocks;
                
                // Update commercial levels - requires same residential level unlocked
                // Commercial L2 requires Residential L2 unlocked, etc.
                let newComUnlocks = [1]; // L1 always available
                if(this.unlockedLevels.includes(2)) newComUnlocks.push(2);
                if(this.unlockedLevels.includes(3)) newComUnlocks.push(3);
                if(this.unlockedLevels.includes(4)) newComUnlocks.push(4);
                
                // Notify new commercial unlocks
                for(let lvl of newComUnlocks) {
                    if(!this.unlockedCommercialLevels.includes(lvl)) {
                        let comBuilding = CFG.BUILDING_DB['COM_' + lvl];
                        if(comBuilding) {
                            Controller.toast(`ğŸª COMMERCIAL UNLOCKED: ${comBuilding.name}!`);
                        }
                    }
                }
                
                this.unlockedCommercialLevels = newComUnlocks;
            },
            
            /**
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             * UNIVERSAL UNLOCK REQUIREMENT CHECKER
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             * Checks ANY combination of unlock requirements dynamically.
             * 
             * Supported requirement types:
             *   - pop: number           â†’ Minimum population
             *   - resources: {wood: n}  â†’ Must have X of resource in stock
             *   - buildings: {type, level?, count, category?} â†’ Must have X buildings
             *   - tech: string[]        â†’ Must have researched technologies (future)
             *   - year: number          â†’ Must reach year X
             *   - level: number         â†’ Player must be at civilization level X
             *   - custom: function      â†’ Custom check function (advanced)
             * 
             * Example unlockReq:
             * {
             *     pop: 5000,
             *     resources: { wood: 500, stone: 200 },
             *     buildings: { type: 'IND', level: 2, count: 3 },
             *     year: 50
             * }
             * 
             * Returns: { met: boolean, reasons: string[] }
             *   - met: true if ALL requirements are satisfied
             *   - reasons: array of unmet requirement descriptions (for UI)
             * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
             */
            checkUnlockRequirements(req, game) {
                if(!req) return { met: true, reasons: [] };
                
                let unmetReasons = [];
                
                // --- POPULATION ---
                if(req.pop !== undefined) {
                    let currentPop = game.pop || 0;
                    if(currentPop < req.pop) {
                        unmetReasons.push(`Need ${req.pop.toLocaleString()} population (have ${currentPop.toLocaleString()})`);
                    }
                }
                
                // --- RESOURCES ---
                if(req.resources) {
                    for(let [resource, amount] of Object.entries(req.resources)) {
                        let current = game.res?.[resource] || 0;
                        if(current < amount) {
                            unmetReasons.push(`Need ${amount.toLocaleString()} ${resource} (have ${current.toLocaleString()})`);
                        }
                    }
                }
                
                // --- BUILDINGS ---
                if(req.buildings) {
                    // Build a count map of all buildings
                    let buildingCounts = this._countBuildings(game);
                    
                    // Support single building requirement or array of requirements
                    let buildingReqs = Array.isArray(req.buildings) ? req.buildings : [req.buildings];
                    
                    for(let bReq of buildingReqs) {
                        let count = 0;
                        
                        if(bReq.id) {
                            // Specific building ID (e.g., 'WELL', 'GRANARY')
                            count = buildingCounts.byId[bReq.id] || 0;
                        } else if(bReq.type && bReq.level !== undefined) {
                            // Type + Level combo (e.g., IND level 2)
                            let key = bReq.type + '_' + bReq.level;
                            count = buildingCounts.byTypeLevel[key] || 0;
                        } else if(bReq.type) {
                            // Any building of type (e.g., any IND)
                            count = buildingCounts.byType[bReq.type] || 0;
                        } else if(bReq.category) {
                            // Any building in category
                            count = buildingCounts.byCategory[bReq.category] || 0;
                        }
                        
                        let required = bReq.count || 1;
                        if(count < required) {
                            let desc = bReq.id || (bReq.type + (bReq.level ? ' L' + bReq.level : ''));
                            unmetReasons.push(`Need ${required}x ${desc} buildings (have ${count})`);
                        }
                    }
                }
                
                // --- YEAR ---
                if(req.year !== undefined) {
                    let currentYear = game.year || 0;
                    if(currentYear < req.year) {
                        unmetReasons.push(`Need to reach Year ${req.year} (current: ${currentYear})`);
                    }
                }
                
                // --- CIVILIZATION LEVEL ---
                if(req.level !== undefined) {
                    let currentLevel = game.civLevel || game.level || 1;
                    if(currentLevel < req.level) {
                        unmetReasons.push(`Need Civilization Level ${req.level} (current: ${currentLevel})`);
                    }
                }
                
                // --- TECHNOLOGIES (Future-proofing) ---
                if(req.tech) {
                    let techs = Array.isArray(req.tech) ? req.tech : [req.tech];
                    let researchedTechs = game.technologies || game.techs || [];
                    for(let tech of techs) {
                        if(!researchedTechs.includes(tech)) {
                            unmetReasons.push(`Need to research: ${tech}`);
                        }
                    }
                }
                
                // --- ACHIEVEMENTS (Future-proofing) ---
                if(req.achievements) {
                    let achievements = Array.isArray(req.achievements) ? req.achievements : [req.achievements];
                    let earnedAchievements = game.achievements || [];
                    for(let ach of achievements) {
                        if(!earnedAchievements.includes(ach)) {
                            unmetReasons.push(`Need achievement: ${ach}`);
                        }
                    }
                }
                
                // --- CUSTOM FUNCTION (Advanced) ---
                if(req.custom && typeof req.custom === 'function') {
                    try {
                        let customResult = req.custom(game);
                        if(customResult !== true) {
                            unmetReasons.push(customResult || 'Custom requirement not met');
                        }
                    } catch(e) {
                        console.error('Custom unlock check failed:', e);
                    }
                }
                
                return {
                    met: unmetReasons.length === 0,
                    reasons: unmetReasons
                };
            },
            
            /**
             * Helper: Count all buildings by various groupings
             * Returns { byId, byType, byTypeLevel, byCategory }
             */
            _countBuildings(game) {
                let counts = {
                    byId: {},         // e.g., { 'WELL': 3, 'GRANARY': 1 }
                    byType: {},       // e.g., { 'IND': 5, 'COM': 3 }
                    byTypeLevel: {},  // e.g., { 'IND_1': 2, 'IND_2': 3 }
                    byCategory: {}    // e.g., { 'RESIDENTIAL': 10, 'INDUSTRIAL': 5 }
                };
                
                let buildings = game.blds || [];
                
                for(let b of buildings) {
                    // By type + level
                    let typeKey = b.t + '_' + (b.lvl || 1);
                    counts.byTypeLevel[typeKey] = (counts.byTypeLevel[typeKey] || 0) + 1;
                    
                    // By type only
                    counts.byType[b.t] = (counts.byType[b.t] || 0) + 1;
                    
                    // By specific building ID (if stored)
                    if(b.id) {
                        counts.byId[b.id] = (counts.byId[b.id] || 0) + 1;
                    }
                    
                    // By category (lookup from BUILDING_DB)
                    let fullId = b.t + '_' + (b.lvl || 1);
                    let bDef = CFG.BUILDING_DB[fullId];
                    if(bDef && bDef.category) {
                        counts.byCategory[bDef.category] = (counts.byCategory[bDef.category] || 0) + 1;
                    }
                }
                
                return counts;
            },
            
            /**
             * Get human-readable unlock requirements for UI display
             */
            getUnlockRequirementsText(req, game) {
                if(!req) return 'Always available';
                
                let { met, reasons } = this.checkUnlockRequirements(req, game);
                
                if(met) return 'âœ… All requirements met';
                
                return reasons.map(r => 'âŒ ' + r).join('\n');
            },

            /**
             * Industrial tier unlock guidance
             * Returns { met, text } with a concise explanation
             */
            getIndustrialUnlockInfo(level, game) {
                // Prefer BUILDING_DB.popUnlock if available
                const b = CFG.BUILDING_DB['IND_' + level];
                const reqPop = (b && typeof b.popUnlock === 'number') ? b.popUnlock : (level === 1 ? 0 : (level === 2 ? 100 : level === 3 ? 500 : level === 4 ? 2000 : 0));
                const havePop = (game && game.pop) ? game.pop : 0;
                const met = havePop >= reqPop;
                if(reqPop === 0) return { met: true, text: 'âœ… Available' };
                const text = met
                    ? 'âœ… Requirement met'
                    : `ğŸ”’ Need ${reqPop.toLocaleString()} population (have ${havePop.toLocaleString()})`;
                return { met, text };
            },
            
            checkUnlock(game) {
                // Update building level unlocks based on population
                this.updateUnlockedLevels(game);
                
                if(this.stage === 0 && game.food >= this.berriesNeeded && this.nomadsFound >= 1) {
                    this.stage = 1;
                    game.res = this.settlementBonus;
                    this.settlementYear = game.year;
                    return 'settlement';
                }
                if(this.stage === 1) {
                    // Unlock hunting at stage 1 (no requirements)
                    this.stage = 2;
                    return 'industrial';
                }
                return false;
            }
        };

        // --- 2. NOISE ---
        const Noise = {
            seed: 1,
            init(s) { this.seed = s; },
            hash(x,y) { let h = Math.sin(x*12.98+y*78.23+this.seed)*43758.54; return h-Math.floor(h); },
            mix(a,b,t) { return a*(1-t)+b*t; },
            val(x,y) {
                let i=Math.floor(x), j=Math.floor(y), f={x:x-i, y:y-j};
                let u={x:f.x*f.x*(3-2*f.x), y:f.y*f.y*(3-2*f.y)};
                let a=this.hash(i,j), b=this.hash(i+1,j), c=this.hash(i,j+1), d=this.hash(i+1,j+1);
                return this.mix(this.mix(a,b,u.x), this.mix(c,d,u.x), u.y);
            },
            fbm(x,y) {
                let t=0, a=0.5;
                for(let i=0; i<5; i++) { t+=this.val(x,y)*a; x*=2; y*=2; a*=0.5; }
                return t;
            }
        };

        // --- 3. RENDERER ---
        const Renderer = {
            cvs: null, ctx: null, w: 0, h: 0, time: 0, particles: [], effects: [],
            
            // Helper function to draw rounded rectangles
            roundRect(c, x, y, w, h, r) {
                if(r > w/2) r = w/2;
                if(r > h/2) r = h/2;
                c.beginPath();
                c.moveTo(x + r, y);
                c.lineTo(x + w - r, y);
                c.quadraticCurveTo(x + w, y, x + w, y + r);
                c.lineTo(x + w, y + h - r);
                c.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                c.lineTo(x + r, y + h);
                c.quadraticCurveTo(x, y + h, x, y + h - r);
                c.lineTo(x, y + r);
                c.quadraticCurveTo(x, y, x + r, y);
                c.closePath();
            },
            
            // Helper to fill rounded rectangle
            fillRoundRect(c, x, y, w, h, r) {
                this.roundRect(c, x, y, w, h, r);
                c.fill();
            },
            
            // Helper to stroke rounded rectangle
            strokeRoundRect(c, x, y, w, h, r) {
                this.roundRect(c, x, y, w, h, r);
                c.stroke();
            },
            
            init() {
                this.cvs = document.getElementById('cvs');
                this.ctx = this.cvs.getContext('2d', { alpha: false });
                this.resize(); window.onresize = () => this.resize();
            },
            addWoodChips(tileX, tileY) {
                // Wood chip burst effect
                const start = performance.now();
                const duration = 600;
                const chips = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2) * (i / 8) + Math.random()*0.3;
                    const speed = 0.5 + Math.random()*0.7;
                    chips.push({ angle, speed });
                }
                this.effects.push({ type: 'woodchips', x: tileX, y: tileY, start, duration, chips });
            },
            addDust(tileX, tileY) {
                // 3-second cartoonish dust cloud effect
                const start = performance.now();
                const duration = 9000;
                const puffs = [];
                // Precompute puff offsets for a consistent look
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2) * (i / 6);
                    const radius = 0.18 + (i % 2) * 0.06; // tile-relative radius
                    puffs.push({ angle, radius });
                }
                this.effects.push({ type: 'dust', x: tileX, y: tileY, start, duration, puffs });
            },
            resize() {
                let vp = document.getElementById('viewport');
                let dpr = window.devicePixelRatio || 1;
                this.w = vp.clientWidth; this.h = vp.clientHeight;
                this.cvs.width = this.w * dpr; this.cvs.height = this.h * dpr;
                this.ctx.scale(dpr, dpr); this.ctx.imageSmoothingEnabled = false;
            },
            draw(cam) {
                let c = this.ctx, T = CFG.TILE; this.time += 0.05;
                c.save(); c.setTransform(1,0,0,1,0,0); c.fillStyle="#000"; c.fillRect(0,0,this.cvs.width,this.cvs.height); c.restore();
                
                if(!Game || !Game.tiles) {
                    c.restore();
                    return;
                }
                
                c.save(); c.translate(this.w/2, this.h/2); c.scale(cam.z, cam.z); c.translate(-cam.x, -cam.y);

                let sc = Math.max(0, Math.floor((cam.x - (this.w/cam.z)/2)/T));
                let ec = Math.min(CFG.W, Math.ceil((cam.x + (this.w/cam.z)/2)/T));
                let sr = Math.max(0, Math.floor((cam.y - (this.h/cam.z)/2)/T));
                let er = Math.min(CFG.H, Math.ceil((cam.y + (this.h/cam.z)/2)/T));

                // Tile corner radius for softer look
                const tileRadius = 6;
                const innerPad = 1; // Small padding inside tile for depth effect
                
                for(let x=sc; x<ec; x++) for(let y=sr; y<er; y++) {
                    let t = Game.tiles[x][y];
                    
                    // Fog of war - only show explored tiles with rounded corners
                    if (!t.explored) {
                        c.fillStyle = "#0a0a12";
                        this.fillRoundRect(c, x*T + innerPad, y*T + innerPad, T - innerPad*2, T - innerPad*2, tileRadius);
                        // Add subtle fog texture
                        c.fillStyle = 'rgba(20,20,40,0.5)';
                        this.fillRoundRect(c, x*T + 2, y*T + 2, T - 4, T - 4, tileRadius - 1);
                        continue;
                    }
                    
                    // Draw base tile with slight rounded corners
                    c.fillStyle = CFG.COLORS[t.type]; 
                    if(t.type === 'FOREST' && t.tree) c.fillStyle = CFG.COLORS.EARTH;
                    this.fillRoundRect(c, x*T + innerPad, y*T + innerPad, T - innerPad*2, T - innerPad*2, tileRadius);
                    
                    // Add subtle inner shadow for depth
                    c.strokeStyle = "rgba(0, 0, 0, 0.08)";
                    c.lineWidth = 2;
                    this.strokeRoundRect(c, x*T + innerPad + 1, y*T + innerPad + 1, T - innerPad*2 - 2, T - innerPad*2 - 2, tileRadius - 1);
                    
                    // Add Mario-style highlights and details
                    if(t.type === 'GRASS') {
                        // Yoshi's Island soft pastel green gradient
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#98FF98');
                        gradient.addColorStop(0.5, '#78E878');
                        gradient.addColorStop(1, '#58C858');
                        c.fillStyle = gradient;
                        this.fillRoundRect(c, x*T + innerPad, y*T + innerPad, T - innerPad*2, T - innerPad*2, tileRadius);
                        
                        // Soft white highlight on top edge (rounded)
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        c.beginPath();
                        c.moveTo(x*T + tileRadius, y*T + innerPad);
                        c.lineTo(x*T + T - tileRadius, y*T + innerPad);
                        c.quadraticCurveTo(x*T + T - innerPad, y*T + innerPad, x*T + T - innerPad, y*T + tileRadius);
                        c.lineTo(x*T + T - innerPad, y*T + 6);
                        c.lineTo(x*T + innerPad, y*T + 6);
                        c.lineTo(x*T + innerPad, y*T + tileRadius);
                        c.quadraticCurveTo(x*T + innerPad, y*T + innerPad, x*T + tileRadius, y*T + innerPad);
                        c.closePath();
                        c.fill();
                        
                        // Soft white highlight on top edge
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        c.fillRect(x*T, y*T, T, 4);
                        
                        // Subtle shadow at bottom
                        c.fillStyle = 'rgba(0,80,0,0.15)';
                        c.fillRect(x*T, y*T + T - 4, T, 4);
                        
                        // Cute grass tufts
                        if((x + y) % 3 === 0) {
                            c.fillStyle = '#B0FFB0';
                            c.beginPath();
                            c.moveTo(x*T + 10, y*T + T - 8);
                            c.lineTo(x*T + 12, y*T + T - 16);
                            c.lineTo(x*T + 14, y*T + T - 8);
                            c.fill();
                            c.beginPath();
                            c.moveTo(x*T + 28, y*T + T - 10);
                            c.lineTo(x*T + 30, y*T + T - 18);
                            c.lineTo(x*T + 32, y*T + T - 10);
                            c.fill();
                        }
                        
                        // Little flower occasionally
                        if((x * 3 + y * 7) % 11 === 0) {
                            c.fillStyle = '#FFD0D0';
                            c.beginPath();
                            c.arc(x*T + 20, y*T + 24, 4, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#FFFF80';
                            c.beginPath();
                            c.arc(x*T + 20, y*T + 24, 2, 0, 6.28);
                            c.fill();
                        }
                    } else if(t.type === 'SAND') {
                        // Warm golden sand like Yoshi's Island beaches
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#FFFFC8');
                        gradient.addColorStop(0.5, '#FFE8A0');
                        gradient.addColorStop(1, '#F8D880');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Sparkly cream highlight
                        c.fillStyle = 'rgba(255,255,240,0.8)';
                        c.fillRect(x*T, y*T, T, 3);
                        
                        // Beach decorations based on tile position (deterministic)
                        let beachSeed = (x * 7 + y * 11) % 23;
                        
                        // Seashells (various types)
                        if(beachSeed < 5) {
                            // Spiral shell
                            c.fillStyle = '#FFD0B0';
                            c.beginPath();
                            c.ellipse(x*T + 16, y*T + 20, 5, 4, 0.3, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#FFF0E0';
                            c.beginPath();
                            c.arc(x*T + 15, y*T + 19, 2, 0, 6.28);
                            c.fill();
                            // Spiral pattern
                            c.strokeStyle = '#E8C0A0';
                            c.lineWidth = 1;
                            c.beginPath();
                            c.arc(x*T + 16, y*T + 20, 3, 0, Math.PI);
                            c.stroke();
                        } else if(beachSeed < 8) {
                            // Clam shell
                            c.fillStyle = '#E8D8C8';
                            c.beginPath();
                            c.ellipse(x*T + 24, y*T + 16, 4, 3, 0, 0, Math.PI);
                            c.fill();
                            c.strokeStyle = '#C8B8A8';
                            c.lineWidth = 0.5;
                            for(let i = 0; i < 5; i++) {
                                c.beginPath();
                                c.moveTo(x*T + 20 + i*2, y*T + 16);
                                c.lineTo(x*T + 24, y*T + 13);
                                c.stroke();
                            }
                        } else if(beachSeed < 11) {
                            // Starfish (cute!)
                            c.fillStyle = '#FF9070';
                            let sx = x*T + 10, sy = y*T + 24;
                            c.beginPath();
                            for(let i = 0; i < 5; i++) {
                                let angle = (i * 72 - 90) * Math.PI / 180;
                                let px = sx + Math.cos(angle) * 5;
                                let py = sy + Math.sin(angle) * 5;
                                if(i === 0) c.moveTo(px, py);
                                else c.lineTo(px, py);
                                let innerAngle = ((i * 72) + 36 - 90) * Math.PI / 180;
                                let ipx = sx + Math.cos(innerAngle) * 2;
                                let ipy = sy + Math.sin(innerAngle) * 2;
                                c.lineTo(ipx, ipy);
                            }
                            c.closePath();
                            c.fill();
                            // Eye dots
                            c.fillStyle = '#FFB090';
                            c.beginPath();
                            c.arc(sx, sy, 1.5, 0, 6.28);
                            c.fill();
                        } else if(beachSeed < 14) {
                            // Seaweed tuft
                            c.fillStyle = '#5A8A5A';
                            for(let i = 0; i < 3; i++) {
                                c.beginPath();
                                let wx = x*T + 26 + i*3;
                                c.moveTo(wx, y*T + T - 2);
                                c.quadraticCurveTo(wx + 2, y*T + T - 10, wx - 1, y*T + T - 16 - i*2);
                                c.quadraticCurveTo(wx + 1, y*T + T - 10, wx, y*T + T - 2);
                                c.fill();
                            }
                        } else if(beachSeed < 16) {
                            // Driftwood
                            c.fillStyle = '#A89078';
                            c.save();
                            c.translate(x*T + 18, y*T + 22);
                            c.rotate(0.3);
                            c.beginPath();
                            c.roundRect(-8, -2, 16, 4, 2);
                            c.fill();
                            c.strokeStyle = '#8A7060';
                            c.lineWidth = 0.5;
                            c.stroke();
                            c.restore();
                        } else if(beachSeed < 18) {
                            // Pebbles cluster
                            c.fillStyle = '#B0A090';
                            c.beginPath();
                            c.arc(x*T + 8, y*T + 28, 3, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#C0B0A0';
                            c.beginPath();
                            c.arc(x*T + 12, y*T + 26, 2, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#A09080';
                            c.beginPath();
                            c.arc(x*T + 10, y*T + 30, 2.5, 0, 6.28);
                            c.fill();
                        }
                        
                        // Sand grain sparkles (always show some)
                        c.fillStyle = 'rgba(255,255,200,0.5)';
                        c.fillRect(x*T + 8, y*T + 12, 2, 2);
                        c.fillRect(x*T + 28, y*T + 26, 2, 2);
                        if((x + y) % 3 === 0) {
                            c.fillRect(x*T + 18, y*T + 8, 1, 1);
                            c.fillRect(x*T + 5, y*T + 22, 1, 1);
                        }
                    } else if(t.type === 'WATER' || t.type === 'RIVER' || t.type === 'DEEP') {
                        // Yoshi's Island crystal clear water
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        if(t.type === 'DEEP') {
                            gradient.addColorStop(0, '#78A8FF');
                            gradient.addColorStop(1, '#5890E8');
                        } else if(t.type === 'WATER') {
                            gradient.addColorStop(0, '#B0E0FF');
                            gradient.addColorStop(1, '#78C8FF');
                        } else {
                            gradient.addColorStop(0, '#C8F0FF');
                            gradient.addColorStop(1, '#A0DCFF');
                        }
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Bright white wave highlight on top
                        c.fillStyle = 'rgba(255,255,255,0.7)';
                        c.fillRect(x*T, y*T, T, 4);
                        
                        // Animated sparkles
                        c.fillStyle = 'rgba(255,255,255,0.8)';
                        let sparkle1 = Math.sin(this.time * 1.5 + x * 0.5 + y) * 3;
                        let sparkle2 = Math.cos(this.time * 1.2 + x + y * 0.5) * 3;
                        c.beginPath();
                        c.arc(x*T + 12 + sparkle1, y*T + 14, 3, 0, 6.28);
                        c.arc(x*T + T - 14 + sparkle2, y*T + T - 16, 2.5, 0, 6.28);
                        c.fill();
                        
                        // Cute wave lines
                        c.strokeStyle = 'rgba(255,255,255,0.4)';
                        c.lineWidth = 2;
                        c.beginPath();
                        let wave = Math.sin(this.time + x * 0.3) * 2;
                        c.moveTo(x*T + 6, y*T + T/2 + wave);
                        c.quadraticCurveTo(x*T + T/2, y*T + T/2 - 3 + wave, x*T + T - 6, y*T + T/2 + wave);
                        c.stroke();
                        
                        // Bright white highlights on top
                        c.fillStyle = 'rgba(255,255,255,0.6)';
                        c.fillRect(x*T, y*T, T, 3);
                        
                        // Bubbly sparkles
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        let sparkle = Math.sin(this.time + x + y) * 2;
                        c.beginPath();
                        c.arc(x*T + 8 + sparkle, y*T + 10, 3, 0, 6.28);
                        c.arc(x*T + T-10 + sparkle, y*T + T-12, 2, 0, 6.28);
                        c.fill();
                        
                        // Reflection shimmer
                        c.fillStyle = 'rgba(200,240,255,0.4)';
                        c.fillRect(x*T + 4, y*T + T/2, T-8, 2);
                    } else if(t.type === 'STONE') {
                        // Yoshi's Island soft purple-gray stone
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#C8C8D8');
                        gradient.addColorStop(0.5, '#B0B0C0');
                        gradient.addColorStop(1, '#9898A8');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Bright highlight on top-left corner
                        c.fillStyle = 'rgba(255,255,255,0.6)';
                        c.fillRect(x*T, y*T, T, 5);
                        c.fillRect(x*T, y*T, 5, T);
                        
                        // Cute rounded rock shapes
                        c.fillStyle = 'rgba(80,80,100,0.2)';
                        c.beginPath();
                        c.arc(x*T + 14, y*T + 14, 8, 0, 6.28);
                        c.arc(x*T + 32, y*T + 24, 6, 0, 6.28);
                        c.arc(x*T + 24, y*T + 36, 5, 0, 6.28);
                        c.fill();
                        
                        // White sparkle spots
                        c.fillStyle = 'rgba(255,255,255,0.5)';
                        c.beginPath();
                        c.arc(x*T + 10, y*T + 10, 3, 0, 6.28);
                        c.arc(x*T + 28, y*T + 20, 2, 0, 6.28);
                        c.fill();
                    } else if(t.type === 'FOREST') {
                        // Yoshi's Island lush forest floor
                        let gradient = c.createLinearGradient(x*T, y*T, x*T, y*T + T);
                        gradient.addColorStop(0, '#60C860');
                        gradient.addColorStop(0.5, '#48B848');
                        gradient.addColorStop(1, '#38A038');
                        c.fillStyle = gradient;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Dappled sunlight highlights
                        c.fillStyle = 'rgba(180,255,180,0.4)';
                        if((x + y) % 2 === 0) {
                            c.beginPath();
                            c.ellipse(x*T + 12, y*T + 16, 6, 4, 0.3, 0, 6.28);
                            c.fill();
                        }
                        if((x * 3 + y) % 4 === 0) {
                            c.beginPath();
                            c.ellipse(x*T + 30, y*T + 28, 5, 3, -0.2, 0, 6.28);
                            c.fill();
                        }
                        
                        // Shadow at bottom
                        c.fillStyle = 'rgba(0,60,0,0.25)';
                        c.fillRect(x*T, y*T + T - 6, T, 6);
                        
                        // Occasional mushroom
                        if((x * 7 + y * 11) % 17 === 0) {
                            // Mushroom cap
                            c.fillStyle = '#FF8080';
                            c.beginPath();
                            c.arc(x*T + 24, y*T + 32, 5, Math.PI, 0);
                            c.fill();
                            // White spots on cap
                            c.fillStyle = '#FFFFFF';
                            c.beginPath();
                            c.arc(x*T + 22, y*T + 30, 1.5, 0, 6.28);
                            c.arc(x*T + 26, y*T + 31, 1, 0, 6.28);
                            c.fill();
                            // Stem
                            c.fillStyle = '#FFF8E8';
                            c.fillRect(x*T + 22, y*T + 32, 4, 6);
                        }
                    }
                    
                    // Draw berry entity - Cave painting style berry clusters
                    if(t.entity && t.entity.type === 'BERRY') {
                        let bx = x*T+T/2;
                        let by = y*T+T/2;
                        
                        // Yoshi's Island style berry bush
                        // Draw cute bush base first
                        c.fillStyle = '#60C060';
                        c.beginPath();
                        c.arc(bx - 8, by + 8, 8, 0, 6.28);
                        c.arc(bx + 8, by + 8, 8, 0, 6.28);
                        c.arc(bx, by + 4, 10, 0, 6.28);
                        c.fill();
                        
                        // Bush highlight
                        c.fillStyle = '#90E890';
                        c.beginPath();
                        c.arc(bx - 6, by + 4, 4, 0, 6.28);
                        c.arc(bx + 4, by + 2, 3, 0, 6.28);
                        c.fill();
                        
                        // Draw 3-5 berries in cluster
                        let berryCount = 3 + Math.floor((x + y) % 3);
                        let positions = [
                            {x: 0, y: -8}, {x: -7, y: -2}, {x: 7, y: -2},
                            {x: -4, y: 4}, {x: 4, y: 4}
                        ];
                        
                        for(let i = 0; i < berryCount; i++) {
                            let pos = positions[i];
                            let bpx = bx + pos.x, bpy = by + pos.y;
                            
                            // Berry with cute gradient
                            let gradient = c.createRadialGradient(bpx-2, bpy-2, 1, bpx, bpy, 7);
                            if(t.entity.is_poisonous) {
                                gradient.addColorStop(0, '#E0B0FF');
                                gradient.addColorStop(0.5, '#C878F0');
                                gradient.addColorStop(1, '#A050D0');
                            } else {
                                gradient.addColorStop(0, '#FF90B0');
                                gradient.addColorStop(0.5, '#FF6090');
                                gradient.addColorStop(1, '#E04070');
                            }
                            c.fillStyle = gradient;
                            c.beginPath();
                            c.arc(bpx, bpy, 6, 0, 6.28);
                            c.fill();
                            
                            // Black outline for cartoon look
                            c.strokeStyle = 'rgba(0,0,0,0.3)';
                            c.lineWidth = 1.5;
                            c.stroke();
                            
                            // Big cute shine spot
                            c.fillStyle = 'rgba(255,255,255,0.8)';
                            c.beginPath();
                            c.arc(bpx-2, bpy-2, 2.5, 0, 6.28);
                            c.fill();
                        }
                    }
                    
                    // Draw nomad entity - Cave painting style stick figure with spear
                    if(t.entity && t.entity.type === 'NOMAD') {
                        let nx = x*T + T/2, ny = y*T + T/2;
                        let scale = T/64;
                        
                        // All nomads look the same (don't reveal hostility)
                        c.strokeStyle = "#8B5A2B"; // Darker brown for better contrast
                        c.lineWidth = 2;
                        c.lineCap = "round";
                        c.lineJoin = "round";
                        
                        // Head (circle)
                        c.beginPath();
                        c.arc(nx, ny - 18*scale, 5*scale, 0, 6.28);
                        c.stroke();
                        
                        // Body (vertical line)
                        c.beginPath();
                        c.moveTo(nx, ny - 13*scale);
                        c.lineTo(nx, ny + 5*scale);
                        c.stroke();
                        
                        // Arms (one raised holding spear)
                        c.beginPath();
                        c.moveTo(nx, ny - 8*scale);
                        c.lineTo(nx - 8*scale, ny - 15*scale); // Left arm raised
                        c.moveTo(nx, ny - 8*scale);
                        c.lineTo(nx + 8*scale, ny - 2*scale); // Right arm down
                        c.stroke();
                        
                        // Legs (walking stance)
                        c.beginPath();
                        c.moveTo(nx, ny + 5*scale);
                        c.lineTo(nx - 6*scale, ny + 15*scale); // Left leg forward
                        c.moveTo(nx, ny + 5*scale);
                        c.lineTo(nx + 6*scale, ny + 15*scale); // Right leg back
                        c.stroke();
                        
                        // Spear (in raised hand)
                        c.strokeStyle = "#8B7355";
                        c.lineWidth = 1.5;
                        c.beginPath();
                        c.moveTo(nx - 8*scale, ny - 15*scale);
                        c.lineTo(nx - 10*scale, ny - 28*scale); // Spear shaft
                        c.stroke();
                        
                        // Spear tip
                        c.fillStyle = "#555";
                        c.beginPath();
                        c.moveTo(nx - 10*scale, ny - 28*scale);
                        c.lineTo(nx - 12*scale, ny - 24*scale);
                        c.lineTo(nx - 8*scale, ny - 24*scale);
                        c.fill();
                    }
                    
                    if(t.road) this.drawRoad(c, x, y, T);
                    else if(t.stoneDeposit) this.drawStoneDeposit(c, x*T, y*T, t.stoneDeposit);
                    else if(t.tree && !t.bld) this.drawTree(c, x*T, y*T, t.type);
                    else if(t.type === 'WATER' || t.type === 'RIVER') this.drawWaterAnim(c, x*T, y*T);
                    else if(t.type === 'SAND') this.drawGrain(c, x*T, y*T);

                    if (Game.vm === 'POL' && t.pol > 0) { c.fillStyle = `rgba(100,0,100,${Math.min(t.pol/100, 0.6)})`; c.fillRect(x*T, y*T, T, T); }
                    
                    // DESIRABILITY HEATMAP VIEW
                    if (Game.vm === 'DESIRABILITY') {
                        let desirability = Game.calculateDesirability(x, y, 1);
                        // Color gradient: Red (0) -> Yellow (0.5) -> Green (1.0) -> Blue (1.5+)
                        let r, g, b, alpha = 0.5;
                        if(desirability < 0.3) {
                            r = 255; g = Math.floor(desirability * 850); b = 0;
                        } else if(desirability < 0.7) {
                            r = Math.floor(255 - (desirability - 0.3) * 600); g = 255; b = 0;
                        } else if(desirability < 1.2) {
                            r = 0; g = 255; b = Math.floor((desirability - 0.7) * 510);
                        } else {
                            r = 0; g = Math.floor(255 - (desirability - 1.2) * 200); b = 255;
                        }
                        c.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                        c.fillRect(x*T, y*T, T, T);
                        
                        // Show value on hover
                        if(Math.abs(Controller.mx - x) === 0 && Math.abs(Controller.my - y) === 0) {
                            c.fillStyle = 'rgba(0,0,0,0.9)';
                            c.fillRect(x*T - 10, y*T - 25, 70, 20);
                            c.fillStyle = '#fff';
                            c.font = 'bold 11px sans-serif';
                            c.textAlign = 'left';
                            c.fillText(`D: ${desirability.toFixed(2)}`, x*T - 5, y*T - 10);
                        }
                    }
                }
                
                // Draw wander wells (Level 0 structures)
                if(Game.wanderWells && Game.wanderWells.length > 0) {
                    for(let well of Game.wanderWells) {
                        let wx = well.x * T + T/2;
                        let wy = well.y * T + T/2;
                        
                        // Stone ring around well
                        c.fillStyle = '#6B6B6B';
                        c.beginPath();
                        c.arc(wx, wy, T * 0.45, 0, 6.28);
                        c.fill();
                        
                        // Inner dark hole
                        c.fillStyle = '#1A1A1A';
                        c.beginPath();
                        c.arc(wx, wy, T * 0.3, 0, 6.28);
                        c.fill();
                        
                        // Water shimmer inside
                        c.fillStyle = '#3B9EDB';
                        c.beginPath();
                        c.arc(wx, wy - 2, T * 0.2, 0, 6.28);
                        c.fill();
                        
                        // Highlight on water
                        c.fillStyle = 'rgba(255,255,255,0.4)';
                        c.beginPath();
                        c.arc(wx - 4, wy - 4, T * 0.08, 0, 6.28);
                        c.fill();
                        
                        // Stone texture dots
                        c.fillStyle = '#888';
                        for(let i = 0; i < 6; i++) {
                            let angle = (i / 6) * Math.PI * 2;
                            let sx = wx + Math.cos(angle) * T * 0.35;
                            let sy = wy + Math.sin(angle) * T * 0.35;
                            c.beginPath();
                            c.arc(sx, sy, 2, 0, 6.28);
                            c.fill();
                        }
                    }
                }
                
                // Draw player - LOGICAL LARRY the cute caveman!
                if (Game.player) {
                    let px = Game.player.x * T + T/2;
                    let py = Game.player.y * T + T/2;
                    let scale = T/64;
                    let dir = Game.player.direction || 'down';
                    
                    // Check bash animation state
                    let isBashing = Game.player.bashTime && (performance.now() - Game.player.bashTime) < 300;
                    let bashProgress = isBashing ? (performance.now() - Game.player.bashTime) / 300 : 0;
                    let facing = (dir === 'right') ? 1 : (dir === 'left') ? -1 : 0;
                    
                    // Soft shadow under character
                    c.fillStyle = 'rgba(0,0,0,0.2)';
                    c.beginPath();
                    c.ellipse(px, py + 12*scale, 8*scale, 3*scale, 0, 0, 6.28);
                    c.fill();
                    
                    // === LOGICAL LARRY - Clean cute caveman ===
                    
                    // Small neat feet (brown fur boots)
                    c.fillStyle = '#8B6914';
                    c.beginPath();
                    c.ellipse(px - 4*scale, py + 10*scale, 3*scale, 2*scale, 0, 0, 6.28);
                    c.ellipse(px + 4*scale, py + 10*scale, 3*scale, 2*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#5D4510';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    // Short stubby legs
                    c.fillStyle = '#DDA675';
                    c.fillRect(px - 5*scale, py + 4*scale, 4*scale, 7*scale);
                    c.fillRect(px + 1*scale, py + 4*scale, 4*scale, 7*scale);
                    
                    // Body - brown fur tunic (clean rounded shape)
                    c.fillStyle = '#A0522D';
                    c.beginPath();
                    c.ellipse(px, py - 2*scale, 8*scale, 9*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#6B3A1E';
                    c.lineWidth = 1.5;
                    c.stroke();
                    
                    // Fur texture dots on tunic
                    c.fillStyle = '#8B4513';
                    c.beginPath();
                    c.arc(px - 3*scale, py - 4*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 2*scale, py + 1*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 4*scale, py - 3*scale, 1*scale, 0, 6.28);
                    c.fill();
                    
                    // Belt (bone belt!)
                    c.fillStyle = '#F5F5DC';
                    c.fillRect(px - 7*scale, py + 2*scale, 14*scale, 2*scale);
                    c.strokeStyle = '#B8A080';
                    c.lineWidth = 0.8;
                    c.strokeRect(px - 7*scale, py + 2*scale, 14*scale, 2*scale);
                    
                    // Cute round head
                    c.fillStyle = '#DDA675';
                    c.beginPath();
                    c.arc(px, py - 14*scale, 9*scale, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#B8865C';
                    c.lineWidth = 1.2;
                    c.stroke();
                    
                    // Messy brown hair (clean tufts)
                    c.fillStyle = '#5D3A1A';
                    c.beginPath();
                    c.arc(px - 5*scale, py - 21*scale, 4*scale, 0, 6.28);
                    c.arc(px, py - 23*scale, 4*scale, 0, 6.28);
                    c.arc(px + 5*scale, py - 20*scale, 3.5*scale, 0, 6.28);
                    c.arc(px - 7*scale, py - 17*scale, 3*scale, 0, 6.28);
                    c.arc(px + 7*scale, py - 16*scale, 3*scale, 0, 6.28);
                    c.fill();
                    
                    // Eyes (big and friendly)
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.ellipse(px - 3*scale, py - 15*scale, 3*scale, 3.5*scale, 0, 0, 6.28);
                    c.ellipse(px + 3*scale, py - 15*scale, 3*scale, 3.5*scale, 0, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#333';
                    c.lineWidth = 0.8;
                    c.stroke();
                    
                    // Pupils (look in direction)
                    c.fillStyle = '#222';
                    c.beginPath();
                    c.arc(px - 3*scale + facing*scale, py - 15*scale, 1.5*scale, 0, 6.28);
                    c.arc(px + 3*scale + facing*scale, py - 15*scale, 1.5*scale, 0, 6.28);
                    c.fill();
                    
                    // Eye shine
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.arc(px - 3.5*scale + facing*0.5*scale, py - 16*scale, 0.7*scale, 0, 6.28);
                    c.arc(px + 2.5*scale + facing*0.5*scale, py - 16*scale, 0.7*scale, 0, 6.28);
                    c.fill();
                    
                    // Small nose
                    c.fillStyle = '#C9966C';
                    c.beginPath();
                    c.ellipse(px + facing*scale, py - 12*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                    c.fill();
                    
                    // Friendly smile
                    c.strokeStyle = '#804020';
                    c.lineWidth = 1.2;
                    c.beginPath();
                    c.arc(px, py - 9*scale, 3*scale, 0.3, 2.84);
                    c.stroke();
                    
                    // Stone club - with bash animation
                    c.save();
                    if(isBashing) {
                        let swingAngle = Math.sin(bashProgress * Math.PI) * -0.7;
                        c.translate(px + 10*scale, py - 6*scale);
                        c.rotate(swingAngle);
                        c.translate(-(px + 10*scale), -(py - 6*scale));
                    }
                    
                    // Club handle (wood)
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.roundRect(px + 8*scale, py - 8*scale, 3*scale, 14*scale, 1);
                    c.fill();
                    c.strokeStyle = '#5D4E3A';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    // Club head (stone)
                    c.fillStyle = '#808080';
                    c.beginPath();
                    c.ellipse(px + 10*scale, py - 10*scale, 5*scale, 6*scale, 0.2, 0, 6.28);
                    c.fill();
                    c.strokeStyle = '#555';
                    c.lineWidth = 1;
                    c.stroke();
                    
                    c.restore();
                    
                    // Bash impact stars
                    if(isBashing && bashProgress > 0.3 && bashProgress < 0.7) {
                        c.fillStyle = '#FFD700';
                        let starX = px + 16*scale;
                        let starY = py + 4*scale;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.arc(starX + (i-1)*4*scale, starY + Math.sin(i)*3*scale, 2*scale, 0, 6.28);
                            c.fill();
                        }
                    }
                }
                
                // Draw ancient animals - MORE REALISTIC style with soft shading
                Game.animals.forEach(animal => {
                    let tile = Game.tiles[animal.x][animal.y];
                    if(!tile.explored) return;
                    
                    let ax = animal.x * T + T/2;
                    let ay = animal.y * T + T/2;
                    let scale = T/64;
                    
                    // Get animal config
                    let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                    
                    // Realistic animal style with soft edges
                    c.lineCap = 'round';
                    c.lineJoin = 'round';
                    
                    // Soft realistic shadow under animal
                    let shadowGrad = c.createRadialGradient(ax, ay + 16*scale, 0, ax, ay + 16*scale, 14*scale);
                    shadowGrad.addColorStop(0, 'rgba(0,0,0,0.25)');
                    shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
                    c.fillStyle = shadowGrad;
                    c.beginPath();
                    c.ellipse(ax, ay + 16*scale, 14*scale, 5*scale, 0, 0, 6.28);
                    c.fill();
                    
                    if(animal.type === 'DEER') {
                        // REALISTIC DEER - Graceful proportions
                        
                        // Back legs (behind body)
                        c.fillStyle = '#C8A070';
                        c.beginPath();
                        c.ellipse(ax - 8*scale, ay + 12*scale, 3*scale, 8*scale, 0.1, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 4*scale, ay + 12*scale, 3*scale, 8*scale, -0.1, 0, 6.28);
                        c.fill();
                        
                        // Hooves
                        c.fillStyle = '#4A3A2A';
                        c.beginPath();
                        c.ellipse(ax - 8*scale, ay + 19*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 4*scale, ay + 19*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Main body - realistic deer shape with fur texture
                        let bodyGrad = c.createRadialGradient(ax - 2*scale, ay - 4*scale, 2, ax, ay + 2*scale, 16*scale);
                        bodyGrad.addColorStop(0, '#E8D0A8');
                        bodyGrad.addColorStop(0.5, '#D4B890');
                        bodyGrad.addColorStop(1, '#B89868');
                        c.fillStyle = bodyGrad;
                        c.beginPath();
                        c.ellipse(ax - 2*scale, ay, 16*scale, 10*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Soft fur edge
                        c.strokeStyle = 'rgba(160,120,80,0.4)';
                        c.lineWidth = 3;
                        c.stroke();
                        
                        // White underbelly with gradient
                        let bellyGrad = c.createLinearGradient(ax, ay, ax, ay + 8*scale);
                        bellyGrad.addColorStop(0, 'rgba(255,252,245,0.9)');
                        bellyGrad.addColorStop(1, 'rgba(255,248,240,0.3)');
                        c.fillStyle = bellyGrad;
                        c.beginPath();
                        c.ellipse(ax - 2*scale, ay + 4*scale, 10*scale, 5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Front legs
                        c.fillStyle = '#C8A878';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 10*scale, 2.5*scale, 9*scale, 0.15, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 8*scale, ay + 10*scale, 2.5*scale, 9*scale, -0.15, 0, 6.28);
                        c.fill();
                        
                        // Front hooves
                        c.fillStyle = '#4A3A2A';
                        c.beginPath();
                        c.ellipse(ax - 11*scale, ay + 18*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 9*scale, ay + 18*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Elegant neck
                        let neckGrad = c.createLinearGradient(ax + 8*scale, ay - 12*scale, ax + 16*scale, ay - 4*scale);
                        neckGrad.addColorStop(0, '#E8D8B8');
                        neckGrad.addColorStop(1, '#D0B888');
                        c.fillStyle = neckGrad;
                        c.beginPath();
                        c.moveTo(ax + 6*scale, ay - 4*scale);
                        c.quadraticCurveTo(ax + 10*scale, ay - 14*scale, ax + 16*scale, ay - 16*scale);
                        c.quadraticCurveTo(ax + 20*scale, ay - 14*scale, ax + 18*scale, ay - 6*scale);
                        c.closePath();
                        c.fill();
                        
                        // Realistic head shape
                        let headGrad = c.createRadialGradient(ax + 16*scale, ay - 18*scale, 2, ax + 18*scale, ay - 14*scale, 10*scale);
                        headGrad.addColorStop(0, '#F0E0C8');
                        headGrad.addColorStop(0.6, '#D8C8A8');
                        headGrad.addColorStop(1, '#C0A880');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay - 16*scale, 7*scale, 5*scale, 0.3, 0, 6.28);
                        c.fill();
                        
                        // Snout/muzzle
                        c.fillStyle = '#E8D8C0';
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay - 14*scale, 4*scale, 3*scale, 0.2, 0, 6.28);
                        c.fill();
                        
                        // Nose
                        c.fillStyle = '#3A2A1A';
                        c.beginPath();
                        c.ellipse(ax + 27*scale, ay - 14*scale, 1.5*scale, 1*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Realistic eye with depth
                        // Eye socket shadow
                        c.fillStyle = 'rgba(80,60,40,0.3)';
                        c.beginPath();
                        c.ellipse(ax + 19*scale, ay - 17*scale, 3*scale, 2.5*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#2A1A0A';
                        c.beginPath();
                        c.ellipse(ax + 19*scale, ay - 17*scale, 2*scale, 2.5*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Eye highlight
                        c.fillStyle = '#FFF';
                        c.beginPath();
                        c.arc(ax + 18*scale, ay - 18*scale, 0.8*scale, 0, 6.28);
                        c.fill();
                        
                        // Ear
                        c.fillStyle = '#D8C098';
                        c.beginPath();
                        c.ellipse(ax + 14*scale, ay - 22*scale, 3*scale, 5*scale, -0.4, 0, 6.28);
                        c.fill();
                        // Inner ear
                        c.fillStyle = '#F0D0C0';
                        c.beginPath();
                        c.ellipse(ax + 14*scale, ay - 21*scale, 1.5*scale, 3*scale, -0.4, 0, 6.28);
                        c.fill();
                        
                        // Antlers (more realistic branching)
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 2.5;
                        c.lineCap = 'round';
                        // Main beam
                        c.beginPath();
                        c.moveTo(ax + 12*scale, ay - 20*scale);
                        c.quadraticCurveTo(ax + 8*scale, ay - 28*scale, ax + 6*scale, ay - 34*scale);
                        c.stroke();
                        // Tines
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(ax + 10*scale, ay - 24*scale);
                        c.lineTo(ax + 4*scale, ay - 26*scale);
                        c.stroke();
                        c.beginPath();
                        c.moveTo(ax + 8*scale, ay - 28*scale);
                        c.lineTo(ax + 2*scale, ay - 30*scale);
                        c.stroke();
                        c.beginPath();
                        c.moveTo(ax + 6*scale, ay - 32*scale);
                        c.lineTo(ax + 10*scale, ay - 36*scale);
                        c.stroke();
                        
                        // White tail spot
                        c.fillStyle = '#FFF8F0';
                        c.beginPath();
                        c.ellipse(ax - 16*scale, ay - 2*scale, 4*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        
                    } else if(animal.type === 'BISON') {
                        // Realistic American Bison
                        
                        // Back legs (behind body)
                        c.fillStyle = '#5C4530';
                        c.beginPath();
                        c.moveTo(ax - 10*scale, ay + 6*scale);
                        c.lineTo(ax - 12*scale, ay + 18*scale);
                        c.lineTo(ax - 8*scale, ay + 18*scale);
                        c.lineTo(ax - 6*scale, ay + 6*scale);
                        c.closePath();
                        c.fill();
                        // Back hoof
                        c.fillStyle = '#2A2018';
                        c.fillRect(ax - 12*scale, ay + 16*scale, 5*scale, 3*scale);
                        
                        // Rear body (hindquarters - lighter, less fur)
                        let rearGrad = c.createLinearGradient(ax - 8*scale, ay - 4*scale, ax + 10*scale, ay + 10*scale);
                        rearGrad.addColorStop(0, '#8B6F4E');
                        rearGrad.addColorStop(1, '#6B5038');
                        c.fillStyle = rearGrad;
                        c.beginPath();
                        c.ellipse(ax - 4*scale, ay + 2*scale, 14*scale, 10*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Front legs (behind body)
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.moveTo(ax + 6*scale, ay + 6*scale);
                        c.lineTo(ax + 4*scale, ay + 18*scale);
                        c.lineTo(ax + 8*scale, ay + 18*scale);
                        c.lineTo(ax + 10*scale, ay + 6*scale);
                        c.closePath();
                        c.fill();
                        // Front hoof
                        c.fillStyle = '#2A2018';
                        c.fillRect(ax + 4*scale, ay + 16*scale, 5*scale, 3*scale);
                        
                        // Massive front hump/shoulder
                        let humpGrad = c.createRadialGradient(ax + 6*scale, ay - 10*scale, 2, ax + 8*scale, ay - 4*scale, 18*scale);
                        humpGrad.addColorStop(0, '#5C4830');
                        humpGrad.addColorStop(0.6, '#4A3820');
                        humpGrad.addColorStop(1, '#382818');
                        c.fillStyle = humpGrad;
                        c.beginPath();
                        c.ellipse(ax + 6*scale, ay - 6*scale, 14*scale, 14*scale, -0.2, 0, 6.28);
                        c.fill();
                        
                        // Shaggy fur texture on hump
                        c.strokeStyle = '#3A2818';
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 8; i++) {
                            c.beginPath();
                            c.moveTo(ax + (i*3 - 6)*scale, ay - 12*scale + Math.random()*4*scale);
                            c.lineTo(ax + (i*3 - 6)*scale, ay - 6*scale + Math.random()*4*scale);
                            c.stroke();
                        }
                        
                        // Beard/throat fur
                        c.fillStyle = '#3A2818';
                        c.beginPath();
                        c.moveTo(ax + 14*scale, ay + 4*scale);
                        c.quadraticCurveTo(ax + 16*scale, ay + 12*scale, ax + 12*scale, ay + 14*scale);
                        c.quadraticCurveTo(ax + 8*scale, ay + 12*scale, ax + 10*scale, ay + 6*scale);
                        c.closePath();
                        c.fill();
                        
                        // Head
                        let headGrad2 = c.createRadialGradient(ax + 16*scale, ay + 2*scale, 2, ax + 18*scale, ay + 4*scale, 10*scale);
                        headGrad2.addColorStop(0, '#6B5538');
                        headGrad2.addColorStop(1, '#4A3828');
                        c.fillStyle = headGrad2;
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay + 2*scale, 8*scale, 7*scale, 0.1, 0, 6.28);
                        c.fill();
                        
                        // Snout
                        c.fillStyle = '#5C4830';
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay + 5*scale, 5*scale, 4*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Nose
                        c.fillStyle = '#2A2018';
                        c.beginPath();
                        c.ellipse(ax + 27*scale, ay + 5*scale, 2*scale, 1.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Eye socket shadow
                        c.fillStyle = '#3A2818';
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay - 1*scale, 3*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#1A0A00';
                        c.beginPath();
                        c.ellipse(ax + 18*scale, ay - 1*scale, 2*scale, 1.8*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Horns
                        c.strokeStyle = '#3A3028';
                        c.lineWidth = 3.5;
                        c.lineCap = 'round';
                        // Left horn
                        c.beginPath();
                        c.moveTo(ax + 14*scale, ay - 4*scale);
                        c.quadraticCurveTo(ax + 10*scale, ay - 10*scale, ax + 14*scale, ay - 12*scale);
                        c.stroke();
                        // Horn tips
                        c.strokeStyle = '#2A2018';
                        c.lineWidth = 2.5;
                        c.beginPath();
                        c.moveTo(ax + 12*scale, ay - 10*scale);
                        c.lineTo(ax + 14*scale, ay - 12*scale);
                        c.stroke();
                        
                        // Ear (small, behind horn)
                        c.fillStyle = '#5C4830';
                        c.beginPath();
                        c.ellipse(ax + 12*scale, ay - 2*scale, 2*scale, 3*scale, -0.3, 0, 6.28);
                        c.fill();
                        
                        // Tail
                        c.strokeStyle = '#4A3828';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(ax - 16*scale, ay + 2*scale);
                        c.quadraticCurveTo(ax - 20*scale, ay + 8*scale, ax - 18*scale, ay + 12*scale);
                        c.stroke();
                        // Tail tuft
                        c.fillStyle = '#3A2818';
                        c.beginPath();
                        c.ellipse(ax - 18*scale, ay + 13*scale, 2*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        
                    } else if(animal.type === 'MAMMOTH') {
                        // Realistic Woolly Mammoth
                        
                        // Back legs (behind body)
                        c.fillStyle = '#5C4838';
                        c.beginPath();
                        c.moveTo(ax - 12*scale, ay + 8*scale);
                        c.lineTo(ax - 16*scale, ay + 22*scale);
                        c.lineTo(ax - 8*scale, ay + 22*scale);
                        c.lineTo(ax - 4*scale, ay + 8*scale);
                        c.closePath();
                        c.fill();
                        // Back foot
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 23*scale, 5*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Mid leg
                        c.fillStyle = '#5C4838';
                        c.beginPath();
                        c.moveTo(ax - 2*scale, ay + 10*scale);
                        c.lineTo(ax - 4*scale, ay + 22*scale);
                        c.lineTo(ax + 4*scale, ay + 22*scale);
                        c.lineTo(ax + 6*scale, ay + 10*scale);
                        c.closePath();
                        c.fill();
                        // Mid foot
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax, ay + 23*scale, 5*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Main massive body
                        let bodyGrad2 = c.createRadialGradient(ax - 4*scale, ay - 6*scale, 4, ax + 4*scale, ay + 6*scale, 28*scale);
                        bodyGrad2.addColorStop(0, '#8B7058');
                        bodyGrad2.addColorStop(0.5, '#6B5040');
                        bodyGrad2.addColorStop(1, '#4A3828');
                        c.fillStyle = bodyGrad2;
                        c.beginPath();
                        c.ellipse(ax, ay + 2*scale, 22*scale, 16*scale, 0.05, 0, 6.28);
                        c.fill();
                        
                        // Front leg
                        c.fillStyle = '#5C4838';
                        c.beginPath();
                        c.moveTo(ax + 10*scale, ay + 10*scale);
                        c.lineTo(ax + 8*scale, ay + 22*scale);
                        c.lineTo(ax + 16*scale, ay + 22*scale);
                        c.lineTo(ax + 18*scale, ay + 10*scale);
                        c.closePath();
                        c.fill();
                        // Front foot
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax + 12*scale, ay + 23*scale, 5*scale, 2.5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Long shaggy fur on underside
                        c.fillStyle = '#5C4838';
                        for(let i = 0; i < 7; i++) {
                            c.beginPath();
                            c.moveTo(ax + (-18 + i*6)*scale, ay + 10*scale);
                            c.quadraticCurveTo(ax + (-18 + i*6)*scale + 2*scale, ay + 18*scale, ax + (-18 + i*6)*scale, ay + 16*scale);
                            c.quadraticCurveTo(ax + (-18 + i*6)*scale - 2*scale, ay + 18*scale, ax + (-18 + i*6)*scale, ay + 10*scale);
                            c.fill();
                        }
                        
                        // Shoulder hump
                        let humpGrad2 = c.createRadialGradient(ax + 8*scale, ay - 12*scale, 3, ax + 10*scale, ay - 6*scale, 16*scale);
                        humpGrad2.addColorStop(0, '#7B6048');
                        humpGrad2.addColorStop(1, '#5A4030');
                        c.fillStyle = humpGrad2;
                        c.beginPath();
                        c.ellipse(ax + 6*scale, ay - 8*scale, 14*scale, 12*scale, -0.1, 0, 6.28);
                        c.fill();
                        
                        // Fur texture on hump
                        c.strokeStyle = '#4A3828';
                        c.lineWidth = 1.5;
                        for(let i = 0; i < 10; i++) {
                            c.beginPath();
                            c.moveTo(ax + (-4 + i*2)*scale, ay - 16*scale + Math.random()*4*scale);
                            c.lineTo(ax + (-4 + i*2)*scale, ay - 8*scale + Math.random()*4*scale);
                            c.stroke();
                        }
                        
                        // Head
                        let headGrad3 = c.createRadialGradient(ax + 22*scale, ay - 4*scale, 3, ax + 26*scale, ay, 14*scale);
                        headGrad3.addColorStop(0, '#7B6048');
                        headGrad3.addColorStop(1, '#5A4030');
                        c.fillStyle = headGrad3;
                        c.beginPath();
                        c.ellipse(ax + 24*scale, ay - 2*scale, 10*scale, 11*scale, 0.15, 0, 6.28);
                        c.fill();
                        
                        // Domed forehead
                        c.fillStyle = '#6B5040';
                        c.beginPath();
                        c.ellipse(ax + 22*scale, ay - 10*scale, 8*scale, 6*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Ear (small for mammoth)
                        c.fillStyle = '#5A4030';
                        c.beginPath();
                        c.ellipse(ax + 16*scale, ay - 8*scale, 3*scale, 4*scale, -0.3, 0, 6.28);
                        c.fill();
                        
                        // Eye socket area
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax + 26*scale, ay - 6*scale, 3.5*scale, 3*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Eye
                        c.fillStyle = '#2A1A08';
                        c.beginPath();
                        c.ellipse(ax + 26*scale, ay - 6*scale, 2.5*scale, 2*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Trunk
                        c.fillStyle = '#6B5040';
                        c.beginPath();
                        c.moveTo(ax + 32*scale, ay + 2*scale);
                        c.quadraticCurveTo(ax + 40*scale, ay + 8*scale, ax + 38*scale, ay + 18*scale);
                        c.quadraticCurveTo(ax + 36*scale, ay + 24*scale, ax + 32*scale, ay + 22*scale);
                        c.quadraticCurveTo(ax + 30*scale, ay + 16*scale, ax + 32*scale, ay + 8*scale);
                        c.quadraticCurveTo(ax + 30*scale, ay + 4*scale, ax + 28*scale, ay + 2*scale);
                        c.closePath();
                        c.fill();
                        
                        // Trunk ridges
                        c.strokeStyle = '#5A4030';
                        c.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.moveTo(ax + 32*scale, ay + (4 + i*4)*scale);
                            c.quadraticCurveTo(ax + 36*scale, ay + (6 + i*4)*scale, ax + 34*scale, ay + (6 + i*4)*scale);
                            c.stroke();
                        }
                        
                        // Trunk tip
                        c.fillStyle = '#5A4030';
                        c.beginPath();
                        c.ellipse(ax + 34*scale, ay + 22*scale, 3*scale, 2*scale, 0.3, 0, 6.28);
                        c.fill();
                        
                        // Tusks (large curved ivory)
                        c.strokeStyle = '#F8F0E0';
                        c.lineWidth = 5;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(ax + 26*scale, ay + 4*scale);
                        c.quadraticCurveTo(ax + 32*scale, ay + 12*scale, ax + 26*scale, ay + 18*scale);
                        c.quadraticCurveTo(ax + 20*scale, ay + 22*scale, ax + 16*scale, ay + 18*scale);
                        c.stroke();
                        
                        // Tusk shading
                        c.strokeStyle = '#E8E0D0';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(ax + 26*scale, ay + 6*scale);
                        c.quadraticCurveTo(ax + 30*scale, ay + 12*scale, ax + 26*scale, ay + 16*scale);
                        c.stroke();
                        
                        // Tail
                        c.strokeStyle = '#5A4030';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(ax - 20*scale, ay + 2*scale);
                        c.quadraticCurveTo(ax - 26*scale, ay + 8*scale, ax - 24*scale, ay + 14*scale);
                        c.stroke();
                        // Tail tuft
                        c.fillStyle = '#4A3828';
                        c.beginPath();
                        c.ellipse(ax - 24*scale, ay + 15*scale, 2.5*scale, 4*scale, 0, 0, 6.28);
                        c.fill();
                    } else if(animal.type === 'TURTLE') {
                        // BEACH TURTLE - Cute cartoon style sea turtle
                        
                        // Soft shadow
                        let shadowGrad = c.createRadialGradient(ax, ay + 12*scale, 0, ax, ay + 12*scale, 14*scale);
                        shadowGrad.addColorStop(0, 'rgba(0,0,0,0.2)');
                        shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
                        c.fillStyle = shadowGrad;
                        c.beginPath();
                        c.ellipse(ax, ay + 12*scale, 14*scale, 5*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Back flippers
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 12*scale, ay + 8*scale, 6*scale, 3*scale, -0.6, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(ax + 12*scale, ay + 8*scale, 6*scale, 3*scale, 0.6, 0, 6.28);
                        c.fill();
                        
                        // Shell (oval dome) with gradient
                        let shellGrad = c.createRadialGradient(ax - 2*scale, ay - 4*scale, 2*scale, ax, ay + 2*scale, 16*scale);
                        shellGrad.addColorStop(0, '#7CAA7C');
                        shellGrad.addColorStop(0.5, '#5A8A5A');
                        shellGrad.addColorStop(1, '#3D6B3D');
                        c.fillStyle = shellGrad;
                        c.beginPath();
                        c.ellipse(ax, ay, 14*scale, 10*scale, 0, 0, 6.28);
                        c.fill();
                        
                        // Shell border
                        c.strokeStyle = '#2D5B2D';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Shell pattern (hexagonal plates)
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1.5;
                        // Center plate
                        c.beginPath();
                        c.ellipse(ax, ay - 1*scale, 5*scale, 4*scale, 0, 0, 6.28);
                        c.stroke();
                        // Side plates
                        c.beginPath();
                        c.ellipse(ax - 7*scale, ay, 4*scale, 3*scale, 0.3, 0, 6.28);
                        c.stroke();
                        c.beginPath();
                        c.ellipse(ax + 7*scale, ay, 4*scale, 3*scale, -0.3, 0, 6.28);
                        c.stroke();
                        
                        // Front flippers
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 10*scale, ay - 4*scale, 8*scale, 4*scale, -0.8, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1;
                        c.stroke();
                        c.beginPath();
                        c.ellipse(ax + 10*scale, ay - 4*scale, 8*scale, 4*scale, 0.8, 0, 6.28);
                        c.fill();
                        c.stroke();
                        
                        // Head
                        let headGrad = c.createRadialGradient(ax + 14*scale, ay - 4*scale, 1*scale, ax + 16*scale, ay - 2*scale, 8*scale);
                        headGrad.addColorStop(0, '#8BC88B');
                        headGrad.addColorStop(1, '#5A8A5A');
                        c.fillStyle = headGrad;
                        c.beginPath();
                        c.ellipse(ax + 16*scale, ay - 3*scale, 6*scale, 5*scale, 0.2, 0, 6.28);
                        c.fill();
                        c.strokeStyle = '#4A7A4A';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Cute eye
                        c.fillStyle = '#222';
                        c.beginPath();
                        c.arc(ax + 18*scale, ay - 5*scale, 2*scale, 0, 6.28);
                        c.fill();
                        // Eye shine
                        c.fillStyle = '#fff';
                        c.beginPath();
                        c.arc(ax + 18.5*scale, ay - 5.5*scale, 0.8*scale, 0, 6.28);
                        c.fill();
                        
                        // Cute smile
                        c.strokeStyle = '#3D6B3D';
                        c.lineWidth = 1.5;
                        c.beginPath();
                        c.arc(ax + 17*scale, ay - 1*scale, 2*scale, 0.2, Math.PI - 0.2);
                        c.stroke();
                        
                        // Tiny tail
                        c.fillStyle = '#6B9B6B';
                        c.beginPath();
                        c.ellipse(ax - 15*scale, ay + 2*scale, 3*scale, 2*scale, -0.3, 0, 6.28);
                        c.fill();
                    }
                    
                    // Show hit count with cute style
                    if(animal.hits > 0) {
                        // Red heart damage indicator
                        c.fillStyle = '#FF6060';
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText(`ğŸ’” ${animal.hits}/${config.hitToKill}`, ax, ay - 26*scale);
                    }
                });

                // Draw zoned residential buildings with road connection check
                for(let x=sc; x<ec; x++) {
                    for(let y=sr; y<er; y++) {
                        let tile = Game.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            this.drawZonedRes(c, x*T, y*T, tile.building, x, y);
                            
                            // Check road connection for residential zones
                            let hasRoad = false;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H && Game.tiles[nx][ny].road) {
                                        hasRoad = true;
                                        break;
                                    }
                                }
                                if(hasRoad) break;
                            }
                            // Draw "!" indicator if no road connection
                            if(!hasRoad) {
                                this.drawIcon(c, x*T + T/2, y*T + T/2, "!", "red");
                            }
                        }
                    }
                }

                // Draw build effects (e.g., dust clouds)
                const now = performance.now();
                // Remove expired effects
                this.effects = this.effects.filter(e => (now - e.start) < e.duration);
                for(const e of this.effects) {
                    if(e.type === 'dust') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.8;
                        const wobble = this.time * 1.5;
                        for(const puff of e.puffs) {
                            const baseR = puff.radius * T * (1 + 0.4*Math.sin(wobble + puff.angle * 2));
                            const dx = Math.cos(puff.angle) * baseR * (1 + 0.3*Math.sin(wobble + puff.angle));
                            const dy = Math.sin(puff.angle) * baseR * (1 + 0.3*Math.cos(wobble + puff.angle));
                            const size = T * (0.12 + 0.06*Math.sin(wobble + puff.angle)) * (1 - progress);
                            c.fillStyle = `rgba(240, 220, 200, ${alpha})`;
                            c.beginPath();
                            c.ellipse(cx + dx, cy + dy, size, size * 0.85, 0, 0, Math.PI*2);
                            c.fill();
                            c.strokeStyle = `rgba(255,255,255,${alpha*0.5})`;
                            c.lineWidth = 1;
                            c.stroke();
                        }
                    } else if(e.type === 'woodchips') {
                        const tx = e.x, ty = e.y;
                        if(tx < sc || tx >= ec || ty < sr || ty >= er) continue;
                        const cx = tx * T + T/2;
                        const cy = ty * T + T/2;
                        const progress = Math.max(0, Math.min(1, (now - e.start) / e.duration));
                        const alpha = (1 - progress) * 0.9;
                        for(const chip of e.chips) {
                            const dist = T * chip.speed * progress * (0.7 + Math.random()*0.3);
                            const dx = Math.cos(chip.angle) * dist;
                            const dy = Math.sin(chip.angle) * dist;
                            const size = T * (0.07 + Math.random()*0.03) * (1 - progress*0.7);
                            c.save();
                            c.translate(cx + dx, cy + dy);
                            c.rotate(chip.angle + progress*2);
                            c.fillStyle = `rgba(180, 120, 60, ${alpha})`;
                            c.fillRect(-size/2, -size/6, size, size/3);
                            c.restore();
                        }
                    }
                }

                Game.blds.forEach(b => {
                    if (b.x < sc-2 || b.x > ec || b.y < sr-2 || b.y > er) return;
                    let bx = b.x * T, by = b.y * T;
                    // COM/IND/WELL/STORAGE_PITS are 1x1; others are 2x2
                    let size = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') ? T : 2 * T;
                    
                    // Only draw shadow for 2x2 buildings
                    if(size > T) {
                        c.fillStyle = "rgba(0,0,0,0.3)"; c.beginPath(); c.roundRect(bx+10, by+15, size-20, size-20, 10); c.fill();
                    }
                    
                    // Highlight if hovering
                    let isHover = Controller.mx >= b.x && Controller.mx < b.x + (size/T) && Controller.my >= b.y && Controller.my < b.y + (size/T);
                    if(isHover && Controller.tool === 'PAN') {
                        c.fillStyle = "rgba(255, 255, 0, 0.3)";
                        c.fillRect(bx, by, size, size);
                    }
                    
                    // Only draw base rect for 2x2 buildings (1x1 are handled in their draw functions)
                    if(size > T) {
                        c.fillStyle = CFG.COLORS[b.t]; c.beginPath(); c.roundRect(bx, by, size, size, 4); c.fill();
                    }
                    
                    if (b.t === 'COM') this.drawCom(c, bx, by, b);
                    else if (b.t === 'IND') this.drawInd(c, bx, by, b);
                    else if (b.t === 'CHIEF') this.drawChief(c, bx, by, b);
                    else if (b.t === 'CLAN_CHIEF') this.drawClanChief(c, bx, by, b);
                    else if (b.t === 'DOCK') this.drawDock(c, bx, by, b);
                    else if (b.t === 'WELL') this.drawWell(c, bx, by, b);
                    else if (b.t === 'BASKET') this.drawBasket(c, bx, by, b);
                    else if (b.t === 'POTTERY') this.drawPottery(c, bx, by, b);
                    else if (b.t === 'GRANARY') this.drawGranary(c, bx, by, b);
                    else if (b.t === 'PALACE') this.drawPalace(c, bx, by, b);
                    else if (b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') this.drawStoragePit(c, bx, by, b);

                    // Show building info on hover
                    if(isHover && Controller.tool === 'PAN') {
                        let upgradeCost = Game.getUpgradeCost(b.lvl);
                        let effPct = Math.floor(b.efficiency * 100);
                        let effColor = b.efficiency > 0.8 ? 'ğŸŸ¢' : (b.efficiency > 0.4 ? 'ğŸŸ¡' : 'ğŸ”´');
                        
                        let infoText = `L${b.lvl} ${effColor}${effPct}%`;
                        if(b.t === 'COM' || b.t === 'IND') infoText += ` | ${Math.floor(Game.getBuildingProduction(b) * b.efficiency)}`;
                        if(b.lvl < 200) infoText += ` | â†‘$${Math.floor(upgradeCost)}`;
                        if(!b.conn) infoText += ' | âš ï¸NO ROAD';
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.9)";
                        c.fillRect(bx - 10, by - 30, size + 20, 25);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 9px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(infoText, bx + size/2, by - 17);
                    }

                    c.strokeStyle = "#fff"; c.lineWidth = 2; c.strokeRect(bx, by, size, size);
                    if (b.t !== 'RES' && !b.conn) this.drawIcon(c, bx + size/2, by + size/2, "!", "red");
                });

                this.drawParticles(c);

                if (Controller.tool !== 'PAN' && Controller.tool !== 'NONE') {
                    let gx = Controller.mx, gy = Controller.my;
                    // All zones are 1x1 (ROAD, WELL, BULL, RES, COM, IND, DEMOLISH), only special buildings are 2x2
                    let sz = (Controller.tool=='ROAD'||Controller.tool=='WELL'||Controller.tool=='BULL'||Controller.tool=='RES'||Controller.tool=='COM'||Controller.tool=='IND'||Controller.tool=='DEMOLISH')?1:2;
                    let dx = gx; let dy = gy;
                    
                    let valid = true;
                    if (Controller.tool === 'BULL') valid = Game.blds.some(b => {
                        // COM, IND, WELL are 1x1 per documentation
                        let bSz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2;
                        return gx>=b.x && gx<b.x+bSz && gy>=b.y && gy<b.y+bSz;
                    }) || Game.tiles[gx][gy].road || Game.tiles[gx][gy].zone;
                    else valid = Game.isValid(dx, dy, Controller.tool);

                    c.fillStyle = valid ? CFG.COLORS.OK : CFG.COLORS.NO;
                    c.fillRect(dx*T, dy*T, sz*T, sz*T);
                    c.strokeStyle = "#fff"; c.lineWidth = 3; c.strokeRect(dx*T, dy*T, sz*T, sz*T);
                    
                    // PREVIEW: Show estimated capacity for RES zones
                    if(Controller.tool === 'RES' && valid) {
                        let previewDesirability = Game.calculateDesirability(dx, dy, sz);
                        let startEra = CFG.ERAS[0];
                        let previewCap = Math.floor(startEra.capacity * previewDesirability);
                        
                        c.fillStyle = "rgba(0, 0, 0, 0.85)";
                        c.fillRect(dx*T, dy*T - 40, sz*T, 35);
                        c.fillStyle = "#FFFFFF";
                        c.font = "bold 11px sans-serif";
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.fillText(`Zone: ${startEra.name}`, dx*T + sz*T/2, dy*T - 28);
                        c.font = "10px sans-serif";
                        c.fillStyle = previewDesirability > 1.5 ? "#4CAF50" : (previewDesirability > 1.0 ? "#FFC107" : "#FF5252");
                        c.fillText(`Est. Capacity: ${previewCap}`, dx*T + sz*T/2, dy*T - 17);
                        c.font = "9px sans-serif";
                        c.fillStyle = "#FFFFFF";
                        c.fillText(`Desirability: ${Math.floor(previewDesirability*100)}%`, dx*T + sz*T/2, dy*T - 6);
                    }
                }
                c.restore();
            },
            drawRoad(c, x, y, T) {
                // Wider, more realistic grey path
                const tx = x * T, ty = y * T;
                const cx = tx + T/2, cy = ty + T/2;
                const lineWidth = Math.max(8, Math.floor(T * 0.26));

                // Neighbor connections
                const up = (y > 0) && !!Game.tiles[x][y-1].road;
                const down = (y < CFG.H - 1) && !!Game.tiles[x][y+1].road;
                const left = (x > 0) && !!Game.tiles[x-1][y].road;
                const right = (x < CFG.W - 1) && !!Game.tiles[x+1][y].road;

                // Main center stroke (dark grey)
                c.lineCap = 'round';
                c.lineJoin = 'round';
                c.strokeStyle = '#555555';
                c.lineWidth = lineWidth + 2;
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                // Always draw the short center stub so isolated tiles look rounded
                c.moveTo(cx, cy);
                c.lineTo(cx + 0.01, cy + 0.01);
                c.stroke();

                // Lighter inner strip to suggest compacted dirt
                c.strokeStyle = '#7a7a7a';
                c.lineWidth = Math.max(4, Math.floor(lineWidth * 0.5));
                c.beginPath();
                if (up) { c.moveTo(cx, cy); c.lineTo(cx, ty); }
                if (down) { c.moveTo(cx, cy); c.lineTo(cx, ty + T); }
                if (left) { c.moveTo(cx, cy); c.lineTo(tx, cy); }
                if (right) { c.moveTo(cx, cy); c.lineTo(tx + T, cy); }
                c.stroke();

                // Subtle edge shading for realism
                c.lineWidth = 1.5;
                c.strokeStyle = 'rgba(0,0,0,0.25)';
                if (up) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty); c.stroke(); }
                if (down) { c.beginPath(); c.moveTo(cx - lineWidth/2, cy); c.lineTo(cx - lineWidth/2, ty + T); c.stroke(); c.beginPath(); c.moveTo(cx + lineWidth/2, cy); c.lineTo(cx + lineWidth/2, ty + T); c.stroke(); }
                if (left) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx, cy + lineWidth/2); c.stroke(); }
                if (right) { c.beginPath(); c.moveTo(cx, cy - lineWidth/2); c.lineTo(tx + T, cy - lineWidth/2); c.stroke(); c.beginPath(); c.moveTo(cx, cy + lineWidth/2); c.lineTo(tx + T, cy + lineWidth/2); c.stroke(); }

                // Deterministic speckles/pebbles along path (seeded by coords)
                const seed = ((x * 73856093) ^ (y * 19349663)) >>> 0;
                const rand = (n) => Math.abs(Math.sin(seed + n) * 10000) % 1;
                c.fillStyle = '#666';
                for (let i = 0; i < 4; i++) {
                    let t = 0.2 + i * 0.2 + rand(i) * 0.1; // position along axis
                    let px = cx + ( (left || right) ? (t - 0.5) * T : 0 );
                    let py = cy + ( (up || down) ? (t - 0.5) * T : 0 );
                    // offset perpendicular
                    let ox = (rand(i+10) - 0.5) * lineWidth * 0.6;
                    let oy = (rand(i+20) - 0.5) * lineWidth * 0.6;
                    if (left || right) { py = cy; px = tx + t * T; oy = (rand(i+20)-0.5) * lineWidth * 0.2; }
                    if (up || down) { px = cx; py = ty + t * T; ox = (rand(i+10)-0.5) * lineWidth * 0.2; }
                    c.beginPath();
                    c.ellipse(px + ox, py + oy, Math.max(1, Math.floor(lineWidth*0.12)), Math.max(1, Math.floor(lineWidth*0.08)), 0, 0, 6.28);
                    c.fill();
                }
            },
            drawWaterAnim(c, x, y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.strokeStyle = "rgba(255,255,255,0.2)"; c.lineWidth = 2*scale; 
                let offset = Math.sin(this.time + x) * 5*scale; 
                c.beginPath(); 
                c.moveTo(x*T+10*scale, y*T+T/2+offset); 
                c.quadraticCurveTo(x*T+T/2, y*T+20*scale+offset, x*T+54*scale, y*T+T/2+offset); 
                c.stroke(); 
            },
            drawStoneDeposit(c, x, y, deposit) {
                let T = CFG.TILE;
                let cx = x + T/2;
                let cy = y + T*0.7;
                let scale = T/64;
                
                // Determine color based on metal value (gradient from gray to gold)
                let metalValue = deposit.metal;
                let ratio = (metalValue - CFG.STONE_DEPOSITS.MIN_METAL) / (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL);
                
                // Color progression: Gray -> Blue -> Purple -> Gold
                let r, g, b;
                if(ratio < 0.33) {
                    // Gray to Blue
                    let t = ratio / 0.33;
                    r = Math.floor(120 + (80 - 120) * t);
                    g = Math.floor(120 + (160 - 120) * t);
                    b = Math.floor(120 + (240 - 120) * t);
                } else if(ratio < 0.66) {
                    // Blue to Purple
                    let t = (ratio - 0.33) / 0.33;
                    r = Math.floor(80 + (180 - 80) * t);
                    g = Math.floor(160 + (80 - 160) * t);
                    b = Math.floor(240 + (200 - 240) * t);
                } else {
                    // Purple to Gold
                    let t = (ratio - 0.66) / 0.34;
                    r = Math.floor(180 + (255 - 180) * t);
                    g = Math.floor(80 + (215 - 80) * t);
                    b = Math.floor(200 + (0 - 200) * t);
                }
                
                let baseColor = `rgb(${r},${g},${b})`;
                let darkColor = `rgb(${Math.floor(r*0.6)},${Math.floor(g*0.6)},${Math.floor(b*0.6)})`;
                let lightColor = `rgb(${Math.min(255, Math.floor(r*1.4))},${Math.min(255, Math.floor(g*1.4))},${Math.min(255, Math.floor(b*1.4))})`;
                
                // Shadow
                c.fillStyle = 'rgba(0,0,0,0.4)';
                c.beginPath();
                c.ellipse(cx + 4*scale, cy + 10*scale, 18*scale, 8*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - black outline
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy, 22*scale, 20*scale, 0, 0, 6.28);
                c.fill();
                
                // Main rock body - colored
                c.fillStyle = baseColor;
                c.beginPath();
                c.ellipse(cx, cy, 20*scale, 18*scale, 0, 0, 6.28);
                c.fill();
                
                // Dark patch (bottom right)
                c.fillStyle = darkColor;
                c.beginPath();
                c.ellipse(cx + 8*scale, cy + 6*scale, 8*scale, 7*scale, 0, 0, 6.28);
                c.fill();
                
                // Bright highlight (top left)
                c.fillStyle = lightColor;
                c.beginPath();
                c.ellipse(cx - 6*scale, cy - 6*scale, 8*scale, 7*scale, 0.3, 0, 6.28);
                c.fill();
                
                // Shine spot (Mario-style)
                c.fillStyle = 'rgba(255,255,255,0.8)';
                c.beginPath();
                c.ellipse(cx - 8*scale, cy - 8*scale, 4*scale, 3*scale, -0.3, 0, 6.28);
                c.fill();
                
                // Smaller shine
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.beginPath();
                c.arc(cx + 4*scale, cy - 4*scale, 2*scale, 0, 6.28);
                c.fill();
                
                // Show metal value on explored tiles
                if(Game.tiles && Game.tiles[Math.floor(x/T)] && Game.tiles[Math.floor(x/T)][Math.floor(y/T)]) {
                    let tile = Game.tiles[Math.floor(x/T)][Math.floor(y/T)];
                    if(tile.explored) {
                        c.fillStyle = '#000';
                        c.font = 'bold 8px sans-serif';
                        c.textAlign = 'center';
                        c.fillText(Controller.formatNum(metalValue), cx, cy + 22*scale);
                    }
                }
            },
            drawTree(c, x, y, t) {
                let T = CFG.TILE;
                let cx=x+T/2, cy=y+T*0.78;
                let scale = T/64; // Scale all measurements based on tile size
                
                // Shadow - improved with gradient for more natural look
                let shadowGrad = c.createRadialGradient(cx+6*scale, cy+6*scale, 0, cx+6*scale, cy+6*scale, 18*scale);
                shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)');
                shadowGrad.addColorStop(0.6, 'rgba(0,0,0,0.2)');
                shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
                c.fillStyle = shadowGrad; 
                c.beginPath(); 
                c.ellipse(cx+6*scale, cy+8*scale, 16*scale, 8*scale, 0.2, 0, 6.28); 
                c.fill();
                
                // Trunk with black outline
                c.fillStyle = "#000000";
                c.fillRect(cx-5*scale, cy-18*scale, 10*scale, 20*scale);
                c.fillStyle = "#8B4513";
                c.fillRect(cx-4*scale, cy-17*scale, 8*scale, 18*scale);
                
                // Trunk texture lines
                c.strokeStyle = "#654321";
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(cx-2*scale, cy-10*scale);
                c.lineTo(cx-2*scale, cy);
                c.stroke();
                c.beginPath();
                c.moveTo(cx+2*scale, cy-12*scale);
                c.lineTo(cx+2*scale, cy);
                c.stroke();
                
                if(t=='PINE'||t=='SNOW'){ 
                    // Pine tree style
                    c.fillStyle = "#000000";
                    c.beginPath(); 
                    c.moveTo(cx-20*scale, cy-10*scale); 
                    c.lineTo(cx+20*scale, cy-10*scale); 
                    c.lineTo(cx, cy-65*scale); 
                    c.fill();
                    
                    c.fillStyle = (t=='SNOW') ? "#2E7D32" : "#1B5E20";
                    c.beginPath(); 
                    c.moveTo(cx-18*scale, cy-10*scale); 
                    c.lineTo(cx+18*scale, cy-10*scale); 
                    c.lineTo(cx, cy-62*scale); 
                    c.fill(); 
                    
                    // Second layer
                    c.fillStyle = "#000000";
                    c.beginPath(); 
                    c.moveTo(cx-16*scale, cy-25*scale); 
                    c.lineTo(cx+16*scale, cy-25*scale); 
                    c.lineTo(cx, cy-70*scale); 
                    c.fill();
                    
                    c.fillStyle = (t=='SNOW') ? "#43A047" : "#2E7D32";
                    c.beginPath(); 
                    c.moveTo(cx-14*scale, cy-25*scale); 
                    c.lineTo(cx+14*scale, cy-25*scale); 
                    c.lineTo(cx, cy-68*scale); 
                    c.fill(); 
                    
                    if(t=='SNOW') { 
                        c.fillStyle="#FFF"; 
                        c.beginPath(); 
                        c.moveTo(cx-6*scale, cy-6*scale); 
                        c.lineTo(cx+6*scale, cy-6*scale); 
                        c.lineTo(cx, cy-14*scale); 
                        c.fill(); 
                    } 
                } else { 
                    // Round tree (Enhanced Mario-style - vibrant with more depth!)
                    // Back shadow foliage for depth
                    c.fillStyle = "#1B4D1B";
                    c.beginPath();
                    c.arc(cx, cy-32*scale, 26*scale, 0, 6.28);
                    c.fill();
                    
                    // Back foliage puff - rich green
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx-14*scale, cy-40*scale, 17*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#2D8B2D";
                    c.beginPath();
                    c.arc(cx-14*scale, cy-40*scale, 15*scale, 0, 6.28);
                    c.fill();
                    
                    // Right foliage puff - rich green
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx+14*scale, cy-40*scale, 17*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#3D9B3D";
                    c.beginPath();
                    c.arc(cx+14*scale, cy-40*scale, 15*scale, 0, 6.28);
                    c.fill();
                    
                    // Main center foliage - with gradient for more natural look
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx, cy-34*scale, 26*scale, 0, 6.28);
                    c.fill();
                    
                    let foliageGrad = c.createRadialGradient(cx-4*scale, cy-40*scale, 0, cx, cy-34*scale, 24*scale);
                    foliageGrad.addColorStop(0, '#7DEB7D');
                    foliageGrad.addColorStop(0.5, '#50C850');
                    foliageGrad.addColorStop(1, '#2D8B2D');
                    c.fillStyle = foliageGrad;
                    c.beginPath();
                    c.arc(cx, cy-34*scale, 24*scale, 0, 6.28);
                    c.fill();
                    
                    // Top highlight puff
                    c.fillStyle = "#000000";
                    c.beginPath();
                    c.arc(cx, cy-52*scale, 12*scale, 0, 6.28);
                    c.fill();
                    c.fillStyle = "#5DD85D";
                    c.beginPath();
                    c.arc(cx, cy-52*scale, 10*scale, 0, 6.28);
                    c.fill();
                    
                    // Bright highlights for depth (softer)
                    c.fillStyle = "#8FFF8F";
                    c.beginPath();
                    c.arc(cx-5*scale, cy-42*scale, 8*scale, 0, 6.28);
                    c.fill();
                    c.beginPath();
                    c.arc(cx+6*scale, cy-38*scale, 6*scale, 0, 6.28);
                    c.fill();
                    
                    // Subtle highlight spot
                    c.fillStyle = "#B8FFB8";
                    c.beginPath();
                    c.arc(cx-4*scale, cy-48*scale, 4*scale, 0, 6.28);
                    c.fill();
                }
            },
            drawZonedRes(c, x, y, bld, gridX, gridY) {
                let lvl = bld.level || 0;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;
                let desirability = bld.desirability || 1.0;
                
                // Check if within Chief's Hut radius for gold border
                let hasChiefBonus = false;
                let chiefHuts = Game.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(gridX - chief.x, 2) + Math.pow(gridY - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChiefBonus = true;
                        break;
                    }
                }
                
                // Get building level info from BUILDING_LEVELS config (not ERAS)
                let buildingConfig = CFG.BUILDING_LEVELS[lvl] || CFG.BUILDING_LEVELS[0];
                let era = { name: buildingConfig.name }; // Use building name, not era name
                
                // LEVEL 0 EVOLUTION VARIANTS
                // (Level 0 is Wanderer/Empty, so we don't draw buildings for it usually)
                
                // Ensure variant is set (default to deterministic random if missing)
                if (bld.variant === undefined) {
                    bld.variant = (gridX + gridY * 57) % 4;
                }
                let variant = bld.variant;

                // === BIRDS EYE VIEW MODE ===
                if(Game.vm === 'BIRDSEYE') {
                    // === SNES SIMCITY STYLE RESIDENTIAL ===
                    // Each level has a distinctly different cute look
                    
                    // Cute shadow for depth
                    c.fillStyle = 'rgba(0,0,0,0.2)';
                    c.beginPath();
                    c.ellipse(cx + 3, cy + T*0.2, T*0.35, T*0.15, 0, 0, 6.28);
                    c.fill();

                    if(lvl === 1) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 1: SIMPLE PIT SHELTER - Like a cozy burrow
                        // A dug-out pit with leaf/stick covering
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        // Ground ring (the pit edge)
                        c.fillStyle = '#6D5D4D';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.08, T*0.38, T*0.22, 0, 0, 6.28);
                        c.fill();
                        
                        // Inner dark pit
                        c.fillStyle = '#3D2D1D';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.08, T*0.28, T*0.15, 0, 0, 6.28);
                        c.fill();
                        
                        // Stick/thatch roof cover (dome of sticks)
                        let roofColor = variant === 0 ? '#5D4D3D' : variant === 1 ? '#7D6D5D' : variant === 2 ? '#9D8D7D' : '#BDA98D';
                        c.fillStyle = roofColor;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.25);
                        c.bezierCurveTo(cx - T*0.35, cy - T*0.1, cx - T*0.35, cy + T*0.1, cx, cy + T*0.12);
                        c.bezierCurveTo(cx + T*0.35, cy + T*0.1, cx + T*0.35, cy - T*0.1, cx, cy - T*0.25);
                        c.fill();
                        
                        // Stick texture lines
                        c.strokeStyle = '#4D3D2D';
                        c.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.25 + i*T*0.12, cy - T*0.2 + i*T*0.03);
                            c.lineTo(cx + T*0.05 + i*T*0.02, cy + T*0.08);
                            c.stroke();
                        }
                        
                        // Entry hole (cute dark opening)
                        c.fillStyle = '#1D0D00';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.05, T*0.08, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Little smoke wisps if inhabited
                        if(bld.pop > 0) {
                            let smokeT = (Renderer.time || 0) * 2;
                            c.fillStyle = 'rgba(200,200,200,0.4)';
                            c.beginPath();
                            c.arc(cx + Math.sin(smokeT)*3, cy - T*0.3 - Math.abs(Math.sin(smokeT*0.5))*5, 3, 0, 6.28);
                            c.fill();
                        }
                        
                    } else if(lvl === 2) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 2: LEAN-TO SHELTER - Like Yoshi's Island hut
                        // A-frame with hide covering, more upright
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        // Ground pad
                        c.fillStyle = '#8B7355';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.15, T*0.35, T*0.12, 0, 0, 6.28);
                        c.fill();
                        
                        // Hide/leather tent body - cute triangular shape
                        let hideColor = variant === 0 ? '#6D5545' : variant === 1 ? '#8D7565' : variant === 2 ? '#AD9585' : '#CDB5A5';
                        c.fillStyle = hideColor;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.38);  // Top point
                        c.lineTo(cx - T*0.32, cy + T*0.12);
                        c.lineTo(cx + T*0.32, cy + T*0.12);
                        c.closePath();
                        c.fill();
                        
                        // Outline for that SNES look
                        c.strokeStyle = '#3E2E1E';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Hide stitching pattern (cute detail)
                        c.strokeStyle = '#5E4E3E';
                        c.lineWidth = 1;
                        c.setLineDash([3, 3]);
                        c.beginPath();
                        c.moveTo(cx - T*0.15, cy - T*0.1);
                        c.lineTo(cx + T*0.15, cy - T*0.1);
                        c.stroke();
                        c.setLineDash([]);
                        
                        // Cute door flap
                        c.fillStyle = '#4E3E2E';
                        c.beginPath();
                        c.moveTo(cx - T*0.08, cy + T*0.12);
                        c.lineTo(cx, cy - T*0.05);
                        c.lineTo(cx + T*0.08, cy + T*0.12);
                        c.closePath();
                        c.fill();
                        
                        // Support poles at top (crossed sticks)
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 3;
                        c.lineCap = 'round';
                        c.beginPath();
                        c.moveTo(cx - T*0.06, cy - T*0.38);
                        c.lineTo(cx - T*0.1, cy - T*0.48);
                        c.stroke();
                        c.beginPath();
                        c.moveTo(cx + T*0.06, cy - T*0.38);
                        c.lineTo(cx + T*0.1, cy - T*0.48);
                        c.stroke();
                        
                    } else if(lvl === 3) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 3: MUD BRICK HUT - Cozy igloo-like dome
                        // Round with cute door and maybe window
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        // Ground base
                        c.fillStyle = '#7D6D5D';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.18, T*0.38, T*0.1, 0, 0, 6.28);
                        c.fill();
                        
                        // Dome body - cute rounded shape
                        let mudColor = variant === 0 ? '#8D7D6D' : variant === 1 ? '#AD9D8D' : variant === 2 ? '#C9B9A9' : '#E5D5C5';
                        c.fillStyle = mudColor;
                        c.beginPath();
                        c.arc(cx, cy, T*0.32, Math.PI, 0, false);
                        c.lineTo(cx + T*0.32, cy + T*0.15);
                        c.lineTo(cx - T*0.32, cy + T*0.15);
                        c.closePath();
                        c.fill();
                        
                        // SNES-style outline
                        c.strokeStyle = '#5D4D3D';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Brick pattern (horizontal lines)
                        c.strokeStyle = '#7D6D5D';
                        c.lineWidth = 1;
                        for(let i = 0; i < 3; i++) {
                            let yy = cy - T*0.15 + i * T*0.1;
                            c.beginPath();
                            c.moveTo(cx - T*0.28 + i*T*0.05, yy);
                            c.lineTo(cx + T*0.28 - i*T*0.05, yy);
                            c.stroke();
                        }
                        
                        // Cute arched doorway
                        c.fillStyle = '#2D1D0D';
                        c.beginPath();
                        c.arc(cx, cy + T*0.08, T*0.1, Math.PI, 0, false);
                        c.lineTo(cx + T*0.1, cy + T*0.15);
                        c.lineTo(cx - T*0.1, cy + T*0.15);
                        c.closePath();
                        c.fill();
                        
                        // Tiny window if high variant (cute round window)
                        if(variant >= 2) {
                            c.fillStyle = '#FFEB3B';
                            c.beginPath();
                            c.arc(cx + T*0.18, cy - T*0.08, T*0.05, 0, 6.28);
                            c.fill();
                            c.strokeStyle = '#5D4D3D';
                            c.lineWidth = 1;
                            c.stroke();
                        }
                        
                        // Smoke hole on top
                        c.fillStyle = '#4D3D2D';
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.3, T*0.05, T*0.03, 0, 0, 6.28);
                        c.fill();
                        
                        // Cute smoke puffs
                        if(bld.pop > 0) {
                            let t = (Renderer.time || 0);
                            for(let i = 0; i < 3; i++) {
                                let puffY = cy - T*0.35 - i*8 - Math.sin(t + i)*3;
                                let puffX = cx + Math.sin(t*0.7 + i*2)*4;
                                let size = 4 - i;
                                c.fillStyle = `rgba(200,200,200,${0.5 - i*0.15})`;
                                c.beginPath();
                                c.arc(puffX, puffY, size, 0, 6.28);
                                c.fill();
                            }
                        }
                        
                    } else if(lvl === 4) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 4: TIPI VILLAGE - Native American Tipis
                        // Multiple tipis with decorative patterns
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        let hideColor = variant === 0 ? '#D4C4A4' : variant === 1 ? '#E4D4B4' : variant === 2 ? '#F4E4C4' : '#FFF4D4';
                        let poleColor = '#5E4E3E';
                        let decorColor = variant === 0 ? '#8B4513' : variant === 1 ? '#A0522D' : variant === 2 ? '#CD853F' : '#DEB887';
                        
                        // Main tipi
                        c.fillStyle = hideColor;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.45);
                        c.lineTo(cx - T*0.28, cy + T*0.18);
                        c.lineTo(cx + T*0.28, cy + T*0.18);
                        c.closePath();
                        c.fill();
                        
                        // SNES outline
                        c.strokeStyle = '#5D4D3D';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Poles sticking out top
                        c.strokeStyle = poleColor;
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx - T*0.05, cy - T*0.45);
                        c.lineTo(cx - T*0.12, cy - T*0.55);
                        c.moveTo(cx + T*0.05, cy - T*0.45);
                        c.lineTo(cx + T*0.12, cy - T*0.55);
                        c.moveTo(cx, cy - T*0.45);
                        c.lineTo(cx, cy - T*0.58);
                        c.stroke();
                        
                        // Decorative band pattern
                        c.strokeStyle = decorColor;
                        c.lineWidth = 3;
                        c.beginPath();
                        c.moveTo(cx - T*0.18, cy - T*0.1);
                        c.lineTo(cx + T*0.18, cy - T*0.1);
                        c.stroke();
                        
                        // Zigzag pattern
                        c.lineWidth = 2;
                        for(let i = 0; i < 4; i++) {
                            let xOff = -T*0.15 + i * T*0.1;
                            c.beginPath();
                            c.moveTo(cx + xOff, cy - T*0.08);
                            c.lineTo(cx + xOff + T*0.05, cy - T*0.15);
                            c.lineTo(cx + xOff + T*0.1, cy - T*0.08);
                            c.stroke();
                        }
                        
                        // Door flap
                        c.fillStyle = '#3E2E1E';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.08, T*0.1, 0, 0, Math.PI);
                        c.fill();
                        
                        // Small secondary tipi (shows village)
                        if(variant >= 1) {
                            c.fillStyle = hideColor;
                            c.globalAlpha = 0.8;
                            c.beginPath();
                            c.moveTo(cx + T*0.25, cy - T*0.15);
                            c.lineTo(cx + T*0.12, cy + T*0.12);
                            c.lineTo(cx + T*0.38, cy + T*0.12);
                            c.closePath();
                            c.fill();
                            c.strokeStyle = '#5D4D3D';
                            c.lineWidth = 1;
                            c.stroke();
                            c.globalAlpha = 1;
                        }
                        
                        // Smoke from top
                        if(bld.pop > 0) {
                            let t = (Renderer.time || 0);
                            for(let i = 0; i < 3; i++) {
                                let puffY = cy - T*0.6 - i*7 - Math.sin(t + i)*3;
                                let puffX = cx + Math.sin(t*0.6 + i*2)*4;
                                let size = 4 - i;
                                c.fillStyle = `rgba(200,200,200,${0.5 - i*0.15})`;
                                c.beginPath();
                                c.arc(puffX, puffY, size, 0, 6.28);
                                c.fill();
                            }
                        }
                        
                    } else if(lvl === 5) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 5: LOG LONGHOUSE - Extended dwelling
                        // Long rectangular wooden structure
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        let woodColor = variant === 0 ? '#5E4E3E' : variant === 1 ? '#7E6E5E' : variant === 2 ? '#9E8E7E' : '#BEAE9E';
                        let roofColor = variant === 0 ? '#3E5E3E' : variant === 1 ? '#4E6E4E' : variant === 2 ? '#5E7E5E' : '#6E8E6E';
                        
                        // Long body
                        c.fillStyle = woodColor;
                        c.fillRect(cx - T*0.4, cy - T*0.1, T*0.8, T*0.28);
                        
                        // SNES outline
                        c.strokeStyle = '#3E2E1E';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.4, cy - T*0.1, T*0.8, T*0.28);
                        
                        // Log texture (horizontal lines)
                        c.strokeStyle = '#4E3E2E';
                        c.lineWidth = 1;
                        for(let i = 0; i < 4; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.4, cy - T*0.06 + i*T*0.07);
                            c.lineTo(cx + T*0.4, cy - T*0.06 + i*T*0.07);
                            c.stroke();
                        }
                        
                        // Rounded bark roof
                        c.fillStyle = roofColor;
                        c.beginPath();
                        c.ellipse(cx, cy - T*0.15, T*0.42, T*0.2, 0, Math.PI, 0);
                        c.fill();
                        c.strokeStyle = '#3E2E1E';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Roof texture lines
                        c.strokeStyle = '#2E4E2E';
                        c.lineWidth = 1;
                        for(let i = 0; i < 5; i++) {
                            let xOff = -T*0.35 + i * T*0.175;
                            c.beginPath();
                            c.moveTo(cx + xOff, cy - T*0.15);
                            c.lineTo(cx + xOff, cy - T*0.32 + Math.abs(i-2)*T*0.04);
                            c.stroke();
                        }
                        
                        // Two doors
                        c.fillStyle = '#2E1E0E';
                        c.fillRect(cx - T*0.28, cy + T*0.02, T*0.12, T*0.16);
                        c.fillRect(cx + T*0.16, cy + T*0.02, T*0.12, T*0.16);
                        
                        // Smoke holes
                        if(bld.pop > 0) {
                            let t = (Renderer.time || 0);
                            // Left smoke
                            for(let i = 0; i < 2; i++) {
                                let puffY = cy - T*0.38 - i*5 - Math.sin(t*0.9 + i)*2;
                                let puffX = cx - T*0.15 + Math.sin(t*0.5 + i)*2;
                                c.fillStyle = `rgba(180,180,180,${0.4 - i*0.15})`;
                                c.beginPath();
                                c.arc(puffX, puffY, 3-i, 0, 6.28);
                                c.fill();
                            }
                            // Right smoke
                            for(let i = 0; i < 2; i++) {
                                let puffY = cy - T*0.38 - i*5 - Math.sin(t*0.8 + i + 1)*2;
                                let puffX = cx + T*0.15 + Math.sin(t*0.6 + i)*2;
                                c.fillStyle = `rgba(180,180,180,${0.4 - i*0.15})`;
                                c.beginPath();
                                c.arc(puffX, puffY, 3-i, 0, 6.28);
                                c.fill();
                            }
                        }
                        
                        // Decorative totems at ends
                        if(variant >= 2) {
                            c.fillStyle = '#8B4513';
                            c.fillRect(cx - T*0.45, cy - T*0.05, T*0.04, T*0.23);
                            c.fillRect(cx + T*0.41, cy - T*0.05, T*0.04, T*0.23);
                        }
                        
                    } else if(lvl >= 6) {
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // LEVEL 6: OLD GROWTH LOG COMPOUND - Multi-structure
                        // Large compound with multiple buildings
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        
                        let woodColor = variant === 0 ? '#4E3E2E' : variant === 1 ? '#6E5E4E' : variant === 2 ? '#8E7E6E' : '#AE9E8E';
                        let roofColor = variant === 0 ? '#2E4E2E' : variant === 1 ? '#3E5E3E' : variant === 2 ? '#4E6E4E' : '#5E7E5E';
                        let stoneColor = '#7E7E7E';
                        
                        // Main large lodge
                        c.fillStyle = woodColor;
                        c.fillRect(cx - T*0.35, cy - T*0.08, T*0.5, T*0.28);
                        c.strokeStyle = '#2E1E0E';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.35, cy - T*0.08, T*0.5, T*0.28);
                        
                        // Old growth log texture (thick horizontal)
                        c.strokeStyle = '#3E2E1E';
                        c.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            c.beginPath();
                            c.moveTo(cx - T*0.35, cy - T*0.02 + i*T*0.09);
                            c.lineTo(cx + T*0.15, cy - T*0.02 + i*T*0.09);
                            c.stroke();
                        }
                        
                        // Main roof with bark shingles
                        c.fillStyle = roofColor;
                        c.beginPath();
                        c.moveTo(cx - T*0.4, cy - T*0.08);
                        c.lineTo(cx - T*0.1, cy - T*0.38);
                        c.lineTo(cx + T*0.2, cy - T*0.08);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#2E1E0E';
                        c.lineWidth = 2;
                        c.stroke();
                        
                        // Secondary structure
                        c.fillStyle = woodColor;
                        c.globalAlpha = 0.9;
                        c.fillRect(cx + T*0.12, cy + T*0.02, T*0.3, T*0.18);
                        c.strokeStyle = '#2E1E0E';
                        c.lineWidth = 1;
                        c.strokeRect(cx + T*0.12, cy + T*0.02, T*0.3, T*0.18);
                        c.globalAlpha = 1;
                        
                        // Secondary roof
                        c.fillStyle = roofColor;
                        c.beginPath();
                        c.moveTo(cx + T*0.1, cy + T*0.02);
                        c.lineTo(cx + T*0.27, cy - T*0.15);
                        c.lineTo(cx + T*0.44, cy + T*0.02);
                        c.closePath();
                        c.fill();
                        c.stroke();
                        
                        // Stone foundation
                        c.fillStyle = stoneColor;
                        c.fillRect(cx - T*0.38, cy + T*0.18, T*0.82, T*0.05);
                        
                        // Main door
                        c.fillStyle = '#1E0E00';
                        c.fillRect(cx - T*0.2, cy + T*0.02, T*0.1, T*0.16);
                        
                        // Windows with hide coverings
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.32, cy - T*0.02, T*0.08, T*0.08);
                        c.fillRect(cx + T*0.02, cy - T*0.02, T*0.08, T*0.08);
                        c.strokeStyle = '#2E1E0E';
                        c.lineWidth = 1;
                        c.strokeRect(cx - T*0.32, cy - T*0.02, T*0.08, T*0.08);
                        c.strokeRect(cx + T*0.02, cy - T*0.02, T*0.08, T*0.08);
                        
                        // Totem pole
                        if(variant >= 1) {
                            c.fillStyle = '#8B4513';
                            c.fillRect(cx + T*0.35, cy - T*0.25, T*0.06, T*0.45);
                            // Totem face
                            c.fillStyle = '#FFD700';
                            c.beginPath();
                            c.arc(cx + T*0.38, cy - T*0.18, T*0.04, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#1E0E00';
                            c.beginPath();
                            c.arc(cx + T*0.36, cy - T*0.19, 2, 0, 6.28);
                            c.arc(cx + T*0.40, cy - T*0.19, 2, 0, 6.28);
                            c.fill();
                        }
                        
                        // Multiple smoke sources
                        if(bld.pop > 0) {
                            let t = (Renderer.time || 0);
                            for(let s = 0; s < 2; s++) {
                                let baseX = s === 0 ? cx - T*0.1 : cx + T*0.27;
                                let baseY = s === 0 ? cy - T*0.4 : cy - T*0.18;
                                for(let i = 0; i < 2; i++) {
                                    let puffY = baseY - i*5 - Math.sin(t*0.7 + i + s)*2;
                                    let puffX = baseX + Math.sin(t*0.5 + i + s*2)*2;
                                    c.fillStyle = `rgba(170,170,170,${0.35 - i*0.12})`;
                                    c.beginPath();
                                    c.arc(puffX, puffY, 3-i*0.5, 0, 6.28);
                                    c.fill();
                                }
                            }
                        }
                    }
                    
                    // Gold border if within Chief's Hut radius
                    if(hasChiefBonus) {
                        c.strokeStyle = "#FFD700";
                        c.lineWidth = 3;
                        c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                    }
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                
                // Get variant name from config
                let variantConfig = null;
                let variantName = buildingConfig.name;
                if(buildingConfig.variants && buildingConfig.variants[variant]) {
                    variantConfig = buildingConfig.variants[variant];
                    variantName = variantConfig.name;
                }
                
                // Color based on level AND variant - Generate colors dynamically
                // Each level gets progressively more vibrant/prestigious colors
                const generateLevelColors = (level) => {
                    // Base hue shifts from brown (30) through green (120) to blue (200) to purple (280)
                    let hueBase = 30 + (level - 1) * 15;
                    if(hueBase > 360) hueBase = hueBase % 360;
                    
                    // Saturation increases with level
                    let sat = Math.min(70, 30 + level * 3);
                    
                    return [
                        `hsla(${hueBase}, ${sat - 20}%, 25%, 0.8)`,   // Abandoned - Dark
                        `hsla(${hueBase}, ${sat}%, 35%, 0.85)`,       // Low - Medium
                        `hsla(${hueBase}, ${sat + 10}%, 45%, 0.9)`,   // Medium - Bright
                        `hsla(${hueBase}, ${sat + 15}%, 55%, 0.95)`   // High - Vibrant
                    ];
                };
                
                // Named colors for first 4 levels for thematic consistency
                let levelColors = {
                    1: [ // Pit level - Brown tones
                        'rgba(101, 67, 33, 0.8)',    
                        'rgba(141, 110, 99, 0.85)',  
                        'rgba(180, 140, 100, 0.9)',  
                        'rgba(212, 180, 130, 0.95)'  
                    ],
                    2: [ // Leather Tent level - Leather/hide tones
                        'rgba(90, 70, 50, 0.8)',     
                        'rgba(139, 90, 43, 0.85)',   
                        'rgba(160, 120, 80, 0.9)',   
                        'rgba(188, 152, 106, 0.95)'  
                    ],
                    3: [ // Mud Brick level - Clay/adobe tones
                        'rgba(80, 60, 40, 0.8)',     
                        'rgba(140, 100, 60, 0.85)',  
                        'rgba(180, 130, 80, 0.9)',   
                        'rgba(210, 160, 100, 0.95)'  
                    ],
                    4: [ // Log House - Wood tones
                        'rgba(60, 40, 20, 0.8)',     
                        'rgba(100, 70, 40, 0.85)', 
                        'rgba(139, 90, 43, 0.9)',  
                        'rgba(160, 120, 60, 0.95)'  
                    ]
                };
                
                // Get color for this level and variant
                let colorArray = levelColors[lvl] || generateLevelColors(lvl);
                let fillColor = colorArray[Math.min(variant, colorArray.length - 1)];
                
                // Check for overcrowding
                let levelCfg = CFG.BUILDING_LEVELS[lvl] || {};
                let capacity = levelCfg.capacity || 20;
                let pop = bld.pop || 0;
                let isOvercrowded = pop > capacity;
                let isAbandoned = variant === 0 || pop === 0;
                
                // Draw building base with level-specific shape
                if(lvl === 1) {
                    // PIT SHELTER - Square shape (simple shelter)
                    c.fillStyle = isAbandoned ? '#4A4A4A' : fillColor;
                    c.fillRect(x + 4, y + 4, T - 8, T - 8);
                    c.strokeStyle = isAbandoned ? '#333' : '#3E2723';
                    c.lineWidth = 2;
                    c.strokeRect(x + 4, y + 4, T - 8, T - 8);
                    
                    // Pit icon in center for Pit Shelter
                    if(!isAbandoned) {
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.ellipse(cx, cy, T*0.2, T*0.15, 0, 0, 6.28);
                        c.fill();
                    }
                } else if(lvl === 2) {
                    // GROUND PIT - Circular pit shape
                    c.fillStyle = isAbandoned ? '#4A4A4A' : fillColor;
                    c.beginPath();
                    c.arc(cx, cy, T * 0.4, 0, 6.28);
                    c.fill();
                    c.strokeStyle = isAbandoned ? '#333' : '#5D4037';
                    c.lineWidth = 2;
                    c.stroke();
                    
                    // Inner dark circle for pit
                    c.fillStyle = isAbandoned ? '#222' : 'rgba(0,0,0,0.3)';
                    c.beginPath();
                    c.arc(cx, cy, T * 0.25, 0, 6.28);
                    c.fill();
                } else if(lvl === 3) {
                    // GROUND CAVE - Dome/cave shape
                    c.fillStyle = isAbandoned ? '#4A4A4A' : fillColor;
                    c.beginPath();
                    c.arc(cx, cy + 5, T * 0.4, Math.PI, 0, false);
                    c.lineTo(x + T - 8, y + T - 5);
                    c.lineTo(x + 8, y + T - 5);
                    c.closePath();
                    c.fill();
                    c.strokeStyle = isAbandoned ? '#333' : '#5D4037';
                    c.lineWidth = 2;
                    c.stroke();
                    
                    // Cave entrance (dark opening)
                    c.fillStyle = '#1A1A1A';
                    c.beginPath();
                    c.arc(cx, cy + 8, T * 0.15, Math.PI, 0, false);
                    c.fill();
                } else {
                    // DEFAULT - Square building
                    c.fillStyle = isAbandoned ? '#4A4A4A' : fillColor;
                    c.fillRect(x + 4, y + 4, T - 8, T - 8);
                    c.strokeStyle = isAbandoned ? '#333' : '#3E2723';
                    c.lineWidth = 2;
                    c.strokeRect(x + 4, y + 4, T - 8, T - 8);
                }
                
                // ABANDONED INDICATOR - Gray X overlay
                if(isAbandoned) {
                    c.strokeStyle = '#666';
                    c.lineWidth = 3;
                    c.beginPath();
                    c.moveTo(x + 8, y + 8);
                    c.lineTo(x + T - 8, y + T - 8);
                    c.moveTo(x + T - 8, y + 8);
                    c.lineTo(x + 8, y + T - 8);
                    c.stroke();
                }
                
                // OVERCROWDED INDICATOR - Red pulsing border
                if(isOvercrowded) {
                    let pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    c.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
                    c.lineWidth = 3;
                    c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                    
                    // Warning icon
                    c.fillStyle = '#FF0000';
                    c.font = 'bold 12px sans-serif';
                    c.textAlign = 'right';
                    c.fillText('âš ï¸', x + T - 2, y + 12);
                }
                
                // Gold border if within Chief's Hut radius
                if(hasChiefBonus && !isOvercrowded) {
                    c.strokeStyle = "#FFD700";
                    c.lineWidth = 2;
                    c.strokeRect(x + 1, y + 1, T - 2, T - 2);
                }
                
                // Show population count at top with color coding
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.font = "bold " + Math.floor(T/5) + "px sans-serif";
                c.fillStyle = isOvercrowded ? '#FF4444' : (isAbandoned ? '#888' : '#FFFFFF');
                c.fillText(`ğŸ‘¥${pop}/${capacity}`, cx, y + T/5);
                
                // Building name in center
                let displayName = variantConfig ? variantConfig.name : buildingConfig.name;
                c.font = "bold " + Math.floor(T/7) + "px sans-serif";
                c.fillStyle = isAbandoned ? '#666' : '#FFFFFF';
                
                // Show building type icon instead of long names
                let icon = 'ğŸ ';
                if(lvl === 1) icon = isAbandoned ? 'ğŸª¹' : (variant >= 2 ? 'ğŸ•ï¸' : 'ğŸªº');
                else if(lvl === 2) icon = isAbandoned ? 'ğŸ•³ï¸' : (variant >= 2 ? 'ğŸ ' : 'ğŸŸ«');
                else if(lvl === 3) icon = isAbandoned ? 'ğŸª¨' : (variant >= 2 ? 'ğŸ”ï¸' : 'â›°ï¸');
                
                c.font = Math.floor(T/3) + "px sans-serif";
                c.fillText(icon, cx, cy + 2);
                
                // Level indicator at bottom
                c.font = Math.floor(T/6) + "px sans-serif";
                c.fillStyle = '#FFFFFF';
                c.fillText(`L${lvl}`, cx, y + T - 6);
            },
            drawRes(c,x,y,b) {
                let lvl = b.lvl || 1;
                let cx = x + 32, cy = y + 32;
                let desirability = b.desirability || 1.0;
                
                // Visual feedback: High desirability = brighter/warmer, Low = darker/smaller
                let brightness = Math.min(1.5, Math.max(0.6, desirability));
                let scale = Math.min(1.1, Math.max(0.85, 0.9 + desirability * 0.1));
                
                // Determine architectural era based on level (1-200)
                if(lvl <= 40) {
                    // PRIMITIVE (1-40): Mud huts â†’ Stone huts
                    let progress = (lvl - 1) / 39;
                    let baseSize = 18 + progress * 8;
                    let roofHeight = 28 + progress * 12;
                    
                    c.fillStyle = "rgba(0,0,0,0.2)";
                    c.beginPath();
                    c.ellipse(cx, cy + 22, baseSize + 2, 6, 0, 0, 6.28);
                    c.fill();
                    
                    // Walls transition mud â†’ stone
                    let mudColor = [141, 110, 99];
                    let stoneColor = [120, 120, 120];
                    let wallColor = mudColor.map((m, i) => Math.floor((m + (stoneColor[i] - m) * progress) * brightness));
                    c.fillStyle = `rgb(${wallColor[0]}, ${wallColor[1]}, ${wallColor[2]})`;
                    c.beginPath();
                    c.arc(cx, cy, baseSize * scale, 0, 6.28);
                    c.fill();
                    
                    // Roof
                    let roofColor = lvl > 20 ? "#8B7355" : "#D4A574";
                    c.fillStyle = roofColor;
                    c.beginPath();
                    c.moveTo(cx - (baseSize + 4) * scale, cy);
                    c.lineTo(cx + (baseSize + 4) * scale, cy);
                    c.lineTo(cx, cy - roofHeight * scale);
                    c.fill();
                    
                    // High desirability: Smoke from chimney
                    if(desirability > 1.5 && Math.random() > 0.7) {
                        Renderer.particles.push({x: cx, y: cy - roofHeight * scale - 5, l: 30, c: "rgba(200,200,200,0.6)"});
                    }
                } else if(lvl <= 80) {
                    // ANCIENT (41-80): Stone houses â†’ Roman villas
                    let progress = (lvl - 41) / 39;
                    let width = (40 + progress * 15) * scale;
                    let height = (30 + progress * 10) * scale;
                    
                    c.fillStyle = `rgba(160, 130, 109, ${brightness})`;
                    c.fillRect(cx - width/2, cy - height/2, width, height);
                    
                    // Columns appear as we progress
                    if(lvl > 60) {
                        c.fillStyle = "#D4C5B9";
                        for(let i = 0; i < 3; i++) {
                            c.fillRect(cx - width/2 + 10 + i * 15, cy - height/2, 5, height);
                        }
                    }
                    
                    // Roof
                    c.fillStyle = "#8B4513";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 5, cy - height/2);
                    c.lineTo(cx + width/2 + 5, cy - height/2);
                    c.lineTo(cx, cy - height/2 - 20);
                    c.fill();
                } else if(lvl <= 120) {
                    // MEDIEVAL (81-120): Wooden houses â†’ Stone manors
                    let progress = (lvl - 81) / 39;
                    let stories = Math.floor(1 + progress * 2);
                    let width = 35 * scale;
                    let storyHeight = 18 * scale;
                    
                    for(let s = 0; s < stories; s++) {
                        let baseColor = s % 2 === 0 ? [101, 67, 33] : [139, 115, 85];
                        c.fillStyle = `rgb(${Math.floor(baseColor[0]*brightness)}, ${Math.floor(baseColor[1]*brightness)}, ${Math.floor(baseColor[2]*brightness)})`;
                        c.fillRect(cx - width/2, cy + 10 - s * storyHeight, width, storyHeight);
                        
                        // Windows
                        c.fillStyle = "#FFE4B5";
                        c.fillRect(cx - 8, cy + 15 - s * storyHeight, 6, 8);
                        c.fillRect(cx + 2, cy + 15 - s * storyHeight, 6, 8);
                    }
                    
                    // Roof
                    c.fillStyle = "#8B0000";
                    c.beginPath();
                    c.moveTo(cx - width/2 - 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx + width/2 + 3, cy + 10 - stories * storyHeight);
                    c.lineTo(cx, cy - 5 - stories * storyHeight);
                    c.fill();
                } else if(lvl <= 160) {
                    // INDUSTRIAL (121-160): Brick apartments â†’ Early skyscrapers
                    let progress = (lvl - 121) / 39;
                    let stories = Math.floor(3 + progress * 5);
                    let width = 32 * scale;
                    let storyHeight = 12 * scale;
                    
                    c.fillStyle = "#8B4513";
                    c.fillRect(cx - width/2, cy + 15 - stories * storyHeight, width, stories * storyHeight);
                    
                    // Grid of windows
                    c.fillStyle = "#FFD700";
                    for(let s = 0; s < stories; s++) {
                        for(let w = 0; w < 2; w++) {
                            c.fillRect(cx - 12 + w * 14, cy + 18 - s * storyHeight, 8, 6);
                        }
                    }
                    
                    // Flat roof
                    c.fillStyle = "#696969";
                    c.fillRect(cx - width/2 - 2, cy + 15 - stories * storyHeight - 3, width + 4, 3);
                    
                    // High desirability: Smoke particles
                    if(desirability > 1.3 && Math.random() > 0.8) {
                        Renderer.particles.push({x: cx + 10, y: cy + 15 - stories * storyHeight - 10, l: 25, c: "rgba(180,180,180,0.5)"});
                    }
                } else {
                    // MODERN/FUTURISTIC (161-200): Skyscrapers â†’ Mega towers
                    let progress = (lvl - 161) / 39;
                    let stories = Math.floor(8 + progress * 12);
                    let width = 28 * scale;
                    let storyHeight = 10 * scale;
                    
                    // Main tower
                    let gradient = c.createLinearGradient(cx - width/2, 0, cx + width/2, 0);
                    gradient.addColorStop(0, "#4A90E2");
                    gradient.addColorStop(1, "#50C878");
                    c.fillStyle = gradient;
                    c.fillRect(cx - width/2, cy + 20 - stories * storyHeight, width, stories * storyHeight);
                    
                    // High-tech windows
                    c.fillStyle = lvl > 180 ? "#00FFFF" : "#87CEEB";
                    for(let s = 0; s < stories; s++) {
                        c.fillRect(cx - 10, cy + 22 - s * storyHeight, 20, 6);
                    }
                    
                    // Futuristic top (for highest levels)
                    if(lvl > 180) {
                        c.fillStyle = "#FF00FF";
                        c.beginPath();
                        c.arc(cx, cy + 20 - stories * storyHeight - 5, 5, 0, 6.28);
                        c.fill();
                    }
                }
                
                // Level indicator
                c.fillStyle = "#FFFFFF";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText(`L${lvl}`, cx, y + 60);
            },
            drawCom(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;  // Center for 1x1 tile
                
                // Get variant for activity level (0=abandoned, 1=low, 2=medium, 3=high)
                let variant = b.variant || 1;
                
                // === BIRDS EYE VIEW MODE - Simple stick-in-ground icons (per level) ===
                if(Game.vm === 'BIRDSEYE') {
                    // Base ground patch
                    c.fillStyle = '#8B7355';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.12, T*0.35, T*0.22, 0, 0, Math.PI*2);
                    c.fill();

                    // Stick size increases with level
                    let stickH = T * (0.18 + 0.06 * Math.max(1, Math.min(3, lvl)));
                    let stickW = 3;
                    let stickColor = variant === 0 ? '#6b6b6b' : '#5D4037';

                    // Draw stick (slightly leaning)
                    c.save();
                    c.translate(cx, cy - T*0.02);
                    c.rotate(-0.08 * (lvl));
                    c.fillStyle = stickColor;
                    c.beginPath();
                    c.roundRect(-stickW/2, -stickH, stickW, stickH, 1);
                    c.fill();
                    c.restore();

                    // Level-specific minimal symbols
                    if(lvl === 1) {
                        // Pebble beside the stick
                        c.fillStyle = variant === 0 ? '#777' : '#9E9E9E';
                        c.beginPath();
                        c.ellipse(cx - T*0.12, cy + T*0.08, T*0.06, T*0.04, 0, 0, Math.PI*2);
                        c.fill();
                    } else if(lvl === 2) {
                        // Slightly bigger base mound to symbolize exchange
                        c.fillStyle = variant === 0 ? '#6b6b6b' : '#A1887F';
                        c.beginPath();
                        c.ellipse(cx + T*0.1, cy + T*0.05, T*0.08, T*0.05, 0, 0, Math.PI*2);
                        c.fill();
                    } else if(lvl === 3) {
                        // Larger stick and small notch marker (beaver trade post motif)
                        c.strokeStyle = variant === 0 ? '#6b6b6b' : '#3E2723';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.moveTo(cx, cy - T*0.12);
                        c.lineTo(cx + T*0.06, cy - T*0.16);
                        c.stroke();
                    } else if(lvl === 4) {
                        // =============================
                        // LEVEL 4: BARTER BARREL - Trading barrel with goods
                        // =============================
                        
                        // Wooden barrel
                        c.fillStyle = variant === 0 ? '#5D4037' : '#8B4513';
                        c.beginPath();
                        c.ellipse(cx - T*0.05, cy - T*0.05, T*0.15, T*0.2, 0, 0, 6.28);
                        c.fill();
                        
                        // Barrel bands
                        c.strokeStyle = '#4E342E';
                        c.lineWidth = 2;
                        c.beginPath();
                        c.ellipse(cx - T*0.05, cy - T*0.15, T*0.12, T*0.04, 0, 0, 6.28);
                        c.stroke();
                        c.beginPath();
                        c.ellipse(cx - T*0.05, cy + T*0.05, T*0.12, T*0.04, 0, 0, 6.28);
                        c.stroke();
                        
                        // Goods spilling out
                        if(variant >= 1) {
                            c.fillStyle = '#FFD700'; // Gold items
                            c.beginPath();
                            c.arc(cx + T*0.15, cy + T*0.1, T*0.04, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#8B7355'; // Brown goods
                            c.beginPath();
                            c.arc(cx + T*0.2, cy + T*0.02, T*0.03, 0, 6.28);
                            c.fill();
                        }
                        
                        // Trade sign
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx + T*0.1, cy - T*0.3, T*0.2, T*0.12);
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 8px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('âš–ï¸', cx + T*0.2, cy - T*0.2);
                        
                    } else if(lvl === 5) {
                        // =============================
                        // LEVEL 5: BLANKET MARKET - Trading blankets with goods
                        // =============================
                        
                        // Trading blanket on ground
                        c.fillStyle = variant === 0 ? '#6b6b6b' : '#CD853F';
                        c.fillRect(cx - T*0.3, cy - T*0.1, T*0.6, T*0.4);
                        c.strokeStyle = '#8B4513';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.3, cy - T*0.1, T*0.6, T*0.4);
                        
                        // Decorative pattern on blanket
                        c.strokeStyle = '#A0522D';
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx - T*0.25, cy);
                        c.lineTo(cx + T*0.25, cy);
                        c.moveTo(cx - T*0.25, cy + T*0.15);
                        c.lineTo(cx + T*0.25, cy + T*0.15);
                        c.stroke();
                        
                        // Zigzag pattern
                        for(let i = 0; i < 3; i++) {
                            let xOff = -T*0.2 + i * T*0.15;
                            c.beginPath();
                            c.moveTo(cx + xOff, cy - T*0.05);
                            c.lineTo(cx + xOff + T*0.075, cy + T*0.05);
                            c.lineTo(cx + xOff + T*0.15, cy - T*0.05);
                            c.stroke();
                        }
                        
                        // Trade goods on blanket
                        if(variant >= 1) {
                            c.fillStyle = '#FFE4B5'; // Shells
                            c.beginPath();
                            c.arc(cx - T*0.1, cy + T*0.08, T*0.04, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#8FBC8F'; // Herbs
                            c.fillRect(cx + T*0.05, cy + T*0.05, T*0.08, T*0.06);
                        }
                        
                        // Vendor sitting
                        if(variant >= 2) {
                            c.fillStyle = '#D4A574';
                            c.beginPath();
                            c.arc(cx - T*0.35, cy + T*0.1, T*0.06, 0, 6.28);
                            c.fill();
                        }
                        
                    } else if(lvl >= 6) {
                        // =============================
                        // LEVEL 6: BEAR MARKET - Large trading complex
                        // =============================
                        
                        // Large ground area
                        c.fillStyle = '#8B7355';
                        c.fillRect(x + T*0.05, y + T*0.1, T*0.9, T*0.75);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.05, y + T*0.1, T*0.9, T*0.75);
                        
                        // Trading shelter/awning
                        c.fillStyle = variant === 0 ? '#6b6b6b' : '#A0522D';
                        c.beginPath();
                        c.moveTo(x + T*0.1, y + T*0.25);
                        c.lineTo(x + T*0.5, y + T*0.05);
                        c.lineTo(x + T*0.9, y + T*0.25);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Support posts
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.12, y + T*0.25, T*0.04, T*0.35);
                        c.fillRect(x + T*0.84, y + T*0.25, T*0.04, T*0.35);
                        
                        // Multiple trading blankets
                        c.fillStyle = '#CD853F';
                        c.fillRect(x + T*0.15, y + T*0.45, T*0.25, T*0.2);
                        c.fillStyle = '#DEB887';
                        c.fillRect(x + T*0.55, y + T*0.45, T*0.25, T*0.2);
                        
                        // Bear icon sign (Bear Market)
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.12, y + T*0.7, T*0.24, T*0.14);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 1;
                        c.strokeRect(cx - T*0.12, y + T*0.7, T*0.24, T*0.14);
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸ»', cx, y + T*0.82);
                        
                        // Trade goods
                        if(variant >= 1) {
                            c.fillStyle = '#FFD700';
                            c.beginPath();
                            c.arc(x + T*0.25, y + T*0.52, T*0.03, 0, 6.28);
                            c.fill();
                            c.fillStyle = '#8B4513';
                            c.fillRect(x + T*0.6, y + T*0.5, T*0.1, T*0.08);
                        }
                    }

                    return;
                }
                
                // === NORMAL VIEW MODE ===
                // Simple colored square based on level - BLUE TONES for commercial
                let color = "#1565C0";  // Dark Blue base
                if(lvl === 2) color = "#1976D2"; // Level 2 - Fire Pit
                
                // Adjust for variant/activity
                if(variant === 0) color = '#5D4037'; // Abandoned - brown
                
                c.fillStyle = color;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);  // 1x1 tile
                
                // Border
                c.strokeStyle = '#333';
                c.lineWidth = 1;
                c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                
                // "C" label
                c.fillStyle = "#FFFFFF";
                c.font = "bold 16px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.fillText("C", cx, cy - 10);
                
                // Worker count (COM zones provide jobs)
                let pop = b.pop || 0;
                c.font = "bold 8px sans-serif";
                c.fillText(`ğŸ‘¥${pop}`, cx, cy + 2);
                
                // Level number
                c.font = "bold 10px sans-serif";
                c.fillText(`L${lvl}`, cx, cy + 12);
                
                // 3-Color Activity Bar (SNES SimCity style)
                let barWidth = T - 12;
                let barHeight = 4;
                let barX = x + 6;
                let barY = y + T - 8;
                
                // Background
                c.fillStyle = '#333';
                c.fillRect(barX, barY, barWidth, barHeight);
                
                // Activity color based on variant
                let activityColor = variant === 0 ? '#666' : variant === 1 ? '#FFEB3B' : variant === 2 ? '#4CAF50' : '#F44336';
                let activityWidth = variant === 0 ? 0 : (variant / 3) * barWidth;
                c.fillStyle = activityColor;
                c.fillRect(barX, barY, activityWidth, barHeight);
            },
            drawInd(c,x,y,b) { 
                let lvl = b.lvl || 1;
                let T = CFG.TILE;
                let cx = x + T/2, cy = y + T/2;  // Center for 1x1 tile
                
                // Get config and variant for this industrial level
                let levelConfig = CFG.INDUSTRIAL_LEVELS[lvl];
                let variant = b.variant || 1; // 0=abandoned, 1=low, 2=medium, 3=high
                
                // === BIRDS EYE VIEW MODE - SNES-style cute industrial buildings ===
                if(Game.vm === 'BIRDSEYE') {
                    
                    if(lvl === 1) {
                        // =============================
                        // LEVEL 1: BIRD HUNTING RANGE - Clean forest with sign
                        // =============================
                        
                        // Ground - clean grass
                        c.fillStyle = '#5A8D32';
                        c.fillRect(x, y, T, T);
                        
                        // Simple grass tufts
                        c.fillStyle = '#6BA33E';
                        c.beginPath();
                        c.ellipse(x + T*0.2, y + T*0.7, T*0.05, T*0.02, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.7, y + T*0.8, T*0.04, T*0.02, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - 2, cy + T*0.05, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.2, cy - T*0.2, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.2, cy - T*0.2, T*0.4, T*0.22);
                        
                        // Bird icon on sign
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸ¦', cx, cy - T*0.02);
                        
                    } else if(lvl === 2) {
                        // =============================
                        // LEVEL 2: GRUB DIGGING PIT - Dirt patch with sign
                        // =============================
                        
                        // Ground - dirt/soil
                        c.fillStyle = '#8B7355';
                        c.fillRect(x, y, T, T);
                        
                        // Digging pit (simple dark circle)
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.ellipse(cx - T*0.15, cy + T*0.15, T*0.2, T*0.12, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx + T*0.15, cy - T*0.1, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.05, cy - T*0.3, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.05, cy - T*0.3, T*0.4, T*0.22);
                        
                        // Worm/grub icon
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸª±', cx + T*0.15, cy - T*0.12);
                        
                    } else if(lvl === 3) {
                        // =============================
                        // LEVEL 3: STONE KNAPPING SITE - Rock area with sign
                        // =============================
                        
                        // Ground - rocky gray
                        c.fillStyle = '#9E9E9E';
                        c.fillRect(x, y, T, T);
                        
                        // A few rocks
                        c.fillStyle = '#757575';
                        c.beginPath();
                        c.ellipse(x + T*0.25, y + T*0.65, T*0.12, T*0.08, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.6, y + T*0.75, T*0.08, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - 2, cy - T*0.1, 4, T*0.35);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.2, cy - T*0.3, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.2, cy - T*0.3, T*0.4, T*0.22);
                        
                        // Stone icon
                        c.fillStyle = '#5D4037';
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸª¨', cx, cy - T*0.12);
                        
                    } else if(lvl === 4) {
                        // =============================
                        // LEVEL 4: TURTLE HUNTING GROUND - Wetland hunting area
                        // =============================
                        
                        // Ground - marshy/wetland
                        c.fillStyle = '#4A6E4A';
                        c.fillRect(x, y, T, T);
                        
                        // Water puddles
                        c.fillStyle = '#4A8BC2';
                        c.beginPath();
                        c.ellipse(x + T*0.25, y + T*0.6, T*0.15, T*0.08, 0, 0, 6.28);
                        c.fill();
                        c.beginPath();
                        c.ellipse(x + T*0.7, y + T*0.75, T*0.1, T*0.06, 0, 0, 6.28);
                        c.fill();
                        
                        // Reeds
                        c.strokeStyle = '#3E5E3E';
                        c.lineWidth = 2;
                        for(let i = 0; i < 4; i++) {
                            let rx = x + T*0.1 + i*T*0.08;
                            c.beginPath();
                            c.moveTo(rx, y + T*0.5);
                            c.lineTo(rx + (i%2 ? 2 : -2), y + T*0.3);
                            c.stroke();
                        }
                        
                        // Turtle shell decoration
                        c.fillStyle = '#5D4037';
                        c.beginPath();
                        c.ellipse(cx + T*0.1, cy - T*0.1, T*0.12, T*0.08, 0, 0, 6.28);
                        c.fill();
                        // Shell pattern
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 1;
                        c.beginPath();
                        c.moveTo(cx + T*0.1, cy - T*0.18);
                        c.lineTo(cx + T*0.1, cy - T*0.02);
                        c.moveTo(cx, cy - T*0.1);
                        c.lineTo(cx + T*0.22, cy - T*0.1);
                        c.stroke();
                        
                        // Hunting sign post
                        c.fillStyle = '#6D4C41';
                        c.fillRect(cx - T*0.2, cy - T*0.05, 4, T*0.3);
                        
                        // Sign board
                        c.fillStyle = '#D4B896';
                        c.fillRect(cx - T*0.38, cy - T*0.25, T*0.4, T*0.22);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(cx - T*0.38, cy - T*0.25, T*0.4, T*0.22);
                        
                        // Turtle icon
                        c.font = 'bold 14px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸ¢', cx - T*0.18, cy - T*0.07);
                        
                    } else if(lvl === 5) {
                        // =============================
                        // LEVEL 5: BEAR PIT - Hunting trap/processing area
                        // =============================
                        
                        // Ground - forest floor
                        c.fillStyle = '#5E4E3E';
                        c.fillRect(x, y, T, T);
                        
                        // Pit trap (dark hole with wooden edge)
                        c.fillStyle = '#1E1E1E';
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.25, T*0.15, 0, 0, 6.28);
                        c.fill();
                        
                        // Wooden pit frame
                        c.strokeStyle = '#6D4C41';
                        c.lineWidth = 4;
                        c.beginPath();
                        c.ellipse(cx, cy + T*0.1, T*0.27, T*0.17, 0, 0, 6.28);
                        c.stroke();
                        
                        // Stakes in pit (dangerous!)
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 2;
                        for(let i = 0; i < 3; i++) {
                            let sx = cx - T*0.1 + i*T*0.1;
                            c.beginPath();
                            c.moveTo(sx, cy + T*0.15);
                            c.lineTo(sx, cy + T*0.02);
                            c.stroke();
                        }
                        
                        // Bear hide on rack nearby
                        c.fillStyle = '#5D4037';
                        c.fillRect(x + T*0.05, cy - T*0.35, T*0.25, T*0.18);
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 1;
                        c.strokeRect(x + T*0.05, cy - T*0.35, T*0.25, T*0.18);
                        
                        // Drying rack posts
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.02, cy - T*0.4, 4, T*0.28);
                        c.fillRect(x + T*0.28, cy - T*0.4, 4, T*0.28);
                        
                        // Bear paw prints decoration
                        if(variant >= 2) {
                            c.fillStyle = '#4E3E2E';
                            c.font = 'bold 10px sans-serif';
                            c.fillText('ğŸ¾', x + T*0.75, y + T*0.25);
                        }
                        
                        // Sign
                        c.fillStyle = '#D4B896';
                        c.fillRect(x + T*0.65, cy - T*0.3, T*0.3, T*0.18);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.65, cy - T*0.3, T*0.3, T*0.18);
                        c.font = 'bold 12px sans-serif';
                        c.fillText('ğŸ»', x + T*0.8, cy - T*0.15);
                        
                    } else if(lvl >= 6) {
                        // =============================
                        // LEVEL 6: BUFFALO GROUNDS - Large hunting/processing complex
                        // =============================
                        
                        // Ground - plains grass
                        c.fillStyle = '#8B9B68';
                        c.fillRect(x, y, T, T);
                        
                        // Tall prairie grass patches
                        c.fillStyle = '#A8B87A';
                        for(let i = 0; i < 5; i++) {
                            let gx = x + T*0.1 + i*T*0.18;
                            let gy = y + T*0.6 + (i%2)*T*0.15;
                            c.beginPath();
                            c.ellipse(gx, gy, T*0.06, T*0.03, 0, 0, 6.28);
                            c.fill();
                        }
                        
                        // Processing shelter (larger structure)
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.55, y + T*0.15, T*0.4, T*0.35);
                        c.strokeStyle = '#3E2723';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.55, y + T*0.15, T*0.4, T*0.35);
                        
                        // Thatched roof
                        c.fillStyle = '#D4B896';
                        c.beginPath();
                        c.moveTo(x + T*0.5, y + T*0.17);
                        c.lineTo(x + T*0.75, y - T*0.05);
                        c.lineTo(x + T, y + T*0.17);
                        c.closePath();
                        c.fill();
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 1;
                        c.stroke();
                        
                        // Buffalo hide drying racks
                        c.fillStyle = '#8B4513';
                        c.fillRect(x + T*0.05, y + T*0.2, T*0.35, T*0.02);
                        // Posts
                        c.fillStyle = '#6D4C41';
                        c.fillRect(x + T*0.05, y + T*0.2, 4, T*0.35);
                        c.fillRect(x + T*0.38, y + T*0.2, 4, T*0.35);
                        
                        // Hanging hides
                        c.fillStyle = '#A0522D';
                        c.fillRect(x + T*0.1, y + T*0.22, T*0.12, T*0.2);
                        c.fillRect(x + T*0.25, y + T*0.22, T*0.1, T*0.18);
                        
                        // Buffalo skull decoration
                        c.fillStyle = '#F5F5DC';
                        c.beginPath();
                        c.ellipse(x + T*0.2, y + T*0.7, T*0.08, T*0.05, 0, 0, 6.28);
                        c.fill();
                        // Horns
                        c.strokeStyle = '#8B7355';
                        c.lineWidth = 3;
                        c.beginPath();
                        c.arc(x + T*0.2, y + T*0.7, T*0.12, Math.PI*1.1, Math.PI*1.5);
                        c.stroke();
                        c.beginPath();
                        c.arc(x + T*0.2, y + T*0.7, T*0.12, Math.PI*1.5, Math.PI*1.9);
                        c.stroke();
                        
                        // Smoke from processing (if active)
                        if(variant > 0) {
                            let t = (Renderer.time || 0);
                            for(let i = 0; i < 2; i++) {
                                let puffY = y - T*0.1 - i*5 - Math.sin(t*0.7 + i)*2;
                                let puffX = x + T*0.75 + Math.sin(t*0.5 + i)*2;
                                c.fillStyle = `rgba(150,150,150,${0.35 - i*0.12})`;
                                c.beginPath();
                                c.arc(puffX, puffY, 3 - i*0.5, 0, 6.28);
                                c.fill();
                            }
                        }
                        
                        // Buffalo icon sign
                        c.fillStyle = '#D4B896';
                        c.fillRect(x + T*0.6, y + T*0.55, T*0.3, T*0.18);
                        c.strokeStyle = '#5D4037';
                        c.lineWidth = 2;
                        c.strokeRect(x + T*0.6, y + T*0.55, T*0.3, T*0.18);
                        c.font = 'bold 12px sans-serif';
                        c.textAlign = 'center';
                        c.fillText('ğŸ¦¬', x + T*0.75, y + T*0.68);
                    }
                    
                    return;
                }
                
                // === NORMAL VIEW MODE ===
                // Color based on level - BROWN/ORANGE tones for industrial
                let color = '#8D6E63';  // Brown base
                if(lvl === 2) color = '#795548';  // Darker brown for Level 2
                if(lvl === 3) color = '#6D4C41';  // Even darker for Level 3
                if(lvl === 4) color = '#5D4037';  // Darkest for Level 4
                
                // Adjust for variant/activity
                if(variant === 0) color = '#424242'; // Abandoned - gray
                else if(variant === 3) color = '#FF5722'; // High activity - orange
                
                c.fillStyle = color;
                c.fillRect(x + 2, y + 2, T - 4, T - 4);  // 1x1 tile
                
                // Border
                c.strokeStyle = variant === 3 ? '#FFD700' : '#333';
                c.lineWidth = variant === 3 ? 2 : 1;
                c.strokeRect(x + 2, y + 2, T - 4, T - 4);
                
                // "I" label
                c.fillStyle = "#FFFFFF";
                c.font = "bold 16px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.fillText("I", cx, cy - 10);
                
                // Worker count
                let pop = b.pop || 0;
                c.font = "bold 8px sans-serif";
                c.fillText(`ğŸ‘¥${pop}`, cx, cy + 2);
                
                // Level number
                c.font = "bold 10px sans-serif";
                c.fillText(`L${lvl}`, cx, cy + 12);
                
                // 3-Color Activity Bar (SNES SimCity style)
                let barWidth = T - 12;
                let barHeight = 4;
                let barX = x + 6;
                let barY = y + T - 8;
                
                // Background
                c.fillStyle = '#333';
                c.fillRect(barX, barY, barWidth, barHeight);
                
                // Activity color based on variant: Yellow=Low, Green=Medium, Red=High
                let activityColor = variant === 0 ? '#666' : variant === 1 ? '#FFEB3B' : variant === 2 ? '#4CAF50' : '#F44336';
                let activityWidth = variant === 0 ? 0 : (variant / 3) * barWidth;
                c.fillStyle = activityColor;
                c.fillRect(barX, barY, activityWidth, barHeight);
            },
            drawWell(c,x,y) {
                let T = CFG.TILE;
                let cx = x + T * 0.5;
                let cy = y + T * 0.55;

                // Drop shadow (smaller, offset)
                c.save();
                c.fillStyle = 'rgba(0,0,0,0.25)';
                c.beginPath();
                c.ellipse(cx + T*0.08, cy + T*0.08, T*0.18, T*0.09, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden rim (elliptical, plank tone gradient)
                let rimGrad = c.createLinearGradient(cx, cy - T*0.12, cx, cy + T*0.12);
                rimGrad.addColorStop(0, '#8D6E63');
                rimGrad.addColorStop(1, '#5D4037');
                c.fillStyle = rimGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.18, T*0.12, 0, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#4E342E';
                c.lineWidth = 2;
                c.stroke();

                // Ambient occlusion under rim
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#000';
                c.beginPath();
                c.ellipse(cx, cy + T*0.03, T*0.17, T*0.11, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Water surface (inner ellipse with highlight)
                let waterGrad = c.createLinearGradient(cx, cy - T*0.08, cx, cy + T*0.08);
                waterGrad.addColorStop(0, '#81D4FA');
                waterGrad.addColorStop(1, '#29B6F6');
                c.fillStyle = waterGrad;
                c.beginPath();
                c.ellipse(cx, cy, T*0.12, T*0.08, 0, 0, Math.PI*2);
                c.fill();
                // Highlight
                c.save();
                c.globalAlpha = 0.25;
                c.fillStyle = '#FFFFFF';
                c.beginPath();
                c.ellipse(cx - T*0.04, cy - T*0.03, T*0.06, T*0.03, 0, 0, Math.PI*2);
                c.fill();
                c.restore();

                // Wooden posts (left/right) and crossbeam
                let postW = T*0.04, postH = T*0.22;
                let postY = cy - T*0.22;
                c.fillStyle = '#6D4C41';
                // Left post
                c.fillRect(cx - T*0.16, postY, postW, postH);
                // Right post
                c.fillRect(cx + T*0.12, postY, postW, postH);
                // Crossbeam
                c.fillStyle = '#8D6E63';
                c.fillRect(cx - T*0.16, postY - T*0.02, T*0.32 + postW, T*0.03);

                // Rope + bucket hint
                c.strokeStyle = '#D7CCC8';
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(cx, postY);
                c.lineTo(cx, cy - T*0.03);
                c.stroke();
                c.fillStyle = '#5D4037';
                c.fillRect(cx - T*0.015, cy - T*0.03, T*0.03, T*0.02);
            },
            drawChief(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Shadow
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                // Main structure - ornate building
                c.fillStyle = "#8B7355";
                c.fillRect(x + 15, y + 30, T*2 - 30, T*2 - 40);
                
                // Columns (4 columns)
                c.fillStyle = "#D4C5B9";
                for(let i = 0; i < 4; i++) {
                    c.fillRect(x + 20 + i * 28, y + 30, 8, T*2 - 40);
                }
                
                // Roof with triangular pediment
                c.fillStyle = "#CD853F";
                c.beginPath();
                c.moveTo(x + 10, y + 30);
                c.lineTo(x + T*2 - 10, y + 30);
                c.lineTo(cx, y + 5);
                c.closePath();
                c.fill();
                
                // Decorative elements
                c.fillStyle = "#FFD700";
                c.beginPath();
                c.arc(cx, y + 15, 8, 0, 6.28);
                c.fill();
                
                // Door
                c.fillStyle = "#654321";
                c.fillRect(cx - 12, cy + 35, 24, 35);
                
                // Cultural symbol (fire bowl on top)
                c.fillStyle = "#FF6347";
                c.beginPath();
                c.arc(cx, y + 8, 6, 0, 6.28);
                c.fill();
                
                    // Smoke/culture particles
                if(Math.random() > 0.5) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 5, 
                        40, 
                        "rgba(255, 215, 0, 0.7)"
                    );
                    if(p) Renderer.particles.push(p);
                }                // Label
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("CHIEF'S HUT", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${Math.floor(CFG.CHIEF_BONUS*100)}% Culture Bonus`, cx, y + T*2 + 27);
            },
            drawClanChief(c,x,y,b) {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // CLAN CHIEF'S HUT - 2x2 Milestone Building
                // Unlocks Level 4-6 buildings
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                // Shadow
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 8, y + 12, T*2 - 16, T*2 - 12);
                
                // Stone foundation
                c.fillStyle = "#7E7E7E";
                c.fillRect(x + 10, y + T*2 - 25, T*2 - 20, 20);
                
                // Main wooden structure
                c.fillStyle = "#8B4513";
                c.fillRect(x + 15, y + 35, T*2 - 30, T*2 - 60);
                
                // Log texture
                c.strokeStyle = "#5D3D2D";
                c.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.moveTo(x + 15, y + 40 + i * 10);
                    c.lineTo(x + T*2 - 15, y + 40 + i * 10);
                    c.stroke();
                }
                
                // Sloped roof with bark
                c.fillStyle = "#3E5E3E";
                c.beginPath();
                c.moveTo(x + 5, y + 37);
                c.lineTo(cx, y + 5);
                c.lineTo(x + T*2 - 5, y + 37);
                c.closePath();
                c.fill();
                c.strokeStyle = "#2E4E2E";
                c.lineWidth = 2;
                c.stroke();
                
                // Roof texture lines
                c.strokeStyle = "#2E4E2E";
                c.lineWidth = 1;
                for(let i = 0; i < 4; i++) {
                    let xOff = -25 + i * 18;
                    c.beginPath();
                    c.moveTo(cx + xOff, y + 35);
                    c.lineTo(cx + xOff * 0.3, y + 12);
                    c.stroke();
                }
                
                // Totem pole (cultural symbol)
                c.fillStyle = "#A0522D";
                c.fillRect(x + T*2 - 25, y + 25, 12, T*2 - 35);
                
                // Totem face
                c.fillStyle = "#FFD700";
                c.beginPath();
                c.arc(x + T*2 - 19, y + 40, 8, 0, 6.28);
                c.fill();
                
                // Totem eyes
                c.fillStyle = "#1E0E00";
                c.beginPath();
                c.arc(x + T*2 - 22, y + 38, 2, 0, 6.28);
                c.arc(x + T*2 - 16, y + 38, 2, 0, 6.28);
                c.fill();
                
                // Totem beak/mouth
                c.fillStyle = "#CD853F";
                c.beginPath();
                c.moveTo(x + T*2 - 19, y + 42);
                c.lineTo(x + T*2 - 15, y + 46);
                c.lineTo(x + T*2 - 23, y + 46);
                c.closePath();
                c.fill();
                
                // Large entrance doorway
                c.fillStyle = "#2E1E0E";
                c.beginPath();
                c.arc(cx - 10, y + T*2 - 30, 15, Math.PI, 0, false);
                c.lineTo(cx + 5, y + T*2 - 5);
                c.lineTo(cx - 25, y + T*2 - 5);
                c.closePath();
                c.fill();
                
                // Fire bowl at entrance
                c.fillStyle = "#5D4037";
                c.beginPath();
                c.ellipse(cx + 20, y + T*2 - 15, 10, 6, 0, 0, 6.28);
                c.fill();
                
                // Fire flames
                if(Math.random() > 0.3) {
                    c.fillStyle = "#FF6347";
                    let flameHeight = 8 + Math.random() * 4;
                    c.beginPath();
                    c.moveTo(cx + 15, y + T*2 - 17);
                    c.lineTo(cx + 20, y + T*2 - 17 - flameHeight);
                    c.lineTo(cx + 25, y + T*2 - 17);
                    c.closePath();
                    c.fill();
                }
                
                // Cultural smoke particles
                if(Math.random() > 0.7) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 5, 
                        40, 
                        "rgba(200, 200, 200, 0.5)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                // Label
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("CLAN CHIEF'S HUT", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillStyle = "#FFFFFF";
                c.fillText("Unlocks L4-L6 Buildings", cx, y + T*2 + 27);
            },
            drawDock(c,x,y,b) {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TRADING DOCK - 3x2 Milestone Building
                // Unlocks Level 7+ buildings
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let T = CFG.TILE;
                let cx = x + T*1.5, cy = y + T;
                
                // Water underneath (extends beyond building)
                c.fillStyle = "#4A8BC2";
                c.fillRect(x, y + T*0.8, T*3, T*1.2);
                
                // Water ripples
                c.strokeStyle = "#6BB3D9";
                c.lineWidth = 1;
                for(let i = 0; i < 4; i++) {
                    c.beginPath();
                    c.arc(x + T*0.5 + i*T*0.7, y + T*1.3, 8 + i*3, 0, Math.PI);
                    c.stroke();
                }
                
                // Main dock platform (wooden planks)
                c.fillStyle = "#8B7355";
                c.fillRect(x + T*0.3, y + T*0.4, T*2.4, T*0.5);
                
                // Plank lines
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                for(let i = 0; i < 8; i++) {
                    let px = x + T*0.35 + i * T*0.3;
                    c.beginPath();
                    c.moveTo(px, y + T*0.4);
                    c.lineTo(px, y + T*0.9);
                    c.stroke();
                }
                
                // Support posts going into water
                c.fillStyle = "#6D4C41";
                c.fillRect(x + T*0.5, y + T*0.9, T*0.15, T*0.7);
                c.fillRect(x + T*1.4, y + T*0.9, T*0.15, T*0.7);
                c.fillRect(x + T*2.3, y + T*0.9, T*0.15, T*0.7);
                
                // Dock shelter/warehouse
                c.fillStyle = "#A0522D";
                c.fillRect(x + T*0.8, y + T*0.05, T*1.4, T*0.4);
                c.strokeStyle = "#5D3D2D";
                c.lineWidth = 2;
                c.strokeRect(x + T*0.8, y + T*0.05, T*1.4, T*0.4);
                
                // Thatched roof
                c.fillStyle = "#D4B896";
                c.beginPath();
                c.moveTo(x + T*0.6, y + T*0.07);
                c.lineTo(x + T*1.5, y - T*0.2);
                c.lineTo(x + T*2.4, y + T*0.07);
                c.closePath();
                c.fill();
                c.strokeStyle = "#8B7355";
                c.lineWidth = 1;
                c.stroke();
                
                // Trade goods barrels/crates
                c.fillStyle = "#8B4513";
                // Barrel
                c.beginPath();
                c.ellipse(x + T*0.95, y + T*0.25, T*0.08, T*0.12, 0, 0, 6.28);
                c.fill();
                // Crate
                c.fillStyle = "#A0826D";
                c.fillRect(x + T*1.8, y + T*0.15, T*0.2, T*0.2);
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                c.strokeRect(x + T*1.8, y + T*0.15, T*0.2, T*0.2);
                
                // Boat moored at dock
                c.fillStyle = "#6D4C41";
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*1.2);
                c.lineTo(x + T*2.9, y + T*1.35);
                c.lineTo(x + T*2.5, y + T*1.5);
                c.lineTo(x + T*2.2, y + T*1.35);
                c.closePath();
                c.fill();
                
                // Boat mast
                c.strokeStyle = "#5D4037";
                c.lineWidth = 2;
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*1.35);
                c.lineTo(x + T*2.5, y + T*0.95);
                c.stroke();
                
                // Sail
                c.fillStyle = "#F5F5DC";
                c.beginPath();
                c.moveTo(x + T*2.5, y + T*0.98);
                c.lineTo(x + T*2.7, y + T*1.15);
                c.lineTo(x + T*2.5, y + T*1.25);
                c.closePath();
                c.fill();
                
                // Rope ties
                c.strokeStyle = "#D7CCC8";
                c.lineWidth = 1;
                c.beginPath();
                c.moveTo(x + T*2.3, y + T*0.85);
                c.lineTo(x + T*2.35, y + T*1.2);
                c.stroke();
                
                // Trading post sign
                c.fillStyle = "#F5DEB3";
                c.fillRect(x + T*0.4, y + T*0.55, T*0.35, T*0.2);
                c.strokeStyle = "#5D4037";
                c.lineWidth = 1;
                c.strokeRect(x + T*0.4, y + T*0.55, T*0.35, T*0.2);
                c.fillStyle = "#5D4037";
                c.font = "bold 8px sans-serif";
                c.textAlign = "center";
                c.fillText("âš“", x + T*0.57, y + T*0.7);
                
                // Label
                c.fillStyle = "#4A8BC2";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.textBaseline = "bottom";
                c.fillText("TRADING DOCK", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillStyle = "#FFFFFF";
                c.fillText("Unlocks L7+ Buildings", cx, y + T*2 + 27);
            },
            drawBasket(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#D2691E";
                c.fillRect(x + 20, y + 40, T*2 - 40, T*2 - 50);
                
                c.strokeStyle = "#8B4513";
                c.lineWidth = 2;
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.moveTo(x + 20, y + 40 + i * 6);
                    c.lineTo(x + T*2 - 20, y + 40 + i * 6);
                    c.stroke();
                }
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("BASKET", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.BASKET.cap} storage`, cx, y + T*2 + 27);
            },
            drawPottery(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.beginPath();
                c.moveTo(x + 30, y + 60);
                c.quadraticCurveTo(x + 25, y + 40, x + 35, y + 35);
                c.lineTo(x + T*2 - 35, y + 35);
                c.quadraticCurveTo(x + T*2 - 25, y + 40, x + T*2 - 30, y + 60);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#DAA520";
                c.fillRect(x + 35, y + 30, T*2 - 70, 5);
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("POTTERY", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.POTTERY.cap} storage`, cx, y + T*2 + 27);
            },
            drawGranary(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.2)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#A0826D";
                c.fillRect(x + 25, y + 35, T*2 - 50, T*2 - 45);
                
                c.fillStyle = "#8B7355";
                c.beginPath();
                c.moveTo(x + 20, y + 35);
                c.lineTo(x + T*2 - 20, y + 35);
                c.lineTo(cx, y + 15);
                c.closePath();
                c.fill();
                
                for(let i = 0; i < 3; i++) {
                    c.fillStyle = "#654321";
                    c.fillRect(x + 30 + i * 20, y + 45, 8, 30);
                }
                
                c.fillStyle = "#CD853F";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("GRANARY", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.GRANARY.cap} storage`, cx, y + T*2 + 27);
            },
            drawPalace(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T, cy = y + T;
                
                c.fillStyle = "rgba(0,0,0,0.3)";
                c.fillRect(x + 10, y + 15, T*2 - 20, T*2 - 15);
                
                c.fillStyle = "#B8860B";
                c.fillRect(x + 20, y + 30, T*2 - 40, T*2 - 35);
                
                c.fillStyle = "#FFD700";
                for(let i = 0; i < 5; i++) {
                    c.fillRect(x + 25 + i * 18, y + 30, 6, T*2 - 35);
                }
                
                c.fillStyle = "#DAA520";
                c.beginPath();
                c.moveTo(x + 15, y + 30);
                c.lineTo(x + T*2 - 15, y + 30);
                c.lineTo(cx, y + 10);
                c.closePath();
                c.fill();
                
                c.fillStyle = "#FF6347";
                c.beginPath();
                c.arc(cx, y + 15, 5, 0, 6.28);
                c.fill();
                
                if(Math.random() > 0.7) {
                    const p = Game.getPooledParticle(
                        cx + (Math.random() - 0.5) * 10, 
                        y + 10, 
                        30, 
                        "rgba(255, 215, 0, 0.8)"
                    );
                    if(p) Renderer.particles.push(p);
                }
                
                c.fillStyle = "#FFD700";
                c.font = "bold 10px sans-serif";
                c.textAlign = "center";
                c.fillText("PALACE", cx, y + T*2 + 15);
                c.font = "9px sans-serif";
                c.fillText(`+${CFG.BUILDINGS.PALACE.cap} storage`, cx, y + T*2 + 27);
            },
            drawStoragePit(c,x,y,b) {
                let T = CFG.TILE;
                let cx = x + T/2;
                let cy = y + T/2;

                // Base pit (common shape)
                c.fillStyle = '#5D4037';
                c.beginPath();
                c.ellipse(cx, cy + T*0.05, T*0.28, T*0.18, 0, 0, Math.PI*2);
                c.fill();
                c.fillStyle = '#3E2723';
                c.beginPath();
                c.ellipse(cx, cy + T*0.03, T*0.22, T*0.14, 0, 0, Math.PI*2);
                c.fill();

                // Resource-specific item inside pit
                if(b.t === 'FOOD_PIT') {
                    // Meat chunk icon
                    c.fillStyle = '#C62828';
                    c.beginPath();
                    c.arc(cx - T*0.06, cy + T*0.02, T*0.06, 0, Math.PI*2);
                    c.fill();
                    c.fillStyle = '#FFF';
                    c.beginPath();
                    c.arc(cx - T*0.06, cy + T*0.02, T*0.02, 0, Math.PI*2);
                    c.fill();
                } else if(b.t === 'WOOD_PIT') {
                    // Small log
                    c.fillStyle = '#8D6E63';
                    c.beginPath();
                    c.ellipse(cx, cy + T*0.02, T*0.12, T*0.06, 0, 0, Math.PI*2);
                    c.fill();
                    c.strokeStyle = '#5D4037';
                    c.lineWidth = 1;
                    c.beginPath();
                    c.arc(cx + T*0.08, cy + T*0.02, T*0.015, 0, Math.PI*2);
                    c.stroke();
                } else if(b.t === 'STONE_PIT') {
                    // Rock chunk
                    c.fillStyle = '#9E9E9E';
                    c.beginPath();
                    c.moveTo(cx - T*0.1, cy);
                    c.lineTo(cx, cy - T*0.08);
                    c.lineTo(cx + T*0.08, cy + T*0.02);
                    c.lineTo(cx - T*0.02, cy + T*0.06);
                    c.closePath();
                    c.fill();
                } else if(b.t === 'METAL_PIT') {
                    // Gear shape (simplified)
                    c.fillStyle = '#616161';
                    c.beginPath();
                    c.arc(cx, cy, T*0.06, 0, Math.PI*2);
                    c.fill();
                    c.strokeStyle = '#424242';
                    c.lineWidth = 2;
                    for(let i=0;i<6;i++){
                        let ang = i * Math.PI/3;
                        c.beginPath();
                        c.moveTo(cx + Math.cos(ang)*T*0.06, cy + Math.sin(ang)*T*0.06);
                        c.lineTo(cx + Math.cos(ang)*T*0.09, cy + Math.sin(ang)*T*0.09);
                        c.stroke();
                    }
                }

                // Label (small)
                c.fillStyle = '#fff';
                c.font = 'bold 8px sans-serif';
                c.textAlign = 'center';
                let label = b.t === 'FOOD_PIT' ? 'FOOD' : b.t === 'WOOD_PIT' ? 'WOOD' : b.t === 'STONE_PIT' ? 'STONE' : 'METAL';
                c.fillText(label, cx, y + T - 6);
            },
            drawIcon(c,x,y,txt,color) { c.fillStyle=color; c.font="bold 24px sans-serif"; c.textAlign="center"; c.textBaseline="middle"; c.fillText(txt, x, y); },
            drawGrain(c,x,y) { 
                let T = CFG.TILE;
                let scale = T/64;
                c.fillStyle="#F9A825";
                // Use deterministic positions based on tile coordinates to prevent movement
                const tx = Math.floor(x / T);
                const ty = Math.floor(y / T);
                // Create pseudo-random but fixed positions using tile coords
                for(let i=0;i<4;i++) {
                    const seed = (tx * 7 + ty * 13 + i * 31) % 1000;
                    const px = x + (seed % T);
                    const py = y + ((seed * 17) % T);
                    c.fillRect(px, py, 3*scale, 3*scale);
                }
            },
            drawParticles(c) { 
                for (let i=this.particles.length-1; i>=0; i--) { 
                    let p=this.particles[i]; 
                    p.y-=1; 
                    p.l--; 
                    c.fillStyle=p.c; 
                    c.beginPath(); 
                    c.arc(p.x, p.y, 5, 0, 6.28); 
                    c.fill(); 
                    if(p.l<=0) {
                        if(p.active !== undefined) p.active = false; // Return to pool
                        this.particles.splice(i,1);
                    }
                } 
            }
        };

        // --- SOUND SYSTEM ---
        const SoundFX = {
            audioCtx: null,
            enabled: true,
            master: null,
            wetBus: null,
            convolver: null,
            _initialized: false,
            
            // Helper: create noise buffer
            _noiseSource(durationSec) {
                const ctx = this.audioCtx;
                const buffer = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * durationSec), ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0;i<data.length;i++) data[i] = Math.random()*2 - 1;
                const src = ctx.createBufferSource();
                src.buffer = buffer;
                return src;
            },
            
            // Helper: create impulse response for reverb
            _createImpulse(seconds, decay) {
                const ctx = this.audioCtx;
                const length = Math.floor(ctx.sampleRate * seconds);
                const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
                for(let c=0;c<2;c++){
                    const ch = impulse.getChannelData(c);
                    for(let i=0;i<length;i++) {
                        ch[i] = (Math.random()*2 - 1) * Math.pow(1 - i/length, decay);
                    }
                }
                return impulse;
            },
            
            // Helper: send to reverb
            _sendToReverb(node, wet=0.15) {
                if(!this.convolver) return;
                const send = this.audioCtx.createGain();
                send.gain.value = wet;
                node.connect(send);
                send.connect(this.convolver);
            },
            
            init() {
                if(this._initialized) return;
                try {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    // Master routing
                    this.master = this.audioCtx.createGain();
                    this.master.gain.value = 0.9;
                    this.master.connect(this.audioCtx.destination);

                    // Simple small-room reverb (now helpers are defined)
                    this.wetBus = this.audioCtx.createGain();
                    this.wetBus.gain.value = 0.22;
                    this.convolver = this.audioCtx.createConvolver();
                    this.convolver.buffer = this._createImpulse(0.18, 1.8);
                    this.wetBus.connect(this.audioCtx.destination);
                    this.convolver.connect(this.wetBus);
                    this._initialized = true;
                    console.log('[SoundFX] Initialized successfully');
                } catch(e) {
                    console.log('[SoundFX] Audio not supported:', e);
                    this.enabled = false;
                }
            },
            
            // Resume audio context (needed for browsers that suspend it)
            resume() {
                if(this.audioCtx && this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }
            },
            
            // Realistic layered collection sounds (sample-free synthesis)
            playCollect(type) {
                console.log('[SoundFX] playCollect called with type:', type, 'enabled:', this.enabled, 'audioCtx:', !!this.audioCtx);
                if(!this.enabled || !this.audioCtx) return;
                this.resume();

                const ctx = this.audioCtx;
                const now = ctx.currentTime;

                const rnd = (min, max) => min + Math.random()*(max-min);
                
                if(type === 'food') {
                    // FOOD: Juicy berry squish + stem snap + satisfied grunt
                    
                    // 1. Wet squish (low filtered noise burst)
                    const squish = this._noiseSource(0.15);
                    const squishLP = ctx.createBiquadFilter();
                    squishLP.type = 'lowpass'; squishLP.frequency.value = rnd(400, 600);
                    const squishG = ctx.createGain();
                    squishG.gain.setValueAtTime(0, now);
                    squishG.gain.linearRampToValueAtTime(0.5, now + 0.02);
                    squishG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    squish.connect(squishLP); squishLP.connect(squishG); squishG.connect(this.master);
                    squish.start(now); squish.stop(now + 0.15);
                    
                    // 2. Stem snap (high click)
                    const snap = ctx.createOscillator(); snap.type = 'square';
                    snap.frequency.setValueAtTime(rnd(1800, 2400), now);
                    snap.frequency.exponentialRampToValueAtTime(800, now + 0.015);
                    const snapG = ctx.createGain();
                    snapG.gain.setValueAtTime(0.3, now);
                    snapG.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
                    snap.connect(snapG); snapG.connect(this.master);
                    snap.start(now); snap.stop(now + 0.03);
                    
                    // 3. Satisfied caveman grunt (low formant)
                    const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                    grunt.frequency.setValueAtTime(rnd(95, 115), now + 0.08);
                    grunt.frequency.linearRampToValueAtTime(rnd(80, 95), now + 0.22);
                    const gruntLP = ctx.createBiquadFilter(); gruntLP.type = 'lowpass'; gruntLP.frequency.value = 350;
                    const gruntG = ctx.createGain();
                    gruntG.gain.setValueAtTime(0, now + 0.08);
                    gruntG.gain.linearRampToValueAtTime(0.18, now + 0.1);
                    gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    grunt.connect(gruntLP); gruntLP.connect(gruntG); gruntG.connect(this.master);
                    this._sendToReverb(gruntG, 0.15);
                    grunt.start(now + 0.08); grunt.stop(now + 0.28);
                    return;
                }

                if(type === 'wood') {
                    // WOOD: Axe impact + wood fiber crack + resonant body
                    
                    // 1. Sharp axe impact (broadband attack)
                    const impact = this._noiseSource(0.04);
                    const impactBP = ctx.createBiquadFilter(); impactBP.type = 'bandpass'; impactBP.frequency.value = rnd(1200, 1800); impactBP.Q.value = 1.5;
                    const impactG = ctx.createGain();
                    impactG.gain.setValueAtTime(0.45, now);
                    impactG.gain.exponentialRampToValueAtTime(0.001, now + 0.035);
                    impact.connect(impactBP); impactBP.connect(impactG); impactG.connect(this.master);
                    impact.start(now); impact.stop(now + 0.04);
                    
                    // 2. Wood fiber cracking (multiple short bursts)
                    for(let i = 0; i < 3; i++) {
                        const crack = this._noiseSource(0.025);
                        const crackHP = ctx.createBiquadFilter(); crackHP.type = 'highpass'; crackHP.frequency.value = rnd(2000, 3500);
                        const crackG = ctx.createGain();
                        const t = now + 0.02 + i * 0.015;
                        crackG.gain.setValueAtTime(rnd(0.15, 0.25), t);
                        crackG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                        crack.connect(crackHP); crackHP.connect(crackG); crackG.connect(this.master);
                        crack.start(t); crack.stop(t + 0.03);
                    }
                    
                    // 3. Resonant wood body thunk (low frequency)
                    const body = ctx.createOscillator(); body.type = 'sine';
                    body.frequency.setValueAtTime(rnd(85, 110), now);
                    body.frequency.exponentialRampToValueAtTime(rnd(55, 70), now + 0.15);
                    const bodyG = ctx.createGain();
                    bodyG.gain.setValueAtTime(0, now);
                    bodyG.gain.linearRampToValueAtTime(0.35, now + 0.008);
                    bodyG.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    body.connect(bodyG); bodyG.connect(this.master);
                    this._sendToReverb(bodyG, 0.08);
                    body.start(now); body.stop(now + 0.2);
                    return;
                }

                if(type === 'metal') {
                    // METAL: Realistic ore chunk clinking with metallic ring
                    
                    // 1. Sharp metallic impact
                    const strike = this._noiseSource(0.02);
                    const strikeHP = ctx.createBiquadFilter(); strikeHP.type = 'highpass'; strikeHP.frequency.value = 2500;
                    const strikeG = ctx.createGain();
                    strikeG.gain.setValueAtTime(0.3, now);
                    strikeG.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                    strike.connect(strikeHP); strikeHP.connect(strikeG); strikeG.connect(this.master);
                    strike.start(now); strike.stop(now + 0.025);
                    
                    // 2. Metallic ring (inharmonic partials)
                    const partials = [1, 2.4, 4.5, 6.7]; // Inharmonic like real metal
                    const baseFreq = rnd(380, 450);
                    partials.forEach((ratio, i) => {
                        const o = ctx.createOscillator(); o.type = 'sine';
                        const f = baseFreq * ratio;
                        o.frequency.setValueAtTime(f, now);
                        // Slight frequency wobble for realism
                        o.frequency.setValueAtTime(f * 1.002, now + 0.1);
                        const g = ctx.createGain();
                        const vol = 0.18 / (i + 1);
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(vol, now + 0.003);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.25 - i * 0.03);
                        o.connect(g); g.connect(this.master);
                        if(i === 0) this._sendToReverb(g, 0.2);
                        o.start(now); o.stop(now + 0.3);
                    });
                    
                    // 3. Low thud (stone/ore mass)
                    const thud = ctx.createOscillator(); thud.type = 'sine';
                    thud.frequency.setValueAtTime(rnd(100, 130), now);
                    thud.frequency.exponentialRampToValueAtTime(60, now + 0.1);
                    const thudG = ctx.createGain();
                    thudG.gain.setValueAtTime(0, now);
                    thudG.gain.linearRampToValueAtTime(0.2, now + 0.005);
                    thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    thud.connect(thudG); thudG.connect(this.master);
                    thud.start(now); thud.stop(now + 0.15);
                    return;
                }

                if(type === 'stone') {
                    // STONE: Rocks clacking together + grinding
                    
                    // 1. Primary clack (two stones hitting)
                    const clack1 = this._noiseSource(0.03);
                    const clack1BP = ctx.createBiquadFilter(); clack1BP.type = 'bandpass'; clack1BP.frequency.value = rnd(800, 1100); clack1BP.Q.value = 2;
                    const clack1G = ctx.createGain();
                    clack1G.gain.setValueAtTime(0.4, now);
                    clack1G.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                    clack1.connect(clack1BP); clack1BP.connect(clack1G); clack1G.connect(this.master);
                    clack1.start(now); clack1.stop(now + 0.04);
                    
                    // 2. Secondary bounce clack
                    const clack2 = this._noiseSource(0.02);
                    const clack2BP = ctx.createBiquadFilter(); clack2BP.type = 'bandpass'; clack2BP.frequency.value = rnd(700, 900); clack2BP.Q.value = 2.5;
                    const clack2G = ctx.createGain();
                    clack2G.gain.setValueAtTime(0.2, now + 0.06);
                    clack2G.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
                    clack2.connect(clack2BP); clack2BP.connect(clack2G); clack2G.connect(this.master);
                    clack2.start(now + 0.06); clack2.stop(now + 0.1);
                    
                    // 3. Low frequency mass thump
                    const thump = ctx.createOscillator(); thump.type = 'sine';
                    thump.frequency.setValueAtTime(rnd(70, 95), now);
                    thump.frequency.exponentialRampToValueAtTime(45, now + 0.08);
                    const thumpG = ctx.createGain();
                    thumpG.gain.setValueAtTime(0, now);
                    thumpG.gain.linearRampToValueAtTime(0.25, now + 0.005);
                    thumpG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    thump.connect(thumpG); thumpG.connect(this.master);
                    this._sendToReverb(thumpG, 0.06);
                    thump.start(now); thump.stop(now + 0.12);
                    return;
                }

                if(type === 'population') {
                    // POPULATION: Caveman greeting call + response
                    
                    // 1. First voice "OOH" (formant)
                    const voice1 = ctx.createOscillator(); voice1.type = 'sawtooth';
                    voice1.frequency.setValueAtTime(rnd(110, 130), now);
                    voice1.frequency.linearRampToValueAtTime(rnd(140, 160), now + 0.12);
                    const v1Form = ctx.createBiquadFilter(); v1Form.type = 'bandpass'; v1Form.frequency.value = rnd(400, 500); v1Form.Q.value = 4;
                    const v1G = ctx.createGain();
                    v1G.gain.setValueAtTime(0, now);
                    v1G.gain.linearRampToValueAtTime(0.2, now + 0.02);
                    v1G.gain.linearRampToValueAtTime(0.15, now + 0.1);
                    v1G.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                    voice1.connect(v1Form); v1Form.connect(v1G); v1G.connect(this.master);
                    this._sendToReverb(v1G, 0.12);
                    voice1.start(now); voice1.stop(now + 0.2);
                    
                    // 2. Response voice "AAH" (different formant)
                    const voice2 = ctx.createOscillator(); voice2.type = 'sawtooth';
                    voice2.frequency.setValueAtTime(rnd(130, 150), now + 0.12);
                    voice2.frequency.linearRampToValueAtTime(rnd(100, 120), now + 0.28);
                    const v2Form = ctx.createBiquadFilter(); v2Form.type = 'bandpass'; v2Form.frequency.value = rnd(700, 900); v2Form.Q.value = 3;
                    const v2G = ctx.createGain();
                    v2G.gain.setValueAtTime(0, now + 0.12);
                    v2G.gain.linearRampToValueAtTime(0.18, now + 0.14);
                    v2G.gain.linearRampToValueAtTime(0.12, now + 0.24);
                    v2G.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    voice2.connect(v2Form); v2Form.connect(v2G); v2G.connect(this.master);
                    this._sendToReverb(v2G, 0.15);
                    voice2.start(now + 0.12); voice2.stop(now + 0.32);
                    return;
                }
            },
            
            // Negative sound for damage/poison - caveman pain grunt
            playHurt() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Sharp inhale gasp (breath noise)
                const gasp = this._noiseSource(0.12);
                const gaspBP = ctx.createBiquadFilter(); gaspBP.type = 'bandpass'; gaspBP.frequency.value = rnd(800, 1200); gaspBP.Q.value = 2;
                const gaspG = ctx.createGain();
                gaspG.gain.setValueAtTime(0, now);
                gaspG.gain.linearRampToValueAtTime(0.25, now + 0.02);
                gaspG.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                gasp.connect(gaspBP); gaspBP.connect(gaspG); gaspG.connect(this.master);
                gasp.start(now); gasp.stop(now + 0.12);
                
                // 2. Pain grunt "UGHH" (falling pitch formant)
                const grunt = ctx.createOscillator(); grunt.type = 'sawtooth';
                grunt.frequency.setValueAtTime(rnd(180, 220), now + 0.05);
                grunt.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.35);
                const gruntForm = ctx.createBiquadFilter(); gruntForm.type = 'bandpass'; gruntForm.frequency.value = rnd(500, 700); gruntForm.Q.value = 3;
                const gruntG = ctx.createGain();
                gruntG.gain.setValueAtTime(0, now + 0.05);
                gruntG.gain.linearRampToValueAtTime(0.3, now + 0.08);
                gruntG.gain.linearRampToValueAtTime(0.2, now + 0.2);
                gruntG.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                grunt.connect(gruntForm); gruntForm.connect(gruntG); gruntG.connect(this.master);
                this._sendToReverb(gruntG, 0.1);
                grunt.start(now + 0.05); grunt.stop(now + 0.45);
                
                // 3. Impact thud (body hit)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(70, 90), now);
                thud.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now);
                thudG.gain.linearRampToValueAtTime(0.25, now + 0.01);
                thudG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                thud.connect(thudG); thudG.connect(this.master);
                thud.start(now); thud.stop(now + 0.18);
            },
            
            // Lucky find - exciting discovery sound
            playLucky() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                const ctx = this.audioCtx; const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Bright discovery shimmer (ascending harmonics)
                [0, 0.06, 0.12].forEach((delay, i) => {
                    const o = ctx.createOscillator(); o.type = 'sine';
                    const f = 600 + i * 280;
                    o.frequency.setValueAtTime(f, now + delay);
                    o.frequency.exponentialRampToValueAtTime(f * 1.1, now + delay + 0.1);
                    const g = ctx.createGain();
                    g.gain.setValueAtTime(0, now + delay);
                    g.gain.linearRampToValueAtTime(0.18 - i * 0.03, now + delay + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.2);
                    o.connect(g); g.connect(this.master);
                    this._sendToReverb(g, 0.25);
                    o.start(now + delay); o.stop(now + delay + 0.22);
                });
                
                // 2. Excited caveman "OOH!"
                const ooh = ctx.createOscillator(); ooh.type = 'sawtooth';
                ooh.frequency.setValueAtTime(rnd(150, 180), now + 0.1);
                ooh.frequency.linearRampToValueAtTime(rnd(200, 240), now + 0.2);
                const oohForm = ctx.createBiquadFilter(); oohForm.type = 'bandpass'; oohForm.frequency.value = rnd(500, 600); oohForm.Q.value = 4;
                const oohG = ctx.createGain();
                oohG.gain.setValueAtTime(0, now + 0.1);
                oohG.gain.linearRampToValueAtTime(0.15, now + 0.12);
                oohG.gain.exponentialRampToValueAtTime(0.001, now + 0.28);
                ooh.connect(oohForm); oohForm.connect(oohG); oohG.connect(this.master);
                this._sendToReverb(oohG, 0.15);
                ooh.start(now + 0.1); ooh.stop(now + 0.3);
            },
            
            // Tree falling thud - realistic timber crash
            playThud() {
                if(!this.enabled || !this.audioCtx) return;
                this.resume();
                
                const ctx = this.audioCtx;
                const now = ctx.currentTime;
                const rnd = (min, max) => min + Math.random()*(max-min);
                
                // 1. Wood creaking before fall
                const creak = ctx.createOscillator(); creak.type = 'sawtooth';
                creak.frequency.setValueAtTime(rnd(180, 220), now);
                creak.frequency.exponentialRampToValueAtTime(rnd(80, 100), now + 0.15);
                const creakBP = ctx.createBiquadFilter(); creakBP.type = 'bandpass'; creakBP.frequency.value = rnd(300, 500); creakBP.Q.value = 5;
                const creakG = ctx.createGain();
                creakG.gain.setValueAtTime(0, now);
                creakG.gain.linearRampToValueAtTime(0.2, now + 0.02);
                creakG.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                creak.connect(creakBP); creakBP.connect(creakG); creakG.connect(this.master);
                creak.start(now); creak.stop(now + 0.18);
                
                // 2. Heavy ground impact (deep bass thud)
                const thud = ctx.createOscillator(); thud.type = 'sine';
                thud.frequency.setValueAtTime(rnd(55, 70), now + 0.1);
                thud.frequency.exponentialRampToValueAtTime(25, now + 0.4);
                const thudG = ctx.createGain();
                thudG.gain.setValueAtTime(0, now + 0.1);
                thudG.gain.linearRampToValueAtTime(0.8, now + 0.12);
                thudG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                thud.connect(thudG); thudG.connect(this.master);
                this._sendToReverb(thudG, 0.15);
                thud.start(now + 0.1); thud.stop(now + 0.55);
                
                // 3. Secondary bounce
                const bounce = ctx.createOscillator(); bounce.type = 'sine';
                bounce.frequency.setValueAtTime(rnd(40, 50), now + 0.25);
                bounce.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                const bounceG = ctx.createGain();
                bounceG.gain.setValueAtTime(0, now + 0.25);
                bounceG.gain.linearRampToValueAtTime(0.4, now + 0.26);
                bounceG.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
                bounce.connect(bounceG); bounceG.connect(this.master);
                bounce.start(now + 0.25); bounce.stop(now + 0.5);
                
                // 4. Branch/leaf rustling (noise burst)
                const rustle = this._noiseSource(0.3);
                const rustleBP = ctx.createBiquadFilter(); rustleBP.type = 'bandpass'; rustleBP.frequency.value = rnd(2000, 3500); rustleBP.Q.value = 1;
                const rustleG = ctx.createGain();
                rustleG.gain.setValueAtTime(0, now + 0.08);
                rustleG.gain.linearRampToValueAtTime(0.25, now + 0.12);
                rustleG.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                rustle.connect(rustleBP); rustleBP.connect(rustleG); rustleG.connect(this.master);
                this._sendToReverb(rustleG, 0.1);
                rustle.start(now + 0.08); rustle.stop(now + 0.38);
                
                // 5. Splintering wood
                for(let i = 0; i < 4; i++) {
                    const splinter = this._noiseSource(0.02);
                    const splinterHP = ctx.createBiquadFilter(); splinterHP.type = 'highpass'; splinterHP.frequency.value = rnd(3000, 5000);
                    const splinterG = ctx.createGain();
                    const t = now + 0.1 + i * 0.03;
                    splinterG.gain.setValueAtTime(rnd(0.1, 0.2), t);
                    splinterG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
                    splinter.connect(splinterHP); splinterHP.connect(splinterG); splinterG.connect(this.master);
                    splinter.start(t); splinter.stop(t + 0.025);
                }
            }
        };
        
        // Initialize sound on first user interaction
        document.addEventListener('click', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });
        document.addEventListener('keydown', () => {
            if(!SoundFX.audioCtx) SoundFX.init();
            SoundFX.resume();
        }, { once: true });

        // --- 4. GAME LOGIC ---
        const Game = {
            tiles:[], blds:[], res:0, food:0, water:100, pop:0, year:0, age:0, housingCap:0, waterCap:0, ordinance:false, ordEnd:0, vm:'NORMAL',
            player: null, // {x, y, health, direction}
            nomadsFound: 0,
            wolves: [], // [{x, y, hits}]
            simcityMode: false,
            pathQueue: [],
            lastMoveTime: 0, // Timer for smooth pathfinding movement
            aiEnabled: false, // AI autoplay toggle
            aiState: 'EXPLORE', // 'EXPLORE', 'GATHER', 'SETTLE', 'BUILD'
            aiTarget: null, // Current AI target position or entity
            aiLastAction: 0, // Timestamp of last AI action
            gameLog: [], // Event log for game history
            gold: 0, // Rare currency - earned by trading 5000 metal for 1 gold
            hasClanChief: false, // Tracks if Clan Chief's Hut is built (unlocks L4-L6)
            hasDock: false, // Tracks if Dock is built (unlocks L7+)
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LORE SYSTEM - Story mode with first-time event popups
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            loreEnabled: false, // Toggle for story mode
            loreSeen: {}, // Track which lore events have been seen
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GAME STATE & INVENTORY SYSTEM
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // gameState: 'WANDER' (Epoch 0 exploration) or 'CITY' (settled, building)
            //
            // MAIN INVENTORY: Affected by nomad count
            //   - Base capacity: 150
            //   - Bonus: +100 per friendly nomad recruited
            //   - Holds: Food, Wood, Metal, Stone
            //   - Overflow: Partial pickups allowed
            //
            // POCKET INVENTORY: Separate, immutable storage
            //   - Capacity: 1000 max (anti-cheat cap)
            //   - Holds: Metal, Stone only
            //   - Source: Passive walking collection (0.01% every 5 steps)
            //   - Not affected by nomad bonuses
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            gameState: 'WANDER', // 'WANDER' or 'CITY'
            gatheringMultiplier: 1.0, // Resource gathering rate multiplier (scales with initial population)
            inventory: {
                capacity: 150,      // Base 150, +100 per nomad
                food: 0,
                wood: 0,
                metal: 0.0,        // Track as float for 0.2 increments
                stone: 0.0         // Track as float
            },
            // POCKET INVENTORY: Separate storage for passive finds (immutable, max 1000)
            // Triggered every 5 steps with 0.01% chance to find 1-5 metal OR stone
            pocket: {
                metal: 0,
                stone: 0,
                capacity: 1000     // Max 1000 total (anti-cheat cap)
            },
            stepCounter: 0,        // Track steps for passive collection (triggers at 5)
            thirstCounter: 0,      // Steps since last drink (WANDER mode thirst mechanic)
            thirst: 100,           // Current thirst level (0-100, dies at 0)
            siteTraits: [],
            totalFoodCollected: 0, // Track total food gathered for stats        // Set during settlement (e.g., ['Arid', 'Mineral Rich'])
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WORKFORCE TRACKING - How residents are assigned
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            workforce: {
                total: 0,           // Total available workers (from residential pop)
                wellWorkers: 0,     // Assigned to wells
                roadWorkers: 0,     // Assigned to road maintenance  
                comWorkers: 0,      // Assigned to commercial buildings
                gatherers: 0,       // Remaining workers (gather/hunt)
                // Calculated needs
                wellsNeeded: 0,     // Workers needed for all wells
                roadsNeeded: 0,     // Workers needed for all roads
                comNeeded: 0,       // Workers needed for all commercial
                shortage: 0         // Worker shortage (negative = surplus)
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEEDS TRACKING - What people require to be happy/productive
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            needs: {
                housing: { have: 0, need: 0, satisfied: 1.0 },
                water: { have: 0, need: 0, satisfied: 1.0 },
                food: { have: 0, need: 0, satisfied: 1.0 },
                jobs: { have: 0, need: 0, satisfied: 1.0 },
                paths: { have: 0, need: 0, satisfied: 1.0 },
                overall: 1.0  // Combined satisfaction (0.0 - 1.0)
            },
            
            // Performance optimizations
            spatialGrid: null, // Fast building lookup grid
            particlePool: [], // Reusable particle objects
            terrainCache: null, // Offscreen canvas for terrain
            dirtyRegions: new Set(), // Track changed areas
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GEOLOGICAL WATER CYCLE - Slow rise/fall over centuries
            // Based on 3 million years of real glacial cycles
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            geology: {
                currentSeaLevel: 3,         // Current water level (0-10)
                periodIndex: 0,             // Current geological period
                centuriesInPeriod: 0,       // Years spent in current period
                lastUpdateYear: 0,          // Last year water was checked
                tilesFlooded: 0,            // Count of tiles lost to rising water
                tilesDrained: 0,            // Count of tiles gained from receding water
                currentPeriodName: "Warm Interglacial"
            },

            init(seed) {
                Noise.init(seed); this.tiles = []; this.blds = []; this.res=0; this.food=0; this.year=0; this.pop=4; this.age=0;
                this.peakPop = 4;  // Track highest population reached for game over screen
                PROGRESSION.reset();
                
                // Initialize game state & inventory (see balance values above)
                this.gameState = 'WANDER';
                this.inventory = {
                    capacity: 450,  // 150 base + 300 (3 extra people Ã— 100)
                    food: 300,   // Starting supplies for 4 people
                    wood: 300,   // Starting supplies for 4 people
                    metal: 0.0,
                    stone: 0.0
                };
                // Initialize pocket inventory (separate, immutable storage for passive finds)
                this.pocket = {
                    metal: 0,
                    stone: 0,
                    capacity: 1000  // Max to prevent exploit
                };
                this.stepCounter = 0;  // Resets every 5 steps (passive collection)
                this.foodStepCounter = 0;  // Resets every 15 steps (food cost)
                this.thirstCounter = 0;   // Steps since last drink
                this.thirst = 100;        // Start fully hydrated
                this.wanderWells = [];    // Wells built in WANDER mode (Level 0)
                this.siteTraits = [];
                this.nomadsFound = 0;
                this.animals = [];
                this.simcityMode = false;
                this.pathQueue = [];
                this.settlementPos = null;
                
                // Initialize workforce tracking
                this.workforce = {
                    total: 0,
                    wellWorkers: 0,
                    roadWorkers: 0,
                    comWorkers: 0,
                    gatherers: 0,
                    wellsNeeded: 0,
                    roadsNeeded: 0,
                    comNeeded: 0,
                    shortage: 0
                };
                this.roadTileCount = 0; // Track road tiles for workforce calculation
                
                // NEW: Resource tracking for Epoch 1+
                this.wood = 0;
                this.metal = 0;
                this.stone = 0;
                
                // Reset geological state for new game
                this.geology = {
                    currentSeaLevel: CFG.ELEVATION_SYSTEM.SEA_LEVEL_BASE,
                    periodIndex: 0,
                    centuriesInPeriod: 0,
                    lastUpdateYear: 0,
                    tilesFlooded: 0,
                    tilesDrained: 0,
                    currentPeriodName: CFG.ELEVATION_SYSTEM.GEOLOGICAL_PERIODS[0].name
                };
                
                // Initialize performance structures
                this.initSpatialGrid();
                this.initParticlePool();
                this.dirtyRegions.clear();
                
                for (let x=0; x<CFG.W; x++) {
                    this.tiles[x] = [];
                    for (let y=0; y<CFG.H; y++) {
                        // ENHANCED TERRAIN GENERATION WITH OCEANS & LAKES & IMPASSABLE MOUNTAINS
                        let h = Noise.fbm(x*0.02, y*0.02); 
                        h = (h / 1.8); // Normalize 0..1
                        
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        // ELEVATION SYSTEM: Convert height to 0-10 scale
                        // 0 = Deepest ocean trench
                        // 3 = Sea level (starting)
                        // 5 = Hills
                        // 8 = Mountains
                        // 10 = Highest peaks
                        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        let elevation = Math.floor(h * 10);
                        
                        // Ocean noise - creates large ocean bodies
                        let oceanNoise = Noise.fbm(x*0.01, y*0.01);
                        oceanNoise = (oceanNoise / 1.8);
                        
                        // Lake noise - creates inland lakes
                        let lakeNoise = Noise.fbm(x*0.08+500, y*0.08+500);
                        lakeNoise = (lakeNoise / 1.8);
                        
                        // Mountain noise - creates impassable stone peaks
                        let mountainNoise = Noise.fbm(x*0.015+1000, y*0.015+1000);
                        mountainNoise = (mountainNoise / 1.8);
                        
                        // River noise
                        let r = Noise.fbm(x*0.05+100, y*0.05+100); 
                        r = (r/1.8);
                        let isRiver = Math.abs(r - 0.5) < 0.02;

                        let t = 'GRASS'; // Default
                        
                        // Get current sea level from geological system
                        let seaLevel = CFG.ELEVATION_SYSTEM.SEA_LEVEL_BASE;
                        
                        // IMPASSABLE STONE MOUNTAINS (highest elevation)
                        if (mountainNoise > 0.72 && h > 0.6) {
                            t = 'STONE';
                            elevation = 9 + Math.floor(Math.random() * 2); // 9-10
                        }
                        // ELEVATION-BASED WATER: Tiles below sea level are water
                        else if (elevation < seaLevel - 1) {
                            t = 'DEEP';
                            elevation = Math.max(0, elevation);
                        } else if (elevation < seaLevel) {
                            t = 'WATER';
                        }
                        // Generate inland lakes (still uses noise but elevation-aware)
                        else if (lakeNoise < 0.15 && elevation >= seaLevel && elevation < seaLevel + 2) {
                            t = 'WATER';
                            elevation = seaLevel - 1; // Lakes are at water level
                        }
                        // Standard elevation-based terrain (MORE LAND - adjusted thresholds)
                        else if (elevation <= seaLevel) {
                            t = 'SAND';  // Beaches at sea level
                        } else if (elevation < 6) {
                            t = 'GRASS'; // Most buildable land (3-5)
                        } else if (elevation < 7) {
                            t = 'FOREST'; 
                        } else if (elevation < 9) {
                            t = 'ROCK'; 
                        } else {
                            t = 'SNOW';
                        }

                        // Carve Rivers (avoid deep ocean)
                        if (isRiver && t !== 'DEEP' && t !== 'WATER') {
                            t = 'RIVER';
                            elevation = seaLevel; // Rivers at sea level
                        }

                        let tree = (t=='GRASS'||t=='FOREST'||t=='SNOW') && Math.random()>0.8;
                        
                        // DEEP TILE SYSTEM: Rich data model with ELEVATION
                        let tileData = { 
                            type:t, 
                            elevation: elevation,   // NEW: 0-10 elevation
                            originalType: t,        // NEW: Original terrain (for water cycle)
                            road:false, 
                            tree:tree, 
                            pol:0, 
                            bld:null, 
                            explored:false,
                            zone: null,     // 'R', 'C', 'I', or null
                            building: null, // { level, growth, desirability }
                            
                            // Resource deposits (for STONE tiles)
                            resource: null, // { type, amount, metal_yield }
                            
                            // Stone deposits (Mario-style rocks with metal)
                            stoneDeposit: null, // { metal: number }
                            
                            // Entity data (complex objects replace simple booleans)
                            entity: null    // { type, data... }
                        };
                        
                        // STONE tiles contain massive resources
                        if(t === 'STONE') {
                            tileData.resource = {
                                type: 'STONE',
                                amount: 1000000 + Math.floor(Math.random() * 500000), // 1M-1.5M stone
                                metal_yield: 0.2 // Hidden metal bonus when worked
                            };
                        }
                        
                        this.tiles[x][y] = tileData;
                    }
                }
                
                // Spawn player in a safe location
                this.spawnPlayer();
                
                // Spawn stone deposits (Mario-style rocks with metal)
                this.spawnStoneDeposits(CFG.STONE_DEPOSITS.SPAWN_COUNT);
                
                // Spawn berries randomly on land tiles
                this.spawnBerries(CFG.BERRIES.SPAWN_COUNT);
                
                // Spawn wolves (separate from other animals)
                // Wolves removed from game
                
                // Spawn other animals (deer, bison, mammoth)
                this.spawnAnimals(CFG.ANIMALS.SPAWN_COUNT);
                
                // Spawn multiple nomads
                for(let i=0; i<CFG.NOMAD.SPAWN_COUNT; i++) {
                    this.spawnNomad();
                }
                
                // HARDCORE MODE: Randomize dangerous berries and hostile nomads
                for(let x=0; x<CFG.W; x++) {
                    for(let y=0; y<CFG.H; y++) {
                        let t = this.tiles[x][y];
                        
                        // 10% Chance of Poison Berry
                        if(t.berry) {
                            t.isPoison = (Math.random() < 0.1);
                        }
                        
                        // 10% Chance of Hostile Nomad carrying 1-10 food
                        if(t.nomad) {
                            t.isHostile = (Math.random() < 0.1);
                            t.carriedFood = Math.floor(Math.random() * 10) + 1;
                        }
                    }
                }
                
                Controller.updateUI();
            },
            
            // PERFORMANCE: Spatial grid for fast building/zone lookups
            initSpatialGrid() {
                const gridSize = Math.ceil(CFG.W / CFG.PERF.SPATIAL_GRID_SIZE);
                this.spatialGrid = [];
                for(let i = 0; i < gridSize; i++) {
                    this.spatialGrid[i] = [];
                    for(let j = 0; j < gridSize; j++) {
                        this.spatialGrid[i][j] = [];
                    }
                }
            },
            
            updateSpatialGrid(x, y, obj, remove = false) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                if(gx < 0 || gy < 0 || gx >= this.spatialGrid.length || gy >= this.spatialGrid[0].length) return;
                
                if(remove) {
                    const idx = this.spatialGrid[gx][gy].indexOf(obj);
                    if(idx !== -1) this.spatialGrid[gx][gy].splice(idx, 1);
                } else {
                    this.spatialGrid[gx][gy].push(obj);
                }
            },
            
            getNearbyObjects(x, y, radius = 1) {
                const gx = Math.floor(x / CFG.PERF.SPATIAL_GRID_SIZE);
                const gy = Math.floor(y / CFG.PERF.SPATIAL_GRID_SIZE);
                const gridRadius = Math.ceil(radius / CFG.PERF.SPATIAL_GRID_SIZE);
                const nearby = [];
                
                for(let dx = -gridRadius; dx <= gridRadius; dx++) {
                    for(let dy = -gridRadius; dy <= gridRadius; dy++) {
                        const gxi = gx + dx;
                        const gyi = gy + dy;
                        if(gxi >= 0 && gyi >= 0 && gxi < this.spatialGrid.length && gyi < this.spatialGrid[0].length) {
                            nearby.push(...this.spatialGrid[gxi][gyi]);
                        }
                    }
                }
                return nearby;
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RCI DEMAND CALCULATION (SimCity-style interdependent zones)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // R demand: People want to live where there are jobs (C+I)
            // C demand: Commerce needs customers (R) AND goods to sell (I)
            // I demand: Industry needs workers (R) AND buyers for goods (C)
            // Returns: {r: 0-100, c: 0-100, i: 0-100} - higher = more needed
            calculateRCIDemand() {
                let resCount = this.zoneCount || 0;
                let comCount = this.blds ? this.blds.filter(b => b.t === 'COM').length : 0;
                let indCount = this.blds ? this.blds.filter(b => b.t === 'IND').length : 0;
                let pop = this.pop || 0;
                let housingCap = this.housingCap || 0;
                
                let totalZones = resCount + comCount + indCount;
                
                // Jobs come from Commercial (10 each) and Industrial (15 each)
                let jobCapacity = (comCount * 10) + (indCount * 15);
                let unemployed = Math.max(0, pop - jobCapacity);
                let housingNeed = housingCap > 0 ? (housingCap - pop) / housingCap : 0;
                
                // === RESIDENTIAL DEMAND ===
                // High when: jobs available but housing full, or C+I exist but R doesn't
                let rDemand = 0;
                if(totalZones === 0) {
                    rDemand = 100; // Nothing built - need residential first!
                } else if(housingNeed < 0.2 && jobCapacity > pop * 0.5) {
                    rDemand = 80; // Housing nearly full but jobs available
                } else if(comCount + indCount > resCount * 0.5) {
                    rDemand = 60; // More industry than people to work it
                } else if(pop < housingCap * 0.5) {
                    rDemand = 40; // Room to grow
                } else {
                    rDemand = Math.max(10, 50 - (resCount / Math.max(1, comCount + indCount)) * 10);
                }
                
                // === COMMERCIAL DEMAND ===
                // Needs BOTH residential (customers) AND industrial (goods to sell)
                let customersPerCom = resCount > 0 ? comCount / resCount : 0;
                let goodsSupply = indCount > 0 ? comCount / indCount : 0;
                
                let cDemand = 0;
                if(resCount === 0) {
                    cDemand = 10; // No customers yet
                } else if(comCount === 0 && resCount > 0) {
                    cDemand = 90; // People but no shops!
                } else if(customersPerCom < 0.3 && indCount > 0) {
                    cDemand = 70; // Not enough shops for the people
                } else if(goodsSupply > 2) {
                    cDemand = 20; // Too many shops, not enough goods
                } else {
                    let idealComRatio = 0.5; // 1 commercial per 2 residential
                    let actualRatio = resCount > 0 ? comCount / resCount : 0;
                    cDemand = Math.max(10, Math.min(80, (idealComRatio - actualRatio) * 100 + 50));
                }
                
                // === INDUSTRIAL DEMAND ===
                // Industry provides: jobs for R, goods for C
                let workersPerInd = resCount > 0 ? indCount / resCount : 0;
                let supplyDemand = comCount > 0 ? indCount / comCount : 0;
                
                let iDemand = 0;
                if(resCount === 0) {
                    iDemand = 10; // No workers yet
                } else if(indCount === 0 && resCount > 0) {
                    iDemand = 80; // People but no industry!
                } else if(comCount > indCount * 2) {
                    iDemand = 90; // Commerce needs goods to sell!
                } else if(unemployed > pop * 0.3) {
                    iDemand = 70; // People need jobs
                } else {
                    let idealIndRatio = 0.5; // 1 industrial per 2 residential
                    let actualRatio = resCount > 0 ? indCount / resCount : 0;
                    iDemand = Math.max(10, Math.min(80, (idealIndRatio - actualRatio) * 100 + 50));
                }
                
                // Clamp all demands 0-100
                return {
                    r: Math.max(0, Math.min(100, rDemand)),
                    c: Math.max(0, Math.min(100, cDemand)),
                    i: Math.max(0, Math.min(100, iDemand))
                };
            },
            
            // PERFORMANCE: Object pooling for particles
            initParticlePool() {
                this.particlePool = [];
                for(let i = 0; i < CFG.PERF.PARTICLE_POOL_SIZE; i++) {
                    this.particlePool.push({x: 0, y: 0, l: 0, c: '', active: false});
                }
            },
            
            getPooledParticle(x, y, life, color) {
                for(let p of this.particlePool) {
                    if(!p.active) {
                        p.x = x; p.y = y; p.l = life; p.c = color; p.active = true;
                        return p;
                    }
                }
                // Pool exhausted, create new (rare)
                const p = {x, y, l: life, c: color, active: true};
                this.particlePool.push(p);
                return p;
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GEOLOGICAL WATER CYCLE UPDATE
            // Called every year, but only processes every 100 years
            // Water rises/falls based on geological periods (ice ages, interglacials)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            updateGeologicalCycle() {
                const cfg = CFG.ELEVATION_SYSTEM;
                const geo = this.geology;
                
                // Only check every 100 years (1 century)
                if(this.year - geo.lastUpdateYear < cfg.UPDATE_INTERVAL_YEARS) return;
                geo.lastUpdateYear = this.year;
                
                // Advance centuries in current period
                geo.centuriesInPeriod++;
                
                // Check if period has ended
                const currentPeriod = cfg.GEOLOGICAL_PERIODS[geo.periodIndex];
                if(geo.centuriesInPeriod >= currentPeriod.duration) {
                    // Move to next period
                    geo.periodIndex = (geo.periodIndex + 1) % cfg.GEOLOGICAL_PERIODS.length;
                    geo.centuriesInPeriod = 0;
                    
                    const newPeriod = cfg.GEOLOGICAL_PERIODS[geo.periodIndex];
                    geo.currentPeriodName = newPeriod.name;
                    
                    // Announce major geological shift
                    const oldLevel = geo.currentSeaLevel;
                    const newLevel = newPeriod.seaLevel;
                    
                    if(newLevel > oldLevel) {
                        Controller.toast(`ğŸŒŠ ${newPeriod.name} begins! Waters are rising as ice melts...`, 5000);
                        this.logEvent(`Year ${this.year}: ${newPeriod.name} - Sea levels rising`);
                    } else if(newLevel < oldLevel) {
                        Controller.toast(`â„ï¸ ${newPeriod.name} begins! Waters recede as glaciers grow...`, 5000);
                        this.logEvent(`Year ${this.year}: ${newPeriod.name} - Sea levels falling`);
                    } else {
                        Controller.toast(`ğŸŒ ${newPeriod.name} begins.`, 3000);
                    }
                }
                
                // Gradual sea level change (don't jump instantly)
                const targetLevel = cfg.GEOLOGICAL_PERIODS[geo.periodIndex].seaLevel;
                if(geo.currentSeaLevel < targetLevel) {
                    // Water rising slowly
                    geo.currentSeaLevel = Math.min(cfg.SEA_LEVEL_MAX, geo.currentSeaLevel + 0.5);
                    this.applySeaLevelChange();
                } else if(geo.currentSeaLevel > targetLevel) {
                    // Water receding slowly
                    geo.currentSeaLevel = Math.max(cfg.SEA_LEVEL_MIN, geo.currentSeaLevel - 0.5);
                    this.applySeaLevelChange();
                }
            },
            
            // Apply sea level change to tiles
            applySeaLevelChange() {
                const seaLevel = Math.floor(this.geology.currentSeaLevel);
                let flooded = 0;
                let drained = 0;
                let buildingsLost = [];
                let populationDrowned = 0;
                let wellsLost = 0;
                let bldsToRemove = []; // Track blds array items to remove
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        const tile = this.tiles[x][y];
                        
                        // Skip tiles that are always water (deep ocean) or always land (mountains)
                        if(tile.elevation <= 0 || tile.elevation >= 8) continue;
                        
                        // Check if tile should be underwater at current sea level
                        if(tile.elevation < seaLevel && tile.type !== 'WATER' && tile.type !== 'DEEP') {
                            // FLOOD THIS TILE
                            
                            // Check for tile-based buildings first - KILL POPULATION IMMEDIATELY
                            if(tile.building || tile.zone) {
                                // Count population lost in this building
                                if(tile.building && tile.building.pop) {
                                    populationDrowned += tile.building.pop;
                                }
                                buildingsLost.push({x, y, type: tile.building?.type || tile.zone, pop: tile.building?.pop || 0});
                                // Destroy building on tile
                                tile.building = null;
                                tile.zone = null;
                                tile.road = false;
                            }
                            
                            // Check for blds array buildings at this location (wells, COM, IND, RES, etc)
                            // These need to be tracked for removal
                            if(this.blds) {
                                for(let i = 0; i < this.blds.length; i++) {
                                    let b = this.blds[i];
                                    // Check if building occupies this tile (1x1 or 2x2 buildings)
                                    let bSize = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                                    if(x >= b.x && x < b.x + bSize && y >= b.y && y < b.y + bSize) {
                                        if(!bldsToRemove.includes(i)) {
                                            bldsToRemove.push(i);
                                            if(b.t === 'WELL') wellsLost++;
                                            // RES buildings have population
                                            if(b.t === 'RES' && b.pop) {
                                                populationDrowned += b.pop;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Check if player is on this tile - instant death!
                            if(this.player && this.player.x === x && this.player.y === y) {
                                populationDrowned += this.pop; // Everyone drowns
                                this.pop = 0;
                            }
                            
                            tile.type = 'WATER';
                            tile.tree = false;
                            flooded++;
                            this.markDirty(x, y, 1);
                        } 
                        else if(tile.elevation >= seaLevel && (tile.type === 'WATER' || tile.type === 'DEEP')) {
                            // DRAIN THIS TILE (was water, now above sea level)
                            // Only drain shallow water tiles (not deep ocean which has elevation 0-1)
                            // NOTE: Buildings do NOT come back - player must rebuild!
                            if(tile.elevation > 1) {
                                tile.type = tile.originalType || 'SAND';
                                drained++;
                                this.markDirty(x, y, 1);
                            }
                        }
                    }
                }
                
                // Remove flooded buildings from blds array (in reverse order to maintain indices)
                if(bldsToRemove.length > 0) {
                    bldsToRemove.sort((a, b) => b - a); // Sort descending
                    for(let idx of bldsToRemove) {
                        let removedBld = this.blds[idx];
                        buildingsLost.push({x: removedBld.x, y: removedBld.y, type: removedBld.t});
                        this.blds.splice(idx, 1);
                    }
                    // Force recalc of well count and other cached values
                    this.wellCount = this.blds.filter(b => b.t === 'WELL').length;
                }
                
                // KILL POPULATION FROM FLOODED BUILDINGS
                if(populationDrowned > 0) {
                    this.pop = Math.max(0, this.pop - populationDrowned);
                    this.geology.populationDrowned = (this.geology.populationDrowned || 0) + populationDrowned;
                    Controller.toast(`ğŸŒŠğŸ’€ ${populationDrowned} people drowned in the rising flood!`, 5000);
                    this.logEvent(`Year ${this.year}: ${populationDrowned} drowned as waters rose`);
                }
                
                // Report wells lost
                if(wellsLost > 0) {
                    Controller.toast(`ğŸ’§ğŸŒŠ ${wellsLost} well${wellsLost > 1 ? 's' : ''} destroyed by flooding!`, 4000);
                    this.logEvent(`Year ${this.year}: ${wellsLost} wells lost to flooding`);
                }
                
                // Update stats
                this.geology.tilesFlooded += flooded;
                this.geology.tilesDrained += drained;
                
                // Warn about lost buildings
                if(buildingsLost.length > 0 && populationDrowned === 0) {
                    Controller.toast(`ğŸ’€ Rising waters destroyed ${buildingsLost.length} building${buildingsLost.length > 1 ? 's' : ''}!`, 4000);
                }
                
                // Force terrain cache rebuild
                if(flooded > 0 || drained > 0) {
                    this.terrainCache = null;
                }
                
                // CHECK FOR GAME OVER - Everyone drowned!
                if(this.pop <= 0 && populationDrowned > 0) {
                    Controller.showGameOver('FLOOD');
                    return;
                }
                
                // Mark that a major flood event happened this year (for game over screen)
                if(populationDrowned > 0) {
                    this.lastMajorFloodYear = this.year;
                    this.lastFloodDeaths = populationDrowned;
                }
            },
            
            // Helper to determine game over reason - checks if flood was the real cause
            getGameOverReason(defaultReason) {
                // If a major flood happened this year and killed significant population, blame the flood
                if(this.lastMajorFloodYear === this.year && this.lastFloodDeaths > 0) {
                    return 'FLOOD';
                }
                return defaultReason;
            },
            
            // Check if a tile is at flood risk
            isFloodRisk(x, y) {
                if(!CFG.ELEVATION_SYSTEM.ENABLED) return false;
                const tile = this.tiles[x]?.[y];
                if(!tile) return false;
                
                const seaLevel = this.geology.currentSeaLevel;
                const margin = CFG.ELEVATION_SYSTEM.FLOOD_WARNING_MARGIN;
                
                // Tile is at risk if elevation is within warning margin of sea level
                return tile.elevation <= seaLevel + margin && tile.elevation > seaLevel;
            },
            
            // Log significant game events
            logEvent(msg) {
                if(!this.gameLog) this.gameLog = [];
                this.gameLog.push(msg);
                if(this.gameLog.length > 100) this.gameLog.shift();
                console.log('[EVENT]', msg);
            },
            
            // Get elevation info for tile (for UI display)
            getTileElevationInfo(x, y) {
                const tile = this.tiles[x]?.[y];
                if(!tile) return null;
                
                const seaLevel = this.geology.currentSeaLevel;
                const elevation = tile.elevation;
                
                let status = 'safe';
                let description = '';
                
                if(elevation < seaLevel) {
                    status = 'underwater';
                    description = 'Underwater';
                } else if(elevation < seaLevel + 1) {
                    status = 'danger';
                    description = 'Flood Risk! (coastal)';
                } else if(elevation < seaLevel + 2) {
                    status = 'warning';
                    description = 'Low ground';
                } else if(elevation >= 8) {
                    status = 'high';
                    description = 'Mountain peaks';
                } else {
                    status = 'safe';
                    description = 'Safe elevation';
                }
                
                return {
                    elevation,
                    seaLevel: Math.floor(seaLevel),
                    status,
                    description,
                    heightAboveSea: elevation - Math.floor(seaLevel)
                };
            },
            
            markDirty(x, y, size = 1) {
                if(!CFG.PERF.DIRTY_RECT_RENDERING) return;
                for(let dx = 0; dx < size; dx++) {
                    for(let dy = 0; dy < size; dy++) {
                        const key = `${x+dx},${y+dy}`;
                        this.dirtyRegions.add(key);
                    }
                }
            },
            
            spawnPlayer() {
                // Find a safe grass tile with at least 60 reachable land tiles
                function floodFillCount(tiles, x, y, maxTiles = 200) {
                    let W = tiles.length, H = tiles[0].length;
                    let seen = Array.from({length: W}, () => Array(H).fill(false));
                    let queue = [[x, y]];
                    let count = 0;
                    while(queue.length > 0 && count < maxTiles) {
                        let [cx, cy] = queue.shift();
                        if(cx < 0 || cy < 0 || cx >= W || cy >= H) continue;
                        if(seen[cx][cy]) continue;
                        let t = tiles[cx][cy].type;
                        if(!(t === 'GRASS' || t === 'FOREST' || t === 'SAND')) continue;
                        seen[cx][cy] = true;
                        count++;
                        queue.push([cx+1, cy]);
                        queue.push([cx-1, cy]);
                        queue.push([cx, cy+1]);
                        queue.push([cx, cy-1]);
                    }
                    return count;
                }
                
                function isValidSpawn(tiles, x, y) {
                    if(x < 0 || x >= tiles.length || y < 0 || y >= tiles[0].length) return false;
                    let t = tiles[x][y].type;
                    // NEVER spawn in water, ocean, river, or stone
                    return t === 'GRASS' || t === 'FOREST' || t === 'SAND' || t === 'SNOW' || t === 'ROCK';
                }
                
                // Phase 1: Try center area (20 tile radius)
                for(let attempt = 0; attempt < 100; attempt++) {
                    let x = Math.floor(CFG.W/2 + (Math.random()-0.5)*40);
                    let y = Math.floor(CFG.H/2 + (Math.random()-0.5)*40);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 60) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(center search)');
                            return;
                        }
                    }
                }
                
                // Phase 2: Try wider area (whole map, but prefer land)
                for(let attempt = 0; attempt < 500; attempt++) {
                    let x = Math.floor(Math.random() * CFG.W);
                    let y = Math.floor(Math.random() * CFG.H);
                    if(isValidSpawn(this.tiles, x, y)) {
                        let reachable = floodFillCount(this.tiles, x, y, 200);
                        if(reachable >= 30) { // Lower threshold for fallback
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(wide search)');
                            return;
                        }
                    }
                }
                
                // Phase 3: Emergency - scan entire map for ANY valid land tile
                console.warn('âš ï¸ Emergency spawn search...');
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        if(isValidSpawn(this.tiles, x, y)) {
                            this.player = {x:x, y:y, health:3, direction: 'down'};
                            this.exploreArea(x, y, 5);
                            Controller.cam.x = x * CFG.TILE;
                            Controller.cam.y = y * CFG.TILE;
                            console.log('âœ… Player spawned at', x, y, '(emergency)');
                            return;
                        }
                    }
                }
                
                // Phase 4: Absolute last resort - spawn at center regardless
                console.error('âŒ No valid spawn found! Forcing center spawn.');
                let cx = Math.floor(CFG.W/2);
                let cy = Math.floor(CFG.H/2);
                this.player = {x:cx, y:cy, health:3, direction: 'down'};
                this.exploreArea(cx, cy, 5);
                Controller.cam.x = cx * CFG.TILE;
                Controller.cam.y = cy * CFG.TILE;
            },
            
            spawnBerries(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    if((tile.type=='GRASS' || tile.type=='FOREST') && !tile.entity) {
                        // DEEP DATA: Rich berry entity using CFG values (Master Design v40.0)
                        tile.entity = {
                            type: 'BERRY',
                            amount: CFG.BERRIES.FOOD_VALUE, // Fixed 10 food per spec
                            poison_chance: CFG.BERRIES.POISON_CHANCE,
                            is_poisonous: Math.random() < CFG.BERRIES.POISON_CHANCE // 10% poison
                        };
                        spawned++;
                    }
                }
            },
            
            spawnStoneDeposits(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*10 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    // Spawn on grass, forest, or rock terrain
                    if((tile.type=='GRASS' || tile.type=='FOREST' || tile.type=='ROCK') && !tile.entity && !tile.stoneDeposit && !tile.tree) {
                        // Random metal value between 1M and 10M
                        let metalValue = CFG.STONE_DEPOSITS.MIN_METAL + 
                            Math.floor(Math.random() * (CFG.STONE_DEPOSITS.MAX_METAL - CFG.STONE_DEPOSITS.MIN_METAL));
                        
                        tile.stoneDeposit = {
                            metal: metalValue
                        };
                        spawned++;
                    }
                }
            },
            
            spawnNomad() {
                for(let attempt=0; attempt<200; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let tile = this.tiles[x][y];
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if((tile.type=='GRASS' || tile.type=='FOREST') && dist > 15 && !tile.entity) {
                        // DEEP DATA: Rich nomad entity using CFG values (Master Design v40.0)
                        let isHostile = Math.random() < CFG.NOMAD.HOSTILE_CHANCE; // 16% hostile
                        let hostileDamageRange = CFG.NOMAD.HOSTILE_DAMAGE;
                        let lootRanges = CFG.NOMAD.LOOT_RANGES;
                        
                        tile.entity = {
                            type: 'NOMAD',
                            pop: CFG.NOMAD.FRIENDLY_POP_BONUS, // +1 Pop
                            loot: {
                                food: lootRanges.FOOD[0] + Math.floor(Math.random() * (lootRanges.FOOD[1] - lootRanges.FOOD[0] + 1)), // 5-30
                                wood: lootRanges.WOOD[0] + Math.floor(Math.random() * (lootRanges.WOOD[1] - lootRanges.WOOD[0] + 1)), // 5-30
                                metal: lootRanges.METAL[0] + Math.floor(Math.random() * (lootRanges.METAL[1] - lootRanges.METAL[0] + 1)), // 0-10
                                stone: lootRanges.STONE[0] + Math.floor(Math.random() * (lootRanges.STONE[1] - lootRanges.STONE[0] + 1))  // 0-5
                            },
                            hostile_chance: CFG.NOMAD.HOSTILE_CHANCE,
                            is_hostile: isHostile,
                            damage: isHostile ? (hostileDamageRange[0] + Math.floor(Math.random() * (hostileDamageRange[1] - hostileDamageRange[0] + 1))) : 0 // 1-3 if hostile
                        };
                        return;
                    }
                }
            },
            
            // Spawn wolves as separate entity type (Master Design v40.0)
            // Wolves always cost -1 Pop to kill, always give +50 Food
            // spawnWolves removed - wolves no longer in game
            
            spawnAnimals(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*20 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let t = this.tiles[x][y].type;
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    
                    // Check if animal already exists on this tile (prevent overlapping)
                    let tileOccupied = this.animals.some(a => a.x === x && a.y === y);
                    
                    // Get valid animal types for this terrain
                    let validTypes = CFG.ANIMALS.TYPES.filter(type => {
                        if(type.terrain) {
                            return type.terrain.includes(t);
                        }
                        return t === 'GRASS' || t === 'FOREST'; // Default terrain for animals without terrain property
                    });
                    
                    if(validTypes.length > 0 && dist > 10 && !tileOccupied) {
                        // Calculate adjusted spawn rates for valid types
                        let totalRate = validTypes.reduce((sum, type) => sum + type.spawnRate, 0);
                        let rand = Math.random() * totalRate;
                        let cumulative = 0;
                        let animalType = validTypes[0].name; // Default to first valid type
                        
                        for(let type of validTypes) {
                            cumulative += type.spawnRate;
                            if(rand < cumulative) {
                                animalType = type.name;
                                break;
                            }
                        }
                        
                        this.animals.push({x:x, y:y, hits:0, type: animalType});
                        spawned++;
                    }
                }
                
                // BEACH TURTLES: Spawn additional turtles specifically on sand tiles
                this.spawnBeachTurtles(CFG.ANIMALS.BEACH_SPAWN_COUNT || 150);
            },
            
            spawnBeachTurtles(count) {
                let spawned = 0;
                for(let attempt=0; attempt<count*30 && spawned<count; attempt++) {
                    let x = Math.floor(Math.random()*CFG.W);
                    let y = Math.floor(Math.random()*CFG.H);
                    let t = this.tiles[x][y].type;
                    
                    // Only spawn on SAND tiles
                    if(t !== 'SAND') continue;
                    
                    // Check if already occupied
                    let tileOccupied = this.animals.some(a => a.x === x && a.y === y);
                    if(tileOccupied) continue;
                    
                    // Distance check from player
                    let dist = Math.abs(x-this.player.x) + Math.abs(y-this.player.y);
                    if(dist <= 5) continue;
                    
                    this.animals.push({x:x, y:y, hits:0, type: 'TURTLE'});
                    spawned++;
                }
            },
            
            exploreArea(cx, cy, radius) {
                for(let x=cx-radius; x<=cx+radius; x++) {
                    for(let y=cy-radius; y<=cy+radius; y++) {
                        if(x>=0 && x<CFG.W && y>=0 && y<CFG.H) {
                            let dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
                            if(dist <= radius) {
                                this.tiles[x][y].explored = true;
                            }
                        }
                    }
                }
            },
            
            getWaterProximity(x, y, size) {
                // Calculate distance to nearest water for a building
                let minDist = Infinity;
                for(let bx=x; bx<x+size; bx++) {
                    for(let by=y; by<y+size; by++) {
                        // Check surrounding area
                        for(let cx=bx-CFG.WATER_PROXIMITY.MAX_DISTANCE; cx<=bx+CFG.WATER_PROXIMITY.MAX_DISTANCE; cx++) {
                            for(let cy=by-CFG.WATER_PROXIMITY.MAX_DISTANCE; cy<=by+CFG.WATER_PROXIMITY.MAX_DISTANCE; cy++) {
                                if(cx>=0 && cx<CFG.W && cy>=0 && cy<CFG.H) {
                                    let tile = this.tiles[cx][cy];
                                    if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                        let dist = Math.sqrt((cx-bx)**2 + (cy-by)**2);
                                        minDist = Math.min(minDist, dist);
                                    }
                                }
                            }
                        }
                    }
                }
                // Convert distance to efficiency (0=far, 1=adjacent)
                if(minDist === 0) return 1.0;
                if(minDist > CFG.WATER_PROXIMITY.MAX_DISTANCE) return CFG.WATER_PROXIMITY.MIN_EFFICIENCY;
                return Math.max(CFG.WATER_PROXIMITY.MIN_EFFICIENCY, 1.0 - (minDist / CFG.WATER_PROXIMITY.MAX_DISTANCE) * (1.0 - CFG.WATER_PROXIMITY.MIN_EFFICIENCY));
            },
            
            getForestProximity(x, y, size) {
                // Calculate if building is near forest
                for(let bx=x-1; bx<=x+size; bx++) {
                    for(let by=y-1; by<=y+size; by++) {
                        if(bx>=0 && bx<CFG.W && by>=0 && by<CFG.H) {
                            if(this.tiles[bx][by].type === 'FOREST') return true;
                        }
                    }
                }
                return false;
            },
            
            movePlayer(dx, dy) {
                if(!this.player) return false;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return false;
                }
                
                // FOOD COST CHECK: Block movement if no food in WANDER mode
                if(this.gameState === 'WANDER' && this.inventory.food <= 0) {
                    Controller.toast("ğŸ– No food! Your tribe cannot travel without food.");
                    return false;
                }
                
                let newX = this.player.x + dx;
                let newY = this.player.y + dy;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FLAT EARTH BOUNDARY - The world ends here!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(newX < 0 || newX >= CFG.W || newY < 0 || newY >= CFG.H) {
                    if(CFG.MAP_EXPANSION.ENABLED) {
                        // Check if we've reached maximum world size
                        if(CFG.W >= CFG.MAP_EXPANSION.MAX_SIZE) {
                            Controller.toast(`ğŸŒ ${CFG.MAP_EXPANSION.BOUNDARY_MESSAGE}`, 5000);
                            this.logEvent(`Year ${this.year}: Scouts discovered the World's Edge`);
                        } else {
                            // World can still be expanded (future feature)
                            Controller.toast("ğŸ—ºï¸ The edge of known lands. Send scouts to explore further?", 3000);
                        }
                    }
                    return false;
                }
                
                let tile = this.tiles[newX][newY];
                
                // Block water tiles
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') return false;
                
                // Block stone deposits
                if(tile.stoneDeposit) {
                    Controller.toast("â›°ï¸ Stone deposit blocking path.");
                    return false;
                }
                
                // Block STONE terrain in WANDER mode
                if(tile.type === 'STONE' && this.gameState === 'WANDER') {
                    Controller.toast("â›°ï¸ Dense rock formation. Impassable.");
                    return false;
                }
                
                // Update direction based on movement
                if(dx > 0) this.player.direction = 'right';
                else if(dx < 0) this.player.direction = 'left';
                else if(dy > 0) this.player.direction = 'down';
                else if(dy < 0) this.player.direction = 'up';
                
                // Move player
                this.player.x = newX;
                this.player.y = newY;
                
                // FOOD COST: 1 food per 15 steps per population (in WANDER mode only)
                if(this.gameState === 'WANDER') {
                    this.foodStepCounter++;
                    if(this.foodStepCounter >= CFG.MOVEMENT.STEPS_PER_FOOD) {
                        this.foodStepCounter = 0;
                        let popCount = Math.max(1, this.pop);
                        let foodCost = popCount * CFG.MOVEMENT.FOOD_PER_PERSON;
                        this.inventory.food = Math.max(0, this.inventory.food - foodCost);
                        // Always show food cost message
                        Controller.toast(`ğŸ– -${foodCost} food (${popCount} people traveling) | Remaining: ${Math.floor(this.inventory.food)}`);
                        
                        // Check for starvation game over
                        if(this.inventory.food <= 0) {
                            Controller.showGameOver('LEVEL1');
                            return false;
                        }
                    }
                }
                
                // THIRST MECHANIC (WANDER mode only): Must drink water every 100 steps
                if(this.gameState === 'WANDER') {
                    this.thirstCounter++;
                    // Thirst depletes by 1 every step
                    this.thirst = Math.max(0, 100 - this.thirstCounter);
                    
                    // Check if standing on drinkable water (RIVER or WATER, NOT ocean/deep)
                    let currentTile = this.tiles[newX][newY];
                    let isDrinkableWater = currentTile && (currentTile.type === 'RIVER' || currentTile.type === 'WATER');
                    
                    // Check if near a wander well (within 1 tile)
                    let nearWanderWell = this.wanderWells && this.wanderWells.some(well => {
                        let dist = Math.abs(well.x - newX) + Math.abs(well.y - newY);
                        return dist <= 1; // Adjacent or on the well
                    });
                    
                    if(isDrinkableWater || nearWanderWell) {
                        this.thirstCounter = 0;
                        this.thirst = 100;
                        if(nearWanderWell && !isDrinkableWater) {
                            Controller.toast(`ğŸ’§ Drank from your well! Thirst replenished.`);
                        } else {
                            Controller.toast(`ğŸ’§ Drank from water source! Thirst replenished.`);
                        }
                    }
                    
                    // Warning at 30% thirst
                    if(this.thirst === 30) {
                        Controller.toast(`âš ï¸ Getting thirsty! Find a river or lake soon!`);
                    }
                    // Warning at 15% thirst
                    if(this.thirst === 15) {
                        Controller.toast(`ğŸ”´ DEHYDRATED! Find water NOW or your tribe will die!`);
                    }
                    
                    // Death at 0 thirst
                    if(this.thirst <= 0) {
                        Controller.showGameOver('THIRST');
                        return false;
                    }
                }
                
                // PASSIVE COLLECTION: Every 5 steps, 0.01% chance to find 1-5 metal or stone
                this.stepCounter++;
                if(this.stepCounter >= 5) {
                    this.stepCounter = 0;
                    if(Math.random() < 0.0001) { // 0.01% chance
                        let pocketTotal = this.pocket.metal + this.pocket.stone;
                        if(pocketTotal < this.pocket.capacity) {
                            let amount = 1 + Math.floor(Math.random() * 5); // 1-5
                            let spaceLeft = this.pocket.capacity - pocketTotal;
                            amount = Math.min(amount, spaceLeft);
                            
                            if(Math.random() < 0.5) {
                                this.pocket.metal += amount;
                                Controller.toast(`âœ¨ Found ${amount} metal nugget${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            } else {
                                this.pocket.stone += amount;
                                Controller.toast(`ğŸ’ Found ${amount} stone${amount > 1 ? 's' : ''}! (Pocket: ${Controller.formatNum(this.pocket.metal)}M ${Controller.formatNum(this.pocket.stone)}S)`);
                            }
                        }
                    }
                }
                
                // Explore around player
                this.exploreArea(newX, newY, 3);
                
                // Animals are now handled by click handler (instant kill)
                // Walking onto animal square does nothing, UNLESS it's a herd
                
                // Check for hostile herds (groups of touching animals)
                if(this.gameState === 'WANDER' && tile.animal) {
                    let adjacentAnimals = 0;
                    for(let dx = -1; dx <= 1; dx++) {
                        for(let dy = -1; dy <= 1; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            let checkX = newX + dx;
                            let checkY = newY + dy;
                            if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                                let adjacentTile = this.tiles[checkX][checkY];
                                if(adjacentTile && adjacentTile.animal) {
                                    adjacentAnimals++;
                                }
                            }
                        }
                    }
                    
                    // If 2+ adjacent animals, it's a hostile herd
                    let isHerd = adjacentAnimals >= 2;
                    
                    if(isHerd) {
                        // Hostile herd encounter - ALWAYS lose at least 1 population (unsafe hunt)
                        let popLoss = Math.max(1, Math.min(3, Math.ceil(this.pop * 0.15))); // Lose 1-3 people (15% of pop, minimum 1)
                        this.pop = Math.max(1, this.pop - popLoss); // Keep at least 1 person
                        SoundFX.playHurt();
                        let animalEmoji = tile.animal.emoji || 'ğŸ¦Œ';
                        Controller.toast(`ğŸ’€ UNSAFE HUNT! ${animalEmoji} Herd attacked! Lost ${popLoss} wanderer${popLoss > 1 ? 's' : ''}. Population: ${this.pop}`);
                        
                        // Don't remove the animal - herds are dangerous to approach
                        this.aiTarget = null;
                        this.checkProgression();
                        return; // Don't continue with movement
                    }
                }
                
                // === FOREST TILE: Passive +1 Wood (Master Design v40.0) ===
                // Stepping on FOREST terrain gives +1 wood (scavenging), doesn't destroy forest
                if(this.gameState === 'WANDER' && tile.type === 'FOREST') {
                    let woodAmount = CFG.FOREST.WOOD_PER_STEP; // +1 wood per step
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        SoundFX.playCollect('wood');
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        // Don't destroy forest - passive collection
                        Controller.toast(`ğŸŒ² Scavenged +${woodAmount} wood (${Math.floor(this.inventory.wood)}W total)`);
                    } else if(spaceAvailable === 0) {
                        Controller.toast(`âš ï¸ Inventory full! Cannot collect wood`);
                    }
                }
                
                // Individual trees can be chopped for more wood (2-5)
                if(this.gameState === 'WANDER' && tile.tree) {
                    let woodAmount = 2 + Math.floor(Math.random() * 4); // 2-5 wood per tree
                    let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                    let spaceAvailable = this.inventory.capacity - totalInventory;
                    if(spaceAvailable >= woodAmount) {
                        this.inventory.wood += woodAmount;
                        tile.tree = false; // Remove individual tree
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ğŸªµ Chopped tree! +${woodAmount} wood (${this.inventory.wood} total)`);
                    } else if(spaceAvailable > 0) {
                        this.inventory.wood += spaceAvailable;
                        tile.tree = false;
                        SoundFX.playThud();
                        // Trigger bash animation for wood collection
                        if(this.player) this.player.bashTime = performance.now();
                        // Add wood chip effect
                        if(typeof Renderer !== 'undefined' && Renderer.addWoodChips) Renderer.addWoodChips(this.player.x, this.player.y);
                        Controller.toast(`ğŸªµ Chopped tree! +${spaceAvailable}/${woodAmount} wood (Inventory Full!)`);
                    } else {
                        Controller.toast(`âš ï¸ Inventory full! Cannot chop tree`);
                    }
                }
                
                // === OPEN GROUND: Rare Find (Master Design v40.0) ===
                // 0.01% chance per step on GRASS/SAND to find +1 Metal or +1 Stone
                if(this.gameState === 'WANDER' && (tile.type === 'GRASS' || tile.type === 'SAND')) {
                    if(Math.random() < CFG.OPEN_GROUND.RARE_FIND_CHANCE) {
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        if(spaceAvailable > 0) {
                            // 50% metal, 50% stone
                            if(Math.random() < CFG.OPEN_GROUND.METAL_CHANCE) {
                                this.inventory.metal += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`âœ¨ Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Metal! (${this.inventory.metal}M total)`);
                            } else {
                                this.inventory.stone += CFG.OPEN_GROUND.FIND_AMOUNT;
                                SoundFX.playLucky();
                                Controller.toast(`âœ¨ Lucky find! +${CFG.OPEN_GROUND.FIND_AMOUNT} Stone! (${this.inventory.stone}S total)`);
                            }
                        }
                    }
                }
                
                // --- HARDCORE INTERACTION LOGIC (DEEP ENTITY SYSTEM) ---
                
                // Check for entity interactions
                console.log(`[Entity Debug] tile.entity:`, tile.entity, `at (${newX}, ${newY})`);
                if(tile.entity) {
                    let entity = tile.entity;
                    console.log(`[Entity Debug] Found entity type: ${entity.type}`);
                    
                    // BERRY ENTITY
                    if(entity.type === 'BERRY') {
                        if(entity.is_poisonous) {
                            // Trigger bash for poison berry
                            if(this.player) this.player.bashTime = performance.now();
                            this.pop = Math.max(0, this.pop - 1);
                            SoundFX.playHurt();
                            Controller.toast(`â˜ ï¸ POISON BERRY! -1 Population - YUCK!`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                            tile.entity = null; // Remove poison berry after eating
                        } else {
                            let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - totalInventory;
                            console.log(`[Berry Debug] totalInventory: ${totalInventory}, spaceAvailable: ${spaceAvailable}, berryAmount: ${entity.amount}`);
                            // Patch: Always collect as much food as possible if space allows
                            let foodToCollect = Math.min(entity.amount, spaceAvailable);
                            if(foodToCollect > 0) {
                                // Trigger bash animation AFTER confirming collection
                                if(this.player) this.player.bashTime = performance.now();
                                this.inventory.food += foodToCollect;
                                this.totalFoodCollected += foodToCollect;
                                SoundFX.playCollect('food');
                                if(foodToCollect === entity.amount) {
                                    Controller.toast(`ğŸ« Found Berry! +${entity.amount} food (${Math.floor(this.inventory.food)}/${this.inventory.capacity}) - YUM!`);
                                } else {
                                    Controller.toast(`ğŸ« Found Berry! +${foodToCollect}/${entity.amount} food (Inventory Full!) - YUM!`);
                                }
                                tile.entity = null; // Remove entity
                            } else {
                                // Don't bash if inventory is full
                                Controller.toast(`âš ï¸ Inventory full! (${Math.floor(totalInventory)}/${this.inventory.capacity}) - Cannot collect berry`);
                                return; // Don't remove berry if inventory completely full
                            }
                        }
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                    
                    // NOMAD ENTITY
                    else if(entity.type === 'NOMAD') {
                        if(entity.is_hostile) {
                            // Trigger bash for hostile encounter
                            if(this.player) this.player.bashTime = performance.now();
                            let damage = entity.damage;
                            this.pop = Math.max(0, this.pop - damage);
                            SoundFX.playHurt();
                            Controller.toast(`âš”ï¸ HOSTILE NOMAD! Ambush! -${damage} Population`);
                            if(this.pop === 0) {
                                Controller.showGameOver('LEVEL1');
                                return;
                            }
                        } else {
                            // Trigger bash for friendly greeting
                            if(this.player) this.player.bashTime = performance.now();
                            PROGRESSION.nomadsFound++;
                            this.nomadsFound++;
                            this.pop += entity.pop;
                            SoundFX.playCollect('population');
                            
                            // Update building populations when nomads join
                            if(typeof assignPopulationToResidential === 'function') {
                                assignPopulationToResidential(this);
                            }
                            
                            // Calculate total loot
                            let totalLoot = entity.loot.food + entity.loot.wood + entity.loot.metal + (entity.loot.stone || 0);
                            let currentInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                            let spaceAvailable = this.inventory.capacity - currentInventory;
                            
                            // Transfer what fits
                            let foodAdded = 0, woodAdded = 0, metalAdded = 0, stoneAdded = 0;
                            
                            if(spaceAvailable >= totalLoot) {
                                // All loot fits
                                this.inventory.food += entity.loot.food;
                                this.totalFoodCollected += entity.loot.food;
                                this.inventory.wood += entity.loot.wood;
                                this.inventory.metal += entity.loot.metal;
                                this.inventory.stone += entity.loot.stone || 0;
                                foodAdded = entity.loot.food;
                                woodAdded = entity.loot.wood;
                                metalAdded = entity.loot.metal;
                                stoneAdded = entity.loot.stone || 0;
                            } else if(spaceAvailable > 0) {
                                // Partial loot - prioritize food > wood > metal > stone
                                let remaining = spaceAvailable;
                                foodAdded = Math.min(entity.loot.food, remaining);
                                this.inventory.food += foodAdded;
                                this.totalFoodCollected += foodAdded;
                                remaining -= foodAdded;
                                
                                if(remaining > 0) {
                                    woodAdded = Math.min(entity.loot.wood, remaining);
                                    this.inventory.wood += woodAdded;
                                    remaining -= woodAdded;
                                }
                                if(remaining > 0) {
                                    metalAdded = Math.min(entity.loot.metal, remaining);
                                    this.inventory.metal += metalAdded;
                                    remaining -= metalAdded;
                                }
                                if(remaining > 0) {
                                    stoneAdded = Math.min(entity.loot.stone || 0, remaining);
                                    this.inventory.stone += stoneAdded;
                                }
                            }
                            
                            // Increase capacity (+100 per nomad)
                            this.inventory.capacity += 100;
                            
                            // Nomad shares local knowledge
                            this.exploreArea(newX, newY, 15);
                            
                            let lootMsg = spaceAvailable >= totalLoot 
                                ? `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S` 
                                : `+${foodAdded}F +${woodAdded}W +${metalAdded}M +${stoneAdded}S (Inventory was full!)`;
                            Controller.toast(`ğŸ‘¤ OOGA BOOGA! Nomad joined! +${entity.pop} Pop, ${lootMsg}, Capacity: ${this.inventory.capacity}`);
                            
                            // LORE TRIGGER: First nomad!
                            if(!this.loreSeen) this.loreSeen = {};
                            if(!this.loreSeen.FIRST_NOMAD) {
                                this.loreSeen.FIRST_NOMAD = true;
                                Controller.showLoreEvent('FIRST_NOMAD');
                            }
                        }
                        tile.entity = null; // Remove entity
                        this.aiTarget = null; // Clear AI target so it finds new one
                        this.checkProgression();
                    }
                }
                
                // Camera follows player smoothly
                Controller.cam.x = this.player.x * CFG.TILE;
                Controller.cam.y = this.player.y * CFG.TILE;
                
                Controller.updateUI();
                
                return true; // Successfully moved
            },
            
            movePlayerToTile(targetX, targetY) {
                if(!this.player) return;
                
                // Check for player death
                if(this.player.health <= 0) {
                    Controller.showGameOver('HUNTING');
                    return;
                }

                if(targetX < 0 || targetX >= CFG.W || targetY < 0 || targetY >= CFG.H) return;
                
                // Check if clicking on an animal to attack it (works from adjacent or same tile)
                let animalIndex = this.animals.findIndex(a => a.x === targetX && a.y === targetY);
                if(animalIndex !== -1) {
                    // Animal attack is now handled by click (instant kill)
                    // Just pathfind to the location normally
                }
                
                let tile = this.tiles[targetX][targetY];
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) return;
                
                // Generate path to target
                this.pathQueue = this.findPath(this.player.x, this.player.y, targetX, targetY);
            },
            
            findPath(startX, startY, endX, endY) {
                // Simple A* pathfinding
                let openSet = [{x: startX, y: startY, g: 0, h: Math.abs(endX - startX) + Math.abs(endY - startY), parent: null}];
                let closedSet = new Set();
                
                while(openSet.length > 0) {
                    // Find node with lowest f score
                    openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                    let current = openSet.shift();
                    
                    if(current.x === endX && current.y === endY) {
                        // Reconstruct path
                        let path = [];
                        while(current.parent) {
                            path.unshift({x: current.x, y: current.y});
                            current = current.parent;
                        }
                        return path;
                    }
                    
                    closedSet.add(`${current.x},${current.y}`);
                    
                    // Check neighbors
                    let directions = [{x:0,y:-1}, {x:0,y:1}, {x:-1,y:0}, {x:1,y:0}];
                    for(let dir of directions) {
                        let nx = current.x + dir.x;
                        let ny = current.y + dir.y;
                        
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        if(closedSet.has(`${nx},${ny}`)) continue;
                        
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE' || tile.stoneDeposit) continue;
                        
                        let g = current.g + 1;
                        let h = Math.abs(endX - nx) + Math.abs(endY - ny);
                        
                        let existing = openSet.find(n => n.x === nx && n.y === ny);
                        if(!existing) {
                            openSet.push({x: nx, y: ny, g: g, h: h, parent: current});
                        } else if(g < existing.g) {
                            existing.g = g;
                            existing.parent = current;
                        }
                    }
                    
                    // Limit search to prevent lag
                    if(closedSet.size > 1000) break;
                }
                
                // No path found, return empty
                return [];
            },
            
            processPath() {
                // Only move every 150ms for smooth visible walking animation
                let now = performance.now();
                if(now - this.lastMoveTime < 150) {
                    return;
                }
                
                if(this.pathQueue.length > 0) {
                    let next = this.pathQueue[0];
                    let dx = next.x - this.player.x;
                    let dy = next.y - this.player.y;
                    
                    if(Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                        let moved = this.movePlayer(dx, dy);
                        if(moved) {
                            this.pathQueue.shift();
                            this.lastMoveTime = now;
                        } else {
                            // Can't move (blocked), clear path and let AI recalculate
                            console.warn('AI: Path blocked, clearing queue');
                            this.pathQueue = [];
                            if(this.aiTarget) this.aiTarget = null;
                        }
                    } else {
                        // Path is invalid, clear it
                        console.warn('AI: Invalid path step, clearing queue');
                        this.pathQueue = [];
                    }
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AI AUTOPLAY SYSTEM - Delegated to External Module
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AI logic has been moved to js/ai.js for better organization
            // and easier debugging. This wrapper maintains compatibility.
            
            aiUpdate() {
                // Delegate to external AI module with safety check
                if(typeof AI !== 'undefined' && AI && typeof AI.update === 'function') {
                    AI.update(this);
                }
            },
            
            // Helper function for AI building attempts
            tryBuild(type, searchRadius) {
                for(let attempt = 0; attempt < 15; attempt++) {
                    let buildX = Math.floor(this.player.x + (Math.random() - 0.5) * searchRadius * 2);
                    let buildY = Math.floor(this.player.y + (Math.random() - 0.5) * searchRadius * 2);
                    buildX = Math.max(0, Math.min(CFG.W - 1, buildX));
                    buildY = Math.max(0, Math.min(CFG.H - 1, buildY));
                    
                    if(this.isValid(buildX, buildY, type)) {
                        this.build(buildX, buildY, type);
                        return true;
                    }
                }
                return false;
            },
            
            // === BUILDING EVOLUTION SYSTEM ===
            // Level 0 buildings evolve based on location desirability
            // Run every 60 frames (~1 second) to update building states
            updateBuildingEvolution() {
                try {
                    if(!this.evolutionFrameCounter) this.evolutionFrameCounter = 0;
                    this.evolutionFrameCounter++;
                    
                    // Only update every 300 frames (5 seconds at 60fps) - OPTIMIZED for performance
                    if(this.evolutionFrameCounter < 300) return;
                    this.evolutionFrameCounter = 0;
                    
                    // Don't run in nomad mode
                    if(this.gameState !== 'CITY') return;
                    
                    // Limit checks to avoid performance issues - REDUCED for better FPS
                    let checksThisFrame = 0;
                    const MAX_CHECKS_PER_FRAME = 20;
                    
                    // Iterate through ALL residential buildings (ALL LEVELS 0-4)
                    for(let x = 0; x < CFG.W && checksThisFrame < MAX_CHECKS_PER_FRAME; x++) {
                        for(let y = 0; y < CFG.H && checksThisFrame < MAX_CHECKS_PER_FRAME; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                checksThisFrame++;
                                
                                let bld = tile.building;
                                
                                // Calculate local desirability for this tile (pass building level)
                                let desirability = this.calculateTileDesirability(x, y, bld.level);
                                
                                // Store desirability for future reference
                                bld.desirability = desirability;
                                
                                // Determine variant based on building level
                                let oldVariant = bld.variant || 0;
                                let newVariant = 0;
                                
                                if(bld.level === 1) {
                                    // Level 1: Tree Shelter - Abandoned (0) â†’ Small Nest (1-5) â†’ Tree Platform (6-10) â†’ Sturdy Treehouse (11-15)
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned Nest
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Small Nest
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Tree Platform
                                    } else {
                                        newVariant = 3; // Sturdy Treehouse
                                    }
                                    
                                    // Level 1 population scaling (0-15 people)
                                    let newPopulation;
                                    if(newVariant === 0) {
                                        // Abandoned: 0 people
                                        newPopulation = 0;
                                    } else if(newVariant === 1) {
                                        // Small Nest: 1-5 people
                                        newPopulation = 1 + Math.floor((desirability - 0.1) / 0.3 * 4);
                                    } else if(newVariant === 2) {
                                        // Tree Platform: 6-10 people
                                        newPopulation = 6 + Math.floor((desirability - 0.4) / 0.3 * 4);
                                    } else {
                                        // Sturdy Treehouse: 11-15 people
                                        newPopulation = 11 + Math.floor((desirability - 0.7) / 0.3 * 4);
                                    }
                                    bld.population = Math.max(0, Math.min(15, newPopulation));
                                } else {
                                    // Levels 2-4: Use same 4-variant system
                                    // Variant 0: Abandoned (desirability < 0.1)
                                    // Variant 1: Low (desirability 0.1-0.4) - Base income
                                    // Variant 2: Medium (desirability 0.4-0.7) - Full bonus
                                    // Variant 3: High (desirability >= 0.7) - Enhanced bonus
                                    if(desirability < 0.1) {
                                        newVariant = 0; // Abandoned state
                                    } else if(desirability < 0.4) {
                                        newVariant = 1; // Low state
                                    } else if(desirability < 0.7) {
                                        newVariant = 2; // Medium state
                                    } else {
                                        newVariant = 3; // High state
                                    }
                                }
                                
                                // Update variant and notify if changed
                                if(newVariant !== oldVariant) {
                                    tile.building.variant = newVariant;
                                    
                                    // Get variant name from BUILDING_LEVELS config
                                    let levelConfig = CFG.BUILDING_LEVELS[tile.building.level] || CFG.BUILDING_LEVELS[1];
                                    let variantName = 'Building';
                                    if(levelConfig.variants && levelConfig.variants[newVariant]) {
                                        variantName = levelConfig.variants[newVariant].name;
                                    }
                                    
                                    let icons = ['ğŸ•³ï¸', 'ğŸšï¸', 'ğŸ ', 'ğŸ˜ï¸'];
                                    
                                    // Show notification for upgrades only (not downgrades to avoid spam)
                                    if(newVariant > oldVariant) {
                                        Controller.toast(`${icons[newVariant]} Upgraded to ${variantName}!`);
                                    }
                                    
                                    // Mark tile for redraw
                                    this.markDirty(x, y, 1);
                                }
                                
                                // Store desirability for future reference
                                tile.building.desirability = desirability;
                            }
                        }
                    }
                } catch(err) {
                    console.error('Evolution update error:', err);
                }
            },
            
            // Calculate desirability for a specific tile - LEVEL 1 SPECIAL CALCULATION
            // Level 1 uses different factors: water, dirt roads, commercial, industrial, berries
            calculateLevel1Desirability(x, y) {
                let score = 0.25; // Lower baseline for Level 1 (minimal bonuses philosophy)
                
                // Water proximity (+0.15 bonus)
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        let dist = Math.abs(dx) + Math.abs(dy);
                        if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                            waterDist = Math.min(waterDist, dist);
                            if(dist === 0) waterFound = true;
                        }
                    }
                }
                if(waterDist <= 3) score += 0.15;
                else if(waterDist <= 5) score += 0.08;
                
                // Dirt road adjacent (+0.10 bonus, but ONLY if roads are maintained!)
                // Roads need workers: 1 worker per 5 road tiles
                // If workforce shortage, road bonus is reduced proportionally
                let hasAdjacentRoad = false;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        // Check for road using tile.road property (not zone)
                        if(this.tiles[nx][ny].road) {
                            hasAdjacentRoad = true;
                            break;
                        }
                    }
                    if(hasAdjacentRoad) break;
                }
                if(hasAdjacentRoad) {
                    // Calculate road maintenance effectiveness
                    let roadMaintenance = 1.0; // 100% if fully staffed
                    if(this.workforce && this.workforce.roadsNeeded > 0) {
                        roadMaintenance = Math.min(1.0, this.workforce.roadWorkers / this.workforce.roadsNeeded);
                    }
                    score += 0.10 * roadMaintenance; // Road bonus scaled by maintenance
                }
                
                // Commercial nearby (+0.08 bonus within 8 tiles)
                let commercialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'COMMERCIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        commercialNearby = true;
                        break;
                    }
                }
                if(commercialNearby) score += 0.08;
                
                // Industrial proximity (+0.15 bonus within 8 tiles - primitive people want to live near butcher/hunter)
                let industrialNearby = false;
                for(let bld of this.blds) {
                    if(bld.t !== 'INDUSTRIAL') continue;
                    let dist = Math.abs(bld.x - x) + Math.abs(bld.y - y);
                    if(dist <= 8) {
                        industrialNearby = true;
                        break;
                    }
                }
                if(industrialNearby) score += 0.15;
                
                // Berry tiles nearby (+0.20 bonus if any berries within 3 tiles)within 3 tiles)
                let berryCount = 0;
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx < 0 || nx >= CFG.W || ny < 0 || ny >= CFG.H) continue;
                        let tile = this.tiles[nx][ny];
                        if(tile.type === 'BERRY') berryCount++;
                    }
                }
                if(berryCount >= 1) score += 0.20;
                
                return Math.max(0, Math.min(1, score));
            },
            
            // Calculate desirability for a specific tile
            // Factors: Water proximity, Wells, Roads, Commercial, Industrial distance, Population density
            calculateTileDesirability(x, y, buildingLevel) {
                // Use Level 1 special calculation
                if(buildingLevel === 1) {
                    return this.calculateLevel1Desirability(x, y);
                }
                
                let score = 0.35; // BUFFED base score (was 0.3) to help reach higher tiers
                
                // === WATER PROXIMITY (Critical: +0.30 BUFFED) ===
                // OPTIMIZED: Reduced search area and added early exit
                let waterDist = 999;
                let waterFound = false;
                for(let dx = -5; dx <= 5 && !waterFound; dx++) {
                    for(let dy = -5; dy <= 5 && !waterFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            let tile = this.tiles[nx][ny];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.water) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                waterDist = Math.min(waterDist, dist);
                                if(dist === 0) waterFound = true; // Early exit if adjacent
                            }
                        }
                    }
                }
                // Closer water = better. 1 tile away = +0.30 (was +0.25), 5 tiles = +0.06
                if(waterDist <= 5) {
                    score += 0.30 * (1 - (waterDist / 6));
                }
                
                // === WELL PROXIMITY (Important: +0.25 BUFFED) ===
                // OPTIMIZED: Only check wells within reasonable range
                let nearestWell = 999;
                for(let well of this.blds) {
                    if(well.t !== 'WELL') continue;
                    let dist = Math.abs(x - well.x) + Math.abs(y - well.y);
                    if(dist > 8) continue; // Skip distant wells
                    nearestWell = Math.min(nearestWell, dist);
                    if(dist === 0) break; // Early exit if on well
                }
                // Well within 8 tiles is valuable: +0.25 (was +0.20)
                if(nearestWell <= 8) {
                    score += 0.25 * (1 - (nearestWell / 9));
                }
                
                // === ROAD CONNECTIVITY (Infrastructure: +0.20 BUFFED) ===
                // OPTIMIZED: Smaller search area with early exit
                let roadDist = 999;
                let roadFound = false;
                for(let dx = -2; dx <= 2 && !roadFound; dx++) {
                    for(let dy = -2; dy <= 2 && !roadFound; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].road) {
                                let dist = Math.abs(dx) + Math.abs(dy);
                                roadDist = Math.min(roadDist, dist);
                                if(dist === 0) roadFound = true;
                            }
                        }
                    }
                }
                if(roadDist <= 2) {
                    score += 0.20 * (1 - (roadDist / 3)); // Was +0.15
                }
                
                // === COMMERCIAL PROXIMITY (Convenience: +0.12) ===
                // OPTIMIZED: Skip if no commercial buildings exist
                let nearestCom = 999;
                for(let com of this.blds) {
                    if(com.t !== 'COM') continue;
                    let dist = Math.abs(x - com.x) + Math.abs(y - com.y);
                    if(dist > 10) continue; // Skip distant ones
                    nearestCom = Math.min(nearestCom, dist);
                    if(dist === 0) break;
                }
                // Commercial within 10 tiles is good
                if(nearestCom <= 10) {
                    score += 0.12 * (1 - (nearestCom / 11));
                }
                
                // === INDUSTRIAL DISTANCE (Pollution penalty: up to -0.20) ===
                // OPTIMIZED: Skip if no industrial buildings exist
                let nearestInd = 999;
                for(let ind of this.blds) {
                    if(ind.t !== 'IND') continue;
                    let dist = Math.abs(x - ind.x) + Math.abs(y - ind.y);
                    if(dist >= 15) continue; // Skip if too far to matter
                    nearestInd = Math.min(nearestInd, dist);
                }
                // Industrial within 3 tiles = severe penalty, 15+ tiles = no penalty
                if(nearestInd < 15) {
                    let penalty = nearestInd < 3 ? -0.20 : -0.20 * (1 - ((nearestInd - 3) / 12));
                    score += penalty;
                }
                
                // === POPULATION DENSITY (Clustering: +0.08) ===
                // OPTIMIZED: Smaller search radius (3 -> 2) and count limit
                let neighbors = 0;
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].zone === 'R') {
                                neighbors++;
                                if(neighbors > 10) break; // Early exit if overcrowded
                            }
                        }
                    }
                    if(neighbors > 10) break;
                }
                // Sweet spot: 2-6 neighbors. Too few = isolated, too many = crowded
                if(neighbors >= 2 && neighbors <= 6) {
                    score += 0.08;
                } else if(neighbors > 6) {
                    // Overcrowding penalty
                    score -= Math.min(0.10, (neighbors - 6) * 0.02);
                } else if(neighbors === 0) {
                    // Severe isolation penalty
                    score -= 0.15;
                }
                
                // === NATURAL FEATURES (Aesthetics: +0.05) ===
                // SIMPLIFIED: Just check immediate surroundings
                let trees = 0;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        let nx = x + dx, ny = y + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].tree) trees++;
                        }
                    }
                }
                score += Math.min(0.05, trees * 0.015);
                
                // Clamp between 0 and 1
                return Math.max(0, Math.min(1, score));
            },
            
            attackAnimal(animalIndex) {
                let animal = this.animals[animalIndex];
                animal.hits++;
                
                // Get animal config
                let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                
                if(animal.hits >= config.hitToKill) {
                    // Animal defeated!
                    
                    // HERD DANGER: Check if other animals are on same tile or adjacent
                    let nearbyAnimals = this.animals.filter((a, idx) => {
                        if(idx === animalIndex) return false; // Skip self
                        let dx = Math.abs(a.x - animal.x);
                        let dy = Math.abs(a.y - animal.y);
                        return dx <= 1 && dy <= 1; // Same tile or adjacent
                    });
                    
                    let isHerd = nearbyAnimals.length > 0;
                    let herdDamage = 0;
                    
                    if(isHerd && this.gameState === 'WANDER') {
                        // Herd attack - costs 1-3 population
                        herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                        this.pop = Math.max(0, this.pop - herdDamage);
                        
                        if(this.pop === 0) {
                            Controller.toast("ğŸ’€ Your tribe has perished attacking a herd!");
                            this.animals.splice(animalIndex, 1);
                            Controller.updateUI();
                            return;
                        }
                    }
                    
                    // Calculate food reward (random for animals)
                    let foodReward;
                    if(Array.isArray(config.foodReward)) {
                        // Random range [min, max]
                        foodReward = config.foodReward[0] + Math.floor(Math.random() * (config.foodReward[1] - config.foodReward[0] + 1));
                    } else {
                        // Fixed value (wolf)
                        foodReward = config.foodReward;
                    }
                    
                    // Apply base population cost (wolf costs -1 Pop to kill)
                    let popCost = config.popCost || 0;
                    let popLostMsg = '';
                    if(popCost > 0 && this.pop > 0) {
                        this.pop = Math.max(0, this.pop - popCost);
                        popLostMsg = ` (-${popCost} Pop!)`;
                        
                        // Check for game over
                        if(this.pop === 0) {
                            Controller.showGameOver('HUNTING');
                            return;
                        }
                    }
                    
                    // Add herd damage to message
                    if(herdDamage > 0) {
                        popLostMsg += ` (Herd cost: ${herdDamage} pop)`;
                    }
                    
                    if(this.gameState === 'WANDER') {
                        // Check capacity
                        let totalInventory = this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone;
                        let spaceAvailable = this.inventory.capacity - totalInventory;
                        
                        // Build message with herd context
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        
                        if(spaceAvailable >= foodReward) {
                            this.inventory.food += foodReward;
                            this.totalFoodCollected += foodReward;
                            SoundFX.playCollect('food');
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} ğŸ–`);
                        } else if(spaceAvailable > 0) {
                            this.inventory.food += spaceAvailable;
                            this.totalFoodCollected += spaceAvailable;
                            SoundFX.playCollect('food');
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${spaceAvailable}/${foodReward} Food${herdMsg}`);
                        } else {
                            Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} Food lost - Inventory Full!${herdMsg}`);
                        }
                    } else {
                        // City mode - add to main food storage
                        this.food += foodReward;
                        SoundFX.playCollect('food');
                        let herdMsg = isHerd ? '' : ' (Safe hunt!)';
                        Controller.toast(`ğŸ¯ ${animalName} defeated!${popLostMsg} +${foodReward} Food${herdMsg} ğŸ–`);
                    }
                    
                    this.animals.splice(animalIndex, 1);
                    
                    // LORE TRIGGERS: Track first kill and special animal kills
                    if(!this.loreSeen) this.loreSeen = {};
                    if(!this.loreSeen.FIRST_KILL) {
                        this.loreSeen.FIRST_KILL = true;
                        Controller.showLoreEvent('FIRST_KILL');
                    }
                    // Special lore for first turtle kill
                    if(animal.type === 'TURTLE' && !this.loreSeen.FIRST_TURTLE) {
                        this.loreSeen.FIRST_TURTLE = true;
                        Controller.showLoreEvent('FIRST_TURTLE');
                    }
                    
                    this.checkProgression();
                } else {
                    Controller.toast(`ğŸ’¥ Hit ${animalName.toLowerCase()}! (${animal.hits}/${config.hitToKill})`);
                }
                Controller.updateUI();
            },
            
            checkProgression() {
                let unlock = PROGRESSION.checkUnlock(this);
                if(unlock === 'settlement') {
                    Controller.toast("Settlement Unlocked! Explore to find water, then build Mud Huts! ğŸ ");
                    Controller.showSettlementUI();
                    // Immediately check for industrial unlock too
                    this.checkProgression();
                } else if(unlock === 'industrial') {
                    Controller.toast("Hunting Grounds Unlocked! Cost: 1000 Food + 1000 Wood. ğŸ­");
                    Controller.showIndustrialUI();
                } else if(unlock === 'industrial_need_population') {
                    Controller.toast(`âš ï¸ Need ${CFG.PRODUCTION.INDUSTRIAL_POPULATION_REQUIREMENT} population to unlock Hunting Grounds!`);
                } else if(unlock === 'industrial_need_food') {
                    Controller.toast(`âš ï¸ Need ${CFG.PRODUCTION.INDUSTRIAL_UNLOCK_COST} food to unlock Hunting Grounds!`);
                }
            },
            
            settleHere() {
                console.log('settleHere() called!');
                console.log('gameState:', this.gameState);
                console.log('pop:', this.pop);
                console.log('inventory.food:', this.inventory.food);
                console.log('inventory.wood:', this.inventory.wood);
                
                // Record player action for AI learning
                if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                    QLearningAI.recordPlayerAction('SETTLE');
                }
                
                // Prevent settling if already in CITY mode
                if(this.gameState === 'CITY') {
                    Controller.toast("âš ï¸ Already settled!");
                    return;
                }
                
                // Get requirements from CFG (Master Design v40.0)
                const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                
                // Check requirements: Pop >= 2, Food >= 100, Wood >= 25
                if(this.pop < REQ.MIN_POP) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_POP}+ population to settle! (${this.pop}/${REQ.MIN_POP} - find nomads)`);
                    return;
                }
                if(this.inventory.food < REQ.MIN_FOOD) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_FOOD} food to settle! (${this.inventory.food}/${REQ.MIN_FOOD})`);
                    return;
                }
                if(this.inventory.wood < REQ.MIN_WOOD) {
                    Controller.toast(`âš ï¸ Need ${REQ.MIN_WOOD} wood to settle! (${this.inventory.wood}/${REQ.MIN_WOOD})`);
                    return;
                }
                
                // Check water proximity for BONUS (not required!)
                let px = this.player.x;
                let py = this.player.y;
                let waterDistance = Infinity;
                let waterFound = false;
                
                // Scan area for fresh water (bonus if nearby)
                for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                    for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                                let dist = Math.abs(dx) + Math.abs(dy); // Manhattan distance
                                waterDistance = Math.min(waterDistance, dist);
                                waterFound = true;
                            }
                        }
                    }
                }
                
                // Water nearby is a BONUS, not a requirement
                if(waterFound && waterDistance <= REQ.WATER_DISTANCE) {
                    Controller.toast(`ğŸ’§ Water nearby! (+Riverside bonus)`);
                }
                
                console.log('All requirements met! Starting settlement...');
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // RESOURCE LOCKING ON SETTLEMENT
                // Berry bush â†’ locks as Residential bonus
                // Tree/Forest â†’ locks as Commercial bonus  
                // Animal nearby â†’ locks as Industrial bonus
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let settleTile = this.tiles[px][py];
                this.lockedResources = {
                    residential: false,  // Berry locked
                    commercial: false,   // Tree locked
                    industrial: false    // Animal locked
                };
                
                // Check for berry on settlement tile
                if(settleTile.entity && settleTile.entity.type === 'BERRY') {
                    this.lockedResources.residential = true;
                    settleTile.entity.locked = true; // Mark as permanently locked
                    console.log('ğŸ‡ Berry locked for Residential bonus!');
                }
                
                // Check for tree on settlement tile
                if(settleTile.tree || settleTile.type === 'FOREST') {
                    this.lockedResources.commercial = true;
                    settleTile.lockedTree = true; // Mark tree as locked
                    console.log('ğŸŒ² Tree locked for Commercial bonus!');
                }
                
                // Check for animal adjacent to settlement (within 2 tiles)
                let foundAnimal = false;
                for(let dx = -2; dx <= 2 && !foundAnimal; dx++) {
                    for(let dy = -2; dy <= 2 && !foundAnimal; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            // Check animals array for nearby animal
                            for(let animal of this.animals) {
                                if(animal.x === x && animal.y === y) {
                                    this.lockedResources.industrial = true;
                                    animal.locked = true; // Mark animal as locked
                                    this.lockedAnimal = animal;
                                    foundAnimal = true;
                                    console.log('ğŸ¦Œ Animal locked for Industrial bonus!');
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Scan 5x5 area for site traits (bonus features)
                let stoneCount = 0;
                let berryCount = 0;
                
                for(let dx = -2; dx <= 2; dx++) {
                    for(let dy = -2; dy <= 2; dy++) {
                        let x = px + dx;
                        let y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = this.tiles[x][y];
                            if(tile.type === 'STONE') stoneCount++;
                            if(tile.entity && tile.entity.type === 'BERRY') berryCount++;
                        }
                    }
                }
                
                // Determine site traits
                this.siteTraits = [];
                if(waterDistance <= 2) this.siteTraits.push('Riverside');
                if(stoneCount >= 3) this.siteTraits.push('Mineral Rich');
                if(berryCount >= 2) this.siteTraits.push('Fertile');
                if(waterDistance <= 2 && berryCount >= 2) this.siteTraits.push('Paradise');
                
                // Transition to CITY mode
                console.log('Transitioning to CITY mode...');
                this.gameState = 'CITY';
                console.log('gameState set to CITY');
                this.settlementPos = { x: px, y: py };
                
                // CONVERT wander wells to city wells - they persist into city mode!
                // Each wanderWell becomes a WELL building in blds array
                let convertedWells = 0;
                if(this.wanderWells && this.wanderWells.length > 0) {
                    for(let well of this.wanderWells) {
                        // Add as city building well
                        this.blds.push({ t: 'WELL', x: well.x, y: well.y, lvl: 1, efficiency: 1.0, age: 0 });
                        convertedWells++;
                    }
                    console.log(`Converted ${convertedWells} wander wells to city wells`);
                }
                this.wanderWells = [];
                console.log('Wander wells cleared after conversion to city mode');
                
                // Transfer inventory to main resources (no deduction - resources persist)
                this.food = this.inventory.food;
                this.wood = this.inventory.wood;
                this.metal = this.inventory.metal;
                this.stone = this.inventory.stone;
                console.log('Resources transferred:', {food: this.food, wood: this.wood, metal: this.metal, stone: this.stone});
                
                // POPULATION-BASED SETTLEMENT BONUSES
                // More nomads recruited = stronger start
                let popBonus = Math.floor((this.pop - 1) * 10); // Each nomad adds +10% bonus
                let gatheringMultiplier = 0.5 + (this.pop * 0.1); // 0.5 base + 0.1 per nomad (caps at reasonable levels)
                
                // Apply population bonus to starting resources
                if (popBonus > 0) {
                    let bonusFood = Math.floor(Number(this.food) * (popBonus / 100));
                    let bonusWood = Math.floor(Number(this.wood) * (popBonus / 100));
                    this.food = Number(this.food) + bonusFood;
                    this.wood = Number(this.wood) + bonusWood;
                    console.log(`Population bonus (${this.pop} people): +${bonusFood} food, +${bonusWood} wood`);
                }
                
                // Set gathering rate based on initial population
                this.gatheringMultiplier = Math.min(3.0, gatheringMultiplier); // Cap at 3x
                console.log(`Gathering rate: ${(this.gatheringMultiplier * 100).toFixed(0)}% (${this.pop} settlers)`);
                
                let traitText = this.siteTraits.length > 0 ? ` (${this.siteTraits.join(', ')})` : '';
                let bonusText = popBonus > 0 ? ` +${popBonus}% Resources!` : '';
                let gatherText = this.gatheringMultiplier > 1.0 ? ` Gathering: ${(this.gatheringMultiplier * 100).toFixed(0)}%` : '';
                let wellText = convertedWells > 0 ? ` ğŸ’§${convertedWells} wells transferred!` : '';
                
                // Build locked resources text
                let lockedText = '';
                if(this.lockedResources.residential || this.lockedResources.commercial || this.lockedResources.industrial) {
                    let locked = [];
                    if(this.lockedResources.residential) locked.push('ğŸ‡ Berriesâ†’Residential');
                    if(this.lockedResources.commercial) locked.push('ğŸŒ² Treesâ†’Commercial');
                    if(this.lockedResources.industrial) locked.push('ğŸ¦Œ Animalsâ†’Industrial');
                    lockedText = ` [Locked: ${locked.join(', ')}]`;
                }
                
                Controller.toast(`ğŸ›ï¸ Settlement Started!${traitText}${bonusText}${gatherText}${wellText}${lockedText}`);
                console.log('Calling Controller.showCityUI()...');
                
                // LORE TRIGGER: First settlement!
                Controller.showLoreEvent('FIRST_SETTLEMENT');
                
                // Force UI update
                setTimeout(() => {
                    console.log('Delayed showCityUI call...');
                    Controller.showCityUI();
                    // Always show and enable t-res after settlement
                    let tResBtn = document.getElementById('t-res');
                    if (tResBtn) {
                        tResBtn.style.display = 'inline-block';
                        tResBtn.disabled = false;
                        tResBtn.title = 'Build Residential';
                    }
                    Controller.updateUI();
                    console.log('Settlement complete!');
                    
                    // Check progression to unlock industrial immediately after settlement
                    this.checkProgression();
                }, 100);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BUILD WANDER WELL (Level 0 only structure)
            // Cost: 25 food + 50 wood
            // Allows player to drink from well to reset thirst
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            buildWanderWell() {
                if(this.gameState !== 'WANDER') {
                    Controller.toast("âš ï¸ Can only build Water Pits while wandering!");
                    return false;
                }
                
                const WELL_COST = { food: 25, wood: 50 };
                
                // Check resources
                if(this.inventory.food < WELL_COST.food) {
                    Controller.toast(`âš ï¸ Need ${WELL_COST.food} food to dig a Water Pit! (${Math.floor(this.inventory.food)}/${WELL_COST.food})`);
                    return false;
                }
                if(this.inventory.wood < WELL_COST.wood) {
                    Controller.toast(`âš ï¸ Need ${WELL_COST.wood} wood to dig a Water Pit! (${Math.floor(this.inventory.wood)}/${WELL_COST.wood})`);
                    return false;
                }
                
                // Check if tile is buildable
                let px = this.player.x;
                let py = this.player.y;
                let tile = this.tiles[px][py];
                
                if(tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP') {
                    Controller.toast("âš ï¸ Can't build on water! You can drink here already.");
                    return false;
                }
                if(tile.type === 'STONE') {
                    Controller.toast("âš ï¸ Too rocky to dig here!");
                    return false;
                }
                
                // Check if well already exists at this location
                if(this.wanderWells.some(w => w.x === px && w.y === py)) {
                    Controller.toast("âš ï¸ There's already a Water Pit here!");
                    return false;
                }
                
                // Deduct resources
                this.inventory.food -= WELL_COST.food;
                this.inventory.wood -= WELL_COST.wood;
                
                // Create well
                this.wanderWells.push({ x: px, y: py });
                
                // Reset thirst immediately after building
                this.thirstCounter = 0;
                this.thirst = 100;
                
                // LORE TRIGGER: First well!
                if(this.wanderWells.length === 1) {
                    Controller.showLoreEvent('FIRST_WELL');
                }
                
                Controller.toast(`ğŸ•³ï¸ Built a Water Pit! (-${WELL_COST.food} food, -${WELL_COST.wood} wood) | You have ${this.wanderWells.length} well(s)`);
                Controller.updateUI();
                return true;
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SMART BUILD WELL - Works in both WANDER and CITY modes
            // WANDER: Builds Water Pit at player location (25 food + 50 wood)
            // CITY: Sets tool to WELL for placement mode (20 food)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            smartBuildWell() {
                if(this.gameState === 'WANDER') {
                    // In WANDER mode, build a water pit at player location
                    this.buildWanderWell();
                } else {
                    // In CITY mode, use the placement tool
                    Controller.setTool('WELL');
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DEBUG FUNCTIONS - For testing the game faster
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            debugAddPopulation(amount) {
                this.pop += amount;
                if(this.gameState === 'CITY') {
                    // In city mode, also increase housing cap so people don't leave
                    this.housingCap = Math.max(this.housingCap, this.pop + 100);
                }
                Controller.toast(`ğŸ› DEBUG: +${amount} population (now ${this.pop})`);
                Controller.updateUI();
            },
            
            debugAddResources(amount) {
                if(this.gameState === 'WANDER') {
                    // In WANDER mode, add to inventory
                    this.inventory.food += amount;
                    this.inventory.wood += amount;
                    this.inventory.metal += amount;
                    this.inventory.stone += amount;
                    this.inventory.capacity = Math.max(this.inventory.capacity, 
                        this.inventory.food + this.inventory.wood + this.inventory.metal + this.inventory.stone + 100);
                    Controller.toast(`ğŸ› DEBUG: +${amount} to all inventory (WANDER)`);
                } else {
                    // In CITY mode, add to main resources
                    this.food += amount;
                    this.wood += amount;
                    this.metal += amount;
                    this.stone += amount;
                    this.res += amount; // Gold too
                    Controller.toast(`ğŸ› DEBUG: +${amount} to all resources (CITY)`);
                }
                Controller.updateUI();
            },
            
            isValid(gx, gy, tool) {
                // All zones are 1x1 per documentation (RES, COM, IND, ROAD, WELL, storage pits)
                let sz = 1;
                let szW = 1, szH = 1; // Width and Height for non-square buildings
                
                // Special buildings are 2x2
                if(tool === 'CHIEF' || tool === 'PALACE' || tool === 'GRANARY' || tool === 'BASKET' || tool === 'POTTERY' || tool === 'CLAN_CHIEF') {
                    sz = 2;
                    szW = 2;
                    szH = 2;
                }
                // DOCK is 3x2
                if(tool === 'DOCK') {
                    szW = 3;
                    szH = 2;
                    sz = Math.max(szW, szH);
                }
                
                if(gx<0 || gy<0 || gx+szW>CFG.W || gy+szH>CFG.H) return false;
                
                // Check for water, existing zones, roads, buildings - hard blocks
                for(let x=gx; x<gx+szW; x++) {
                    for(let y=gy; y<gy+szH; y++) { 
                        let tile = this.tiles[x][y];
                        let t = tile.type; 
                        if(t=='WATER'||t=='DEEP'||t=='RIVER'||t=='STONE') return false;
                        
                        // === NEW: Cannot build on unexplored tiles! ===
                        if(!tile.explored) {
                            Controller.toast('âš ï¸ Cannot build in fog - explore first!');
                            return false;
                        }
                        
                        // Stone deposits block most buildings (industrial can override)
                        if(tile.stoneDeposit && tool !== 'IND') return false;
                        
                        // Check for existing zone or building on tile (RES uses tile.zone system)
                        if(tile.zone || tile.building) return false;
                        
                        // Check for roads (can't build on roads)
                        if(tile.road) return false;
                    }
                }
                
                // Check for building overlap (COM/IND/WELL/storage pits use blds array)
                for(let b of this.blds) { 
                    // Get building size - check config first, then fallback to type-based sizes
                    let bConfig = CFG.BUILDING_DB && CFG.BUILDING_DB[b.t];
                    let bzW = 1, bzH = 1;
                    if(bConfig && bConfig.size) {
                        bzW = bConfig.size.w;
                        bzH = bConfig.size.h;
                    } else if(b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') {
                        bzW = 1; bzH = 1;
                    } else if(b.t === 'DOCK') {
                        bzW = 3; bzH = 2;
                    } else {
                        bzW = 2; bzH = 2;
                    }
                    if(gx<b.x+bzW && gx+szW>b.x && gy<b.y+bzH && gy+szH>b.y) return false; 
                }
                
                return true;
            },
            build(t, gx, gy) {
                try {
                    console.log('build() called:', {tool: t, x: gx, y: gy});
                    
                    // Record player action for AI learning - NOW WITH POSITION!
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        let action = 'BUILD_' + (t === 'RES' ? 'RES' : t === 'IND' ? 'IND' : t === 'COM' ? 'COM' : t === 'WELL' ? 'WELL' : t === 'ROAD' ? 'ROAD' : 'OTHER');
                        QLearningAI.recordPlayerAction(action, gx, gy);
                    }
                    
                    // BULLDOZER: Remove zones or buildings
                    if(t === 'BULL') {
                    if(this.simcityMode && this.res < CFG.COST.BULL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < 1) return Controller.toast("Need Food");
                    
                    // Clear zone and building from tile
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        if(this.simcityMode) this.res -= CFG.COST.BULL;
                        else this.food -= 1;
                        Controller.toast("Zone Cleared");
                    }
                    // Check for buildings - COM/IND/WELL are 1x1, others are 2x2
                    else {
                        let hit = -1;
                        for (let i = 0; i < this.blds.length; i++) { 
                            let b = this.blds[i]; 
                            let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2; 
                            if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                                hit = i; 
                                break; 
                            } 
                        }
                        if (hit !== -1) { 
                            this.blds.splice(hit, 1); 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Demolished"); 
                        }
                        else if (this.tiles[gx][gy].road) { 
                            this.tiles[gx][gy].road = false; 
                            if(this.simcityMode) this.res -= CFG.COST.BULL;
                            else this.food -= 1;
                            Controller.toast("Road Removed"); 
                        }
                    }
                    this.recalc();
                    return;
                }
                
                // ROADS - supports diagonal placement by drawing lines between clicks
                if (t == 'ROAD') {
                    console.log('Road building - gx:', gx, 'gy:', gy, 'food:', this.food, 'lastRoadPos:', this.lastRoadPos);
                    
                    // Helper to place single road tile
                    const placeRoadTile = (rx, ry, showError = false) => {
                        // Bounds check
                        if(rx < 0 || rx >= CFG.W || ry < 0 || ry >= CFG.H) {
                            if(showError) Controller.toast("Out of bounds");
                            console.log('Road fail: out of bounds', rx, ry);
                            return false;
                        }
                        let tile = this.tiles[rx]?.[ry];
                        if(!tile) {
                            if(showError) Controller.toast("Invalid tile");
                            console.log('Road fail: invalid tile', rx, ry);
                            return false;
                        }
                        if (tile.type == 'WATER' || tile.type == 'DEEP' || tile.type == 'RIVER' || tile.type == 'STONE') {
                            if(showError) Controller.toast("Can't build on water/stone");
                            console.log('Road fail: water/stone', rx, ry, tile.type);
                            return false;
                        }
                        // === NEW: Cannot build road on unexplored tiles! ===
                        if (!tile.explored) {
                            if(showError) Controller.toast("âš ï¸ Cannot build in fog - explore first!");
                            console.log('Road fail: unexplored', rx, ry);
                            return false;
                        }
                        if (tile.stoneDeposit) {
                            if(showError) Controller.toast("Stone deposit blocking");
                            console.log('Road fail: stone deposit', rx, ry);
                            return false;
                        }
                        if (tile.road) {
                            if(showError) Controller.toast("Road already exists");
                            console.log('Road fail: already exists', rx, ry);
                            return false;
                        }
                        
                        // Check if we can afford it
                        if(this.simcityMode && this.res < CFG.COST.ROAD) {
                            if(showError) Controller.toast(`Need $${CFG.COST.ROAD} funds`);
                            console.log('Road fail: no funds');
                            return false;
                        }
                        else if(!this.simcityMode && this.food < CFG.COST.ROAD) {
                            if(showError) Controller.toast(`Need ${CFG.COST.ROAD} food`);
                            console.log('Road fail: no food', this.food, '<', CFG.COST.ROAD);
                            return false;
                        }
                        
                        console.log('Road SUCCESS at', rx, ry);
                        tile.road = true; 
                        tile.tree = false;
                        // Remove any entity (berry bush, etc) - roads destroy resources
                        if (tile.entity) {
                            tile.entity = null;
                        }
                        if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(rx, ry);
                        this.roadTileCount = (this.roadTileCount || 0) + 1;
                        
                        if(this.simcityMode) this.res -= CFG.COST.ROAD;
                        else this.food -= CFG.COST.ROAD;
                        return true;
                    };
                    
                    // Get tiles in a line between two points (Bresenham's algorithm)
                    const getLineTiles = (x0, y0, x1, y1) => {
                        let tiles = [];
                        let dx = Math.abs(x1 - x0);
                        let dy = Math.abs(y1 - y0);
                        let sx = x0 < x1 ? 1 : -1;
                        let sy = y0 < y1 ? 1 : -1;
                        let err = dx - dy;
                        
                        while (true) {
                            tiles.push({x: x0, y: y0});
                            if (x0 === x1 && y0 === y1) break;
                            let e2 = 2 * err;
                            if (e2 > -dy) { err -= dy; x0 += sx; }
                            if (e2 < dx) { err += dx; y0 += sy; }
                        }
                        return tiles;
                    };
                    
                    // DIAGONAL ROADS: Hold shift + click to draw a line from last road
                    // Or just click to place single road
                    if (this.lastRoadPos && Controller.shiftHeld && (this.lastRoadPos.x !== gx || this.lastRoadPos.y !== gy)) {
                        // Draw diagonal line from last position to current
                        let lineTiles = getLineTiles(this.lastRoadPos.x, this.lastRoadPos.y, gx, gy);
                        let placed = 0;
                        let skipped = 0;
                        for (let t of lineTiles) {
                            if (t.x >= 0 && t.x < CFG.W && t.y >= 0 && t.y < CFG.H) {
                                let tile = this.tiles[t.x]?.[t.y];
                                // Skip tiles that already have roads (not an error)
                                if (tile && tile.road) {
                                    skipped++;
                                    continue;
                                }
                                if (placeRoadTile(t.x, t.y, false)) placed++;
                            }
                        }
                        if (placed > 0) {
                            Controller.toast(`ğŸ›£ï¸ Drew ${placed} road tiles!`);
                        } else if (skipped > 0) {
                            Controller.toast(`ğŸ›£ï¸ Road complete (${skipped} already paved)`);
                        } else {
                            Controller.toast("âš ï¸ Can't place roads there");
                        }
                    } else {
                        // Single click - place one road
                        if (placeRoadTile(gx, gy, true)) {
                            Controller.toast("ğŸ›£ï¸ Road placed! (Shift+click for diagonal)");
                        }
                    }
                    
                    // Remember this position for diagonal drawing
                    this.lastRoadPos = {x: gx, y: gy};
                    this.recalc();
                    return;
                }
                
                // WELLS (keep as instant building)
                if(t === 'WELL') {
                    if(this.simcityMode && this.res < CFG.COST.WELL) return Controller.toast("Need Funds");
                    else if(!this.simcityMode && this.food < CFG.COST.WELL) return Controller.toast("Need Food");
                    
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    this.tiles[gx][gy].tree = false;
                    this.blds.push({ t: 'WELL', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    if(this.simcityMode) this.res -= CFG.COST.WELL;
                    else this.food -= CFG.COST.WELL;
                    this.recalc();
                    return;
                }
                
                // CHIEF'S HUT (special 2x2 building with culture bonus)
                if(t === 'CHIEF') {
                    if(this.food < CFG.CHIEF_COST) return Controller.toast(`Need ${CFG.CHIEF_COST} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 2x2 area
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'CHIEF', x: gx, y: gy });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.CHIEF_COST;
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    Controller.toast("ğŸ›ï¸ Chief's Hut built! +Culture Bonus in 50-tile radius");
                    this.recalc();
                    return;
                }
                
                // CLAN CHIEF'S HUT (milestone - unlocks L4-L6 buildings)
                if(t === 'CLAN_CHIEF') {
                    let config = CFG.BUILDING_DB['CLAN_CHIEF'];
                    if(!config) return Controller.toast("Building config not found");
                    
                    // Check if already built
                    if(this.hasClanChief) return Controller.toast("âœ… Clan Chief's Hut already built!");
                    
                    // Check population requirement
                    if(config.unlockReq && config.unlockReq.pop && this.pop < config.unlockReq.pop) {
                        return Controller.toast(`Need ${config.unlockReq.pop} Population`);
                    }
                    
                    // Check resources
                    if(this.food < config.cost.food) return Controller.toast(`Need ${Controller.formatNum(config.cost.food)} Food`);
                    if(this.wood < config.cost.wood) return Controller.toast(`Need ${Controller.formatNum(config.cost.wood)} Wood`);
                    if((this.gold || 0) < config.cost.gold) return Controller.toast(`Need ${config.cost.gold} Gold`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 2x2 area
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            if(this.tiles[x] && this.tiles[x][y]) {
                                this.tiles[x][y].tree = false;
                            }
                        }
                    }
                    
                    this.blds.push({ t: 'CLAN_CHIEF', x: gx, y: gy, lvl: 1 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resources
                    this.food -= config.cost.food;
                    this.wood -= config.cost.wood;
                    this.gold = (this.gold || 0) - config.cost.gold;
                    
                    // Set milestone flag
                    this.hasClanChief = true;
                    
                    this.exploreArea(gx, gy, 5);
                    Controller.toast("ğŸ›ï¸ Clan Chief's Hut built! Level 4-6 buildings now available!");
                    this.recalc();
                    return;
                }
                
                // TRADING DOCK (milestone - unlocks L7+ buildings)
                if(t === 'DOCK') {
                    let config = CFG.BUILDING_DB['DOCK'];
                    if(!config) return Controller.toast("Building config not found");
                    
                    // Check prerequisites
                    if(!this.hasClanChief) return Controller.toast("ğŸ”’ Build Clan Chief's Hut first!");
                    
                    // Check if already built
                    if(this.hasDock) return Controller.toast("âœ… Trading Dock already built!");
                    
                    // Check resources
                    if(this.food < config.cost.food) return Controller.toast(`Need ${Controller.formatNum(config.cost.food)} Food`);
                    if(this.wood < config.cost.wood) return Controller.toast(`Need ${Controller.formatNum(config.cost.wood)} Wood`);
                    if((this.gold || 0) < config.cost.gold) return Controller.toast(`Need ${config.cost.gold} Gold`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in 3x2 area
                    for(let x=gx; x<gx+3; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            if(this.tiles[x] && this.tiles[x][y]) {
                                this.tiles[x][y].tree = false;
                            }
                        }
                    }
                    
                    this.blds.push({ t: 'DOCK', x: gx, y: gy, lvl: 1 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resources
                    this.food -= config.cost.food;
                    this.wood -= config.cost.wood;
                    this.gold = (this.gold || 0) - config.cost.gold;
                    
                    // Set milestone flag
                    this.hasDock = true;
                    
                    this.exploreArea(gx, gy, 5);
                    Controller.toast("âš“ Trading Dock built! Level 7+ buildings now available!");
                    this.recalc();
                    return;
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // STORAGE PITS (10k capacity each for specific resource)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                const storagePitTypes = ['FOOD_PIT', 'WOOD_PIT', 'STONE_PIT', 'METAL_PIT'];
                if(storagePitTypes.includes(t)) {
                    let pit = CFG.STORAGE_PITS[t];
                    
                    // Check costs
                    if(this.food < pit.food) return Controller.toast(`Need ${Controller.formatNum(pit.food)} Food`);
                    if(this.wood < pit.wood) return Controller.toast(`Need ${Controller.formatNum(pit.wood)} Wood`);
                    if(this.stone < pit.stone) return Controller.toast(`Need ${pit.stone} Stone`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    // Clear trees in build area
                    this.tiles[gx][gy].tree = false;
                    
                    // Add building
                    this.blds.push({ t: t, x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0, resource: pit.resource, cap: pit.cap });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct costs
                    this.food -= pit.food;
                    this.wood -= pit.wood;
                    this.stone -= pit.stone;
                    
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`${pit.icon} ${pit.desc} built! +${Controller.formatNum(pit.cap)} ${pit.resource} storage`);
                    this.recalc();
                    return;
                }
                
                // STORAGE BUILDINGS (reduce food spoilage)
                if(t === 'BASKET') {
                    if(this.pop < CFG.BUILDINGS.BASKET.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.BASKET.cost) return Controller.toast(`Need ${CFG.BUILDINGS.BASKET.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'BASKET', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.BASKET.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ§º Basket built! +${CFG.BUILDINGS.BASKET.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'POTTERY') {
                    if(this.pop < CFG.BUILDINGS.POTTERY.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.POTTERY.cost) return Controller.toast(`Need ${CFG.BUILDINGS.POTTERY.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'POTTERY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.POTTERY.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸº Pottery built! +${CFG.BUILDINGS.POTTERY.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'GRANARY') {
                    if(this.pop < CFG.BUILDINGS.GRANARY.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.GRANARY.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.GRANARY.cost) return Controller.toast(`Need ${CFG.BUILDINGS.GRANARY.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'GRANARY', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.GRANARY.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ›ï¸ Granary built! +${CFG.BUILDINGS.GRANARY.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                if(t === 'PALACE') {
                    if(this.pop < CFG.BUILDINGS.PALACE.reqPop) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.reqPop} Population`);
                    if(this.food < CFG.BUILDINGS.PALACE.cost) return Controller.toast(`Need ${CFG.BUILDINGS.PALACE.cost} Food`);
                    if (!this.isValid(gx, gy, t)) return Controller.toast("Invalid Spot");
                    
                    for(let x=gx; x<gx+2; x++) {
                        for(let y=gy; y<gy+2; y++) {
                            this.tiles[x][y].tree = false;
                        }
                    }
                    
                    this.blds.push({ t: 'PALACE', x: gx, y: gy, lvl: 1, efficiency: 1.0, age: 0 });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    this.food -= CFG.BUILDINGS.PALACE.cost;
                    this.exploreArea(gx, gy, 5);
                    Controller.toast(`ğŸ° Palace built! +${CFG.BUILDINGS.PALACE.cap} food storage`);
                    this.recalc();
                    return;
                }
                
                // INDUSTRIAL BUILDING (1x1 - Hunting Ground, Hunting Pit, etc.)
                if(t === 'IND') {
                    // Get selected industrial level from Controller
                    let selectedLevel = Controller.selectedIndustrialLevel || 1;
                    let levelConfig = CFG.INDUSTRIAL_LEVELS[selectedLevel];
                    
                    if(!levelConfig) {
                        return Controller.toast("Invalid industrial level!");
                    }
                    
                    // Check if level is unlocked
                    if(!PROGRESSION.unlockedIndustrialLevels.includes(selectedLevel)) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(selectedLevel, this);
                        return Controller.toast(info.text);
                    }
                    
                    // Check resource costs
                    if(this.food < levelConfig.food) return Controller.toast(`Need ${levelConfig.food} Food`);
                    if(this.wood < levelConfig.wood) return Controller.toast(`Need ${levelConfig.wood} Wood`);
                    if(levelConfig.stone > 0 && this.stone < levelConfig.stone) return Controller.toast(`Need ${levelConfig.stone} Stone`);
                    if(levelConfig.metal > 0 && this.metal < levelConfig.metal) return Controller.toast(`Need ${levelConfig.metal} Metal`);
                    
                    // Validate 1x1 spot
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    
                    // Check for stone deposit bonus (single tile)
                    let hasStoneDeposit = tile.stoneDeposit ? true : false;
                    let totalMetal = hasStoneDeposit ? tile.stoneDeposit.metal : 0;
                    
                    // Validate tile type
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // Clear tree and stone deposit (1x1)
                    tile.tree = false;
                    if(tile.stoneDeposit) {
                        tile.stoneDeposit = null;
                    }
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'IND');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'IND');
                    
                    // Flood risk warning
                    let floodWarning = '';
                    if(CFG.ELEVATION_SYSTEM.ENABLED && this.isFloodRisk(gx, gy)) {
                        floodWarning = ' âš ï¸ Flood risk!';
                    }
                    
                    // Create 1x1 industrial building with level and variant support
                    this.blds.push({ 
                        t: 'IND', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0, 
                        onDeposit: hasStoneDeposit,
                        desirability: 0.5,  // Start at medium
                        variant: 1          // Start at Low variant
                    });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct costs
                    this.food -= levelConfig.food;
                    this.wood -= levelConfig.wood;
                    if(levelConfig.stone > 0) this.stone -= levelConfig.stone;
                    if(levelConfig.metal > 0) this.metal -= levelConfig.metal;
                    
                    // Give metal bonus if built on deposits
                    if(hasStoneDeposit) {
                        this.metal += totalMetal;
                        Controller.toast(`â›ï¸ ${levelConfig.name} built on deposit! ${bonusInfo.text} +${Controller.formatNum(totalMetal)} metal!${floodWarning}`);
                    } else {
                        Controller.toast(`ğŸ­ ${levelConfig.name} built! ${bonusInfo.text} Cap: ${levelConfig.capacity}${floodWarning}`);
                    }
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.recalc();
                    return;
                }
                
                // COMMERCIAL (Level 1 = Campfire, Level 2 = Fire Pit)
                if(t === 'COM') {
                    // Get selected commercial level (default to 1)
                    let selectedLevel = Controller.selectedCommercialLevel || 1;
                    
                    // Get building data from BUILDING_DB for proper cost lookup
                    let buildingData = CFG.BUILDING_DB['COM_' + selectedLevel];
                    if(!buildingData) {
                        return Controller.toast(`Commercial level ${selectedLevel} not found!`);
                    }
                    let levelCost = buildingData.cost;
                    
                    // Check resource costs (food + wood + stone based on building)
                    if(this.food < levelCost.food) {
                        return Controller.toast(`Need ${levelCost.food} Food for ${buildingData.name}`);
                    }
                    if(this.wood < levelCost.wood) {
                        return Controller.toast(`Need ${levelCost.wood} Wood for ${buildingData.name}`);
                    }
                    if(levelCost.stone && this.stone < levelCost.stone) {
                        return Controller.toast(`Need ${levelCost.stone} Stone for ${buildingData.name}`);
                    }
                    
                    // Validate 1x1 spot
                    if(gx < 0 || gy < 0 || gx >= CFG.W || gy >= CFG.H) return Controller.toast("Invalid Spot");
                    let tile = this.tiles[gx][gy];
                    if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') {
                        return Controller.toast("Invalid Spot - Can't build on water/stone");
                    }
                    if(tile.zone || tile.road || tile.bld) {
                        return Controller.toast("Space Occupied");
                    }
                    
                    // Clear tree if present (1x1)
                    tile.tree = false;
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'COM');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'COM');
                    
                    // Flood risk warning
                    let floodWarning = '';
                    if(CFG.ELEVATION_SYSTEM.ENABLED && this.isFloodRisk(gx, gy)) {
                        floodWarning = ' âš ï¸ Flood risk!';
                    }
                    
                    // Place 1x1 commercial zone
                    this.blds.push({ 
                        t: 'COM', 
                        x: gx, 
                        y: gy, 
                        lvl: selectedLevel, 
                        efficiency: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0,
                        variant: 1  // Start at Low activity
                    });
                    if (typeof Renderer !== 'undefined' && Renderer.addDust) Renderer.addDust(gx, gy);
                    
                    // Deduct resource costs
                    this.food -= levelCost.food;
                    this.wood -= levelCost.wood;
                    if(levelCost.stone) this.stone -= levelCost.stone;
                    
                    let costStr = `-${levelCost.food} food, -${levelCost.wood} wood`;
                    if(levelCost.stone) costStr += `, -${levelCost.stone} stone`;
                    Controller.toast(`ğŸª ${buildingData.name} built! ${bonusInfo.text} (${costStr})${floodWarning}`);
                    
                    // Auto-explore area around new building for visibility
                    this.exploreArea(gx, gy, 3);
                    
                    this.recalc();
                    return;
                }
                
                // RESIDENTIAL ZONING (new zone-based system with level selection)
                if(t === 'RES') {
                    console.log('RES building block reached!');
                    
                    // First check if we're in city mode
                    if(this.gameState !== 'CITY') {
                        return Controller.toast("âš ï¸ Must settle first! Click ğŸ›ï¸ button to settle.");
                    }
                    
                    console.log('isValid check:', this.isValid(gx, gy, t));
                    if (!this.isValid(gx, gy, t)) {
                        // More detailed error message
                        let tile = this.tiles[gx][gy];
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER') {
                            return Controller.toast("âŒ Can't build on water!");
                        }
                        if(tile.type === 'STONE') {
                            return Controller.toast("âŒ Can't build on stone mountains!");
                        }
                        if(tile.zone || tile.building) {
                            return Controller.toast("âŒ Tile already has a building!");
                        }
                        if(tile.road) {
                            return Controller.toast("âŒ Can't build on roads!");
                        }
                        return Controller.toast("âŒ Invalid Spot");
                    }
                    
                    // Get selected building level (default to highest unlocked level)
                    let selectedLevel = Controller.selectedBuildingLevel;
                    console.log('Selected level:', selectedLevel);
                    if(selectedLevel === undefined || selectedLevel === null) {
                        // Default to Level 1 if unlocked, otherwise Level 0
                        selectedLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    }
                    let levelConfig = CFG.BUILDING_LEVELS[selectedLevel];
                    console.log('Level config:', levelConfig);
                    
                    if(!levelConfig) {
                        return Controller.toast("âŒ Invalid building level!");
                    }
                    
                    console.log('Current resources - Food:', this.food, 'Wood:', this.wood, 'Stone:', this.stone);
                    
                    // Check if player has required resources
                    if(this.food < levelConfig.food) {
                        return Controller.toast(`Need ${levelConfig.food} Food for ${levelConfig.name}`);
                    }
                    if(levelConfig.wood > 0 && this.wood < levelConfig.wood) {
                        return Controller.toast(`Need ${levelConfig.wood} Wood for ${levelConfig.name}`);
                    }
                    if(levelConfig.stone > 0 && this.stone < levelConfig.stone) {
                        return Controller.toast(`Need ${levelConfig.stone} Stone for ${levelConfig.name}`);
                    }
                    
                    // Deduct resources
                    console.log('Deducting resources...');
                    this.food = Number(this.food) - Number(levelConfig.food);
                                        if (isNaN(this.food)) this.food = 0;
                                        if (isNaN(this.food)) this.food = 0;
                                            if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                    if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                                if (isNaN(this.inventory.food)) this.inventory.food = 0;
                                            if (isNaN(this.food)) this.food = 0;
                    if(levelConfig.wood > 0) this.wood = Number(this.wood) - Number(levelConfig.wood);
                    if(levelConfig.stone > 0) this.stone = Number(this.stone) - Number(levelConfig.stone);
                    console.log('Resources after deduction - Food:', this.food, 'Wood:', this.wood);
                    
                    // Calculate SimCity SNES style zoning bonus
                    let zoneBonus = this.calculateZoneBonus(gx, gy, 'RES');
                    let bonusInfo = this.getZoneBonusDescription(gx, gy, 'RES');
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // FLOOD RISK WARNING - Check if building on low-elevation coastal land
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let floodWarning = '';
                    if(CFG.ELEVATION_SYSTEM.ENABLED && this.isFloodRisk(gx, gy)) {
                        floodWarning = ' âš ï¸ WARNING: Flood risk! Low elevation!';
                    }
                    
                    // Create zone with selected level
                    console.log('Creating zone at', gx, gy);
                    this.tiles[gx][gy].zone = 'R';
                    this.tiles[gx][gy].building = {
                        level: selectedLevel,
                        growth: 0,
                        desirability: zoneBonus,  // Use calculated bonus instead of 1.0
                        age: 0,
                        lastBirthYear: this.year,
                        pop: 0,
                        capacity: levelConfig.capacity,
                        // Buildings start at variant 1 (Low) for visual variety
                        // Can evolve up/down based on desirability
                        variant: 1
                    };
                    this.tiles[gx][gy].tree = false;
                    
                    // Update building populations after creating residential
                    if(typeof assignPopulationToResidential === 'function') {
                        assignPopulationToResidential(this);
                    }
                    
                    // Auto-explore area around new zone for visibility
                    this.exploreArea(gx, gy, 5);
                    
                    this.markDirty(gx, gy, 1); // Mark for redraw
                    
                    Controller.toast(`ğŸ  ${levelConfig.name} built! ${bonusInfo.text} Cap: ${levelConfig.capacity}${floodWarning}`);
                    
                    this.recalc();
                    return;
                }
                
                // DEMOLISH: Remove zones, buildings, or roads
                if(t === 'DEMOLISH') {
                    // Check if there's a road to demolish
                    if(this.tiles[gx][gy].road) {
                        this.tiles[gx][gy].road = false;
                        this.roadTileCount = Math.max(0, (this.roadTileCount || 0) - 1);
                        Controller.toast('ğŸ›£ï¸ Road demolished');
                        this.recalc();
                        return;
                    }
                    
                    // Check for buildings in blds array (WELL, COM, IND, CHIEF, etc.)
                    let bldHit = -1;
                    for (let i = 0; i < this.blds.length; i++) {
                        let b = this.blds[i];
                        // COM, IND, WELL are 1x1 per documentation
                        let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                        if (gx >= b.x && gx < b.x + bz && gy >= b.y && gy < b.y + bz) {
                            bldHit = i;
                            break;
                        }
                    }
                    if (bldHit !== -1) {
                        let removedBld = this.blds[bldHit];
                        this.blds.splice(bldHit, 1);
                        Controller.toast(`ğŸ”¨ ${removedBld.t} demolished`);
                        this.recalc();
                        return;
                    }
                    
                    // Check for zoned residential buildings
                    if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                        let bld = this.tiles[gx][gy].building;
                        
                        // FLAT 10% SALVAGE RATE for all building levels
                        if(bld && bld.level !== undefined) {
                            let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                            if(levelConfig) {
                                let refundRate = 0.10; // 10% refund for all levels
                                
                                let foodRefund = Math.floor(levelConfig.food * refundRate);
                                let woodRefund = Math.floor(levelConfig.wood * refundRate);
                                let stoneRefund = Math.floor(levelConfig.stone * refundRate);
                                
                                this.food += foodRefund;
                                this.wood += woodRefund;
                                this.stone += stoneRefund;
                                
                                if(foodRefund > 0 || woodRefund > 0 || stoneRefund > 0) {
                                    let refundText = [];
                                    if(foodRefund > 0) refundText.push(`${foodRefund} food`);
                                    if(woodRefund > 0) refundText.push(`${woodRefund} wood`);
                                    if(stoneRefund > 0) refundText.push(`${stoneRefund} stone`);
                                    Controller.toast(`â™»ï¸ Salvaged 10%: ${refundText.join(', ')}`);
                                } else {
                                    Controller.toast(`ğŸ”¨ Demolished (no salvage value)`);
                                }
                            }
                        }
                        
                        this.tiles[gx][gy].zone = null;
                        this.tiles[gx][gy].building = null;
                        this.markDirty(gx, gy, 1);
                        this.recalc();
                    } else {
                        Controller.toast("Nothing to demolish here");
                    }
                }
                } catch(err) {
                    console.error('Build error:', err);
                    Controller.toast('âŒ Build error: ' + err.message);
                }
            },
            bull(gx, gy) {
                // Legacy function - now handled in build()
                // Kept for compatibility
                if (this.res < CFG.COST.BULL && this.simcityMode) return Controller.toast("Need Funds");
                if (this.food < 1 && !this.simcityMode) return Controller.toast("Need Food");
                
                // Check for zones first
                if(this.tiles[gx][gy].zone || this.tiles[gx][gy].building) {
                    this.tiles[gx][gy].zone = null;
                    this.tiles[gx][gy].building = null;
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Zone Cleared");
                    this.recalc();
                    return;
                }
                
                // Check for buildings
                let hit = -1;
                for (let i = 0; i < this.blds.length; i++) { 
                    let b = this.blds[i]; 
                    // COM, IND, WELL are 1x1 per documentation
                    let sz = (b.t=='WELL'||b.t=='COM'||b.t=='IND') ? 1 : 2; 
                    if (gx >= b.x && gx < b.x + sz && gy >= b.y && gy < b.y + sz) { 
                        hit = i; 
                        break; 
                    } 
                }
                if (hit !== -1) { 
                    this.blds.splice(hit, 1); 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Demolished"); 
                }
                else if (this.tiles[gx][gy].road) { 
                    this.tiles[gx][gy].road = false; 
                    if(this.simcityMode) this.res -= CFG.COST.BULL;
                    else this.food -= 1;
                    Controller.toast("Road Removed"); 
                }
                this.recalc();
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SIMCITY SNES STYLE ZONING BONUS CALCULATOR
            // Build anywhere, but smart placement gets bonuses!
            // Returns a multiplier (0.3 to 2.5+) based on placement quality
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            calculateZoneBonus(gx, gy, zoneType) {
                let bonus = 1.0; // Base multiplier
                const B = CFG.ZONE_BONUSES;
                const tiles = this.tiles;
                
                // Helper: Count nearby tiles of a type
                const countNearby = (checkFn, range) => {
                    let count = 0;
                    for(let dx = -range; dx <= range; dx++) {
                        for(let dy = -range; dy <= range; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            let nx = gx + dx, ny = gy + dy;
                            if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                                if(checkFn(tiles[nx][ny], nx, ny)) count++;
                            }
                        }
                    }
                    return count;
                };
                
                // Helper: Check if any tile nearby matches
                const hasNearby = (checkFn, range) => countNearby(checkFn, range) > 0;
                
                // === ROAD ACCESS (critical for all zones) ===
                let roadCount = countNearby(t => t.road, 1);
                if(roadCount > 0) {
                    bonus += B.ROAD_ACCESS_BONUS;
                    // Extra bonus for road junctions (commercial loves these)
                    if(roadCount >= 3 && zoneType === 'COM') {
                        bonus += B.COM_ROAD_JUNCTION_BONUS;
                    }
                } else {
                    // Check if road is at least within 3 tiles
                    let hasRoadNearby = hasNearby(t => t.road, 3);
                    if(!hasRoadNearby) {
                        bonus -= B.NO_ROAD_PENALTY;
                    }
                }
                
                // === WATER PROXIMITY ===
                let hasWater = hasNearby(t => t.type === 'WATER' || t.type === 'RIVER', 3);
                if(hasWater) {
                    if(zoneType === 'RES') bonus += B.RES_WATER_BONUS;
                    else if(zoneType === 'IND') bonus += B.IND_WATER_BONUS;
                }
                
                // === WELL PROXIMITY ===
                let wellNearby = this.blds.some(b => {
                    if(b.t !== 'WELL') return false;
                    let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                    return dist <= 3;
                });
                if(wellNearby && zoneType === 'RES') {
                    bonus += B.RES_WELL_BONUS;
                }
                
                // === TREE/FOREST PROXIMITY ===
                let treeCount = countNearby(t => t.tree || t.type === 'FOREST', 2);
                if(treeCount > 0) {
                    if(zoneType === 'RES') bonus += B.RES_TREE_BONUS;
                    else if(zoneType === 'IND') bonus += B.IND_FOREST_BONUS * Math.min(treeCount / 3, 1);
                }
                
                // === STONE PROXIMITY (Industrial loves this) ===
                let stoneNearby = hasNearby(t => t.type === 'STONE' || t.stoneDeposit, 3);
                if(stoneNearby && zoneType === 'IND') {
                    bonus += B.IND_STONE_BONUS;
                }
                
                // === RESIDENTIAL BONUSES/PENALTIES ===
                if(zoneType === 'RES') {
                    // Clustering bonus
                    let resCount = countNearby(t => t.zone === 'R', 1);
                    bonus += resCount * B.RES_CLUSTER_BONUS;
                    
                    // Industrial penalty (pollution)
                    let indNearby = this.blds.some(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 2;
                    });
                    if(indNearby) bonus -= B.RES_INDUSTRIAL_PENALTY;
                }
                
                // === COMMERCIAL BONUSES/PENALTIES ===
                if(zoneType === 'COM') {
                    // Needs customers (residential)
                    let resNearby = countNearby(t => t.zone === 'R', 5);
                    if(resNearby >= 3) {
                        bonus += B.COM_RES_NEARBY_BONUS;
                    } else if(resNearby === 0) {
                        bonus -= B.COM_ISOLATION_PENALTY;
                    }
                    
                    // Industrial workers nearby
                    let indNearby = this.blds.some(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 5;
                    });
                    if(indNearby) bonus += B.COM_INDUSTRIAL_NEARBY;
                }
                
                // === INDUSTRIAL BONUSES/PENALTIES ===
                if(zoneType === 'IND') {
                    // Clustering bonus (industrial parks)
                    let indCount = this.blds.filter(b => {
                        if(b.t !== 'IND') return false;
                        let dist = Math.abs(b.x - gx) + Math.abs(b.y - gy);
                        return dist <= 2;
                    }).length;
                    bonus += indCount * B.IND_CLUSTER_BONUS;
                    
                    // Penalty if too close to residential
                    let resTooClose = countNearby(t => t.zone === 'R', 2);
                    if(resTooClose > 0) bonus -= B.IND_RES_NEARBY_PENALTY;
                }
                
                // === CHIEF'S HUT BONUS ===
                let chiefNearby = this.blds.some(b => {
                    if(b.t !== 'CHIEF') return false;
                    let dist = Math.sqrt(Math.pow(b.x - gx, 2) + Math.pow(b.y - gy, 2));
                    return dist <= B.CHIEF_CULTURE_RADIUS;
                });
                if(chiefNearby) bonus += B.CHIEF_BONUS;
                
                // === LOCKED RESOURCE BONUSES (from settlement) ===
                // Each person needs access to commercial/industrial zones
                // Locked resources provide permanent 25% bonus to their zone type
                if(this.lockedResources) {
                    if(zoneType === 'RES' && this.lockedResources.residential) {
                        bonus += 0.25; // +25% for having berries locked
                    }
                    if(zoneType === 'COM' && this.lockedResources.commercial) {
                        bonus += 0.25; // +25% for having trees locked
                    }
                    if(zoneType === 'IND' && this.lockedResources.industrial) {
                        bonus += 0.25; // +25% for having animals locked
                    }
                }
                
                // Clamp to reasonable range
                return Math.max(0.3, Math.min(2.5, bonus));
            },
            
            // Get a text description of zone bonuses for UI feedback
            getZoneBonusDescription(gx, gy, zoneType) {
                const B = CFG.ZONE_BONUSES;
                let bonuses = [];
                let penalties = [];
                
                // Road check
                let roadCount = 0;
                for(let dx = -1; dx <= 1; dx++) {
                    for(let dy = -1; dy <= 1; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let nx = gx + dx, ny = gy + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            if(this.tiles[nx][ny].road) roadCount++;
                        }
                    }
                }
                if(roadCount > 0) bonuses.push('ğŸ›£ï¸ Road Access');
                else penalties.push('âŒ No Road');
                
                // Water check
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let nx = gx + dx, ny = gy + dy;
                        if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                            let t = this.tiles[nx][ny].type;
                            if(t === 'WATER' || t === 'RIVER') {
                                bonuses.push('ğŸ’§ Near Water');
                                dx = 99; dy = 99; // break out
                            }
                        }
                    }
                }
                
                let totalBonus = this.calculateZoneBonus(gx, gy, zoneType);
                let percentage = Math.round((totalBonus - 1) * 100);
                let prefix = percentage >= 0 ? '+' : '';
                
                return {
                    bonuses: bonuses,
                    penalties: penalties,
                    total: totalBonus,
                    text: `${prefix}${percentage}% Efficiency`
                };
            },
            
            upgradeBuilding(buildingIndex) {
                let b = this.blds[buildingIndex];
                if(!b || b.lvl >= 200) return Controller.toast("Max Level!");
                
                let cost = this.getUpgradeCost(b.lvl);
                
                // In SimCity mode, use funds; in survival mode, use food
                if(this.simcityMode) {
                    if(this.res < cost) return Controller.toast(`Need ${Math.floor(cost)} Funds`);
                    b.lvl++;
                    this.res -= cost;
                } else {
                    if(this.food < cost) return Controller.toast(`Need ${Math.floor(cost)} Food`);
                    b.lvl++;
                    this.food -= cost;
                }
                
                // Buildings in blds array (COM, IND, WELL, CHIEF) don't need special capacity updates
                // Zones handle their own capacity based on era level
                
                Controller.toast(`Upgraded to Level ${b.lvl}!`);
                this.recalc();
            },
            getUpgradeCost(currentLevel) {
                return Math.floor(CFG.UPGRADE.BASE_COST * Math.pow(CFG.UPGRADE.COST_MULTIPLIER, currentLevel - 1));
            },
            getBuildingProduction(building) {
                if(building.t === 'COM') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.COM_PRODUCTION_PER_LEVEL;
                } else if(building.t === 'IND') {
                    return 1500 + (building.lvl - 1) * CFG.UPGRADE.IND_PRODUCTION_PER_LEVEL;
                }
                return 0;
            },
            
            calculateDesirability(x, y, sz) {
                // Calculate desirability score for a location (0.5 to 3.0+)
                let score = 1.0;
                let neighborCount = 0;
                let hasTree = false;
                let hasWater = false;
                let hasChief = false;
                
                // Check neighbors (adjacent residential zones)
                for(let dx = -1; dx <= sz; dx++) {
                    for(let dy = -1; dy <= sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            // Check for zoned residential neighbors
                            let tile = this.tiles[checkX][checkY];
                            if(tile.zone === 'R') neighborCount++;
                            
                            // Check for trees/forest
                            if(tile.tree || tile.type === 'FOREST') hasTree = true;
                        }
                    }
                }
                
                // Check water proximity (within 3 tiles)
                for(let dx = -CFG.DESIRABILITY.WATER_RANGE; dx <= CFG.DESIRABILITY.WATER_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.WATER_RANGE; dy <= CFG.DESIRABILITY.WATER_RANGE + sz; dy++) {
                        let checkX = x + dx;
                        let checkY = y + dy;
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            let tile = this.tiles[checkX][checkY];
                            if(tile.type === 'WATER' || tile.type === 'RIVER') {
                                hasWater = true;
                            }
                        }
                    }
                }
                
                // Check Chief's Hut proximity (massive bonus within 50 tiles)
                let chiefHuts = this.blds.filter(b => b.t === 'CHIEF');
                for(let chief of chiefHuts) {
                    let dist = Math.sqrt(Math.pow(x - chief.x, 2) + Math.pow(y - chief.y, 2));
                    if(dist <= CFG.CHIEF_RADIUS) {
                        hasChief = true;
                        break;
                    }
                }
                
                // Apply bonuses
                score += neighborCount * CFG.DESIRABILITY.NEIGHBOR_BONUS;
                if(hasTree) score += CFG.DESIRABILITY.TREE_BONUS;
                if(hasWater) score += CFG.DESIRABILITY.WATER_BONUS;
                if(hasChief) score *= CFG.CHIEF_BONUS;  // Multiplier for Chief bonus
                
                // Isolation penalty - check if any buildings within 2 tiles
                let isolated = true;
                for(let dx = -CFG.DESIRABILITY.ISOLATION_RANGE; dx <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dx++) {
                    for(let dy = -CFG.DESIRABILITY.ISOLATION_RANGE; dy <= CFG.DESIRABILITY.ISOLATION_RANGE + sz; dy++) {
                        if(dx === 0 && dy === 0) continue;
                        let checkX = x + dx;
                        let checkY = y + dy;
                        
                        // Check for zoned tiles
                        if(checkX >= 0 && checkX < CFG.W && checkY >= 0 && checkY < CFG.H) {
                            if(this.tiles[checkX][checkY].zone) {
                                isolated = false;
                                break;
                            }
                        }
                        
                        // Check for 2x2 buildings
                        let nearBuilding = this.blds.find(b => 
                            checkX >= b.x && checkX < b.x + 2 &&
                            checkY >= b.y && checkY < b.y + 2
                        );
                        if(nearBuilding) {
                            isolated = false;
                            break;
                        }
                    }
                    if(!isolated) break;
                }
                
                if(isolated) score -= CFG.DESIRABILITY.ISOLATION_PENALTY;
                
                return Math.max(0.5, score);
            },
            recalc() {
                let wSup=50, jobs=0, housing=0, comJobs=0, indJobs=0;
                
                // Track peak population for game over screen
                if(this.pop > (this.peakPop || 0)) {
                    this.peakPop = this.pop;
                }
                
                // JIT HINT: Monomorphic array access pattern
                const tilesArray = this.tiles;
                const bldsArray = this.blds;
                const eraCount = CFG.ERAS.length;
                
                // Calculate zoned residential capacity AND average desirability
                let totalDesirability = 0;
                let zoneCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x]; // Cache array access
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Count neighboring residential zones for clustering bonus
                            let neighbors = 0;
                            for(let dx = -1; dx <= 1; dx++) {
                                for(let dy = -1; dy <= 1; dy++) {
                                    if(dx === 0 && dy === 0) continue;
                                    let nx = x + dx, ny = y + dy;
                                    if(nx >= 0 && nx < CFG.W && ny >= 0 && ny < CFG.H) {
                                        if(tilesArray[nx][ny].zone === 'R') neighbors++;
                                    }
                                }
                            }
                            
                            // Growth penalty for isolated houses, bonus for grouped
                            // 0 neighbors = 0.3x (very slow), 1 = 0.5x, 2 = 0.8x, 3 = 1x, 4+ = 1.5x
                            let clusterMultiplier = 1.0;
                            if(neighbors === 0) clusterMultiplier = 0.3;
                            else if(neighbors === 1) clusterMultiplier = 0.5;
                            else if(neighbors === 2) clusterMultiplier = 0.8;
                            else if(neighbors === 3) clusterMultiplier = 1.0;
                            else clusterMultiplier = 1.5;
                            
                            // Use building level from BUILDING_LEVELS config
                            let buildingLevel = bld.level || 0;
                            let levelConfig = CFG.BUILDING_LEVELS[buildingLevel];
                            if(levelConfig) {
                                let baseCapacity = levelConfig.capacity;
                                
                                // Level 1 buildings always have 20 capacity (population varies 0-20 based on desirability)
                                // Housing capacity = max people that CAN live there
                                if(buildingLevel === 1) {
                                    housing += baseCapacity; // Always 20 for Level 1
                                } else {
                                    // Other levels use desirability multiplier
                                    let desirabilityBonus = Math.max(1.0, (bld.desirability || 1.0) * 1.5);
                                    let finalCapacity = Math.floor(baseCapacity * desirabilityBonus);
                                    housing += finalCapacity;
                                }
                                
                                totalDesirability += bld.desirability || 1.0;
                                zoneCount++;
                            }
                        }
                    }
                }
                
                this.blds.forEach(b => {
                    b.conn = false; 
                    // COM/IND/WELL are 1x1 per documentation, others are 2x2
                    let sz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND') ? 1 : 2;
                    
                    // Check road connection
                    for (let x=b.x-1; x<b.x+sz+1; x++) {
                        for (let y=b.y-1; y<b.y+sz+1; y++) { 
                            if (x>=0 && x<CFG.W && y>=0 && y<CFG.H && this.tiles[x][y].road) {
                                b.conn = true;
                            }
                        }
                    }
                    
                    // Calculate building efficiency (organic growth)
                    let eff = 1.0;
                    
                    // NON-RESIDENTIAL: Use efficiency system
                    if(!b.conn) {
                        eff *= CFG.EFFICIENCY.NO_ROAD_PENALTY;
                    }
                    
                    if(b.waterProximity) {
                        eff += b.waterProximity * CFG.EFFICIENCY.WATER_BONUS_MAX;
                    } else {
                        eff *= 0.7;
                    }
                    
                    if(b.t === 'IND' && b.forestProximity) {
                        eff += CFG.EFFICIENCY.FOREST_BONUS;
                    }
                    
                    if(b.age > 50 && !b.conn) {
                        eff *= Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, 1 - (b.age - 50) * CFG.EFFICIENCY.DECAY_RATE);
                    }
                    
                    b.efficiency = Math.max(CFG.EFFICIENCY.MIN_EFFICIENCY, Math.min(3.0, eff));
                    
                    // Apply efficiency to calculations
                    if (b.t=='WELL') {
                        wSup += Math.floor(200 * (1 + (b.lvl - 1) * 0.5) * b.efficiency);
                    } else if (b.t=='COM') {
                        comJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    } else if (b.t=='IND') {
                        indJobs += Math.floor(10000 * b.lvl * b.efficiency);
                    }
                    
                    b.age++;
                });
                
                jobs = comJobs + indJobs;
                this.eff = (jobs>0) ? Math.min(1.0, this.pop/jobs) : 1.0;
                
                // CACHE housing capacity AND avg desirability to avoid recalculating 40k tiles every turn
                this.housingCap = housing;
                this.avgDesirability = zoneCount > 0 ? totalDesirability / zoneCount : 1.0;
                this.zoneCount = zoneCount;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKFORCE CALCULATION - Assign workers to infrastructure
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                let comCount = this.blds.filter(b => b.t === 'COM').length;
                let indCount = this.blds.filter(b => b.t === 'IND').length;
                
                // Use cached road count (updated when roads placed/removed) - avoids 62,500 tile loop!
                let roadTileCount = this.roadTileCount || 0;
                
                // Calculate workforce needs (with null checks for early game)
                // Wells no longer need workers - they work automatically
                let roadsNeeded = Math.ceil(roadTileCount / 5) * (CFG.WORKFORCE && CFG.WORKFORCE.ROAD_WORKERS !== undefined ? CFG.WORKFORCE.ROAD_WORKERS : 1);
                let comNeeded = comCount * (CFG.WORKFORCE ? CFG.WORKFORCE.COMMERCIAL_WORKERS : 3);
                let totalNeeded = roadsNeeded + comNeeded;
                
                // Total workforce = residential population
                let totalWorkforce = this.pop;
                
                // Assign workers (priority: Roads > Commercial > Gathering)
                let remaining = totalWorkforce;
                
                let roadWorkers = Math.min(roadsNeeded, remaining);
                remaining -= roadWorkers;
                
                let comWorkers = Math.min(comNeeded, remaining);
                remaining -= comWorkers;
                
                let gatherers = remaining; // Everyone else gathers/hunts
                
                // Store workforce data
                this.workforce = {
                    total: totalWorkforce,
                    roadWorkers: roadWorkers,
                    comWorkers: comWorkers,
                    gatherers: gatherers,
                    roadsNeeded: roadsNeeded,
                    comNeeded: comNeeded,
                    shortage: totalNeeded - totalWorkforce
                };
                
                // Water calculation: all wells provide water automatically
                this.waterCap = wellCount * (CFG.WATER ? CFG.WATER.WELL_CAPACITY : 100);
                // WELLS ARE ALWAYS REQUIRED - 1 well per 100 people minimum
                let waterNeeded = Math.max(1, Math.ceil(this.pop / 100)); // At least 1 well always needed
                this.water = wellCount - waterNeeded; // Wells vs need
                
                // Store counts for UI
                this.wellCount = wellCount;
                this.roadTileCount = roadTileCount;
                this.housingCap = housing;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NEEDS CALCULATION - Determine what people are missing
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                this.calculateNeeds();
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // LEVEL UNLOCK CHECK - Unlock higher building levels based on population
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                PROGRESSION.updateUnlockedLevels(this);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // POPULATION ASSIGNMENT - Distribute population to residential buildings
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(typeof assignPopulationToResidential === 'function') {
                    assignPopulationToResidential(this);
                }
                
                Controller.updateUI();
            },
            
            // Calculate needs satisfaction for all categories
            calculateNeeds() {
                let pop = this.pop || 0;
                if(pop === 0) {
                    this.needs.overall = 1.0;
                    return;
                }
                
                // HOUSING: Do we have enough homes?
                let housingNeed = pop;
                let housingHave = this.housingCap || 0;
                this.needs.housing = {
                    have: housingHave,
                    need: housingNeed,
                    satisfied: Math.min(1.0, housingHave / Math.max(1, housingNeed)),
                    shortage: Math.max(0, housingNeed - housingHave)
                };
                
                // WATER: Do we have enough wells?
                // In CITY mode: Always need at least 1 well, then 1 per 100 people
                let waterNeed = Math.max(1, Math.ceil(pop / 100)); // Always 1+ in settlement
                let waterHave = this.wellCount || 0;
                this.needs.water = {
                    have: waterHave,
                    need: waterNeed,
                    satisfied: Math.min(1.0, waterHave / Math.max(1, waterNeed)),
                    shortage: Math.max(0, waterNeed - waterHave)
                };
                
                // FOOD: Do we have food surplus?
                let foodConsumption = pop * (CFG.CONSTANTS ? CFG.CONSTANTS.FOOD_PER_PERSON : 0.2);
                let foodHave = this.food || 0;
                this.needs.food = {
                    have: foodHave,
                    need: foodConsumption * 10, // Need 10 years of food for full satisfaction
                    satisfied: Math.min(1.0, foodHave / Math.max(1, foodConsumption * 10)),
                    shortage: foodHave < foodConsumption ? Math.ceil(foodConsumption - foodHave) : 0
                };
                
                // JOBS: Do we have enough commercial/industrial?
                let jobsNeed = Math.ceil(pop * 0.5); // 50% of population wants jobs beyond gathering
                let jobsHave = 0;
                this.blds.forEach(b => {
                    if(b.t === 'COM') jobsHave += 20 * (b.lvl || 1);
                    if(b.t === 'IND') jobsHave += 30 * (b.lvl || 1);
                });
                this.needs.jobs = {
                    have: jobsHave,
                    need: jobsNeed,
                    satisfied: jobsNeed > 0 ? Math.min(1.0, jobsHave / jobsNeed) : 1.0,
                    shortage: Math.max(0, jobsNeed - jobsHave)
                };
                
                // PATHS: Do we have road coverage?
                let pathsNeed = Math.ceil(this.zoneCount * 2); // 2 road tiles per residential zone
                let pathsHave = this.roadTileCount || 0;
                this.needs.paths = {
                    have: pathsHave,
                    need: pathsNeed,
                    satisfied: pathsNeed > 0 ? Math.min(1.0, pathsHave / pathsNeed) : 1.0,
                    shortage: Math.max(0, pathsNeed - pathsHave)
                };
                
                // OVERALL SATISFACTION (weighted average)
                // Housing and Food are critical (weight 2), others weight 1
                let totalWeight = 8;
                this.needs.overall = (
                    this.needs.housing.satisfied * 2 +
                    this.needs.water.satisfied * 2 +
                    this.needs.food.satisfied * 2 +
                    this.needs.jobs.satisfied * 1 +
                    this.needs.paths.satisfied * 1
                ) / totalWeight;
            },
            
            // Generate yearly announcement about what people need
            generateNeedsAnnouncement() {
                if(!this.simcityMode && this.gameState !== 'CITY') return null;
                if(this.pop < 5) return null; // Don't spam for tiny settlements
                
                let missing = [];
                let icons = {
                    housing: 'ğŸ ',
                    water: 'ğŸ’§',
                    food: 'ğŸŒ¾',
                    jobs: 'ğŸ’¼',
                    paths: 'ğŸ›¤ï¸'
                };
                
                // Check each need
                if(this.needs.housing.satisfied < 0.9) {
                    missing.push(`${icons.housing} Housing (${this.needs.housing.shortage} homeless)`);
                }
                if(this.needs.water.satisfied < 0.9) {
                    missing.push(`${icons.water} Wells (need ${this.needs.water.shortage} more)`);
                }
                if(this.needs.food.satisfied < 0.5) {
                    missing.push(`${icons.food} Food reserves low`);
                }
                if(this.needs.jobs.satisfied < 0.7 && this.pop > 20) {
                    missing.push(`${icons.jobs} Jobs (${this.needs.jobs.shortage} unemployed)`);
                }
                if(this.needs.paths.satisfied < 0.5 && this.zoneCount > 3) {
                    missing.push(`${icons.paths} Paths (${this.needs.paths.shortage} tiles needed)`);
                }
                
                if(missing.length === 0) {
                    // All needs met - prosperity message every 10 years
                    if(this.year % 10 === 0) {
                        return `âœ¨ Year ${this.year}: Your people are prosperous! (${Math.floor(this.needs.overall * 100)}% satisfaction)`;
                    }
                    return null;
                }
                
                return `âš ï¸ Year ${this.year}: Your people need: ${missing.join(', ')}`;
            },
            
            // Calculate income based on population, desirability, and needs satisfaction
            calculateIncome() {
                let baseIncome = 0;
                let pop = this.pop || 0;
                
                // Base income per person (people generate value by existing)
                let incomePerPerson = 0.5; // Base income per person per year
                
                // Desirability multiplier (wealthy areas = more spending)
                let desirabilityMult = Math.max(0.5, Math.min(2.0, this.avgDesirability || 1.0));
                
                // Needs satisfaction multiplier (unhappy people = less productive)
                let satisfactionMult = Math.max(0.3, this.needs.overall || 1.0);
                
                // Population income (base economy)
                baseIncome = pop * incomePerPerson * desirabilityMult * satisfactionMult;
                
                // Commercial building income (boosted by population & satisfaction)
                this.blds.forEach(b => {
                    if(b.t === 'COM') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Commercial income scales with local population density
                        let popBonus = Math.min(2.0, 1.0 + (pop / 500)); // Up to 2x at 500 pop
                        baseIncome += buildingBase * b.efficiency * satisfactionMult * popBonus;
                    }
                    if(b.t === 'IND') {
                        let buildingBase = this.getBuildingProduction(b);
                        // Industrial provides 50% income (rest is food production)
                        baseIncome += buildingBase * 0.5 * b.efficiency * satisfactionMult;
                    }
                });
                
                return Math.floor(baseIncome);
            },
            endTurn() {
                try {
                    // Record player action for AI learning
                    if(typeof QLearningAI !== 'undefined' && QLearningAI.isWatching) {
                        QLearningAI.recordPlayerAction('PASS_YEAR');
                    }
                    
                    this.year++;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // GEOLOGICAL WATER CYCLE - Check every 100 years
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if(CFG.ELEVATION_SYSTEM.ENABLED) {
                        this.updateGeologicalCycle();
                    }
                    
                    // CRITICAL: Recalculate workforce FIRST before any production/consumption
                    this.recalc();
                    
                    // Process player pathfinding
                    this.processPath();
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NOTE: Level 0 buildings removed - Level 0 is WANDER epoch only
                // All building starts at Level 1 (Settlement) now
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // LEVEL 1 RESIDENTIAL UPKEEP & ABANDONED TIMER
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Upkeep is simple: 0.5 wood per building per year (very low)
                // Only abandoned buildings (5+ years empty) have higher upkeep
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let level1UpkeepTotal = 0;
                let level1Count = 0;
                let abandonedCount = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building && tile.building.level === 1) {
                            let bld = tile.building;
                            level1Count++;
                            
                            // Initialize empty years tracker if not exists
                            if(bld.emptyYears === undefined) bld.emptyYears = 0;
                            
                            // Check if building is abandoned (variant 0 AND empty for 5+ years)
                            let isAbandoned = bld.variant === 0 && bld.emptyYears >= 5;
                            
                            if(isAbandoned) {
                                // Abandoned: higher upkeep (1 wood)
                                level1UpkeepTotal += 1;
                            } else {
                                // Normal upkeep: 0.5 wood per building
                                level1UpkeepTotal += 0.5;
                                
                                // Track empty years for abandonment
                                let hasOccupancy = this.pop > 0; // Any population means buildings are in use
                                if(!hasOccupancy) {
                                    bld.emptyYears++;
                                } else {
                                    bld.emptyYears = 0;
                                }
                            }
                            
                            // Check for abandoned (5 years with 0 population in settlement)
                            if(bld.emptyYears >= 5 && bld.variant !== 0 && this.pop === 0) {
                                bld.variant = 0; // Force to Abandoned variant
                                abandonedCount++;
                                this.markDirty(x, y, 1);
                            }
                        }
                    }
                }
                
                // Round upkeep to nearest whole number
                level1UpkeepTotal = Math.ceil(level1UpkeepTotal);
                
                // Deduct wood upkeep (silently - only warn on shortage)
                if(level1UpkeepTotal > 0) {
                    if(this.wood >= level1UpkeepTotal) {
                        this.wood -= level1UpkeepTotal;
                    } else {
                        // Not enough wood
                        this.wood = 0;
                    }
                }
                
                if(abandonedCount > 0) {
                    Controller.toast(`ğŸ’€ ${abandonedCount} settlement${abandonedCount > 1 ? 's' : ''} abandoned due to neglect!`);
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // WORKFORCE GATHERING - Unassigned workers gather/hunt food AND wood
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Workers not assigned to infrastructure (wells, roads, commercial)
                // automatically gather food AND wood. This is the main resource source before
                // Industrial zones are built in Epoch 2.
                // Scaled by gatheringMultiplier (based on initial settlement population)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(this.workforce && this.workforce.gatherers > 0 && CFG.WORKFORCE) {
                    let baseFood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5);
                    let gathererFood = baseFood * (this.gatheringMultiplier || 1.0);
                    this.food += gathererFood;
                    
                    // WOOD PRODUCTION: Gatherers also collect wood
                    // Using config rate, scaled by gathering multiplier
                    let baseWood = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_WOOD_RATE || 3.0);
                    let gathererWood = baseWood * (this.gatheringMultiplier || 1.0);
                    this.wood += gathererWood;
                    
                    // STONE GATHERING: 25% of food rate - finding rocks while foraging
                    let baseStone = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5) * 0.25;
                    let gathererStone = baseStone * (this.gatheringMultiplier || 1.0);
                    this.stone = (this.stone || 0) + gathererStone;
                    
                    // METAL GATHERING: 5% of food rate - rare finds while foraging
                    let baseMetal = this.workforce.gatherers * (CFG.WORKFORCE.GATHERER_FOOD_RATE || 1.5) * 0.05;
                    let gathererMetal = baseMetal * (this.gatheringMultiplier || 1.0);
                    this.metal = (this.metal || 0) + gathererMetal;
                    
                    // Warn if no gatherers due to infrastructure demand
                    if(this.workforce.shortage > 0) {
                        Controller.toast(`âš ï¸ Worker shortage! ${this.workforce.shortage} more needed. ${this.workforce.gatherers} gathering.`);
                    } else if(this.workforce.gatherers > 0 && this.pop < 20) {
                        // Show production details for early game
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`ğŸŒ¾ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood, +${gathererStone.toFixed(1)} stone${multiplierText}`);
                    } else if(this.workforce.gatherers > 10 && Math.random() < 0.2) {
                        let multiplierText = this.gatheringMultiplier > 1.0 ? ` (${(this.gatheringMultiplier * 100).toFixed(0)}% rate)` : '';
                        Controller.toast(`ğŸŒ¾ ${this.workforce.gatherers} gatherers: +${gathererFood.toFixed(1)} food, +${gathererWood.toFixed(1)} wood, +${gathererStone.toFixed(1)} stone${multiplierText}`);
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ROAD DECAY - Unmaintained roads decay over time
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // If not enough road workers, roads provide no desirability bonus
                if(this.workforce && this.workforce.roadWorkers < this.workforce.roadsNeeded) {
                    let unmaintainedRoads = Math.ceil((this.workforce.roadsNeeded - this.workforce.roadWorkers) * 5);
                    if(unmaintainedRoads > 10 && Math.random() < 0.3) {
                        Controller.toast(`âš ï¸ ${unmaintainedRoads} road tiles unmaintained! Desirability reduced.`);
                    }
                }
                
                // AUTO-EVOLUTION: Update all zoned buildings
                const tilesArray = this.tiles;
                const popTotal = this.pop;
                const growthThreshold = CFG.GROWTH_THRESHOLD;
                const decayThreshold = CFG.DECAY_THRESHOLD;
                
                // Use cached housing capacity from recalc() - don't recalculate 40k tiles!
                let housingCap = this.housingCap || 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    const tileRow = tilesArray[x];
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = tileRow[y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            
                            // Age the zone (only every 10 years to slow progression)
                            if(!bld.age) bld.age = 0;
                            if(!bld.lastBirthYear) bld.lastBirthYear = this.year;
                            if(this.year % 10 === 0) bld.age++;
                            
                            // Calculate desirability
                            bld.desirability = this.calculateDesirability(x, y, 1);
                            
                            // NATURAL POPULATION BOOM: Every 10 years, zones generate bonus population
                            let yearsSinceBirth = this.year - bld.lastBirthYear;
                            if(yearsSinceBirth >= 10 && bld.desirability >= 1.0) {
                                // Calculate boom size: 1-2 base, +1 for high desirability, +1 for high level
                                let boomSize = 1 + Math.floor(Math.random() * 2);
                                if(bld.desirability >= 1.5) boomSize++;
                                if(bld.level >= 4) boomSize++;
                                
                                this.pop += boomSize;
                                bld.lastBirthYear = this.year;
                                
                                // Update building populations after population boom
                                if(typeof assignPopulationToResidential === 'function') {
                                    assignPopulationToResidential(this);
                                }
                                
                                if(Math.random() < 0.3) { // Only show some messages to avoid spam
                                    Controller.toast(`ğŸ‘¶ Population boom! +${boomSize} from established settlement`);
                                }
                            }
                            
                            // NOTE: maxLevel no longer used - building LEVEL only changes via player action
                            // Variant state (appearance) changes automatically based on desirability
                            
                            // Growth rate based on desirability - CHANGES VARIANT STATE, NOT LEVEL
                            // Level (zone tier) only changes when player builds/bulldozes
                            // Variant (0=Abandoned, 1=Low, 2=Medium, 3=High) changes based on desirability
                            if(!bld.variant) bld.variant = 1; // Default to Low variant
                            if(!bld.growth) bld.growth = 0;
                            
                            // Determine target variant based on desirability
                            let targetVariant = 1; // Default Low
                            if(bld.desirability < 0.1) targetVariant = 0; // Abandoned
                            else if(bld.desirability < 0.4) targetVariant = 1; // Low
                            else if(bld.desirability < 0.7) targetVariant = 2; // Medium
                            else targetVariant = 3; // High
                            
                            // Gradually move toward target variant
                            if(bld.variant < targetVariant) {
                                // Growing: desirability supports higher variant
                                let growthSpeed = 0.02; // Base (50 years to upgrade)
                                if(bld.desirability >= 1.0) growthSpeed = 0.04; // Faster (25 years)
                                if(bld.desirability >= 1.5) growthSpeed = 0.08; // Even faster (12.5 years)
                                if(bld.desirability >= 2.0) growthSpeed = 0.15; // Fast (6-7 years)
                                
                                bld.growth += growthSpeed;
                                
                                // Gathering logic: increase food production at medium/high variants
                                if(bld.variant >= 2) {
                                    let gatherBonus = 1.0;
                                    if(bld.variant === 2) gatherBonus = 1.25; // Medium
                                    if(bld.variant >= 3) gatherBonus = 1.5; // High
                                    this.food += gatherBonus;
                                }
                                
                                if(bld.growth >= 1.0) {
                                    bld.variant = Math.min(bld.variant + 1, 3); // Max variant is 3
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`ğŸ  Building upgraded to ${variantName}!`);
                                        }
                                    }
                                }
                            } else if(bld.variant > targetVariant && bld.variant > 0) {
                                // Decaying: desirability doesn't support current variant
                                bld.growth -= 0.05;
                                if(bld.growth <= -1.0) {
                                    bld.variant = Math.max(bld.variant - 1, 0); // Min variant is 0
                                    bld.growth = 0;
                                    this.markDirty(x, y, 1);
                                    
                                    // Get variant name for toast
                                    let levelConfig = CFG.BUILDING_LEVELS[bld.level];
                                    if(levelConfig && levelConfig.variants && levelConfig.variants[bld.variant]) {
                                        let variantName = levelConfig.variants[bld.variant].name;
                                        if(Math.random() < 0.3) { // Don't spam
                                            Controller.toast(`ğŸ“‰ Building declined to ${variantName}`);
                                        }
                                    }
                                }
                            }
                            
                            // NOTE: Buildings player PAID FOR are not downgraded.
                            // The maxLevel only limits natural GROWTH, not existing buildings.
                            // This prevents frustration from losing expensive buildings.
                        }
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // OVERCROWDING PENALTY SYSTEM
                // Buildings can hold +5 extra people (overflowCapacity) but if
                // overcrowded for more than 1 year, they start losing population
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let overcrowdingDeaths = 0;
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            let buildingLevel = bld.level || 1;
                            let levelConfig = CFG.BUILDING_LEVELS[buildingLevel];
                            
                            if(levelConfig) {
                                let capacity = levelConfig.capacity;
                                let overflowCapacity = levelConfig.overflowCapacity || (capacity + 5);
                                let currentPop = bld.pop || 0;
                                
                                // Initialize overcrowdedYears tracker
                                if(bld.overcrowdedYears === undefined) bld.overcrowdedYears = 0;
                                
                                // Check if building is overcrowded (above normal capacity)
                                if(currentPop > capacity) {
                                    bld.overcrowdedYears++;
                                    
                                    // If overcrowded for more than 1 year, start losing population
                                    if(bld.overcrowdedYears > 1) {
                                        // Lose 1-2 people per year from disease/stress
                                        let deaths = 1 + Math.floor(Math.random() * 2);
                                        deaths = Math.min(deaths, currentPop - capacity); // Don't reduce below capacity
                                        
                                        if(deaths > 0) {
                                            this.pop = Math.max(0, this.pop - deaths);
                                            overcrowdingDeaths += deaths;
                                        }
                                    }
                                } else {
                                    // Not overcrowded, reset timer
                                    bld.overcrowdedYears = 0;
                                }
                            }
                        }
                    }
                }
                
                if(overcrowdingDeaths > 0) {
                    Controller.toast(`ğŸ’€ OVERCROWDING! ${overcrowdingDeaths} people died from cramped conditions!`);
                    // Re-assign population after deaths
                    if(typeof assignPopulationToResidential === 'function') {
                        assignPopulationToResidential(this);
                    }
                    // Check for game over
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // LIFESPAN SYSTEM
                // Base lifespan: 20 years (Low density/variant 1)
                // Medium density (variant 2): +5% = 21 years
                // High density (variant 3): +10% = 22 years
                // Higher quality buildings = longer lives due to better conditions
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let totalPopInBuildings = 0;
                let weightedLifespan = 0;
                
                for(let x = 0; x < CFG.W; x++) {
                    for(let y = 0; y < CFG.H; y++) {
                        let tile = this.tiles[x][y];
                        if(tile.zone === 'R' && tile.building) {
                            let bld = tile.building;
                            let pop = bld.pop || 0;
                            if(pop > 0) {
                                // Base lifespan is 20 years
                                let baseLifespan = 20;
                                
                                // Variant bonus: 0=abandoned (no bonus), 1=low (+0), 2=medium (+5%), 3=high (+10%)
                                let variant = bld.variant || 1;
                                let lifespanBonus = 0;
                                if(variant === 2) lifespanBonus = 0.05; // +5% = 21 years
                                else if(variant >= 3) lifespanBonus = 0.10; // +10% = 22 years
                                
                                let lifespan = baseLifespan * (1 + lifespanBonus);
                                
                                totalPopInBuildings += pop;
                                weightedLifespan += pop * lifespan;
                            }
                        }
                    }
                }
                
                // Calculate natural deaths from old age
                if(totalPopInBuildings > 0 && this.pop > 0) {
                    let avgLifespan = weightedLifespan / totalPopInBuildings;
                    
                    // Each year, 1/lifespan of the population dies of old age
                    // e.g., with 20 year lifespan, ~5% die per year (1/20 = 0.05)
                    let expectedDeaths = this.pop / avgLifespan;
                    
                    // Add some randomness (50% to 150% of expected)
                    let randomFactor = 0.5 + Math.random();
                    let naturalDeaths = Math.floor(expectedDeaths * randomFactor);
                    
                    // Cap at current population
                    naturalDeaths = Math.max(0, Math.min(naturalDeaths, this.pop));
                    
                    if(naturalDeaths > 0) {
                        this.pop -= naturalDeaths;
                        
                        // Only show message occasionally to avoid spam
                        if(Math.random() < 0.2 || naturalDeaths > 5) {
                            Controller.toast(`âš°ï¸ ${naturalDeaths} died of old age. Avg lifespan: ${avgLifespan.toFixed(1)} years`);
                        }
                        
                        // Re-assign population after deaths
                        if(typeof assignPopulationToResidential === 'function') {
                            assignPopulationToResidential(this);
                        }
                        
                        // Check for game over - attribute to flood if that was the cause
                        if(this.pop <= 0) {
                            Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                            return;
                        }
                    }
                }
                
                // SIMCITY MODE - Modern city management
                if(this.simcityMode) {
                    // Use cached values from recalc() - PERFORMANCE FIX (no 40k tile iteration!)
                    let housingCap = this.housingCap || 0;
                    let avgDesirability = this.avgDesirability || 1.0;
                    let zoneCount = this.zoneCount || 0;
                    let jobs = 0;
                    let foodProduction = 0;
                    
                    // Calculate jobs and food from 2x2 buildings
                    this.blds.forEach(b => {
                        if(b.t === 'COM') jobs += Math.floor(100 * b.lvl * b.efficiency);
                        else if(b.t === 'IND') {
                            jobs += Math.floor(100 * b.lvl * b.efficiency);
                            foodProduction += Math.floor(50 * b.lvl * b.efficiency); // Industry still produces food
                        }
                    });
                    
                    // Food remains relevant - population health
                    // Wealthier areas (high desirability) consume more food per person
                    
                    let foodNeeded = this.pop * CFG.PRODUCTION.SIMCITY_FOOD_PER_PERSON * (avgDesirability > 1.5 ? CFG.DESIRABILITY.WEALTH_FOOD_MULTIPLIER : 1.0);
                    this.food += foodProduction;
                    this.food -= foodNeeded;
                    
                    // Starvation - population shrinks without food
                    if(this.food < 0) {
                        let starvation = Math.ceil(Math.abs(this.food) * CFG.PRODUCTION.STARVATION_RATE);
                        this.pop -= starvation;
                        this.pop = Math.max(0, this.pop);
                        this.food = 0;
                        Controller.toast(`âš ï¸ ${starvation} people starved! Need more Industrial!`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    
                    // WATER SYSTEM: Wells are critical for survival
                    // Each well supports 100 people. No wells = death after 1 year
                    // Insufficient wells = population dies off from dehydration
                    let wellCount = this.blds.filter(b => b.t === 'WELL').length;
                    let waterCapacity = wellCount * 100; // Each well supports 100 people
                    
                    if(wellCount === 0 && this.pop > 0) {
                        // NO WELLS AT ALL - instant death after 1 year
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // Die after 1 year with no wells
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(wellCount > 0 && this.pop > waterCapacity) {
                        // NOT ENOUGH WELLS - only people WITHOUT water die (not everyone)
                        let peopleWithoutWater = this.pop - waterCapacity;
                        let dehydrationDeaths = Math.ceil(peopleWithoutWater * 0.20); // 20% of those without water
                        this.pop -= dehydrationDeaths;
                        this.pop = Math.max(1, this.pop);
                        
                        if(dehydrationDeaths > 0) {
                            Controller.toast(`ğŸ’§ Water shortage! ${dehydrationDeaths} died. Have ${wellCount} wells (${waterCapacity} capacity), pop: ${this.pop}`);
                        }
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                        this.yearsWithoutWell = 0;
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Population growth based on balance (see-saw)
                    let targetPop = Math.min(housingCap, jobs);
                    if(this.pop < targetPop && this.food > foodNeeded * 2) {
                        let growth = Math.floor((targetPop - this.pop) * CFG.PRODUCTION.SIMCITY_POPULATION_GROWTH_RATE);
                        this.pop += Math.max(1, growth);
                        this.pop = Math.min(this.pop, targetPop);
                    } else if(this.pop > housingCap) {
                        // BRUTAL OVERPOPULATION - homeless people are a massive drain
                        let homeless = this.pop - housingCap;
                        
                        // DISEASE: 25% of homeless die every year from overcrowding, disease, crime
                        let deaths = Math.ceil(homeless * 0.25);
                        this.pop -= deaths;
                        
                        // Economic collapse from chaos - 20% loss
                        let econLoss = Math.ceil(this.res * 0.20);
                        this.res = Math.max(0, this.res - econLoss);
                        
                        // Food waste and theft
                        let foodLoss = Math.ceil(this.food * 0.15);
                        this.food = Math.max(0, this.food - foodLoss);
                        
                        if(deaths > 10) {
                            Controller.toast(`â˜ ï¸ OVERCROWDING! ${deaths} homeless died! $${econLoss} economic collapse!`);
                        }
                    }
                    
                    // Income from buildings (NOW INTERDEPENDENT!)
                    // Uses new calculateIncome() which factors in population, desirability, and needs
                    let incR = this.calculateIncome();
                    
                    let maint = this.blds.length * 2;
                    this.res = Math.max(0, this.res + incR - maint);
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    this.recalc();
                    Controller.updateUI();
                    return;
                }
                
                // EPOCH 0 (Paleolithic) - BRUTAL SURVIVAL ECONOMY
                if(this.age === 0) {
                    // --- BRUTAL ECONOMY ---
                    
                    // 1. FOOD SPOILAGE (The Rot)
                    // Base capacity is just what people can carry/store without infrastructure
                    let storageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let woodStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let stoneStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    let metalStorageCap = CFG.CONSTANTS.BASE_STORAGE;
                    
                    this.blds.forEach(b => {
                        // Old storage buildings (all add to food)
                        if(b.t === 'BASKET') storageCap += CFG.BUILDINGS.BASKET.cap;
                        if(b.t === 'POTTERY') storageCap += CFG.BUILDINGS.POTTERY.cap;
                        if(b.t === 'GRANARY') storageCap += CFG.BUILDINGS.GRANARY.cap;
                        if(b.t === 'PALACE') storageCap += CFG.BUILDINGS.PALACE.cap;
                        
                        // Storage Pits (specific to each resource)
                        if(b.t === 'FOOD_PIT') storageCap += CFG.STORAGE_PITS.FOOD_PIT.cap;
                        if(b.t === 'WOOD_PIT') woodStorageCap += CFG.STORAGE_PITS.WOOD_PIT.cap;
                        if(b.t === 'STONE_PIT') stoneStorageCap += CFG.STORAGE_PITS.STONE_PIT.cap;
                        if(b.t === 'METAL_PIT') metalStorageCap += CFG.STORAGE_PITS.METAL_PIT.cap;
                    });

                    // If you have more food than storage, it rots FAST
                    if(this.food > storageCap) {
                        let rot = Math.floor((this.food - storageCap) * CFG.CONSTANTS.BASE_SPOILAGE);
                        this.food = Math.max(0, this.food - rot);
                        if(rot > 100 && Math.random() < 0.3) {
                            Controller.toast(`ğŸ‚ ${rot} food rotted! Need storage buildings!`);
                        }
                    }
                    
                    // Wood rot (slower than food - 10% rate)
                    if(this.wood > woodStorageCap) {
                        let rot = Math.floor((this.wood - woodStorageCap) * 0.10);
                        this.wood = Math.max(0, this.wood - rot);
                        if(rot > 50 && Math.random() < 0.2) {
                            Controller.toast(`ğŸªµ ${rot} wood rotted! Build Wood Pit!`);
                        }
                    }
                    
                    // Stone doesn't rot but can be "lost" at very high amounts (5% rate)
                    if(this.stone > stoneStorageCap) {
                        let lost = Math.floor((this.stone - stoneStorageCap) * 0.05);
                        this.stone = Math.max(0, this.stone - lost);
                        if(lost > 20 && Math.random() < 0.1) {
                            Controller.toast(`ğŸª¨ ${lost} stone scattered! Build Stone Pit!`);
                        }
                    }
                    
                    // Metal rusts slowly (3% rate)
                    if(this.metal > metalStorageCap) {
                        let rust = Math.floor((this.metal - metalStorageCap) * 0.03);
                        this.metal = Math.max(0, this.metal - rust);
                        if(rust > 10 && Math.random() < 0.1) {
                            Controller.toast(`âš™ï¸ ${rust} metal rusted! Build Metal Pit!`);
                        }
                    }
                    
                    // 2. PRODUCTION & CONSUMPTION
                    let housingCap = this.housingCap || 0;
                    // Only count homeless if there ARE residential buildings - nomads don't need housing
                    // This prevents plague from triggering in early game before any buildings exist
                    let hasResBuildings = housingCap > 0;
                    let homeless = hasResBuildings ? Math.max(0, this.pop - housingCap) : 0;
                    let housed = this.pop - homeless;
                    
                    // Calculate average zone level for food production scaling
                    let totalLevel = 0;
                    let zoneCount = 0;
                    for(let x = 0; x < CFG.W; x++) {
                        for(let y = 0; y < CFG.H; y++) {
                            let tile = this.tiles[x][y];
                            if(tile.zone === 'R' && tile.building) {
                                let buildingLevel = tile.building.level || 1;
                                totalLevel += buildingLevel;
                                // Use level-specific capacity from BUILDING_LEVELS config
                                let levelConfig = CFG.BUILDING_LEVELS[buildingLevel - 1] || CFG.BUILDING_LEVELS[0];
                                zoneCount++;
                            }
                        }
                    }
                    let avgLevel = zoneCount > 0 ? totalLevel / zoneCount : 1;
                    
                    // Food production scales with civilization level (better tools, farming, etc.)
                    // Level 1: 1.0x, Level 3: 1.5x, Level 5: 2.0x, Level 8: 3.0x
                    let techMultiplier = 1.0 + (avgLevel - 1) * 0.3;
                    
                    // Food consumption scales FASTER than production (luxury goods, waste)
                    // Level 1: 1.0x, Level 3: 2.0x, Level 5: 3.5x, Level 8: 6.0x
                    let consumptionMultiplier = 1.0 + (avgLevel - 1) * 0.7;
                    
                    // ONLY HOUSED PEOPLE PRODUCE FOOD
                    let gathered = housed * CFG.PRODUCTION.PERSON_HUNTS * CFG.CONSTANTS.BASE_PROD * techMultiplier;
                    
                    // EVERYONE EATS, consumption scales faster than production
                    let housedConsumption = housed * CFG.CONSTANTS.FOOD_PER_PERSON * consumptionMultiplier;
                    let homelessConsumption = homeless * CFG.CONSTANTS.FOOD_PER_PERSON * 2.0; // Homeless eat DOUBLE
                    let eaten = housedConsumption + homelessConsumption;
                    
                    // Add hunting grounds production
                    let industrialCount = 0;
                    this.blds.forEach(b => {
                        if(b.t === 'IND' && PROGRESSION.stage >= 2 && b.forestProximity) {
                            // Check if built on STONE tiles (quarry mode)
                            let isQuarry = false;
                            let stoneMined = 0;
                            let metalExtracted = 0;
                            
                            for(let dx = 0; dx < 2; dx++) {
                                for(let dy = 0; dy < 2; dy++) {
                                    let tile = this.tiles[b.x + dx]?.[b.y + dy];
                                    if(tile && tile.type === 'STONE' && tile.resource && tile.resource.amount > 0) {
                                        isQuarry = true;
                                        // Mine stone from deposit
                                        let mineAmount = Math.min(100, tile.resource.amount);
                                        tile.resource.amount -= mineAmount;
                                        stoneMined += mineAmount;
                                        metalExtracted += mineAmount * tile.resource.metal_yield;
                                        
                                        // Notify when deposit depleted
                                        if(tile.resource.amount <= 0) {
                                            Controller.toast(`â›ï¸ Quarry stone deposit depleted!`);
                                        }
                                    }
                                }
                            }
                            
                            if(isQuarry) {
                                // Quarry mode: mine stone and extract metal
                                this.stone += stoneMined;
                                this.metal += metalExtracted;
                            } else {
                                // Hunting grounds mode: produce food
                                gathered += CFG.PRODUCTION.INDUSTRIAL_FOOD_PER_TURN;
                            }
                            industrialCount++;
                        }
                    });
                    
                    this.food += gathered;
                    this.food -= eaten;
                    
                    // 3. BRUTAL OVERPOPULATION (Disease, starvation, crime)
                    if(homeless > 0) {
                        let overcrowdingPct = homeless / this.pop; // 0.0 to 1.0
                        
                        // 1. CRIME & THEFT (Immediate Resource Drain)
                        // Desperate people steal food. 
                        // You lose 10% of your TOTAL stockpile per year.
                        let stolenFood = Math.ceil(this.food * 0.10); 
                        this.food = Math.max(0, this.food - stolenFood);

                        // 2. EXPOSURE (Constant Death)
                        // Living without shelter kills 15% of the homeless every turn.
                        let exposureDeaths = Math.ceil(homeless * 0.15);
                        this.pop -= exposureDeaths;

                        // 3. THE PLAGUE (The Civilization Killer)
                        // The chance of outbreak = 2x % of population that is homeless.
                        // If 20% are homeless, you have a 40% chance of Plague every turn.
                        if(Math.random() < (overcrowdingPct * 2)) {
                             // Plague kills 30% of EVERYONE (housed and homeless)
                             let plagueDeaths = Math.ceil(this.pop * 0.30);
                             this.pop -= plagueDeaths;
                             
                             // Economic Crash
                             let lostFunds = Math.ceil(this.res * 0.50);
                             this.res -= lostFunds;

                             Controller.toast(`â˜ ï¸ PLAGUE OUTBREAK! ${plagueDeaths} dead! Economy Collapsed!`);
                        } else {
                             // ALWAYS show overcrowding warning when homeless exist
                             Controller.toast(`ğŸšï¸ OVERCROWDED! ${homeless} homeless: -${exposureDeaths} died, -${stolenFood} food stolen!`);
                        }
                    }
                    
                    // 4. CHECK CAPACITY - use cached value from recalc() for PERFORMANCE
                    housingCap = this.housingCap || 0;
                    
                    // 4. STARVATION (THE DEATH SPIRAL)
                    if(this.food < 0) {
                        this.food = 0;
                        let deaths = Math.ceil(this.pop * CFG.CONSTANTS.STARVATION_DEATH);
                        this.pop = Math.max(0, this.pop - deaths);
                        Controller.toast(`ğŸ’€ FAMINE! ${deaths} people starved to death!`);
                    }
                    
                    // 5. WATER SHORTAGE - POPULATION ALWAYS DEPENDS ON FRESH WATER
                    // Calculate how many wells are needed - at least 1 well always required!
                    let wellsNeeded = Math.max(1, Math.ceil(this.pop / 100)); // 1 well per 100 people, minimum 1
                    let totalWellCount = this.blds.filter(b => b.t === 'WELL').length;
                    
                    // Track years without ANY wells
                    if(totalWellCount === 0 && this.pop > 0) {
                        if(!this.yearsWithoutWell) this.yearsWithoutWell = 0;
                        this.yearsWithoutWell++;
                        
                        // After 1 year with NO wells at all = instant death
                        if(this.yearsWithoutWell >= 1) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else {
                        this.yearsWithoutWell = 0;
                    }
                    
                    // Check if we have enough wells
                    let wellShortage = Math.max(0, wellsNeeded - totalWellCount);
                    
                    if(wellShortage > 0 && totalWellCount > 0) {
                        // Has wells but not enough - only people WITHOUT water die
                        // Each well supports 100 people, so calculate how many lack water
                        let waterCapacity = totalWellCount * 100;
                        let peopleWithoutWater = Math.max(0, this.pop - waterCapacity);
                        
                        // Only 20% of those without water die each year (gives time to build more)
                        let waterDeaths = Math.ceil(peopleWithoutWater * 0.20);
                        this.pop = Math.max(1, this.pop - waterDeaths);
                        
                        if(waterDeaths > 0) {
                            Controller.toast(`ğŸ’§ Water shortage! ${waterDeaths} died. Have ${totalWellCount} wells (${waterCapacity} capacity), need ${wellsNeeded} for ${this.pop} people.`);
                        }
                        
                        if(this.pop <= 0) {
                            Controller.showGameOver('NO_WATER');
                            return;
                        }
                    } else if(totalWellCount > 0 && Math.random() < 0.05) {
                        // Rare reminder that water is fine
                        Controller.toast(`ğŸ’§ Water OK: ${totalWellCount} wells serving ${this.pop} people.`);
                    }
                    
                    // GAME OVER: No food or no population = instant death
                    if(this.food <= 0 && this.pop > 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    if(this.pop <= 0) {
                        Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                        return;
                    }
                    
                    // 5. GROWTH LOGIC (Only if surplus exists AND under capacity)
                    else if(this.food > eaten * 1.5 && this.pop < housingCap) {
                        // Slow, realistic growth - 5% per year if well-fed
                        let growth = Math.max(1, Math.ceil(this.pop * 0.05));
                        this.pop = Math.min(this.pop + growth, housingCap);
                        if(growth > 1 && Math.random() < 0.3) {
                            Controller.toast(`ğŸ‘¶ ${growth} new tribe members born!`);
                        }
                    }
                    
                    // 6. CAPACITY WARNINGS
                    let industrialCapacity = industrialCount * CFG.PRODUCTION.INDUSTRIAL_SUPPORTS_POPULATION;
                    if(this.pop > industrialCapacity && industrialCount > 0) {
                        Controller.toast(`âš ï¸ Need more Hunting Grounds! (${industrialCount} supports ${industrialCapacity} pop)`);
                    }
                    
                    // YEARLY NEEDS ANNOUNCEMENT - Tell player what's missing
                    let announcement = this.generateNeedsAnnouncement();
                    if(announcement) {
                        Controller.toast(announcement);
                    }
                    
                    // Check for industrial unlock
                    this.checkProgression();
                }
                
                // FINAL GAME OVER CHECK - Catch any edge cases where pop reaches 0
                if(this.pop <= 0) {
                    Controller.showGameOver(this.getGameOverReason('LEVEL1'));
                    return;
                }
                
                this.recalc();
                Controller.updateUI();
                } catch(error) {
                    console.error('Error in endTurn:', error);
                    Controller.toast('Error processing turn!');
                }
            },
            toggleOrdinance() {
                if (this.ordinance) return;
                if (this.res < CFG.COST.ORD) return Controller.toast("Need Funds");
                this.res -= CFG.COST.ORD; this.ordinance = true; this.ordEnd = this.year + 20;
                Controller.toast("Act Enacted"); Controller.updateUI();
            }
        };

        const Controller = {
            cam: { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM }, 
            mx: 0, my: 0, tool: 'PAN', drag: false, last: {x:0, y:0},
            selectedBuildingLevel: 1, // Default to Level 1 Settlement (first buildable level)
            shiftHeld: false, // Track shift key for diagonal road drawing
            
            // Format numbers with M/B/T/Q suffixes
            formatNum(num) {
                if(num >= 1000000000000000) return (num/1000000000000000).toFixed(1) + 'Q'; // Quadrillion
                if(num >= 1000000000000) return (num/1000000000000).toFixed(1) + 'T'; // Trillion
                if(num >= 1000000000) return (num/1000000000).toFixed(1) + 'B'; // Billion
                if(num >= 1000000) return (num/1000000).toFixed(1) + 'M'; // Million
                if(num >= 1000) return (num/1000).toFixed(1) + 'K'; // Thousand
                return num.toString();
            },
            
            init() {
                // Capture console logs to technical log
                this.captureConsoleLogs();
                
                try {
                    console.log('Initializing Renderer...');
                    Renderer.init(); 
                    console.log('Initializing Game...');
                    Game.init(123);
                    console.log('Game initialized successfully');
                    // DELAY RENDER TO PREVENT 0-WIDTH BUG
                    setTimeout(() => {
                        console.log('Starting render loop...');
                        Renderer.resize();
                        let c = Renderer.cvs;
                        
                        // Keyboard controls for player movement (always available)
                        window.onkeydown = (e) => {
                            // Track shift key for diagonal road drawing
                            if(e.key === 'Shift') Controller.shiftHeld = true;
                            
                            // DEBUG: Press 'B' to test build residential at player position
                            if(e.key === 'b' || e.key === 'B') {
                                if(Game.gameState === 'CITY' && Game.player) {
                                    console.log('=== DEBUG BUILD TEST ===');
                                    console.log('Attempting to build at player position:', Game.player.x, Game.player.y);
                                    console.log('Current tool:', this.tool);
                                    console.log('Selected level:', this.selectedBuildingLevel);
                                    Game.build('RES', Game.player.x, Game.player.y);
                                    e.preventDefault();
                                    return;
                                }
                            }
                            
                            // Settle shortcut (only in WANDER mode)
                            if((e.key === 'Enter' || e.key === ' ') && Game.gameState === 'WANDER') { 
                                Game.settleHere(); 
                                e.preventDefault(); 
                                return;
                            }
                            
                            if(e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') { Game.movePlayer(0, -1); e.preventDefault(); }
                            else if(e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') { Game.movePlayer(0, 1); e.preventDefault(); }
                            else if(e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') { Game.movePlayer(-1, 0); e.preventDefault(); }
                            else if(e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') { Game.movePlayer(1, 0); e.preventDefault(); }
                            // Diagonals
                            else if(e.key === 'q' || e.key === 'Q') { Game.movePlayer(-1, -1); e.preventDefault(); }
                            else if(e.key === 'e' || e.key === 'E') { Game.movePlayer(1, -1); e.preventDefault(); }
                            else if(e.key === 'z' || e.key === 'Z') { Game.movePlayer(-1, 1); e.preventDefault(); }
                            else if(e.key === 'c' || e.key === 'C') { Game.movePlayer(1, 1); e.preventDefault(); }
                        };
                        
                        // Track shift key release for diagonal road drawing
                        window.onkeyup = (e) => {
                            if(e.key === 'Shift') Controller.shiftHeld = false;
                        };
                        
                        c.onmousedown=e=>{ 
                            // Check if click is on a UI element - don't build behind menus!
                            if(e.target !== c) {
                                return; // Click was on a UI element, not the canvas
                            }
                            
                            // Check if any menu panels are open - don't click through them
                            const menuPanels = ['building-menu-panel', 'industrial-menu-panel', 'commercial-menu-panel', 'storage-menu-panel', 'special-menu-panel', 'road-menu-panel', 'milestone-menu-panel'];
                            for(let panelId of menuPanels) {
                                let panel = document.getElementById(panelId);
                                if(panel && panel.style.display !== 'none' && panel.style.display !== '') {
                                    // A menu is open - check if click is within viewport area covered by menu
                                    let rect = panel.getBoundingClientRect();
                                    if(e.clientX >= rect.left && e.clientX <= rect.right && 
                                       e.clientY >= rect.top && e.clientY <= rect.bottom) {
                                        return; // Click is on the menu, don't process
                                    }
                                }
                            }
                            
                            // Left click: build if tool selected, otherwise move/attack
                            if (e.button==0) {
                                console.log('Mouse down - Tool:', this.tool, 'Position:', this.mx, this.my);
                                if(this.tool !== 'NONE' && this.tool !== 'PAN') {
                                    // Building mode - available once settled
                                    console.log('Building mode detected, calling click()');
                                    this.click();
                                } else {
                                    // Click to move player or attack animals (works in both WANDER and CITY modes)
                                    if(Game.player) {
                                        // Check if clicking on an animal - instant kill
                                        let animalIndex = Game.animals.findIndex(a => a.x === this.mx && a.y === this.my);
                                        if(animalIndex !== -1) {
                                            // Trigger bash animation
                                            if(Game.player) Game.player.bashTime = performance.now();
                                            
                                            // Move to animal position
                                            Game.movePlayerToTile(this.mx, this.my);
                                            
                                            let animal = Game.animals[animalIndex];
                                            let config = CFG.ANIMALS.TYPES.find(a => a.name === animal.type);
                                            let animalName = animal.type.charAt(0) + animal.type.slice(1).toLowerCase();
                                            
                                            // HERD DANGER: Check if other animals are on same tile or adjacent
                                            let nearbyAnimals = Game.animals.filter((a, idx) => {
                                                if(idx === animalIndex) return false; // Skip self
                                                let dx = Math.abs(a.x - animal.x);
                                                let dy = Math.abs(a.y - animal.y);
                                                return dx <= 1 && dy <= 1; // Same tile or adjacent
                                            });
                                            
                                            let isHerd = nearbyAnimals.length > 0;
                                            let herdDamage = 0;
                                            
                                            if(isHerd && Game.gameState === 'WANDER') {
                                                // Herd attack - costs 1-3 population
                                                herdDamage = 1 + Math.floor(Math.random() * 3); // 1, 2, or 3
                                                Game.pop = Math.max(0, Game.pop - herdDamage);
                                                Controller.toast(`âš ï¸ Attacked by herd! Lost ${herdDamage} population! (${Game.pop} remaining)`);
                                                
                                                if(Game.pop === 0) {
                                                    Controller.toast("ğŸ’€ Your tribe has perished!");
                                                    // Game over logic could go here
                                                    Controller.updateUI();
                                                    return;
                                                }
                                            }
                                            
                                            if(Game.gameState === 'WANDER') {
                                                let totalInventory = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                                                let spaceAvailable = Game.inventory.capacity - totalInventory;
                                                
                                                // Build message with herd context
                                                let herdMsg = isHerd ? ` (Herd cost: ${herdDamage} pop)` : ' (Safe hunt!)';
                                                
                                                if(spaceAvailable >= config.foodReward) {
                                                    Game.inventory.food += config.foodReward;
                                                    Game.totalFoodCollected += config.foodReward;
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! +${config.foodReward} Food${herdMsg} ğŸ–`);
                                                } else if(spaceAvailable > 0) {
                                                    Game.inventory.food += spaceAvailable;
                                                    Game.totalFoodCollected += spaceAvailable;
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! +${spaceAvailable}/${config.foodReward} Food${herdMsg}`);
                                                } else {
                                                    Controller.toast(`ğŸ¯ ${animalName} killed! Food lost - Inventory Full!${herdMsg}`);
                                                }
                                            } else {
                                                Game.food += config.foodReward;
                                                Controller.toast(`ğŸ¯ ${animalName} killed! +${config.foodReward} Food ğŸ–`);
                                            }
                                            
                                            Game.animals.splice(animalIndex, 1);
                                            Game.checkProgression();
                                            Controller.updateUI();
                                        } else {
                                            // Normal movement
                                            Game.movePlayerToTile(this.mx, this.my);
                                        }
                                    }
                                }
                            }
                            // Middle click or right click: pan camera
                            else if(e.button==1 || e.button==2) {
                                this.drag=true; 
                                this.last={x:e.clientX, y:e.clientY}; 
                                document.body.style.cursor='grabbing';
                            }
                        };
                        window.onmouseup=()=>{ this.drag=false; document.body.style.cursor='default'; };
                        window.onmousemove=e=>{
                            if (this.drag) {
                                this.cam.x -= (e.clientX-this.last.x)/this.cam.z; this.cam.y -= (e.clientY-this.last.y)/this.cam.z;
                                this.cam.x = Math.max(0, Math.min(6400, this.cam.x)); this.cam.y = Math.max(0, Math.min(6400, this.cam.y));
                                this.last={x:e.clientX, y:e.clientY};
                            }
                            let r=c.getBoundingClientRect();
                            let wx=(e.clientX-r.left-Renderer.w/2)/this.cam.z+this.cam.x; let wy=(e.clientY-r.top-Renderer.h/2)/this.cam.z+this.cam.y;
                            this.mx=Math.floor(wx/CFG.TILE); this.my=Math.floor(wy/CFG.TILE);
                            document.getElementById('debug').innerText=`Pos: ${this.mx}, ${this.my}`;
                        };
                        c.onwheel=e=>{ e.preventDefault(); let f=e.deltaY<0?CFG.ZOOM.STEP:1/CFG.ZOOM.STEP; this.cam.z=Math.max(CFG.ZOOM.MIN, Math.min(CFG.ZOOM.MAX, this.cam.z*f)); }, {passive:false};
                        const loop=()=> { 
                            try {
                                // Process player pathfinding automatically
                                if(Game.pathQueue && Game.pathQueue.length > 0) {
                                    Game.processPath();
                                }
                                
                                // AI autoplay
                                Game.aiUpdate();
                                
                                // Update building evolution states (every 60 frames = ~1 second)
                                Game.updateBuildingEvolution();
                                
                                // Render
                                Renderer.draw(this.cam);
                            } catch(err) {
                                console.error('Game loop error:', err);
                                // Continue running even if there's an error
                            }
                            requestAnimationFrame(loop); 
                        }; 
                        console.log('Starting animation loop...');
                        loop();
                    }, 200);
                } catch(e){
                    console.error('Initialization error:', e);
                    Controller.toast('ERROR: ' + e.message);
                }
            },
            click() {
                let gx=this.mx, gy=this.my;
                console.log('Click handler - Tool:', this.tool, 'Position:', gx, gy);
                if (this.tool!='NONE' && this.tool!='PAN') {
                    // Auto-settle UX: If trying to build Residential while still in WANDER, attempt to settle
                    if (this.tool === 'RES' && typeof Game !== 'undefined' && Game.gameState !== 'CITY') {
                        console.log('Attempting auto-settle before building RES...');
                        Controller.toast('ğŸ›ï¸ Settling so you can build...');
                        if (typeof Game.settleHere === 'function') {
                            Game.settleHere();
                            // If settlement succeeded, proceed to build
                            if (Game.gameState === 'CITY') {
                                console.log('Auto-settle succeeded, placing RES');
                                Game.build(this.tool, gx, gy);
                            } else {
                                console.log('Auto-settle failed due to requirements');
                                Controller.toast('âš ï¸ Settle first: Need water nearby + basic resources');
                            }
                            return;
                        }
                    }
                    console.log('Calling Game.build with:', this.tool, gx, gy);
                    Game.build(this.tool, gx, gy);
                } else {
                    console.log('Tool is NONE or PAN, not building');
                }
            },
            setTool(t) { 
                // Check if button is disabled
                let btnId = 't-' + t.toLowerCase();
                let btn = document.getElementById(btnId);
                if(btn && btn.disabled) {
                    Controller.toast(btn.title || 'ğŸ”’ This building is locked');
                    return;
                }
                
                // Reset diagonal road tracking when switching tools
                if(t !== 'ROAD' && typeof Game !== 'undefined') {
                    Game.lastRoadPos = null;
                }
                
                this.tool=t; 
                document.querySelectorAll('.build-btn').forEach(b => b.classList.remove('active')); 
                let b=document.getElementById('b-'+t.toLowerCase()); 
                if(b) b.classList.add('active'); 
            },
            openBuildingMenu() {
                console.log('=== openBuildingMenu called ===');
                // Set default selection to Level 1 (first buildable level)
                if(this.selectedBuildingLevel === undefined || this.selectedBuildingLevel === 0) {
                    this.selectedBuildingLevel = 1;
                }
                
                // Dynamically generate building cards from BUILDING_DB
                let grid = document.getElementById('building-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('RESIDENTIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedLevels.includes(levelNum);
                    let isSelected = this.selectedBuildingLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'ğŸ ';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectBuildingLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    
                    // Show unlock requirements if locked
                    let unlockText = '';
                    if(!isUnlocked && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(Controller.formatNum(req.pop) + ' pop');
                        if(req.buildings) {
                            parts.push(req.buildings.count + 'x ' + req.buildings.type + ' L' + req.buildings.level);
                        }
                        unlockText = 'ğŸ”’ ' + parts.join(' + ');
                        costText = unlockText;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${icon}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">Cap: ${Controller.formatNum(building.capacity)}</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('building-menu-panel').style.display = 'block';
            },
            closeBuildingMenu() {
                document.getElementById('building-menu-panel').style.display = 'none';
            },
            
            // Industrial menu functions
            openIndustrialMenu() {
                console.log('=== openIndustrialMenu called ===');
                // Set default selection to Level 1
                if(this.selectedIndustrialLevel === undefined || this.selectedIndustrialLevel === 0) {
                    this.selectedIndustrialLevel = 1;
                }
                
                // Dynamically generate industrial cards from BUILDING_DB
                let grid = document.getElementById('industrial-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('INDUSTRIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedIndustrialLevels.includes(levelNum);
                    let isSelected = this.selectedIndustrialLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'ğŸ­';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-ind-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.onclick = () => this.selectIndustrialLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    if(!isUnlocked) {
                        const info = PROGRESSION.getIndustrialUnlockInfo(levelNum, Game);
                        costText = info.text;
                    }
                    
                    card.innerHTML = `
                        <div class="level-number">L${levelNum}</div>
                        <div class="level-icon">${icon}</div>
                        <div class="level-name">${building.name}</div>
                        <div class="level-stats">Cap: ${building.capacity} workers</div>
                        <div class="level-cost">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('industrial-menu-panel').style.display = 'block';
            },
            closeIndustrialMenu() {
                document.getElementById('industrial-menu-panel').style.display = 'none';
            },
            selectIndustrialLevel(level) {
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.selectedIndustrialLevel = level;
                
                // Update card styling
                document.querySelectorAll('#industrial-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                });
                let card = document.getElementById('card-ind-level-' + level);
                if(card) card.classList.add('selected');
                
                Controller.toast(`Selected: ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            confirmIndustrialSelection() {
                let level = this.selectedIndustrialLevel || 1;
                if(!PROGRESSION.unlockedIndustrialLevels.includes(level)) {
                    const info = PROGRESSION.getIndustrialUnlockInfo(level, Game);
                    Controller.toast(info.text);
                    return;
                }
                this.closeIndustrialMenu();
                this.setTool('IND');
                Controller.toast(`ğŸ­ Click to place ${CFG.INDUSTRIAL_LEVELS[level].name}`);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // COMMERCIAL MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedCommercialLevel: 1,
            
            openCommercialMenu() {
                console.log('=== openCommercialMenu called ===');
                // Set default selection to Level 1
                if(this.selectedCommercialLevel === undefined || this.selectedCommercialLevel === 0) {
                    this.selectedCommercialLevel = 1;
                }
                
                // Dynamically generate commercial cards from BUILDING_DB
                let grid = document.getElementById('commercial-level-grid');
                grid.innerHTML = '';
                
                let buildings = CFG.getBuildingsByCategory('COMMERCIAL');
                for(let i = 0; i < buildings.length; i++) {
                    let building = buildings[i];
                    let levelNum = building.level;
                    
                    let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(levelNum) : (levelNum === 1);
                    let isSelected = this.selectedCommercialLevel === levelNum;
                    let icon = building.variants ? building.variants[building.variants.length - 1].icon : 'ğŸª';
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked ? ' level-locked' : '');
                    card.id = 'card-com-level-' + levelNum;
                    card.setAttribute('data-building-id', building.id);
                    card.style.cssText = 'background:#2a2a4a; border:2px solid ' + (isSelected ? '#4a9eff' : '#444') + '; border-radius:8px; padding:10px; cursor:pointer; text-align:center;';
                    card.onclick = () => this.selectCommercialLevel(levelNum);
                    
                    let costText = Controller.formatNum(building.cost.food) + ' F + ' + Controller.formatNum(building.cost.wood) + ' W';
                    if(building.cost.stone > 0) costText += ' + ' + Controller.formatNum(building.cost.stone) + ' S';
                    if(building.cost.metal > 0) costText += ' + ' + Controller.formatNum(building.cost.metal) + ' M';
                    if(!isUnlocked) {
                        costText = 'ğŸ”’ Locked';
                    }
                    
                    card.innerHTML = `
                        <div style="font-size:10px; color:#888;">L${levelNum}</div>
                        <div style="font-size:28px;">${icon}</div>
                        <div style="font-size:12px; font-weight:bold; color:#4a9eff;">${building.name}</div>
                        <div style="font-size:10px; color:#888;">Cap: ${building.capacity} workers</div>
                        <div style="font-size:9px; color:#666;">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('commercial-menu-panel').style.display = 'block';
            },
            closeCommercialMenu() {
                document.getElementById('commercial-menu-panel').style.display = 'none';
            },
            selectCommercialLevel(level) {
                let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(level) : (level === 1);
                if(!isUnlocked) {
                    Controller.toast('ğŸ”’ Locked! Build more residential first.');
                    return;
                }
                this.selectedCommercialLevel = level;
                
                // Update card styling
                document.querySelectorAll('#commercial-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-com-level-' + level);
                if(card) {
                    card.classList.add('selected');
                    card.style.borderColor = '#4a9eff';
                }
                
                let building = CFG.getBuilding('COM_' + level);
                Controller.toast(`Selected: ${building ? building.name : 'Commercial L' + level}`);
            },
            confirmCommercialSelection() {
                let level = this.selectedCommercialLevel || 1;
                let isUnlocked = PROGRESSION.unlockedCommercialLevels ? PROGRESSION.unlockedCommercialLevels.includes(level) : (level === 1);
                if(!isUnlocked) {
                    Controller.toast('ğŸ”’ Locked! Build more residential first.');
                    return;
                }
                this.closeCommercialMenu();
                this.setTool('COM');
                let building = CFG.getBuilding('COM_' + level);
                Controller.toast(`ğŸª Click to place ${building ? building.name : 'Commercial'}`);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STORAGE MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedStoragePit: 'FOOD_PIT',
            
            openStorageMenu() {
                console.log('=== openStorageMenu called ===');
                this.selectedStoragePit = 'FOOD_PIT';
                
                // Dynamically generate storage pit cards
                let grid = document.getElementById('storage-level-grid');
                grid.innerHTML = '';
                
                const pits = CFG.STORAGE_PITS;
                const pitKeys = ['FOOD_PIT', 'WOOD_PIT', 'STONE_PIT', 'METAL_PIT'];
                const resourceColors = {
                    'FOOD_PIT': '#4CAF50',
                    'WOOD_PIT': '#8B4513',
                    'STONE_PIT': '#808080',
                    'METAL_PIT': '#FFD700'
                };
                
                for(let key of pitKeys) {
                    let pit = pits[key];
                    let isSelected = this.selectedStoragePit === key;
                    let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!canAfford ? ' level-locked' : '');
                    card.id = 'card-storage-' + key;
                    card.style.cssText = 'background:#2a2a4a; border:2px solid ' + (isSelected ? resourceColors[key] : '#444') + '; border-radius:8px; padding:15px; cursor:pointer; text-align:center;';
                    card.onclick = () => this.selectStoragePit(key);
                    
                    let costText = `${Controller.formatNum(pit.food)} ğŸ– + ${Controller.formatNum(pit.wood)} ğŸªµ + ${pit.stone} ğŸª¨`;
                    
                    card.innerHTML = `
                        <div style="font-size:36px;">${pit.icon}</div>
                        <div style="font-size:14px; font-weight:bold; color:${resourceColors[key]};">${pit.desc}</div>
                        <div style="font-size:12px; color:#4CAF50; margin:5px 0;">+${Controller.formatNum(pit.cap)} ${pit.resource} storage</div>
                        <div style="font-size:10px; color:${canAfford ? '#888' : '#f44336'};">${costText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('storage-menu-panel').style.display = 'block';
            },
            closeStorageMenu() {
                document.getElementById('storage-menu-panel').style.display = 'none';
            },
            selectStoragePit(pitKey) {
                let pit = CFG.STORAGE_PITS[pitKey];
                let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                
                if(!canAfford) {
                    Controller.toast(`âŒ Need ${Controller.formatNum(pit.food)} food, ${Controller.formatNum(pit.wood)} wood, ${pit.stone} stone`);
                    return;
                }
                
                this.selectedStoragePit = pitKey;
                
                // Update card styling
                const resourceColors = {
                    'FOOD_PIT': '#4CAF50',
                    'WOOD_PIT': '#8B4513',
                    'STONE_PIT': '#808080',
                    'METAL_PIT': '#FFD700'
                };
                
                document.querySelectorAll('#storage-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-storage-' + pitKey);
                if(card) {
                    card.classList.add('selected');
                    card.style.borderColor = resourceColors[pitKey];
                }
                
                Controller.toast(`Selected: ${pit.desc}`);
            },
            confirmStorageSelection() {
                let pitKey = this.selectedStoragePit || 'FOOD_PIT';
                let pit = CFG.STORAGE_PITS[pitKey];
                
                let canAfford = Game.food >= pit.food && Game.wood >= pit.wood && Game.stone >= pit.stone;
                if(!canAfford) {
                    Controller.toast(`âŒ Need ${Controller.formatNum(pit.food)} food, ${Controller.formatNum(pit.wood)} wood, ${pit.stone} stone`);
                    return;
                }
                
                this.closeStorageMenu();
                this.setTool(pitKey);
                Controller.toast(`ğŸ•³ï¸ Click to place ${pit.desc}`);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SPECIAL BUILDINGS MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedSpecialBuilding: 'CHIEF',
            
            openSpecialMenu() {
                console.log('=== openSpecialMenu called ===');
                this.selectedSpecialBuilding = 'CHIEF';
                
                // Dynamically generate special building cards
                let grid = document.getElementById('special-level-grid');
                grid.innerHTML = '';
                
                // Define special buildings with their requirements
                const specialBuildings = [
                    {
                        id: 'CHIEF',
                        name: "Chief's Hut",
                        icon: 'ğŸ›ï¸',
                        desc: '+50% bonus to all buildings within radius',
                        cost: { food: CFG.CHIEF_COST || 10000, wood: 0 },
                        unlockReq: { hasCommercial: true },
                        unlockText: 'Build a campfire first'
                    },
                    {
                        id: 'DOCK',
                        name: 'Trading Dock',
                        icon: 'âš“',
                        desc: '+5% output when connected to water',
                        cost: { food: 10000, wood: 100000 },
                        unlockReq: { pop: 500 },
                        unlockText: 'Need 500 population'
                    },
                    {
                        id: 'GRANARY',
                        name: 'Granary',
                        icon: 'ğŸ›ï¸',
                        desc: 'Reduces food decay by 50%',
                        cost: { food: 5000, wood: 5000 },
                        unlockReq: { pop: 100 },
                        unlockText: 'Need 100 population'
                    },
                    {
                        id: 'MONUMENT',
                        name: 'Stone Monument',
                        icon: 'ğŸ—¿',
                        desc: '+100% population happiness',
                        cost: { food: 25000, wood: 10000, stone: 5000 },
                        unlockReq: { pop: 1000 },
                        unlockText: 'Need 1000 population'
                    }
                ];
                
                for(let building of specialBuildings) {
                    let isSelected = this.selectedSpecialBuilding === building.id;
                    let canAfford = Game.food >= building.cost.food && Game.wood >= (building.cost.wood || 0);
                    
                    // Check unlock requirements
                    let isUnlocked = true;
                    let unlockReason = '';
                    if(building.unlockReq.hasCommercial) {
                        let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                        isUnlocked = comCount > 0;
                        unlockReason = building.unlockText;
                    }
                    if(building.unlockReq.pop) {
                        isUnlocked = (Game.pop || 0) >= building.unlockReq.pop;
                        unlockReason = building.unlockText;
                    }
                    
                    let card = document.createElement('div');
                    card.className = 'level-card' + (isSelected ? ' selected' : '') + (!isUnlocked || !canAfford ? ' level-locked' : '');
                    card.id = 'card-special-' + building.id;
                    card.style.cssText = 'background:#2a2a4a; border:2px solid ' + (isSelected ? '#FFD700' : '#444') + '; border-radius:8px; padding:15px; cursor:pointer; text-align:center;';
                    card.onclick = () => this.selectSpecialBuilding(building.id);
                    
                    let costText = `${Controller.formatNum(building.cost.food)} ğŸ–`;
                    if(building.cost.wood) costText += ` + ${Controller.formatNum(building.cost.wood)} ğŸªµ`;
                    if(building.cost.stone) costText += ` + ${Controller.formatNum(building.cost.stone)} ğŸª¨`;
                    
                    let statusText = !isUnlocked ? `ğŸ”’ ${unlockReason}` : (!canAfford ? 'âŒ Cannot afford' : 'âœ… Available');
                    let statusColor = !isUnlocked ? '#888' : (!canAfford ? '#f44336' : '#4CAF50');
                    
                    card.innerHTML = `
                        <div style="font-size:36px;">${building.icon}</div>
                        <div style="font-size:14px; font-weight:bold; color:#FFD700;">${building.name}</div>
                        <div style="font-size:11px; color:#aaa; margin:5px 0;">${building.desc}</div>
                        <div style="font-size:10px; color:#888;">${costText}</div>
                        <div style="font-size:10px; color:${statusColor}; margin-top:5px;">${statusText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('special-menu-panel').style.display = 'block';
            },
            closeSpecialMenu() {
                document.getElementById('special-menu-panel').style.display = 'none';
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MILESTONE BUILDINGS MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedMilestoneBuilding: 'CLAN_CHIEF',
            
            openMilestoneMenu() {
                console.log('=== openMilestoneMenu called ===');
                this.selectedMilestoneBuilding = 'CLAN_CHIEF';
                
                // Update resource displays
                let metalEl = document.getElementById('milestone-metal-display');
                let goldEl = document.getElementById('milestone-gold-display');
                if(metalEl) metalEl.textContent = Controller.formatNum((Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0));
                if(goldEl) goldEl.textContent = Game.gold || 0;
                
                // Dynamically generate milestone building cards
                let grid = document.getElementById('milestone-level-grid');
                grid.innerHTML = '';
                
                const milestoneBuildings = [
                    {
                        id: 'CLAN_CHIEF',
                        name: "Clan Chief's Hut",
                        icon: 'ğŸ›ï¸',
                        desc: 'Unlocks Level 4-6 buildings. The seat of power for your clan.',
                        cost: { food: 100000, wood: 100000, gold: 1 },
                        size: '2x2',
                        unlocked: !Game.hasClanChief,
                        built: Game.hasClanChief,
                        requires: 'Pop 500+'
                    },
                    {
                        id: 'DOCK',
                        name: 'Trading Dock',
                        icon: 'âš“',
                        desc: 'Unlocks Level 7+ buildings. A major port for trade.',
                        cost: { food: 500000, wood: 500000, gold: 5 },
                        size: '3x2',
                        unlocked: Game.hasClanChief && !Game.hasDock,
                        built: Game.hasDock,
                        requires: 'Clan Chief\'s Hut'
                    }
                ];
                
                for(let building of milestoneBuildings) {
                    let isSelected = this.selectedMilestoneBuilding === building.id;
                    let canAfford = Game.food >= building.cost.food && 
                                   Game.wood >= building.cost.wood && 
                                   (Game.gold || 0) >= building.cost.gold;
                    
                    let card = document.createElement('div');
                    let statusClass = building.built ? 'level-locked' : (!building.unlocked ? 'level-locked' : (isSelected ? ' selected' : ''));
                    card.className = 'level-card ' + statusClass;
                    card.id = 'card-milestone-' + building.id;
                    card.style.cssText = 'background:#2a2a4a; border:2px solid ' + (building.built ? '#4CAF50' : (isSelected ? '#FFD700' : '#444')) + '; border-radius:8px; padding:15px; cursor:pointer; text-align:center;';
                    if(!building.built && building.unlocked) {
                        card.onclick = () => this.selectMilestoneBuilding(building.id);
                    }
                    
                    let costText = `${Controller.formatNum(building.cost.food)} ğŸ– + ${Controller.formatNum(building.cost.wood)} ğŸªµ + ${building.cost.gold} ğŸ’°`;
                    
                    let statusText = building.built ? 'âœ… Already Built' : 
                                    (!building.unlocked ? 'ğŸ”’ ' + building.requires : 
                                    (!canAfford ? 'âŒ Cannot afford' : 'âœ… Available'));
                    let statusColor = building.built ? '#4CAF50' : (!building.unlocked ? '#888' : (!canAfford ? '#f44336' : '#4CAF50'));
                    
                    card.innerHTML = `
                        <div style="font-size:42px;">${building.icon}</div>
                        <div style="font-size:16px; font-weight:bold; color:#FFD700;">${building.name}</div>
                        <div style="font-size:10px; color:#888; margin:3px 0;">Size: ${building.size}</div>
                        <div style="font-size:11px; color:#aaa; margin:5px 0;">${building.desc}</div>
                        <div style="font-size:11px; color:#ddd; margin:5px 0;">${costText}</div>
                        <div style="font-size:11px; color:${statusColor}; margin-top:5px;">${statusText}</div>
                    `;
                    grid.appendChild(card);
                }
                
                document.getElementById('milestone-menu-panel').style.display = 'block';
            },
            closeMilestoneMenu() {
                document.getElementById('milestone-menu-panel').style.display = 'none';
            },
            selectMilestoneBuilding(buildingId) {
                this.selectedMilestoneBuilding = buildingId;
                
                // Update card styling
                document.querySelectorAll('#milestone-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-milestone-' + buildingId);
                if(card && !card.classList.contains('level-locked')) {
                    card.classList.add('selected');
                    card.style.borderColor = '#FFD700';
                }
            },
            confirmMilestoneSelection() {
                let buildingId = this.selectedMilestoneBuilding;
                let config = CFG.BUILDING_DB[buildingId];
                
                if(!config) {
                    Controller.toast('âŒ Invalid building selection');
                    return;
                }
                
                // Check if already built
                if(buildingId === 'CLAN_CHIEF' && Game.hasClanChief) {
                    Controller.toast('âœ… Clan Chief\'s Hut already built!');
                    return;
                }
                if(buildingId === 'DOCK' && Game.hasDock) {
                    Controller.toast('âœ… Trading Dock already built!');
                    return;
                }
                
                // Check prerequisites
                if(buildingId === 'DOCK' && !Game.hasClanChief) {
                    Controller.toast('ğŸ”’ Build Clan Chief\'s Hut first!');
                    return;
                }
                
                // Check resources
                let cost = config.cost;
                if(Game.food < cost.food) {
                    Controller.toast(`âŒ Need ${Controller.formatNum(cost.food)} food (have ${Controller.formatNum(Game.food)})`);
                    return;
                }
                if(Game.wood < cost.wood) {
                    Controller.toast(`âŒ Need ${Controller.formatNum(cost.wood)} wood (have ${Controller.formatNum(Game.wood)})`);
                    return;
                }
                if((Game.gold || 0) < cost.gold) {
                    Controller.toast(`âŒ Need ${cost.gold} gold (have ${Game.gold || 0})`);
                    return;
                }
                
                this.closeMilestoneMenu();
                this.setTool(buildingId);
                Controller.toast(`ğŸ›ï¸ Click to place ${config.name}`);
            },
            exchangeGold() {
                let metalNeeded = CFG.GOLD_EXCHANGE_RATE || 5000;
                let totalMetal = (Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0);
                
                if(totalMetal < metalNeeded) {
                    Controller.toast(`âŒ Need ${Controller.formatNum(metalNeeded)} metal to exchange (have ${Controller.formatNum(totalMetal)})`);
                    return;
                }
                
                // Deduct from pocket first, then main inventory
                let remaining = metalNeeded;
                if(Game.pocket && Game.pocket.metal > 0) {
                    let fromPocket = Math.min(Game.pocket.metal, remaining);
                    Game.pocket.metal -= fromPocket;
                    remaining -= fromPocket;
                }
                if(remaining > 0) {
                    Game.metal = (Game.metal || 0) - remaining;
                }
                
                Game.gold = (Game.gold || 0) + 1;
                
                Controller.toast(`ğŸ’° Exchanged ${Controller.formatNum(metalNeeded)} metal for 1 gold! Total gold: ${Game.gold}`);
                
                // Update displays if milestone menu is open
                let metalEl = document.getElementById('milestone-metal-display');
                let goldEl = document.getElementById('milestone-gold-display');
                if(metalEl) metalEl.textContent = Controller.formatNum((Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0));
                if(goldEl) goldEl.textContent = Game.gold || 0;
                
                // Refresh the menu if open
                if(document.getElementById('milestone-menu-panel').style.display !== 'none') {
                    this.openMilestoneMenu();
                }
            },
            
            selectSpecialBuilding(buildingId) {
                this.selectedSpecialBuilding = buildingId;
                
                // Update card styling
                document.querySelectorAll('#special-level-grid .level-card').forEach(card => {
                    card.classList.remove('selected');
                    card.style.borderColor = '#444';
                });
                let card = document.getElementById('card-special-' + buildingId);
                if(card) {
                    card.classList.add('selected');
                    card.style.borderColor = '#FFD700';
                }
            },
            confirmSpecialSelection() {
                let buildingId = this.selectedSpecialBuilding || 'CHIEF';
                
                // Check unlock requirements
                if(buildingId === 'CHIEF') {
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    if(comCount === 0) {
                        Controller.toast('ğŸ”’ Build a campfire (commercial) first!');
                        return;
                    }
                    if(Game.food < (CFG.CHIEF_COST || 10000)) {
                        Controller.toast(`âŒ Need ${Controller.formatNum(CFG.CHIEF_COST || 10000)} food`);
                        return;
                    }
                }
                
                this.closeSpecialMenu();
                this.setTool(buildingId);
                Controller.toast(`â­ Click to place special building`);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ROADS MENU FUNCTIONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            selectedRoadLevel: 1,
            
            openRoadMenu() {
                console.log('=== openRoadMenu called ===');
                this.selectedRoadLevel = 1;
                this.updateRoadUnlocks();
                document.getElementById('road-menu-panel').style.display = 'block';
            },
            closeRoadMenu() {
                document.getElementById('road-menu-panel').style.display = 'none';
            },
            updateRoadUnlocks() {
                // Only Path (level 1) is unlocked for now
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) {
                        card.classList.remove('selected');
                        if(i === 1) {
                            card.classList.remove('level-locked');
                        } else {
                            card.classList.add('level-locked');
                        }
                    }
                }
                let card1 = document.getElementById('card-road-1');
                if(card1) card1.classList.add('selected');
            },
            selectRoadLevel(level) {
                if(level !== 1) {
                    Controller.toast('ğŸ”’ Locked! Only Path is available.');
                    return;
                }
                for(let i = 1; i <= 4; i++) {
                    let card = document.getElementById('card-road-' + i);
                    if(card) card.classList.remove('selected');
                }
                let card = document.getElementById('card-road-' + level);
                if(card) card.classList.add('selected');
                this.selectedRoadLevel = level;
                Controller.toast('Selected: Path');
            },
            confirmRoadSelection() {
                this.closeRoadMenu();
                this.setTool('ROAD');
                Controller.toast('ğŸ›£ï¸ Click to place Path ($5)');
            },
            
            updateNeedsWarning() {
                // Only show in SimCity mode and if population is reasonable
                if(!Game.simcityMode || Game.pop < 5) {
                    document.getElementById('needs-warning-panel').style.display = 'none';
                    return;
                }
                
                let panel = document.getElementById('needs-warning-panel');
                let needsList = document.getElementById('needs-list');
                let satisfactionBar = document.getElementById('satisfaction-bar');
                
                let warnings = [];
                let colors = {
                    housing: '#FF6B6B',     // Red
                    water: '#4ECDC4',       // Teal
                    food: '#FFD93D',        // Yellow
                    jobs: '#6BCF7F',        // Green
                    paths: '#A78BFA'        // Purple
                };
                
                // Check each need
                if(Game.needs.housing.satisfied < 0.5) {
                    warnings.push(`ğŸ  Housing CRITICAL (${Game.needs.housing.shortage} homeless)`);
                } else if(Game.needs.housing.satisfied < 0.8) {
                    warnings.push(`ğŸ  Housing needed (${Game.needs.housing.shortage} shortage)`);
                }
                
                if(Game.needs.water.satisfied < 0.5 && Game.pop >= 10) {
                    warnings.push(`ğŸ’§ Water CRITICAL (need ${Game.needs.water.shortage} wells)`);
                } else if(Game.needs.water.satisfied < 0.8 && Game.pop >= 10) {
                    warnings.push(`ğŸ’§ Water needed (${Game.needs.water.shortage} wells)`);
                }
                
                if(Game.needs.food.satisfied < 0.3) {
                    warnings.push(`ğŸŒ¾ Food CRITICAL - reserves low!`);
                } else if(Game.needs.food.satisfied < 0.6) {
                    warnings.push(`ğŸŒ¾ Food low - build industry`);
                }
                
                if(Game.needs.jobs.satisfied < 0.7 && Game.pop > 20) {
                    warnings.push(`ğŸ’¼ Jobs needed (${Game.needs.jobs.shortage} unemployed)`);
                }
                
                if(Game.needs.paths.satisfied < 0.5 && Game.zoneCount > 3) {
                    warnings.push(`ğŸ›¤ï¸ Paths needed (${Game.needs.paths.shortage} tiles)`);
                }
                
                // If no warnings, show satisfaction message
                if(warnings.length === 0) {
                    needsList.innerHTML = `<span style="color: #6BCF7F;">âœ“ All needs met!</span>`;
                    panel.style.border = '2px solid #6BCF7F';
                    panel.style.boxShadow = '0 8px 25px rgba(107,207,127,0.3)';
                } else {
                    needsList.innerHTML = warnings.map(w => `<div>â€¢ ${w}</div>`).join('');
                    panel.style.border = '2px solid #FF6B6B';
                    panel.style.boxShadow = '0 8px 25px rgba(255,107,107,0.3)';
                }
                
                // Update satisfaction bar
                let satisfaction = Game.needs.overall || 1.0;
                let satPercent = Math.floor(satisfaction * 100);
                satisfactionBar.style.width = (satisfaction * 100) + '%';
                satisfactionBar.textContent = satPercent + '%';
                
                // Color code the bar
                if(satisfaction >= 0.8) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #6BCF7F 0%, #4CAF50 100%)';
                } else if(satisfaction >= 0.5) {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FFD93D 0%, #FFA726 100%)';
                } else {
                    satisfactionBar.style.background = 'linear-gradient(90deg, #FF6B6B 0%, #C62828 100%)';
                }
                
                panel.style.display = 'block';
            },
            updateBuildingUnlocks() {
                let pop = Game.pop;
                
                // Level 0 removed - WANDER epoch only, no building placement
                
                // Level 1 (Pit) - Always unlocked (first buildable level)
                let card1 = document.getElementById('card-level-1');
                card1.classList.remove('level-locked');
                card1.querySelector('.level-cost').textContent = 'Cost: 100 Food + 100 Wood';
                
                // Level 2 (Leather Tent) - Unlock at 50 pop
                let card2 = document.getElementById('card-level-2');
                if(pop >= 50) {
                    card2.classList.remove('level-locked');
                    card2.querySelector('.level-cost').textContent = 'Cost: 300 Food + 300 Wood';
                } else {
                    card2.classList.add('level-locked');
                    card2.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 50 Population';
                }
                
                // Level 3 (Mud Brick) - Unlock at 200 pop
                let card3 = document.getElementById('card-level-3');
                if(pop >= 200) {
                    card3.classList.remove('level-locked');
                    card3.querySelector('.level-cost').textContent = 'Cost: 900 Food + 900 Wood';
                } else {
                    card3.classList.add('level-locked');
                    card3.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 200 Population';
                }
                
                // Level 4 (Stone House) - Unlock at 500 pop
                let card4 = document.getElementById('card-level-4');
                if(pop >= 500) {
                    card4.classList.remove('level-locked');
                    card4.querySelector('.level-cost').textContent = 'Cost: 300 Food + 50 Wood + 100 Stone';
                } else {
                    card4.classList.add('level-locked');
                    card4.querySelector('.level-cost').textContent = 'ğŸ”’ Unlock at 500 Population';
                }
                
                // Auto-select highest unlocked level
                let highestUnlocked = 0;
                if(pop >= 500) highestUnlocked = 4;
                else if(pop >= 200) highestUnlocked = 3;
                else if(pop >= 50) highestUnlocked = 2;
                else if(pop >= 10) highestUnlocked = 1;
                
                // If current selection is locked, switch to highest unlocked
                if(this.selectedBuildingLevel > highestUnlocked) {
                    this.selectBuildingLevel(highestUnlocked);
                }
            },
            selectBuildingLevel(level) {
                // Check if this level is locked
                let card = document.getElementById('card-level-' + level);
                if(!card) {
                    console.error('Card not found for level:', level);
                    return;
                }
                if(card.classList.contains('level-locked')) {
                    // Get actual unlock requirements from BUILDING_DB
                    let building = CFG.BUILDING_DB['RES_' + level];
                    if(building && building.unlockReq) {
                        let req = building.unlockReq;
                        let parts = [];
                        if(req.pop) parts.push(`${Controller.formatNum(req.pop)} population`);
                        if(req.buildings) {
                            parts.push(`${req.buildings.count}x ${req.buildings.type} L${req.buildings.level}`);
                        }
                        Controller.toast(`ğŸ”’ Locked! Need: ${parts.join(' + ')}`);
                    } else {
                        Controller.toast(`ğŸ”’ This level is locked`);
                    }
                    return;
                }
                
                // Remove selected class from all cards (only levels 1-4 exist)
                for(let i = 1; i <= 4; i++) {
                    let c = document.getElementById('card-level-' + i);
                    if(c) c.classList.remove('selected');
                }
                // Add selected class to chosen card
                card.classList.add('selected');
                this.selectedBuildingLevel = level;
            },
            confirmBuildingSelection() {
                let levelConfig = CFG.BUILDING_LEVELS[this.selectedBuildingLevel];
                console.log('confirmBuildingSelection: Level', this.selectedBuildingLevel, 'Config:', levelConfig);
                this.closeBuildingMenu();
                this.tool = 'RES';
                console.log('Tool set to RES, current tool value:', this.tool);
                
                // Highlight the residential button to show it's active
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                let resBtn = document.getElementById('t-res');
                if(resBtn) {
                    resBtn.classList.add('active');
                    console.log('Residential button activated, tool set to RES');
                } else {
                    console.error('t-res button not found!');
                }
                
                Controller.toast(`Ready to build: ${levelConfig.name} (Capacity: ${levelConfig.capacity})`);
                
                // TEST: Try to build immediately at player position as a test
                if(Game.player) {
                    console.log('TEST: Attempting to build at player position:', Game.player.x, Game.player.y);
                }
            },
            setBuildingLevel(level) {
                this.selectedBuildingLevel = level;
                let levelConfig = CFG.BUILDING_LEVELS[level];
                Controller.toast(`Selected: ${levelConfig.name} (Cap: ${levelConfig.capacity})`);
            },
            toggleView() { 
                // Cycle through view modes: NORMAL -> DESIRABILITY -> BIRDSEYE -> POL -> NORMAL
                let modes = ['NORMAL', 'DESIRABILITY', 'BIRDSEYE', 'POL'];
                let currentIndex = modes.indexOf(Game.vm);
                Game.vm = modes[(currentIndex + 1) % modes.length];
                
                let btn = document.getElementById('btn-view');
                let icons = { 'NORMAL': 'ğŸ‘ï¸', 'DESIRABILITY': 'ğŸ”¥', 'BIRDSEYE': 'ğŸ¨', 'POL': 'â˜¢ï¸' };
                let titles = { 'NORMAL': 'Normal View', 'DESIRABILITY': 'Desirability Heatmap', 'BIRDSEYE': 'Birds Eye View (No UI)', 'POL': 'Pollution View' };
                btn.innerText = icons[Game.vm];
                btn.title = titles[Game.vm];
                Controller.toast(`View: ${titles[Game.vm]}`);
            },
            toggleAI() {
                // Use external AI module's toggle function
                let enabled = AI.toggle();
                
                // Update game state for compatibility
                Game.aiEnabled = enabled;
                
                // Update UI
                let btn = document.getElementById('btn-ai');
                btn.innerText = 'ğŸ¤–';
                btn.title = enabled ? 'AI Autoplay: ON' : 'Toggle AI Autoplay';
                btn.style.background = enabled ? '#4CAF50' : '';
                Controller.toast(enabled ? 'ğŸ¤– AI Autoplay Enabled' : 'ğŸ¤– AI Autoplay Disabled');
            },
            toggleBuildPanel() {
                let sidebar = document.getElementById('sidebar');
                if(sidebar.style.display === 'none' || sidebar.style.display === '') {
                    sidebar.style.display = 'block';
                    document.getElementById('btn-build').style.background = '#4CAF50';
                } else {
                    sidebar.style.display = 'none';
                    document.getElementById('btn-build').style.background = '#444';
                }
            },
            showCityUI() {
                console.log('=== showCityUI START ===');
                console.log('Game.gameState:', Game.gameState);
                
                // Force CITY mode
                Game.gameState = 'CITY';
                console.log('Forced gameState to CITY');
                
                // Hide wander mode buttons
                try {
                    let settleBtn = document.getElementById('btn-settle');
                    if(settleBtn) {
                        settleBtn.style.display = 'none';
                        console.log('Hid settlement button');
                    }
                } catch(e) {
                    console.error('Error hiding settlement button:', e);
                }
                
                // Show build tools
                console.log('Showing build tools...');
                try {
                    let elements = {
                        't-road': document.getElementById('t-road'),
                        't-well': document.getElementById('t-well'),
                        't-demolish': document.getElementById('t-demolish'),
                        't-res': document.getElementById('t-res'),
                        't-com': document.getElementById('t-com'),
                        't-ind': document.getElementById('t-ind'),
                        't-chief': document.getElementById('t-chief'),
                        't-basket': document.getElementById('t-basket'),
                        't-pottery': document.getElementById('t-pottery'),
                        't-granary': document.getElementById('t-granary'),
                        't-palace': document.getElementById('t-palace'),
                        'sep1': document.getElementById('sep1'),
                        'sep2': document.getElementById('sep2'),
                        'btn-turn': document.getElementById('btn-turn'),
                        'btn-view': document.getElementById('btn-view')
                    };
                    for(let id in elements) {
                        if(elements[id]) {
                            elements[id].style.display = 'inline-block';
                            // Special: always enable t-res in city mode
                            if(id === 't-res') {
                                elements[id].disabled = false;
                                elements[id].style.display = 'inline-block';
                                elements[id].title = 'Build Residential';
                            }
                            console.log('Showed:', id);
                        } else {
                            console.error('Element not found:', id);
                        }
                    }
                } catch(e) {
                    console.error('Error showing build tools:', e);
                }
                
                console.log('Build tools shown');
                
                // Initialize building level selector (default to highest unlocked level)
                if(Controller.selectedBuildingLevel === undefined) {
                    Controller.selectedBuildingLevel = PROGRESSION.unlockedLevels.includes(1) ? 1 : 0;
                    console.log('Set default building level to', Controller.selectedBuildingLevel);
                }
                
                console.log('Checking progression locks...');
                
                // Check progression and disable locked buildings
                // Industrial is unlocked at stage 2 (after settlement triggers stage 1 â†’ 2 transition)
                let industrialUnlocked = PROGRESSION.stage >= 2;
                let simcityUnlocked = Game.simcityMode;
                
                // Commercial (campfire) - unlocked after first residential zone at epoch 1
                let btnCom = document.getElementById('t-com');
                btnCom.disabled = false; // Always available in city mode
                btnCom.title = 'Build campfire to unlock commerce';
                
                // Industrial (Hunting Ground) - always available in city mode (after settlement)
                let btnInd = document.getElementById('t-ind');
                // In CITY mode, industrial is always unlocked
                btnInd.disabled = false;
                btnInd.title = 'Build hunting ground (1000 food + 1000 wood)';
                
                // Chief's Hut - requires simcity mode
                let btnChief = document.getElementById('t-chief');
                if(!simcityUnlocked) {
                    btnChief.disabled = true;
                    btnChief.title = `ğŸ”’ LOCKED: Build campfire first (${CFG.PRODUCTION.SIMCITY_MODE_UNLOCK_COST} food)`;
                } else {
                    btnChief.disabled = false;
                    btnChief.title = "Chief's Hut (10,000 food)";
                }
                
                // Storage buildings - require simcity mode
                let btnBasket = document.getElementById('t-basket');
                let btnPottery = document.getElementById('t-pottery');
                let btnGranary = document.getElementById('t-granary');
                let btnPalace = document.getElementById('t-palace');
                
                if(!simcityUnlocked) {
                    btnBasket.disabled = true;
                    btnBasket.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnPottery.disabled = true;
                    btnPottery.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnGranary.disabled = true;
                    btnGranary.title = `ğŸ”’ LOCKED: Build campfire first`;
                    btnPalace.disabled = true;
                    btnPalace.title = `ğŸ”’ LOCKED: Build campfire first`;
                } else {
                    btnBasket.disabled = false;
                    btnBasket.title = 'Basket (500 food) - +25 storage';
                    btnPottery.disabled = false;
                    btnPottery.title = 'Pottery (5,000 food) - +100 storage';
                    btnGranary.disabled = false;
                    btnGranary.title = 'Granary (50,000 food) - +500 storage';
                    btnPalace.disabled = false;
                    btnPalace.title = 'Palace (250,000 food) - +2,500 storage';
                }
                
                // Show city stats
                document.getElementById('stat-year').style.display = 'flex';
                document.getElementById('stat-water').style.display = 'flex';
                document.getElementById('stat-funds').style.display = 'flex';
                
                // Show camera control arrows (if they exist)
                let camUp = document.getElementById('cam-up');
                let camDown = document.getElementById('cam-down');
                let camLeft = document.getElementById('cam-left');
                let camRight = document.getElementById('cam-right');
                if (camUp) camUp.style.display = 'block';
                if (camDown) camDown.style.display = 'block';
                if (camLeft) camLeft.style.display = 'block';
                if (camRight) camRight.style.display = 'block';
                
                console.log('showCityUI() complete');
                
                // Visual confirmation
                setTimeout(() => {
                    Controller.toast('ğŸ—ï¸ City Build Mode Active! Click Residential to start building.');
                }, 200);
            },
            formatNumber(num) {
                // Use the same formatter as formatNum for consistency
                return this.formatNum(num);
            },
            updateUI() {
                // Show population differently in WANDER vs CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}`;
                } else {
                    document.getElementById('v-pop').innerText = `${this.formatNumber(Game.pop)}/${this.formatNumber(Game.housingCap)}`;
                }
                                document.getElementById('v-res').innerText = this.formatNumber(Math.floor(Game.gold || 0));
                
                // Show inventory food in WANDER mode, regular food in CITY mode
                if(Game.gameState === 'WANDER') {
                    document.getElementById('v-food').innerText = `${this.formatNumber(Math.floor(Game.inventory.food))}/${this.formatNumber(Game.inventory.capacity)}`;
                    document.getElementById('v-wood').innerText = Math.floor(Game.inventory.wood);
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show inventory metal/stone (from active collection) + pocket (passive finds)
                    let wanderMetal = Math.floor(Game.inventory.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let wanderStone = Math.floor(Game.inventory.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    document.getElementById('v-metal').innerText = wanderMetal;
                    document.getElementById('v-stone').innerText = wanderStone;
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    // Show total inventory
                    let totalInv = Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone;
                    document.getElementById('v-inventory').innerText = `${Math.floor(totalInv)}/${Game.inventory.capacity}`;
                    document.getElementById('stat-inventory').style.display = 'flex';
                    
                    // Show thirst indicator in WANDER mode
                    document.getElementById('stat-thirst').style.display = 'flex';
                    let thirstEl = document.getElementById('v-thirst');
                    let thirst = Game.thirst || 100;
                    thirstEl.innerText = thirst;
                    // Color code thirst level
                    if(thirst > 50) thirstEl.style.color = '#29B6F6'; // Blue - good
                    else if(thirst > 25) thirstEl.style.color = '#FFA726'; // Orange - warning
                    else thirstEl.style.color = '#E53935'; // Red - critical
                    
                    // Show wander wells count
                    document.getElementById('stat-wander-wells').style.display = 'flex';
                    document.getElementById('v-wander-wells').innerText = (Game.wanderWells ? Game.wanderWells.length : 0);
                } else {
                    document.getElementById('v-food').innerText = this.formatNumber(Math.floor(Game.food));
                    // Show wood in CITY mode (needed for upkeep)
                    document.getElementById('v-wood').innerText = Math.floor(Game.wood);
                    document.getElementById('stat-wood').style.display = 'flex';
                    
                    // Show metal and stone (from inventory + pocket)
                    let totalMetal = Math.floor(Game.metal || 0) + Math.floor(Game.pocket.metal || 0);
                    let totalStone = Math.floor(Game.stone || 0) + Math.floor(Game.pocket.stone || 0);
                    
                    document.getElementById('v-metal').innerText = totalMetal;
                    document.getElementById('v-stone').innerText = totalStone;
                    document.getElementById('stat-metal').style.display = 'flex';
                    document.getElementById('stat-stone').style.display = 'flex';
                    
                    document.getElementById('stat-inventory').style.display = 'none';
                    document.getElementById('stat-thirst').style.display = 'none'; // Hide thirst in CITY mode
                    
                    // Hide wander wells stat in CITY mode
                    document.getElementById('stat-wander-wells').style.display = 'none';
                }

                let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                let comCount = Game.blds.filter(b => b.t === 'COM').length;
                let indCount = Game.blds.filter(b => b.t === 'IND').length;
                
                // Update water display: percentage of capacity used
                let totalWells = Game.wellCount || wellCount;
                let waterCapacity = totalWells * 100; // Each well supports 100 people
                let waterUsed = Math.min(Game.pop, waterCapacity);
                let waterPercent = waterCapacity > 0 ? Math.round((waterUsed / waterCapacity) * 100) : 0;
                let waterStatus = `ğŸ’§ ${waterPercent}% capacity`;
                if(waterCapacity === 0) waterStatus = `âš ï¸ No wells!`;
                else if(Game.pop > waterCapacity) waterStatus = `ğŸ”´ OVER CAPACITY! (${Game.pop}/${waterCapacity})`;
                else if(waterPercent > 80) waterStatus = `ğŸŸ¡ ${waterPercent}% capacity`;
                else waterStatus = `ğŸŸ¢ ${waterPercent}% capacity`;
                document.getElementById('v-wat').innerText = waterStatus;
                
                // Update wells meter (new detailed view)
                if(Game.gameState === 'CITY') {
                    let wellsNeeded = Math.max(1, Math.ceil(Game.pop / 100)); // 1 well per 100 people
                    let wellsWithBuffer = wellsNeeded + 2; // +2 buffer recommended
                    let wellsEl = document.getElementById('v-wells');
                    let wellsStatEl = document.getElementById('stat-wells');
                    if(wellsEl && wellsStatEl) {
                        wellsStatEl.style.display = 'flex';
                        // Show wells: how many built and capacity usage
                        let wellsStatus = '';
                        let capacityUsed = totalWells > 0 ? Math.round((Game.pop / (totalWells * 100)) * 100) : 0;
                        
                        if(totalWells >= wellsNeeded) {
                            // Enough wells - show capacity usage
                            wellsStatus = `ğŸŸ¢ ${totalWells} wells (${capacityUsed}% capacity)`;
                        } else if(totalWells > 0) {
                            // Not enough wells - DANGER!
                            let shortage = wellsNeeded - totalWells;
                            wellsStatus = `ğŸ”´ ${totalWells} wells - Need ${shortage} more!`;
                        } else {
                            wellsStatus = `âš ï¸ NO WELLS! Need ${wellsNeeded}`;
                        }
                        wellsEl.innerText = wellsStatus;
                    }
                } else {
                    let wellsStatEl = document.getElementById('stat-wells');
                    if(wellsStatEl) wellsStatEl.style.display = 'none';
                }
                
                document.getElementById('v-nomad').innerText = Game.nomadsFound;
                document.getElementById('v-year').innerText = Game.year;
                
                // Update geological period display (if enabled)
                if(CFG.ELEVATION_SYSTEM.ENABLED && Game.geology) {
                    let geoEl = document.getElementById('v-geology');
                    if(geoEl) {
                        let seaIcon = Game.geology.currentSeaLevel > 3 ? 'ğŸŒŠ' : 
                                     Game.geology.currentSeaLevel < 3 ? 'â„ï¸' : 'ğŸŒ';
                        geoEl.innerText = `${seaIcon} ${Game.geology.currentPeriodName}`;
                        document.getElementById('stat-geology').style.display = 'flex';
                    }
                }
                
                // Update workforce display (only in CITY mode)
                if(Game.gameState === 'CITY' && Game.workforce) {
                    let wf = Game.workforce;
                    let workforceEl = document.getElementById('v-workforce');
                    if(workforceEl) {
                        let status = `ğŸ‘· ${wf.gatherers} gathering`;
                        if(wf.shortage > 0) {
                            status = `âš ï¸ ${wf.shortage} workers short! ${wf.gatherers} gathering`;
                        }
                        workforceEl.innerText = status;
                        document.getElementById('stat-workforce').style.display = 'flex';
                    }
                } else {
                    let workforceEl = document.getElementById('stat-workforce');
                    if(workforceEl) workforceEl.style.display = 'none';
                }
                
                // Update health display - HIDE in Epoch 0 (population IS health)
                // Health display removed - player health is now tied to population
                
                // Dynamic contextual guidance based on game state
                if(PROGRESSION.stage === 0) {
                    // Exploration phase - keep it open-ended
                    document.getElementById('v-epoch').innerText = `ğŸŒ EXPLORING THE WORLD`;
                } else if(PROGRESSION.stage === 1) {
                    // Settlement phase - simple status
                    document.getElementById('v-epoch').innerText = `ğŸ•ï¸ BUILDING SETTLEMENT`;
                } else if(PROGRESSION.stage === 2 && Game.age === 0) {
                    // Paleolithic - simple status
                    document.getElementById('v-epoch').innerText = `ğŸ¹ PALEOLITHIC AGE`;
                } else {
                    // Advanced ages - just show current age
                    let ageName = AGES[Game.age].n;
                    document.getElementById('v-epoch').innerText = `âš”ï¸ ${ageName.toUpperCase()} AGE`;
                }
                
                // UPDATE NEEDS WARNING PANEL
                this.updateNeedsWarning();
                
                // Update RCI demand meters (SimCity-style interdependent balance)
                if(Game.gameState === 'CITY') {
                    document.getElementById('rci-meters').style.display = 'block';
                    
                    // Use centralized RCI calculation (shared with AI)
                    let rci = Game.calculateRCIDemand();
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    
                    // Update the visual bars
                    let rBar = document.getElementById('r-bar-fill');
                    let cBar = document.getElementById('c-bar-fill');
                    let iBar = document.getElementById('i-bar-fill');
                    
                    if(rBar) rBar.style.height = rci.r + '%';
                    if(cBar) cBar.style.height = rci.c + '%';
                    if(iBar) iBar.style.height = rci.i + '%';
                    
                    // Update tooltip with counts
                    let tooltip = document.getElementById('rci-tooltip');
                    if(tooltip) {
                        tooltip.innerText = `R:${resCount} C:${comCount} I:${indCount}`;
                    }
                } else {
                    document.getElementById('rci-meters').style.display = 'none';
                }
            },
            currentLogView: 'player',
            captureConsoleLogs() {
                // Store original console methods
                const originalLog = console.log;
                const originalError = console.error;
                const originalWarn = console.warn;
                const originalInfo = console.info;
                
                // Initialize technical log if needed
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Override console.log
                console.log = function(...args) {
                    originalLog.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [LOG] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.error - Enhanced with auto-toast for critical errors
                console.error = function(...args) {
                    originalError.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [ERROR] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                    
                    // AUTO-ALERT: Flash toast RED immediately on any error
                    // This ensures testers/AI notice when something breaks
                    if(typeof Controller !== 'undefined' && Controller.toast) {
                        Controller.toast(`âš ï¸ ERROR: ${msg.substring(0, 80)}...`, true);
                    }
                    
                    // Optional: Auto-open log modal on critical errors (uncomment to enable)
                    // if(typeof Controller !== 'undefined' && Controller.showLog) {
                    //     Controller.showLog();
                    //     Controller.switchLog('technical');
                    // }
                };
                
                // Override console.warn
                console.warn = function(...args) {
                    originalWarn.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [WARN] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
                
                // Override console.info
                console.info = function(...args) {
                    originalInfo.apply(console, args);
                    let msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
                    if(Game.technicalLog) {
                        let timestamp = new Date().toLocaleTimeString();
                        Game.technicalLog.push(`[${timestamp}] [INFO] ${msg}`);
                        if(Game.technicalLog.length > 500) Game.technicalLog.shift();
                    }
                };
            },
            toast(m, isError = false) { 
                let t = document.getElementById('toast'); 
                t.innerText = m; 
                t.style.opacity = 1; 
                if(isError) t.style.background = '#F44336';
                else t.style.background = 'rgba(0,0,0,0.85)';
                setTimeout(() => t.style.opacity = 0, 2000); 
                
                // Initialize logs if needed
                if(!Game.playerLog) Game.playerLog = [];
                if(!Game.technicalLog) Game.technicalLog = [];
                
                // Add to player log (user-friendly messages)
                let timestamp = `[Y${Game.year || 0}]`;
                Game.playerLog.push(`${timestamp} ${m}`);
                if(Game.playerLog.length > 200) Game.playerLog.shift();
                
                // Add to technical log with more detail
                let techTimestamp = new Date().toLocaleTimeString();
                Game.technicalLog.push(`[${techTimestamp}] ${m}`);
                if(Game.technicalLog.length > 500) Game.technicalLog.shift();
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LORE SYSTEM - Story Mode with Cartoon Illustrations
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            toggleLore() {
                Game.loreEnabled = !Game.loreEnabled;
                let btn = document.getElementById('btn-lore');
                if(Game.loreEnabled) {
                    btn.classList.add('active');
                    this.toast('ğŸ“– Lore Mode ON - Story events will appear!');
                    // Show intro lore if this is a fresh game
                    if(!Game.loreSeen.GAME_START && Game.year === 0) {
                        this.showLoreEvent('GAME_START');
                    }
                } else {
                    btn.classList.remove('active');
                    this.toast('ğŸ“– Lore Mode OFF');
                }
            },
            
            showLoreEvent(eventId) {
                // Only show if lore is enabled and not already seen
                if(!Game.loreEnabled) return;
                if(Game.loreSeen[eventId]) return;
                
                // Mark as seen
                Game.loreSeen[eventId] = true;
                
                // Get event data
                let event = CFG.LORE_EVENTS[eventId];
                if(!event) {
                    console.warn('Lore event not found:', eventId);
                    return;
                }
                
                // Update popup content
                document.getElementById('lore-title').textContent = event.title;
                document.getElementById('lore-text').textContent = event.text;
                
                // Draw illustration
                this.drawLoreIllustration(event.illustration);
                
                // Show popup
                document.getElementById('lore-popup-overlay').style.display = 'block';
                document.getElementById('lore-popup').style.display = 'block';
            },
            
            closeLorePopup() {
                document.getElementById('lore-popup-overlay').style.display = 'none';
                document.getElementById('lore-popup').style.display = 'none';
            },
            
            drawLoreIllustration(type) {
                let canvas = document.getElementById('lore-canvas');
                let c = canvas.getContext('2d');
                let w = canvas.width;
                let h = canvas.height;
                
                // Clear canvas
                c.clearRect(0, 0, w, h);
                
                // Draw based on illustration type (Pokemon/cartoon style)
                switch(type) {
                    case 'wanderer':
                        this.drawWandererScene(c, w, h);
                        break;
                    case 'well':
                        this.drawWellScene(c, w, h);
                        break;
                    case 'hut':
                        this.drawHutScene(c, w, h);
                        break;
                    case 'hunting':
                        this.drawHuntingScene(c, w, h);
                        break;
                    case 'road':
                        this.drawRoadScene(c, w, h);
                        break;
                    case 'hunt_success':
                        this.drawHuntSuccessScene(c, w, h);
                        break;
                    case 'settlement':
                        this.drawSettlementScene(c, w, h);
                        break;
                    case 'storage':
                        this.drawStorageScene(c, w, h);
                        break;
                    case 'trading':
                        this.drawTradingScene(c, w, h);
                        break;
                    case 'nomad':
                        this.drawNomadScene(c, w, h);
                        break;
                    case 'turtle':
                        this.drawTurtleScene(c, w, h);
                        break;
                    case 'flood':
                        this.drawFloodScene(c, w, h);
                        break;
                    case 'berry':
                        this.drawBerryScene(c, w, h);
                        break;
                    default:
                        this.drawDefaultScene(c, w, h);
                }
            },
            
            // Helper function for drawing cartoon-style characters
            drawCartoonPerson(c, x, y, scale, facing) {
                // Facing: 1 = right, -1 = left
                let s = scale || 1;
                let f = facing || 1;
                
                // Body (fur clothes)
                c.fillStyle = '#8B6914';
                c.beginPath();
                c.ellipse(x, y + 15*s, 12*s, 18*s, 0, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#5D4E37';
                c.lineWidth = 2;
                c.stroke();
                
                // Head
                c.fillStyle = '#E8C4A0';
                c.beginPath();
                c.arc(x, y - 10*s, 14*s, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#B8947A';
                c.stroke();
                
                // Hair (messy)
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.ellipse(x, y - 20*s, 12*s, 8*s, 0, 0, Math.PI*2);
                c.fill();
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.arc(x + (i-2)*5*s, y - 24*s, 4*s, 0, Math.PI*2);
                    c.fill();
                }
                
                // Eyes (big cartoon eyes)
                c.fillStyle = '#fff';
                c.beginPath();
                c.ellipse(x - 5*s*f, y - 12*s, 4*s, 5*s, 0, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(x + 3*s*f, y - 12*s, 4*s, 5*s, 0, 0, Math.PI*2);
                c.fill();
                
                // Pupils
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(x - 4*s*f, y - 12*s, 2*s, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.arc(x + 4*s*f, y - 12*s, 2*s, 0, Math.PI*2);
                c.fill();
                
                // Smile
                c.strokeStyle = '#6B4A3A';
                c.lineWidth = 2;
                c.beginPath();
                c.arc(x, y - 5*s, 6*s, 0.2, Math.PI - 0.2);
                c.stroke();
            },
            
            // Scene drawing functions
            drawWandererScene(c, w, h) {
                // Sky gradient (sunset)
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#FF7F50');
                skyGrad.addColorStop(0.4, '#FFD700');
                skyGrad.addColorStop(0.7, '#87CEEB');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Sun
                c.fillStyle = '#FFE135';
                c.beginPath();
                c.arc(w - 80, 50, 35, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#FFA500';
                c.lineWidth = 4;
                c.stroke();
                
                // Rolling hills
                c.fillStyle = '#7CB342';
                c.beginPath();
                c.moveTo(0, h);
                c.quadraticCurveTo(100, h - 80, 200, h - 40);
                c.quadraticCurveTo(350, h - 100, w, h - 50);
                c.lineTo(w, h);
                c.fill();
                
                // Grass tufts
                c.fillStyle = '#558B2F';
                for(let i = 0; i < 15; i++) {
                    let gx = Math.random() * w;
                    let gy = h - 30 - Math.random() * 40;
                    c.beginPath();
                    c.moveTo(gx, gy);
                    c.lineTo(gx - 3, gy + 10);
                    c.lineTo(gx + 3, gy + 10);
                    c.fill();
                }
                
                // Wanderer walking toward horizon
                this.drawCartoonPerson(c, w/2 - 30, h - 60, 1.2, 1);
                
                // Walking stick
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 - 5, h - 80);
                c.lineTo(w/2 + 10, h - 25);
                c.stroke();
            },
            
            drawWellScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#8B7355';
                c.fillRect(0, h - 60, w, 60);
                
                // Well structure
                c.fillStyle = '#696969';
                c.fillRect(w/2 - 40, h - 100, 80, 50);
                
                // Well opening
                c.fillStyle = '#1a1a2e';
                c.beginPath();
                c.ellipse(w/2, h - 100, 30, 12, 0, 0, Math.PI*2);
                c.fill();
                
                // Water splash!
                c.fillStyle = '#4FC3F7';
                for(let i = 0; i < 8; i++) {
                    let sx = w/2 + (Math.random() - 0.5) * 40;
                    let sy = h - 110 - Math.random() * 30;
                    c.beginPath();
                    c.ellipse(sx, sy, 4, 6, Math.random(), 0, Math.PI*2);
                    c.fill();
                }
                
                // Happy caveman
                this.drawCartoonPerson(c, w/2 + 80, h - 80, 1.3, -1);
                
                // Surprised expression (raised eyebrows - draw over)
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.ellipse(w/2 + 75, h - 108, 8, 3, -0.3, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(w/2 + 88, h - 106, 8, 3, 0.3, 0, Math.PI*2);
                c.fill();
            },
            
            drawHutScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Hut (cute round structure)
                // Main body
                c.fillStyle = '#DEB887';
                c.beginPath();
                c.arc(w/2, h - 60, 60, Math.PI, 0);
                c.fill();
                
                // Door
                c.fillStyle = '#4A3728';
                c.beginPath();
                c.arc(w/2, h - 55, 20, Math.PI, 0);
                c.fill();
                
                // Straw roof
                c.fillStyle = '#DAA520';
                c.beginPath();
                c.moveTo(w/2 - 70, h - 60);
                c.lineTo(w/2, h - 120);
                c.lineTo(w/2 + 70, h - 60);
                c.fill();
                
                // Roof texture
                c.strokeStyle = '#B8860B';
                c.lineWidth = 2;
                for(let i = 0; i < 7; i++) {
                    c.beginPath();
                    c.moveTo(w/2 - 50 + i*15, h - 60);
                    c.lineTo(w/2, h - 115);
                    c.stroke();
                }
                
                // Proud caveman
                this.drawCartoonPerson(c, w/2 + 100, h - 80, 1.2, -1);
                
                // Smoke from invisible fire inside
                c.fillStyle = 'rgba(200, 200, 200, 0.5)';
                for(let i = 0; i < 4; i++) {
                    c.beginPath();
                    c.arc(w/2 + 5, h - 130 - i*20, 8 + i*3, 0, Math.PI*2);
                    c.fill();
                }
            },
            
            drawHuntingScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Forest background
                c.fillStyle = '#228B22';
                for(let i = 0; i < 5; i++) {
                    let tx = i * 120;
                    c.beginPath();
                    c.moveTo(tx, h - 50);
                    c.lineTo(tx + 40, h - 140);
                    c.lineTo(tx + 80, h - 50);
                    c.fill();
                }
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 50, w, 50);
                
                // Deer (cute style)
                let dx = w/2 - 60;
                let dy = h - 70;
                c.fillStyle = '#D4A76A';
                c.beginPath();
                c.ellipse(dx, dy, 35, 20, 0, 0, Math.PI*2);
                c.fill();
                // Head
                c.beginPath();
                c.ellipse(dx + 40, dy - 10, 15, 12, 0.3, 0, Math.PI*2);
                c.fill();
                // Eye
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(dx + 45, dy - 13, 3, 0, Math.PI*2);
                c.fill();
                // Antlers
                c.strokeStyle = '#8B4513';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(dx + 38, dy - 22);
                c.lineTo(dx + 30, dy - 40);
                c.moveTo(dx + 32, dy - 30);
                c.lineTo(dx + 22, dy - 35);
                c.stroke();
                c.beginPath();
                c.moveTo(dx + 45, dy - 22);
                c.lineTo(dx + 55, dy - 40);
                c.moveTo(dx + 52, dy - 30);
                c.lineTo(dx + 62, dy - 35);
                c.stroke();
                // Legs
                c.fillStyle = '#C49A6C';
                c.fillRect(dx - 20, dy + 10, 8, 25);
                c.fillRect(dx + 15, dy + 10, 8, 25);
                
                // Hiding hunter
                this.drawCartoonPerson(c, 100, h - 70, 1, 1);
                // Spear
                c.strokeStyle = '#5D4037';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(110, h - 90);
                c.lineTo(180, h - 110);
                c.stroke();
                // Spear tip
                c.fillStyle = '#808080';
                c.beginPath();
                c.moveTo(180, h - 115);
                c.lineTo(190, h - 110);
                c.lineTo(180, h - 105);
                c.fill();
            },
            
            drawRoadScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Grass
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 80, w, 80);
                
                // Dirt road
                c.fillStyle = '#C4A76C';
                c.beginPath();
                c.moveTo(0, h - 30);
                c.quadraticCurveTo(w/2, h - 60, w, h - 30);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Road texture (stones)
                c.fillStyle = '#A08050';
                for(let i = 0; i < 15; i++) {
                    let rx = Math.random() * w;
                    let ry = h - 10 - Math.random() * 20;
                    c.beginPath();
                    c.ellipse(rx, ry, 5, 3, Math.random(), 0, Math.PI*2);
                    c.fill();
                }
                
                // Happy caveman pointing at road
                this.drawCartoonPerson(c, w/2, h - 90, 1.3, 1);
                
                // Pointing arm
                c.strokeStyle = '#E8C4A0';
                c.lineWidth = 8;
                c.beginPath();
                c.moveTo(w/2 + 10, h - 90);
                c.lineTo(w/2 + 50, h - 70);
                c.stroke();
            },
            
            drawHuntSuccessScene(c, w, h) {
                // Dramatic red/orange sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#8B0000');
                skyGrad.addColorStop(0.5, '#FF4500');
                skyGrad.addColorStop(1, '#FFD700');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#6B8E23';
                c.fillRect(0, h - 60, w, 60);
                
                // Victorious hunter
                this.drawCartoonPerson(c, w/2, h - 80, 1.5, 1);
                
                // Raised spear
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 + 20, h - 70);
                c.lineTo(w/2 + 40, h - 150);
                c.stroke();
                c.fillStyle = '#808080';
                c.beginPath();
                c.moveTo(w/2 + 35, h - 155);
                c.lineTo(w/2 + 45, h - 145);
                c.lineTo(w/2 + 35, h - 135);
                c.fill();
                
                // Meat on ground
                c.fillStyle = '#8B0000';
                c.beginPath();
                c.ellipse(w/2 - 60, h - 40, 25, 15, 0.2, 0, Math.PI*2);
                c.fill();
                c.strokeStyle = '#5D0000';
                c.lineWidth = 2;
                c.stroke();
                
                // Victory sparkles
                c.fillStyle = '#FFD700';
                for(let i = 0; i < 8; i++) {
                    let sx = w/2 + Math.cos(i*0.8) * 80;
                    let sy = h - 120 + Math.sin(i*1.2) * 40;
                    c.beginPath();
                    c.moveTo(sx, sy - 8);
                    c.lineTo(sx + 3, sy);
                    c.lineTo(sx, sy + 8);
                    c.lineTo(sx - 3, sy);
                    c.fill();
                }
            },
            
            drawSettlementScene(c, w, h) {
                // Bright sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 70, w, 70);
                
                // Multiple huts
                for(let i = 0; i < 3; i++) {
                    let hx = 80 + i * 150;
                    c.fillStyle = '#DEB887';
                    c.beginPath();
                    c.arc(hx, h - 50, 35, Math.PI, 0);
                    c.fill();
                    c.fillStyle = '#DAA520';
                    c.beginPath();
                    c.moveTo(hx - 45, h - 50);
                    c.lineTo(hx, h - 90);
                    c.lineTo(hx + 45, h - 50);
                    c.fill();
                }
                
                // Proud founder in center
                this.drawCartoonPerson(c, w/2, h - 100, 1.4, 1);
                
                // Flag/banner
                c.fillStyle = '#8B0000';
                c.strokeStyle = '#5D4037';
                c.lineWidth = 4;
                c.beginPath();
                c.moveTo(w/2 + 30, h - 140);
                c.lineTo(w/2 + 30, h - 80);
                c.stroke();
                c.beginPath();
                c.moveTo(w/2 + 30, h - 140);
                c.lineTo(w/2 + 70, h - 130);
                c.lineTo(w/2 + 30, h - 120);
                c.fill();
            },
            
            drawStorageScene(c, w, h) {
                // Underground view
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h/2);
                c.fillStyle = '#8B7355';
                c.fillRect(0, h/2, w, h/2);
                
                // Pit
                c.fillStyle = '#5D4037';
                c.beginPath();
                c.moveTo(w/2 - 60, h/2);
                c.lineTo(w/2 - 40, h - 40);
                c.lineTo(w/2 + 40, h - 40);
                c.lineTo(w/2 + 60, h/2);
                c.fill();
                
                // Food in pit
                c.fillStyle = '#FF6347';
                c.beginPath();
                c.arc(w/2 - 15, h - 60, 12, 0, Math.PI*2);
                c.fill();
                c.fillStyle = '#FFD700';
                c.beginPath();
                c.ellipse(w/2 + 10, h - 55, 15, 10, 0.3, 0, Math.PI*2);
                c.fill();
                
                // Person looking down proudly
                this.drawCartoonPerson(c, w/2 + 100, h/2 - 30, 1.2, -1);
            },
            
            drawTradingScene(c, w, h) {
                // Sky
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Two people facing each other
                this.drawCartoonPerson(c, w/2 - 60, h - 80, 1.2, 1);
                this.drawCartoonPerson(c, w/2 + 60, h - 80, 1.2, -1);
                
                // Trading items floating between them
                c.fillStyle = '#4FC3F7';
                c.beginPath();
                c.arc(w/2 - 20, h - 100, 10, 0, Math.PI*2); // Fish
                c.fill();
                c.fillStyle = '#FF6B6B';
                c.beginPath();
                c.arc(w/2 + 20, h - 100, 8, 0, Math.PI*2); // Berry
                c.fill();
                
                // Trade arrows
                c.strokeStyle = '#FFD700';
                c.lineWidth = 3;
                c.beginPath();
                c.moveTo(w/2 - 30, h - 90);
                c.lineTo(w/2, h - 85);
                c.stroke();
                c.beginPath();
                c.moveTo(w/2 + 30, h - 110);
                c.lineTo(w/2, h - 115);
                c.stroke();
            },
            
            drawNomadScene(c, w, h) {
                // Misty sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#708090');
                skyGrad.addColorStop(1, '#B0C4DE');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Ground
                c.fillStyle = '#6B8E23';
                c.fillRect(0, h - 60, w, 60);
                
                // Mist
                c.fillStyle = 'rgba(200, 200, 200, 0.3)';
                for(let i = 0; i < 5; i++) {
                    c.beginPath();
                    c.ellipse(i * 120, h - 50, 80, 30, 0, 0, Math.PI*2);
                    c.fill();
                }
                
                // Our protagonist
                this.drawCartoonPerson(c, w/2 - 80, h - 80, 1.2, 1);
                
                // Mysterious stranger emerging from mist
                this.drawCartoonPerson(c, w/2 + 80, h - 80, 1.2, -1);
                
                // Raised hand (peace gesture)
                c.fillStyle = '#E8C4A0';
                c.beginPath();
                c.moveTo(w/2 + 50, h - 110);
                c.lineTo(w/2 + 45, h - 130);
                c.lineTo(w/2 + 55, h - 130);
                c.lineTo(w/2 + 60, h - 110);
                c.fill();
            },
            
            drawTurtleScene(c, w, h) {
                // Beach scene
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                
                // Ocean
                c.fillStyle = '#4FC3F7';
                c.fillRect(0, h - 40, w, 40);
                
                // Sand
                c.fillStyle = '#F4D03F';
                c.beginPath();
                c.moveTo(0, h - 40);
                c.quadraticCurveTo(w/2, h - 80, w, h - 40);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Turtle (cute cartoon style)
                let tx = w/2 - 40;
                let ty = h - 80;
                // Shell
                c.fillStyle = '#4A7A4A';
                c.beginPath();
                c.ellipse(tx, ty, 30, 20, 0, 0, Math.PI*2);
                c.fill();
                // Shell pattern
                c.strokeStyle = '#3D6B3D';
                c.lineWidth = 2;
                c.beginPath();
                c.arc(tx, ty, 15, 0, Math.PI*2);
                c.stroke();
                // Head
                c.fillStyle = '#6B8E6B';
                c.beginPath();
                c.ellipse(tx + 35, ty - 5, 12, 10, 0.3, 0, Math.PI*2);
                c.fill();
                // Eye
                c.fillStyle = '#222';
                c.beginPath();
                c.arc(tx + 40, ty - 8, 3, 0, Math.PI*2);
                c.fill();
                // Flippers
                c.fillStyle = '#6B8E6B';
                c.beginPath();
                c.ellipse(tx - 20, ty + 15, 15, 6, -0.5, 0, Math.PI*2);
                c.fill();
                c.beginPath();
                c.ellipse(tx + 20, ty + 15, 15, 6, 0.5, 0, Math.PI*2);
                c.fill();
                
                // Confused hunter
                this.drawCartoonPerson(c, w/2 + 80, h - 90, 1.2, -1);
                // Question mark
                c.fillStyle = '#FFD700';
                c.font = 'bold 30px Arial';
                c.fillText('?', w/2 + 90, h - 130);
            },
            
            drawFloodScene(c, w, h) {
                // Stormy sky
                let skyGrad = c.createLinearGradient(0, 0, 0, h);
                skyGrad.addColorStop(0, '#2F4F4F');
                skyGrad.addColorStop(1, '#4682B4');
                c.fillStyle = skyGrad;
                c.fillRect(0, 0, w, h);
                
                // Rising water
                c.fillStyle = '#1E90FF';
                c.fillRect(0, h - 100, w, 100);
                
                // Waves
                c.fillStyle = '#4169E1';
                c.beginPath();
                c.moveTo(0, h - 100);
                for(let i = 0; i < 10; i++) {
                    c.quadraticCurveTo(i*60 + 30, h - 120, i*60 + 60, h - 100);
                }
                c.lineTo(w, h - 100);
                c.lineTo(w, h);
                c.lineTo(0, h);
                c.fill();
                
                // Small hut on hill (safe)
                c.fillStyle = '#6B8E23';
                c.beginPath();
                c.ellipse(w - 100, h - 110, 60, 30, 0, Math.PI, 0);
                c.fill();
                c.fillStyle = '#DEB887';
                c.beginPath();
                c.arc(w - 100, h - 120, 25, Math.PI, 0);
                c.fill();
                
                // Worried person looking at water
                this.drawCartoonPerson(c, w - 100, h - 150, 1, -1);
                
                // Rain
                c.strokeStyle = 'rgba(200, 200, 255, 0.5)';
                c.lineWidth = 1;
                for(let i = 0; i < 30; i++) {
                    let rx = Math.random() * w;
                    let ry = Math.random() * (h - 100);
                    c.beginPath();
                    c.moveTo(rx, ry);
                    c.lineTo(rx - 5, ry + 15);
                    c.stroke();
                }
            },
            
            drawBerryScene(c, w, h) {
                // Forest scene
                c.fillStyle = '#228B22';
                c.fillRect(0, 0, w, h);
                
                // Lighter ground
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                
                // Berry bush
                c.fillStyle = '#2E7D32';
                c.beginPath();
                c.arc(w/2 - 50, h - 80, 50, 0, Math.PI*2);
                c.fill();
                
                // Berries (red and juicy)
                c.fillStyle = '#DC143C';
                for(let i = 0; i < 12; i++) {
                    let bx = w/2 - 50 + (Math.random() - 0.5) * 70;
                    let by = h - 80 + (Math.random() - 0.5) * 50;
                    c.beginPath();
                    c.arc(bx, by, 6, 0, Math.PI*2);
                    c.fill();
                    // Shine
                    c.fillStyle = 'rgba(255,255,255,0.5)';
                    c.beginPath();
                    c.arc(bx - 2, by - 2, 2, 0, Math.PI*2);
                    c.fill();
                    c.fillStyle = '#DC143C';
                }
                
                // Hungry person reaching
                this.drawCartoonPerson(c, w/2 + 60, h - 80, 1.2, -1);
                // Reaching arm
                c.strokeStyle = '#E8C4A0';
                c.lineWidth = 8;
                c.beginPath();
                c.moveTo(w/2 + 45, h - 80);
                c.lineTo(w/2, h - 70);
                c.stroke();
                
                // Drool? Maybe just a happy expression
            },
            
            drawDefaultScene(c, w, h) {
                // Generic stone age scene
                c.fillStyle = '#87CEEB';
                c.fillRect(0, 0, w, h);
                c.fillStyle = '#90EE90';
                c.fillRect(0, h - 60, w, 60);
                this.drawCartoonPerson(c, w/2, h - 80, 1.3, 1);
            },
            switchLog(type) {
                this.currentLogView = type;
                let playerBtn = document.getElementById('btn-player-log');
                let techBtn = document.getElementById('btn-technical-log');
                
                if(type === 'player') {
                    playerBtn.style.background = '#4CAF50';
                    playerBtn.style.fontWeight = 'bold';
                    techBtn.style.background = '#333';
                    techBtn.style.fontWeight = 'normal';
                } else {
                    playerBtn.style.background = '#333';
                    playerBtn.style.fontWeight = 'normal';
                    techBtn.style.background = '#4CAF50';
                    techBtn.style.fontWeight = 'bold';
                }
                
                this.updateLogDisplay();
            },
            updateLogDisplay() {
                let content = document.getElementById('log-content');
                if(this.currentLogView === 'player') {
                    if(!Game.playerLog || Game.playerLog.length === 0) {
                        content.innerText = 'No player events logged yet.';
                    } else {
                        content.innerText = Game.playerLog.join('\n');
                    }
                } else {
                    if(!Game.technicalLog || Game.technicalLog.length === 0) {
                        content.innerText = 'No technical events logged yet.';
                    } else {
                        content.innerText = Game.technicalLog.join('\n');
                    }
                }
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
            },
            copyLog() {
                let content = document.getElementById('log-content');
                let text = content.innerText;
                
                navigator.clipboard.writeText(text).then(() => {
                    this.toast('ğŸ“‹ Log copied to clipboard!');
                }).catch(err => {
                    // Fallback for older browsers
                    let textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        this.toast('ğŸ“‹ Log copied to clipboard!');
                    } catch(err) {
                        this.toast('âŒ Failed to copy log', true);
                    }
                    document.body.removeChild(textarea);
                });
            },
            showLog() {
                this.updateLogDisplay();
                document.getElementById('log-modal').style.display = 'flex';
            },
            hideLog() {
                document.getElementById('log-modal').style.display = 'none';
            },
            reset() {
                try {
                    console.log('Resetting game...');
                    // Set camera and tool
                    this.cam = { x: CFG.CAMERA.START_X, y: CFG.CAMERA.START_Y, z: CFG.CAMERA.START_ZOOM };
                    this.tool = 'PAN';
                    // Reset progression
                    PROGRESSION.reset();
                    // Reset game state
                    if (typeof Game === 'object') {
                        Game.gameState = 'WANDER';
                        Game.simcityMode = false;
                        Game.gatheringMultiplier = 1.0;
                        Game.age = 0;
                        Game.pop = 4;
                        Game.food = 0;
                        Game.wood = 0;
                        Game.metal = 0;
                        Game.stone = 0;
                        Game.res = 0;
                        Game.year = 0;
                        Game.nomadsFound = 0;
                        Game.totalFoodCollected = 0;
                        Game.housingCap = 0;
                        Game.blds = [];
                        Game.animals = [];
                        Game.pathQueue = [];
                        Game.player = null;
                        Game.inventory = { food: 0, wood: 0, metal: 0, stone: 0, capacity: CFG.INVENTORY.BACKPACK_BASE };
                        Game.pocket = { metal: 0, stone: 0 };
                    }
                    // Re-initialize game
                    Game.init(Math.floor(Math.random() * 999999));
                    // Hide all city building buttons (with null checks)
                    const hideElement = (id) => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = 'none';
                    };
                    const showElement = (id, display = 'inline-block') => {
                        let el = document.getElementById(id);
                        if(el) el.style.display = display;
                    };
                    hideElement('t-res');
                    hideElement('t-com');
                    hideElement('t-ind');
                    hideElement('t-road');
                    hideElement('t-well');
                    hideElement('t-chief');
                    hideElement('t-basket');
                    hideElement('t-pottery');
                    hideElement('t-granary');
                    hideElement('t-palace');
                    hideElement('t-demolish');
                    hideElement('sep1');
                    hideElement('sep2');
                    hideElement('btn-turn');
                    hideElement('btn-view');
                    hideElement('t-bull');
                    hideElement('stat-funds');
                    hideElement('stat-water');
                    hideElement('stat-nomad');
                    hideElement('stat-year');
                    hideElement('stat-workforce');
                    hideElement('cam-up');
                    hideElement('cam-down');
                    hideElement('cam-left');
                    hideElement('cam-right');
                    hideElement('building-menu-panel');
                    hideElement('rci-meters');
                    // Show wander mode buttons
                    showElement('btn-settle');
                    this.updateUI();
                    console.log('Game reset complete!');
                } catch(err) {
                    console.error('Reset error:', err);
                    // Force page reload as fallback
                    location.reload();
                }
            },
            
            showStatsMenu() {
                try {
                    this.updateStatsMenu();
                    let menu = document.getElementById('stats-menu');
                    let overlay = document.getElementById('stats-overlay');
                    if(menu && overlay) {
                        menu.style.display = 'block';
                        overlay.style.display = 'block';
                    } else {
                        console.error('Stats menu elements not found!', {menu, overlay});
                        this.toast('âŒ Stats menu not available', true);
                    }
                } catch(e) {
                    console.error('Error showing stats menu:', e);
                    this.toast('âŒ Error opening stats', true);
                }
            },
            
            hideStatsMenu() {
                document.getElementById('stats-menu').style.display = 'none';
                document.getElementById('stats-overlay').style.display = 'none';
            },
            
            updateStatsMenu() {
                let html = '';
                
                // Time & Progress Stats
                html += '<div style="margin-bottom:10px;"><strong style="color:#81C784;">â±ï¸ Progress</strong></div>';
                html += `<div>Year: ${Game.year || 0}</div>`;
                html += `<div>Turns Played: ${Game.turn || 0}</div>`;
                html += `<div>Game Mode: ${Game.gameState}</div>`;
                
                // Population Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#FF7043;">ğŸ‘¥ Population</strong></div>';
                    html += `<div>Total Population: ${this.formatNumber(Game.pop)}</div>`;
                    html += `<div>Population Capacity: ${this.formatNumber(Game.popCap)}</div>`;
                    
                    let resBuildings = Game.blds.filter(b => b.t === 'RES');
                    let avgLevel = resBuildings.length > 0 ? (resBuildings.reduce((sum, b) => sum + b.lvl, 0) / resBuildings.length).toFixed(1) : 0;
                    html += `<div>Residential Buildings: ${resBuildings.length}</div>`;
                    html += `<div>Average Res Level: ${avgLevel}</div>`;
                }
                
                // Resource Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#4CAF50;">ğŸŒ¾ Resources</strong></div>';
                html += `<div>Food Collected: ${this.formatNumber(Game.totalFoodCollected)}</div>`;
                if(Game.gameState === 'WANDER') {
                    html += `<div>Nomads Found: ${Game.nomadsFound || 0}</div>`;
                    html += `<div>Inventory Used: ${Math.floor((Game.inventory.food + Game.inventory.wood + Game.inventory.metal + Game.inventory.stone))}/${Game.inventory.capacity}</div>`;
                }
                
                // Building Stats
                if(Game.gameState === 'CITY') {
                    html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#2196F3;">ğŸ—ï¸ Buildings</strong></div>';
                    let resCount = Game.blds.filter(b => b.t === 'RES').length;
                    let comCount = Game.blds.filter(b => b.t === 'COM').length;
                    let indCount = Game.blds.filter(b => b.t === 'IND').length;
                    let wellCount = Game.blds.filter(b => b.t === 'WELL').length;
                    
                    html += `<div>Residential: ${resCount}</div>`;
                    html += `<div>Commercial: ${comCount}</div>`;
                    html += `<div>Industrial: ${indCount}</div>`;
                    html += `<div>Wells: ${wellCount}</div>`;
                    html += `<div>Total Buildings: ${Game.blds.length}</div>`;
                }
                
                // Unlocks Stats
                html += '<div style="margin: 15px 0 10px 0;"><strong style="color:#9C27B0;">ğŸ”“ Progress</strong></div>';
                html += `<div>Unlocked Res Levels: ${PROGRESSION.unlockedLevels.length}</div>`;
                html += `<div>Highest Unlocked: Level ${Math.max(...PROGRESSION.unlockedLevels, 0)}</div>`;
                
                document.getElementById('stats-content').innerHTML = html;
            },
            saveMap() {
                let saveData = {
                    version: '28.0',
                    game: {
                        tiles: Game.tiles,
                        blds: Game.blds,
                        res: Game.res,
                        food: Game.food,
                        water: Game.water,
                        pop: Game.pop,
                        year: Game.year,
                        age: Game.age,
                        player: Game.player,
                        wolves: Game.wolves,
                        nomadsFound: Game.nomadsFound
                    },
                    progression: {
                        stage: PROGRESSION.stage,
                        nomadsFound: PROGRESSION.nomadsFound,
                        settlementYear: PROGRESSION.settlementYear
                    },
                    camera: {
                        x: this.cam.x,
                        y: this.cam.y,
                        z: this.cam.z
                    }
                };
                let d = JSON.stringify(saveData);
                let blob = new Blob([d], {type: 'application/json'});
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a'); a.href = url; a.download = 'citgame_save.json'; a.click();
                this.toast('Game Saved!');
            },
            loadMap() { document.getElementById('file-input').click(); },
            
            zoomIn() {
                this.cam.z = Math.min(CFG.ZOOM.MAX, this.cam.z * CFG.ZOOM.STEP);
            },
            
            zoomOut() {
                this.cam.z = Math.max(CFG.ZOOM.MIN, this.cam.z / CFG.ZOOM.STEP);
            },
            
            moveCameraUp() {
                this.cam.y -= CFG.TILE * 5;
            },
            
            moveCameraDown() {
                this.cam.y += CFG.TILE * 5;
            },
            
            moveCameraLeft() {
                this.cam.x -= CFG.TILE * 5;
            },
            
            moveCameraRight() {
                this.cam.x += CFG.TILE * 5;
            },
            
            showSettlementUI() {
                // Show building tools (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-road'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-well'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-res'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-com'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep1'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-funds'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-water'); if(el) el.style.display = 'flex';
                el = document.getElementById('btn-turn'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('stat-year'); if(el) el.style.display = 'flex';
                el = document.getElementById('stat-nomad'); if(el) el.style.display = 'flex';
                console.log('Settlement UI shown - Pass Turn button should be visible');
                this.updateUI();
            },
            
            showIndustrialUI() {
                // Enable Industrial/Hunting Ground button (use t-* IDs which are the actual button IDs)
                let el;
                el = document.getElementById('t-ind'); 
                if(el) { el.style.display = 'inline-block'; el.disabled = false; el.title = 'Build hunting ground'; }
                el = document.getElementById('t-basket'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-pottery'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-granary'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-palace'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-chief'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('t-demolish'); if(el) el.style.display = 'inline-block';
                el = document.getElementById('sep2'); if(el) el.style.display = 'inline-block';
                console.log('Industrial UI shown - Industrial button should be visible');
                this.updateUI();
            },
            
                showSimCityUI() {
                // Enable all storage and special buildings (with null checks)
                let btnChief = document.getElementById('t-chief');
                if (btnChief) {
                    btnChief.disabled = false;
                    btnChief.title = "Chief's Hut (10,000 food)";
                }
                
                let btnBasket = document.getElementById('t-basket');
                if (btnBasket) {
                    btnBasket.disabled = false;
                    btnBasket.title = 'Basket (500 food) - +25 storage';
                }
                
                let btnPottery = document.getElementById('t-pottery');
                if (btnPottery) {
                    btnPottery.disabled = false;
                    btnPottery.title = 'Pottery (5,000 food) - +100 storage';
                }
                
                let btnGranary = document.getElementById('t-granary');
                if (btnGranary) {
                    btnGranary.disabled = false;
                    btnGranary.title = 'Granary (50,000 food) - +500 storage';
                }
                
                let btnPalace = document.getElementById('t-palace');
                if (btnPalace) {
                    btnPalace.disabled = false;
                    btnPalace.title = 'Palace (250,000 food) - +2,500 storage';
                }
                
                // Show all building tools when SimCity mode unlocks
                let elem;
                elem = document.getElementById('t-res'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-com'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-ind'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-chief'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-road'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-well'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('t-bull'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep1'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('sep2'); if (elem) elem.style.display = 'inline-block';
                elem = document.getElementById('stat-funds'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-water'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('stat-year'); if (elem) elem.style.display = 'block';
                elem = document.getElementById('btn-view'); if (elem) elem.style.display = 'inline-block';
                
                // Update button texts for SimCity mode
                let tRes = document.getElementById('t-res'); if (tRes) tRes.innerHTML = 'ğŸ  Residence ($50)';
                let tCom = document.getElementById('t-com'); if (tCom) tCom.innerHTML = 'ğŸ¢ Commercial ($75)';
                let tInd = document.getElementById('t-ind'); if (tInd) tInd.innerHTML = 'ğŸ­ Industrial ($500)';
                
                this.updateUI();
            }
        };

        // Game Over overlay helpers - Newspaper Article Style
        Controller.showGameOver = function(reason) {
            var panel = document.getElementById('gameover-screen');
            var dateEl = document.getElementById('newspaper-date');
            var headline = document.getElementById('newspaper-headline');
            var subheadline = document.getElementById('newspaper-subheadline');
            var body = document.getElementById('newspaper-body');
            var stats = document.getElementById('newspaper-stats');
            
            // Get today's date formatted
            var today = new Date();
            var months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            var dateStr = months[today.getMonth()] + ' ' + today.getDate() + ', ' + today.getFullYear();
            if(dateEl) dateEl.textContent = dateStr;
            
            // Gather game state - use peakPop for stats since current pop is often 0 at game over
            var pop = Game.peakPop || Game.pop || 0;
            var food = Math.floor(Game.food || (Game.inventory ? Game.inventory.food : 0) || 0);
            var wood = Math.floor(Game.wood || (Game.inventory ? Game.inventory.wood : 0) || 0);
            var gameState = Game.gameState || 'WANDER';
            var year = Game.year || 0;
            
            // Check if player ever established a settlement (had buildings beyond starter or high population)
            var hadSettlement = (Game.blds && Game.blds.length > 0) || pop > 10 || gameState === 'CITY';
            
            // Level 0 (WANDER) - Archaeological discovery article (only if never settled)
            if(!hadSettlement || reason === 'HUNTING') {
                var fossilCount = Math.max(1, pop);
                var siteAge = '2.' + Math.floor(Math.random()*9) + ' million';
                // Vary headlines
                var headlines = [
                    'Ancient Hominid Remains Discovered in Remote Valley',
                    'Fossilized Hunter-Gatherers Unearthed at Excavation Site',
                    'Pre-Historic Human Ancestors Found After ' + siteAge + ' Years',
                    'Archaeological Team Uncovers Early Human Settlement Attempt',
                    'Nomadic Tribe Fossils Reveal Harsh Prehistoric Reality'
                ];
                // Vary based on population
                var popDesc;
                if(fossilCount === 1) popDesc = 'a solitary individual';
                else if(fossilCount <= 3) popDesc = 'a small family group of ' + fossilCount;
                else if(fossilCount <= 10) popDesc = 'a band of ' + fossilCount + ' individuals';
                else if(fossilCount <= 50) popDesc = 'a tribe of ' + fossilCount + ' members';
                else popDesc = 'a large clan numbering ' + fossilCount + ' individuals';
                // Food context
                var foodContext;
                if(food <= 0) foodContext = 'with no food stores remaining, suggesting starvation';
                else if(food < 20) foodContext = 'with only ' + food + ' units of preserved food nearbyâ€”barely enough for survival';
                else if(food < 100) foodContext = 'alongside ' + food + ' units of stored provisions';
                else foodContext = 'with substantial food reserves of ' + food + ' units, indicating capable foragers';
                // Wood/tools context
                var woodContext;
                if(wood <= 0) woodContext = 'No wooden implements were recovered';
                else if(wood < 10) woodContext = 'A few crude wooden tools (' + wood + ' pieces) were found';
                else if(wood < 50) woodContext = 'Evidence of ' + wood + ' wooden implements suggests basic tool use';
                else woodContext = 'An impressive cache of ' + wood + ' wooden items indicates advanced craftsmanship';
                // Death cause context
                var deathCause;
                if(reason === 'HUNTING') {
                    deathCause = 'Skeletal trauma patterns suggest the group perished during a hunting expedition gone wrong. Large animal bones nearby indicate a dangerous prey encounter.';
                } else if(reason === 'THIRST') {
                    deathCause = 'Analysis of the bone structure reveals severe dehydration. The group appears to have wandered too far from water sources during a prolonged drought, unable to find rivers or lakes in time.';
                } else if(food <= 0) {
                    deathCause = 'The absence of food remains and evidence of malnutrition in the bones suggests this group succumbed to starvation during a harsh season.';
                } else {
                    deathCause = 'The circumstances of their demise remain unclear, though the harsh environment of the Pleistocene era claimed countless such groups.';
                }
                // Professor names for article quote
                var professors = [
                    'Sarah Chen', 'Michael Oduya', 'Elena Vasquez', 'James Thornton',
                    'Fatima Al-Hassan', 'Robert Kimura', 'Catherine Dubois', 'Henrik Larsson',
                    'Priya Nair', 'Luca Romano', 'Ava MÃ¼ller', 'Santiago Perez',
                    'Yara Haddad', 'Wei Zhang', 'Nina Petrova', 'Omar Farouk',
                    'Isabella Rossi', 'Jonas Berg', 'Maya Singh', 'Lucas Silva'
                ];
                var prof = professors[Math.floor(Math.random()*professors.length)];
                
                // Draw fossil illustration
                var canvas = document.getElementById('fossil-illustration');
                if(canvas && canvas.getContext) {
                    var ctx = canvas.getContext('2d');
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    
                    // Background dirt/sediment texture
                    ctx.fillStyle = '#D4C4A8';
                    ctx.fillRect(0,0,280,140);
                    for(var i=0; i<50; i++) {
                        ctx.fillStyle = ['#C9B896','#BFA97E','#E0D4BC','#A89878'][Math.floor(Math.random()*4)];
                        ctx.beginPath();
                        ctx.arc(Math.random()*280, Math.random()*140, Math.random()*8+2, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Randomize which bones to show (20+ variations)
                    var variant = Math.floor(Math.random()*20);
                    var boneColor = '#F5F0E0';
                    var boneShade = '#D8D0BC';
                    var crackColor = '#A09080';
                    
                    // Draw partial skull (most variants)
                    if(variant !== 5 && variant !== 12) {
                        var skullX = 40 + (variant % 3) * 10;
                        var skullY = 50 + (variant % 2) * 15;
                        // Skull dome
                        ctx.beginPath();
                        ctx.ellipse(skullX, skullY, 28, 22, 0.2, 0, Math.PI * 1.8);
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        // Eye socket
                        ctx.beginPath();
                        ctx.ellipse(skullX + 8, skullY + 8, 7, 9, 0.1, 0, 2*Math.PI);
                        ctx.fillStyle = '#B0A090';
                        ctx.fill();
                        // Cracks
                        ctx.strokeStyle = crackColor;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(skullX - 10, skullY - 5);
                        ctx.lineTo(skullX + 5, skullY + 3);
                        ctx.lineTo(skullX + 2, skullY + 15);
                        ctx.stroke();
                    }
                    
                    // Draw spine/vertebrae
                    if(variant % 3 !== 2) {
                        var spineX = 100 + (variant % 4) * 8;
                        for(var v = 0; v < 5 + (variant % 3); v++) {
                            ctx.beginPath();
                            ctx.ellipse(spineX + v * 14, 75 + Math.sin(v)*5, 8, 6, 0.3, 0, 2*Math.PI);
                            ctx.fillStyle = boneColor;
                            ctx.fill();
                            ctx.strokeStyle = boneShade;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Draw ribs
                    if(variant % 4 !== 3) {
                        var ribX = 120 + (variant % 3) * 15;
                        var ribY = 35;
                        ctx.strokeStyle = boneColor;
                        ctx.lineWidth = 4;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        for(var r = 0; r < 3 + (variant % 2); r++) {
                            ctx.beginPath();
                            ctx.arc(ribX, ribY + r * 12, 25 + r * 3, 0.5, Math.PI - 0.3);
                            ctx.stroke();
                        }
                    }
                    
                    // Draw femur/leg bone
                    if(variant % 2 === 0) {
                        var femurX = 200 + (variant % 5) * 8;
                        var femurY = 30 + (variant % 3) * 10;
                        ctx.save();
                        ctx.translate(femurX, femurY);
                        ctx.rotate(0.4 + (variant % 4) * 0.2);
                        // Shaft
                        ctx.fillStyle = boneColor;
                        ctx.fillRect(-5, 0, 10, 70);
                        // Joint ends
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 12, 10, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(0, 70, 10, 8, 0, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(-5, 0, 10, 70);
                        ctx.restore();
                    }
                    
                    // Draw hand bones (scattered)
                    if(variant > 7) {
                        var handX = 230 + (variant % 4) * 10;
                        var handY = 90 - (variant % 3) * 15;
                        for(var f = 0; f < 4; f++) {
                            ctx.fillStyle = boneColor;
                            ctx.save();
                            ctx.translate(handX + f * 8, handY);
                            ctx.rotate(-0.2 + f * 0.15);
                            ctx.fillRect(-2, 0, 4, 18);
                            ctx.beginPath();
                            ctx.arc(0, 0, 4, 0, 2*Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    
                    // Draw pelvis fragment
                    if(variant % 5 === 0 || variant > 15) {
                        var pelvisX = 180;
                        var pelvisY = 100;
                        ctx.beginPath();
                        ctx.moveTo(pelvisX, pelvisY);
                        ctx.quadraticCurveTo(pelvisX + 30, pelvisY - 20, pelvisX + 50, pelvisY + 5);
                        ctx.quadraticCurveTo(pelvisX + 35, pelvisY + 15, pelvisX + 10, pelvisY + 10);
                        ctx.closePath();
                        ctx.fillStyle = boneColor;
                        ctx.fill();
                        ctx.strokeStyle = boneShade;
                        ctx.stroke();
                    }
                    
                    // Add some scattered small bone fragments
                    for(var b = 0; b < 3 + (variant % 4); b++) {
                        ctx.fillStyle = boneColor;
                        ctx.beginPath();
                        var fx = 50 + Math.random() * 200;
                        var fy = 100 + Math.random() * 30;
                        ctx.ellipse(fx, fy, 4 + Math.random()*6, 3 + Math.random()*4, Math.random()*Math.PI, 0, 2*Math.PI);
                        ctx.fill();
                    }
                    
                    // Caption label
                    ctx.fillStyle = '#443322';
                    ctx.font = 'italic 10px Georgia';
                    ctx.fillText('Fig. 1: Excavation site photograph', 10, 132);
                }
                if(headline) headline.textContent = headlines[Math.floor(Math.random()*headlines.length)];
                if(subheadline) subheadline.textContent = 'Researchers document ' + popDesc + ' who never established permanent settlement';
                if(body) body.innerHTML = '<p><strong>EAST AFRICAN RIFT VALLEY</strong> â€” An international team of paleoanthropologists has announced the discovery of ' + popDesc + ' dating back approximately ' + siteAge + ' years.</p>' +
                    '<p>The remains were found ' + foodContext + '. ' + woodContext + ', providing valuable insight into early human material culture.</p>' +
                    '<p>"These ancestors never made the crucial transition to permanent settlement," noted Professor ' + prof + ', lead researcher on the excavation. "They represent the countless groups who wandered but never found the right conditions to establish lasting communities."</p>' +
                    '<p>' + deathCause + '</p>' +
                    '<p>This discovery adds to our understanding of the tremendous challenges faced by early <strong>hominids</strong>, where survival was never guaranteed and most lineages ended without descendants.</p>';
                if(stats) stats.innerHTML = '<strong>ğŸ“‹ EXCAVATION DATA:</strong><br>' +
                    'â€¢ Fossils recovered: ' + fossilCount + '<br>' +
                    'â€¢ Food remains: ' + food + ' units<br>' +
                    'â€¢ Wooden artifacts: ' + wood + ' pieces<br>' +
                    'â€¢ Site age: ~' + siteAge + ' years<br>' +
                    'â€¢ Settlement status: <span style="color:#8B0000;">Never established</span>';
            }
            // Level 1+ (CITY) - Historical collapse article
            else {
                // Count buildings by type AND level
                var resBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='RES';}) : [];
                var comBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='COM';}) : [];
                var indBlds = Game.blds ? Game.blds.filter(function(b){return b.t==='IND';}) : [];
                var wellCount = Game.blds ? Game.blds.filter(function(b){return b.t==='WELL';}).length : 0;
                var roadCount = Game.blds ? Game.blds.filter(function(b){return b.t==='ROAD';}).length : 0;
                
                var resCount = resBlds.length;
                var comCount = comBlds.length;
                var indCount = indBlds.length;
                var totalZones = resCount + comCount + indCount;
                
                // Get descriptive names for building types
                var getResDescription = function(blds) {
                    if(blds.length === 0) return 'no residential structures';
                    // Most buildings will be level 1 (Pit Class) early game
                    var names = [];
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    if(lvl1 > 0) names.push(lvl1 + ' Pit dwelling' + (lvl1 > 1 ? 's' : '') + ' (simple straw-lined earth pits where families huddled for warmth)');
                    if(lvl2 > 0) names.push(lvl2 + ' GrubenhÃ¤user (semi-subterranean pit houses with basic roofing)');
                    return names.join(', ') || blds.length + ' residential structures';
                };
                
                var getComDescription = function(blds) {
                    if(blds.length === 0) return 'no commercial areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Campfire' + (lvl1 > 1 ? 's' : '') + ' (communal gathering spots where tribes traded goods and shared stories)');
                    if(lvl2 > 0) names.push(lvl2 + ' Fire Pit' + (lvl2 > 1 ? 's' : '') + ' (larger communal areas for trade and ceremony)');
                    return names.join(', ') || blds.length + ' commercial areas';
                };
                
                var getIndDescription = function(blds) {
                    if(blds.length === 0) return 'no food production areas';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var names = [];
                    if(lvl1 > 0) names.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : '') + ' (designated areas where hunters tracked and trapped wild game)');
                    if(lvl2 > 0) names.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : '') + ' (deep pits dug to trap larger prey)');
                    return names.join(', ') || blds.length + ' hunting areas';
                };
                
                // Short versions for stats
                var getResShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Pit' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Grubenhaus' + (lvl2 > 1 ? 'er' : ''));
                    return parts.join(', ');
                };
                
                var getComShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Campfire' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Fire Pit' + (lvl2 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                var getIndShort = function(blds) {
                    if(blds.length === 0) return 'None';
                    var lvl1 = blds.filter(function(b){ return (b.level || 1) === 1; }).length;
                    var lvl2 = blds.filter(function(b){ return (b.level || 1) === 2; }).length;
                    var parts = [];
                    if(lvl1 > 0) parts.push(lvl1 + ' Hunting Ground' + (lvl1 > 1 ? 's' : ''));
                    if(lvl2 > 0) parts.push(lvl2 + ' Hunting Pit' + (lvl2 > 1 ? 's' : ''));
                    return parts.join(', ');
                };
                
                // Water needs calculation (1 well per 100 population)
                var wellsNeeded = Math.max(1, Math.ceil(pop / 100));
                
                // Settlement size description
                var sizeDesc;
                if(pop <= 20) sizeDesc = 'a tiny hamlet';
                else if(pop <= 100) sizeDesc = 'a small village';
                else if(pop <= 500) sizeDesc = 'a growing settlement';
                else if(pop <= 2000) sizeDesc = 'a thriving community';
                else sizeDesc = 'a substantial town';
                
                // Failure analysis
                var failureReason;
                if(reason === 'NO_WATER') {
                    failureReason = 'Skeletal analysis reveals catastrophic dehydration as the primary cause of death. The settlement existed for over two years without any permanent water infrastructureâ€”a fatal oversight. Bone analysis shows progressive signs of water stress, malnutrition, and ultimately mass mortality during what appears to have been a severe drought season.';
                } else if(food <= 0) {
                    failureReason = 'Archaeological evidence strongly suggests famine as the primary cause of collapse. Grain stores were found completely empty, and skeletal remains show signs of severe malnutrition.';
                } else if(wellCount === 0 && pop > 50) {
                    failureReason = 'The absence of any water infrastructure proved fatal. Without wells, the growing population could not sustain itself through dry seasons.';
                } else if(indCount === 0 && pop > 30) {
                    failureReason = 'No hunting grounds or food production facilities were established. The settlement relied entirely on foraged food, an unsustainable strategy for a permanent community.';
                } else {
                    failureReason = 'Poor resource management and inadequate planning appear to have doomed this early settlement. Early humans who succeeded were those who learned to think ahead.';
                }
                
                var headlines2 = [
                    'Ancient Settlement Collapse Reveals Harsh Lessons of Early Civilization',
                    'Failed Neolithic Village Discovered: "They Didn\'t Plan Ahead"',
                    'Archaeologists Uncover Tragic End of ' + sizeDesc.charAt(0).toUpperCase() + sizeDesc.slice(1),
                    'Early Human Settlement Found Abandoned After Apparent Collapse',
                    '"Planning Was Everything": Ruins Tell Story of Prehistoric Failure'
                ];
                
                if(reason === 'NO_WATER') {
                    headlines2 = [
                        'Mass Dehydration Wiped Out Ancient Settlement, Study Confirms',
                        'No Wells, No Water, No Survivors: Prehistoric Village\'s Fatal Flaw',
                        'Settlement Died of Thirst: "Water Was Everything," Say Archaeologists',
                        'Archaeological Evidence Shows Entire Community Perished From Lack of Water',
                        'Two Years Without Wells Proved Fatal for Early Human Settlement'
                    ];
                }
                
                // FLOOD DEATH - New catastrophic ending
                if(reason === 'FLOOD') {
                    var drowned = Game.geology ? Game.geology.populationDrowned || pop : pop;
                    var periodName = Game.geology ? Game.geology.currentPeriodName : 'Unknown Climate Shift';
                    headlines2 = [
                        'Rising Seas Swallowed Ancient Settlement Whole',
                        'Climate Catastrophe: Entire Village Lost to Flooding',
                        '"The Waters Came Too Fast": Flood Erased Early Civilization',
                        'Geological Shift Drowned Prehistoric Community',
                        periodName + ' Floods Claimed Settlement Without Warning'
                    ];
                    failureReason = 'Geological records indicate a catastrophic flooding event during the ' + periodName + '. Rising sea levels, driven by melting glaciers or tectonic shifts, overwhelmed the low-lying settlement. ' + drowned + ' inhabitants perished as waters rose faster than they could escape. The lesson for future settlements: always build on high ground.';
                }
                
                if(headline) headline.textContent = headlines2[Math.floor(Math.random()*headlines2.length)];
                if(subheadline) subheadline.textContent = 'Excavation of ' + sizeDesc + ' (' + pop + ' inhabitants) shows why early humans needed foresight to survive';
                
                // Build descriptive body text
                var resDesc = getResDescription(resBlds);
                var comDesc = getComDescription(comBlds);
                var indDesc = getIndDescription(indBlds);
                
                if(body) body.innerHTML = '<p><strong>FERTILE CRESCENT REGION</strong> â€” Researchers have completed their analysis of ' + sizeDesc + ' that housed approximately ' + pop + ' people before its sudden collapse in Year ' + year + ' of the settlement\'s existence.</p>' +
                    '<p>The excavation revealed ' + resDesc + '. ' + (comCount > 0 ? 'For trade and social gatherings, the community had established ' + comDesc + '. ' : 'No evidence of organized trade or social gathering spots was found. ') + (indCount > 0 ? 'Food was procured through ' + indDesc + '.' : 'Remarkably, no organized food production was ever establishedâ€”the settlement relied entirely on opportunistic foraging.') + '</p>' +
                    '<p>' + (wellCount > 0 ? 'Water infrastructure consisted of ' + wellCount + ' well' + (wellCount > 1 ? 's' : '') + '. A settlement of this size required ' + wellsNeeded + ' functioning wells.' : 'Notably, no permanent water infrastructure was ever constructedâ€”a critical oversight that may have contributed to the settlement\'s demise.') + '</p>' +
                    '<p>' + failureReason + '</p>' +
                    '<p>"The difference between the groups that survived and those that perished often came down to planning," explained Dr. ' + ['Henrik Larsson','Fatima Al-Hassan','Robert Kimura','Catherine Dubois'][Math.floor(Math.random()*4)] + '. "Those who thought seasons ahead, who built reserves, who prepared for hardshipâ€”they became our ancestors. The others... became archaeology."</p>' +
                    '<p>This settlement joins thousands of similar failed attempts across the prehistoric world, each a testament to the razor-thin margin between survival and extinction that defined early human existence.</p>';
                    
                if(stats) stats.innerHTML = '<strong>ğŸ“‹ SETTLEMENT SURVEY:</strong><br>' +
                    'â€¢ Peak population: ' + pop + '<br>' +
                    'â€¢ Years survived: ' + year + '<br>' +
                    'â€¢ Dwellings: ' + (getResShort(resBlds) || 'None') + '<br>' +
                    'â€¢ Trade spots: ' + (getComShort(comBlds) || 'None') + '<br>' +
                    'â€¢ Food production: ' + (getIndShort(indBlds) || 'None') + '<br>' +
                    'â€¢ Water wells: ' + wellCount + ' built / ' + wellsNeeded + ' needed<br>' +
                    'â€¢ Food at collapse: ' + food + ' units<br>' +
                    (reason === 'NO_WATER' ? 'â€¢ Years without water: ' + (Game.yearsWithoutWell || 2) + '<br>' : '') +
                    (reason === 'FLOOD' ? 'â€¢ Sea level: ' + (Game.geology ? Math.floor(Game.geology.currentSeaLevel) : '?') + '/10<br>' : '') +
                    (reason === 'FLOOD' ? 'â€¢ Climate period: ' + (Game.geology ? Game.geology.currentPeriodName : 'Unknown') + '<br>' : '') +
                    'â€¢ Verdict: <span style="color:#8B0000;">' + (reason === 'FLOOD' ? 'Death by flooding' : reason === 'NO_WATER' ? 'Death by dehydration' : 'Insufficient planning') + '</span>';
            }
            
            if (panel) panel.style.display = 'flex';
        };

        document.addEventListener('DOMContentLoaded', function() {
            var btn = document.getElementById('btn-newgame');
            if (btn) {
                btn.onclick = function() {
                    var panel = document.getElementById('gameover-screen');
                    if (panel) panel.style.display = 'none';
                    if (typeof Controller.reset === 'function') Controller.reset();
                };
            }
        });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PATCH: Integrate Pass Year button updates with Controller lifecycle
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function() {
            // Patch window.startNewGame to update Pass Year buttons
            var origStartNewGame = window.startNewGame;
            window.startNewGame = function() {
                if (origStartNewGame) origStartNewGame();
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.updateUI to update Pass Year buttons
            var origUpdateUI = Controller.updateUI;
            Controller.updateUI = function() {
                if (origUpdateUI) origUpdateUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showSettlementUI to update Pass Year buttons
            var origShowSettlementUI = Controller.showSettlementUI;
            Controller.showSettlementUI = function() {
                if (origShowSettlementUI) origShowSettlementUI.call(this);
                if (typeof updatePassYearButton === 'function') updatePassYearButton();
            };
            
            // Patch Controller.showCityUI to update Pass Year buttons  
            if (Controller.showCityUI) {
                var origShowCityUI = Controller.showCityUI;
                Controller.showCityUI = function() {
                    if (origShowCityUI) origShowCityUI.call(this);
                    if (typeof updatePassYearButton === 'function') updatePassYearButton();
                };
            }
        })();
        
        document.getElementById('file-input').onchange=e=>{ 
            let r=new FileReader(); 
            r.onload=ev=>{ 
                try {
                    let saveData=JSON.parse(ev.target.result);
                    if(saveData.version && saveData.game) {
                        Object.assign(Game, saveData.game);
                        Object.assign(PROGRESSION, saveData.progression);
                        Controller.cam = saveData.camera;
                        
                        // Restore UI state based on progression
                        if(PROGRESSION.stage >= 1) {
                            Controller.showSettlementUI();
                        }
                        
                        Game.recalc();
                        Controller.updateUI();
                        Controller.toast("Game Loaded!");
                    } else {
                        Controller.toast("Invalid save file!");
                    }
                } catch(err) {
                    Controller.toast("Failed to load!");
                    console.error(err);
                }
            }; 
            r.readAsText(e.target.files[0]); 
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Q-LEARNING AI - Learns to play the game through reinforcement learning
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        var QLearningAI = {
            // Hyperparameters (TUNED FOR FASTER LEARNING)
            learningRate: 0.25,     // How quickly we update Q-values (was 0.1)
            discountFactor: 0.9,    // How much we value future rewards (was 0.95, lower = focus on immediate)
            explorationRate: 0.8,   // Start with 80% exploration (was 1.0, faster to exploit)
            explorationDecay: 0.98, // Decay exploration each episode (was 0.995, much faster decay)
            minExploration: 0.1,    // Minimum exploration rate (was 0.05, keep some exploration)
            
            // Q-table: state -> action -> value
            qTable: {},
            maxQTableSize: 50000, // Limit Q-table to prevent memory explosion
            
            // Training stats
            episode: 0,
            totalReward: 0,
            episodeRewards: [],
            bestScore: 0,
            gamesPlayed: 0,
            isTraining: false,
            trainingSpeed: 10, // 1 = normal, 10 = fast, 100 = ultra fast (default matches dropdown)
            isResetting: false, // Prevent multiple simultaneous resets
            lastExploredCount: 0,
            
            // === LEARNING ANALYTICS ===
            citiesBuilt: 0,         // Times AI successfully settled
            bestPopulation: 0,      // Highest population reached
            bestSurvivalYears: 0,   // Longest city survival
            balancedCities: 0,      // Cities with all 3 zone types balanced
            smartSettlements: 0,    // Settlements near resources (animals/berries)
            rewardHistory: [],      // Last 20 episode rewards for graph
            episodeStartSnapshotTaken: false,
            episodeStartPop: 0,
            episodeStartRes: 0,
            episodeStartStage: 0,
            episodeStartYear: 0,
            progressMade: false,
            lastExpansionRadius: 0,
            lastQuadrantCount: 0,
            lastStageAwarded: 0,
            lastLevelUnlockAward: 1,
            
            // === CURRICULUM LEARNING ===
            // Phase 1: Learn to survive WANDER (drink water, gather food)
            // Phase 2: Learn to settle successfully
            // Phase 3: Learn to build balanced cities
            learningPhase: 1,       // Current curriculum phase
            phase1Threshold: 10,    // Settle 10 times to move to phase 2
            phase2Threshold: 5,     // Build 5 balanced cities to move to phase 3
            
            // === IMITATION LEARNING (Watch & Learn from Player) ===
            isWatching: false,          // Is AI watching player?
            playerDemonstrations: [],    // Records of player actions
            watchStartState: null,       // State when watching started
            
            // === EXPLORATION TEST MODE ===
            explorationTestMode: false,  // Is exploration test active?
            exploreStats: {
                tilesVisited: new Set(),    // Set of "x,y" strings for visited tiles
                totalTiles: 0,              // Total explorable tiles on map
                resourcesCollected: 0,      // Total resources picked up
                berriesCollected: 0,
                woodCollected: 0,
                nomadsRecruited: 0,
                animalsHunted: 0,
                deaths: 0,                  // Total deaths during test
                totalSteps: 0,              // Steps taken across all runs
                stepsThisRun: 0,            // Steps in current run
                runsCompleted: 0,           // Number of exploration runs
                deathLocations: [],         // Array of {x, y, cause, steps}
                dangerZones: {},            // "x,y" -> death count
                startTime: null
            },
            
            // Actions the AI can take (includes Level 2-6 buildings!)
            actions: [
                'SETTLE', 'WANDER', 
                'BUILD_RES', 'BUILD_RES_L2', 'BUILD_RES_L3', 'BUILD_RES_L4', 'BUILD_RES_L5', 'BUILD_RES_L6',
                'BUILD_WELL', 'PASS_YEAR', 
                'BUILD_IND', 'BUILD_IND_L2', 'BUILD_IND_L3', 'BUILD_IND_L4', 'BUILD_IND_L5', 'BUILD_IND_L6',
                'BUILD_COM', 'BUILD_COM_L2', 'BUILD_COM_L3', 'BUILD_COM_L4', 'BUILD_COM_L5', 'BUILD_COM_L6',
                'BUILD_ROAD', 'WAIT', 'BUILD_CLAN_CHIEF', 'BUILD_DOCK', 'EXCHANGE_GOLD'
            ],
            macroPlaybooks: [
                {
                    id: 'early_twin_res',
                    name: 'Twin Huts Opener',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 }
                    ]
                },
                {
                    id: 'water_buffer',
                    name: 'Water Buffer Start',
                    steps: [
                        { action: 'BUILD_WELL' },
                        { action: 'BUILD_RES', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2, requirePop: 12 },
                        { action: 'BUILD_COM', waitYears: 1, minYear: 3, requireDemand: 'C' }
                    ]
                },
                {
                    id: 'wood_stack',
                    name: 'Wood Stockpile First',
                    steps: [
                        { action: 'PASS_YEAR', waitYears: 1 },
                        { action: 'PASS_YEAR', waitYears: 1 },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 2 }
                    ]
                },
                {
                    id: 'double_well_after50',
                    name: 'Double Wells After 50 Pop',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2, requirePop: 20 },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_COM', waitYears: 1, minYear: 6 }
                    ]
                },
                {
                    id: 'twin_roads_kickoff',
                    name: 'Twin Roads Kickoff',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_COM', waitYears: 1 }
                    ]
                },
                {
                    id: 'demand_cycle',
                    name: 'Demand Cycle Builder',
                    steps: [
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_DEMAND', waitYears: 2 }
                    ]
                },
                {
                    id: 'homeless_cover',
                    name: 'Homeless Cover Plan',
                    steps: [
                        { action: 'BUILD_RES', requireHousingNearFull: true },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', requireHousingNearFull: true, waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', requireHomeless: 1, waitYears: 2 }
                    ]
                },
                {
                    id: 'worker_gate',
                    name: 'Worker Gatekeeper',
                    steps: [
                        { action: 'BUILD_ROAD', requireWorkerShortage: false },
                        { action: 'BUILD_WELL', requireWorkerShortage: false, waitYears: 1 },
                        { action: 'BUILD_RES', requireWorkerShortage: true, waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_COM', waitYears: 1 }
                    ]
                },
                {
                    id: 'satisfaction_ladder',
                    name: 'Satisfaction Ladder',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 1 },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 2 },
                        { action: 'BUILD_COM', requireDemand: 'C', waitYears: 1 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'food_ratio_guard',
                    name: 'Food Ratio Guard',
                    steps: [
                        { action: 'BUILD_COM', requireFoodPerPop: 5, waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 1 },
                        { action: 'BUILD_COM', requireFoodPerPop: 4, waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'yearly_cycle',
                    name: 'Yearly Cycle Plan',
                    steps: [
                        { action: 'BUILD_RES', minYear: 1 },
                        { action: 'BUILD_ROAD', minYear: 2 },
                        { action: 'BUILD_WELL', minYear: 3 },
                        { action: 'BUILD_RES', minYear: 4 },
                        { action: 'BUILD_COM', minYear: 5 },
                        { action: 'BUILD_ROAD', minYear: 6 }
                    ]
                },
                {
                    id: 'double_res_pulse',
                    name: 'Double Residential Pulse',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_RES', waitYears: 3 },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 3 }
                    ]
                },
                {
                    id: 'tutorial_clone',
                    name: 'Tutorial Clone',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_WELL', waitYears: 2 },
                        { action: 'PASS_YEAR', waitYears: 7 },
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_COM' },
                        { action: 'BUILD_ROAD' }
                    ]
                },
                {
                    id: 'builder_merchant_split',
                    name: 'Builder Merchant Split',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_COM', minYear: 8, waitYears: 1 },
                        { action: 'BUILD_COM', minYear: 10, waitYears: 1 }
                    ]
                },
                {
                    id: 'industrial_threshold',
                    name: 'Industrial Threshold',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_COM', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_IND', requirePop: 25, requireFood: 1000, requireWood: 1000, waitYears: 5 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                },
                {
                    id: 'rain_balance',
                    name: 'Rain Balance',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_COM', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 2, requireNeeds: ['water'] },
                        { action: 'BUILD_DEMAND', waitYears: 1 }
                    ]
                },
                {
                    id: 'panic_flow',
                    name: 'Panic Flow',
                    steps: [
                        { action: 'BUILD_WELL', requireNeeds: ['water'] },
                        { action: 'BUILD_RES', requireNeeds: ['housing'], waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 1 }
                    ]
                },
                {
                    id: 'balanced_pairing',
                    name: 'Balanced Pairing',
                    steps: [
                        { action: 'BUILD_RES' },
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 },
                        { action: 'BUILD_WELL', waitYears: 1 }
                    ]
                },
                {
                    id: 'road_grid_first',
                    name: 'Road Grid First',
                    steps: [
                        { action: 'BUILD_ROAD' },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 2 },
                        { action: 'BUILD_RES', waitYears: 2 },
                        { action: 'BUILD_WELL', waitYears: 1 },
                        { action: 'BUILD_COM', waitYears: 2 }
                    ]
                },
                {
                    id: 'scout_stall',
                    name: 'Scout And Stall',
                    steps: [
                        { action: 'PASS_YEAR', waitYears: 1, maxYear: 2 },
                        { action: 'PASS_YEAR', waitYears: 1, maxYear: 3 },
                        { action: 'BUILD_DEMAND', waitYears: 1 },
                        { action: 'BUILD_DEMAND', waitYears: 2 },
                        { action: 'BUILD_ROAD', waitYears: 1 }
                    ]
                }
            ],
            activeMacroTactic: null,
            macroStepIndex: 0,
            macroWaitUntilYear: 0,
            macroRotationIndex: 0,
            
            assignMacroTactic: function(advance = false) {
                if(!this.macroPlaybooks || this.macroPlaybooks.length === 0) {
                    this.activeMacroTactic = null;
                    return;
                }
                
                // Initialize tactic stats if needed
                if(!this.tacticStats) this.tacticStats = {};
                for(let pb of this.macroPlaybooks) {
                    if(!this.tacticStats[pb.id]) {
                        this.tacticStats[pb.id] = { attempts: 0, successes: 0, totalYears: 0, maxPop: 0, avgScore: 0 };
                    }
                }
                
                // Smart tactic selection: favor successful tactics, but still explore
                let candidates = this.macroPlaybooks.slice();
                if(Math.random() < 0.7 && this.episode > 10) { // 70% chance to pick strategically after 10 episodes
                    // Sort by success rate + average score
                    candidates.sort((a, b) => {
                        let statsA = this.tacticStats[a.id] || { attempts: 0, avgScore: 0 };
                        let statsB = this.tacticStats[b.id] || { attempts: 0, avgScore: 0 };
                        let scoreA = statsA.attempts > 0 ? (statsA.successes / statsA.attempts * 100 + statsA.avgScore) : 50;
                        let scoreB = statsB.attempts > 0 ? (statsB.successes / statsB.attempts * 100 + statsB.avgScore) : 50;
                        return scoreB - scoreA;
                    });
                    // Pick from top 5 with weighted random
                    let topN = candidates.slice(0, Math.min(5, candidates.length));
                    let weights = topN.map((_, i) => Math.pow(0.6, i));
                    let totalWeight = weights.reduce((a, b) => a + b, 0);
                    let r = Math.random() * totalWeight;
                    let cumulative = 0;
                    for(let i = 0; i < topN.length; i++) {
                        cumulative += weights[i];
                        if(r <= cumulative) {
                            this.activeMacroTactic = topN[i];
                            break;
                        }
                    }
                } else {
                    // Random exploration
                    if(advance || this.macroRotationIndex === undefined) {
                        this.macroRotationIndex = Math.floor(Math.random() * candidates.length);
                    }
                    this.activeMacroTactic = candidates[this.macroRotationIndex];
                }
                
                this.macroStepIndex = 0;
                this.macroWaitUntilYear = 0;
                
                if(this.activeMacroTactic) {
                    this.tacticStats[this.activeMacroTactic.id].attempts++;
                    let stats = this.tacticStats[this.activeMacroTactic.id];
                    let successRate = stats.attempts > 0 ? Math.round(stats.successes / stats.attempts * 100) : 0;
                    this.log(`ğŸ“˜ Tactic: ${this.activeMacroTactic.name} (${successRate}% success, ${stats.attempts} tries)`);
                }
            },

            getMacroAction: function(context) {
                if(!this.activeMacroTactic || !context || Game.gameState !== 'CITY') return null;
                if(this.macroStepIndex >= this.activeMacroTactic.steps.length) return null;
                if(this.macroWaitUntilYear && (Game.year || 0) < this.macroWaitUntilYear) return null;
                let step = this.activeMacroTactic.steps[this.macroStepIndex];
                if(!this.macroConditionsMet(step, context)) return null;
                let resolvedAction = this.resolveMacroAction(step, context);
                if(!resolvedAction) return null;
                if(!this.canAffordMacroAction(resolvedAction, context)) return null;
                this.log(`ğŸ“˜ Macro ${this.activeMacroTactic.name}: ${resolvedAction}`);
                this.macroStepIndex++;
                this.macroWaitUntilYear = (Game.year || 0) + (step.waitYears || 0);
                if(this.macroStepIndex >= this.activeMacroTactic.steps.length) {
                    this.log(`ğŸ“— Macro ${this.activeMacroTactic.name} complete.`);
                    this.activeMacroTactic = null;
                }
                return resolvedAction;
            },

            macroConditionsMet: function(step, context) {
                if(!step) return false;
                if(step.minYear !== undefined && context.year < step.minYear) return false;
                if(step.maxYear !== undefined && context.year > step.maxYear) return false;
                if(step.requirePop !== undefined && context.pop < step.requirePop) return false;
                if(step.requireDemand && context.highestDemand !== step.requireDemand) return false;
                if(step.requireNeeds) {
                    for(let need of step.requireNeeds) {
                        if(need === 'water' && !context.needsWater) return false;
                        if(need === 'food' && !context.needsFood) return false;
                        if(need === 'housing' && !context.needsHousing) return false;
                    }
                }
                if(step.requireHousingNearFull && !context.housingNearFull) return false;
                if(step.requireHomeless && context.homeless < step.requireHomeless) return false;
                if(step.requireWorkerShortage === true && !context.workerShortage) return false;
                if(step.requireWorkerShortage === false && context.workerShortage) return false;
                if(step.requireFood && context.food < step.requireFood) return false;
                if(step.requireWood && context.wood < step.requireWood) return false;
                if(step.requireFoodPerPop && (context.pop === 0 || (context.food / Math.max(1, context.pop)) < step.requireFoodPerPop)) return false;
                return true;
            },

            resolveMacroAction: function(step, context) {
                if(!step) return null;
                if(step.action === 'BUILD_DEMAND') {
                    if(context.highestDemand === 'R') return 'BUILD_RES';
                    if(context.highestDemand === 'C') return 'BUILD_COM';
                    return 'BUILD_IND';
                }
                return step.action;
            },

            canAffordMacroAction: function(action, context) {
                switch(action) {
                    case 'BUILD_RES':
                        return context.food >= context.resCost.food && context.wood >= context.resCost.wood;
                    case 'BUILD_COM':
                        return context.food >= context.comCost.food && context.wood >= context.comCost.wood;
                    case 'BUILD_IND':
                        return context.food >= context.indCost.food && context.wood >= context.indCost.wood;
                    case 'BUILD_WELL':
                        return context.food >= context.wellCost;
                    case 'BUILD_ROAD':
                        return context.food >= context.roadCost;
                    case 'PASS_YEAR':
                        return true;
                    default:
                        return true;
                }
            },

            // Get discretized state representation
            getState: function() {
                // Track population in WANDER mode too! AI needs to know nomad count
                if(!Game) return 'WANDER_P0';

                let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                let highestUnlock = 1;
                if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                    highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                }
                let civLevel = Game.civLevel || Game.level || 1;

                let pop = Game.pop || 0;
                let popBucket = Math.min(10, Math.floor(pop / 5)); // 0-10 (tracks 0-50 nomads in groups of 5)
                
                if(Game.gameState === 'WANDER') {
                    // Include food and wood status for settling decisions
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    let foodOK = food >= 100 ? 1 : 0;
                    let woodOK = wood >= 25 ? 1 : 0;
                    return `WANDER_S${stage}_LV${highestUnlock}_P${popBucket}_F${foodOK}_W${woodOK}`;
                }
                
                // CITY mode - detailed state
                let foodBucket = Math.min(5, Math.floor((Game.food || 0) / 100)); // 0-5
                let woodBucket = Math.min(5, Math.floor((Game.wood || 0) / 50)); // 0-5
                let wellCount = Math.min(3, Game.wellCount || 0); // 0-3
                let resCount = Math.min(5, Game.zoneCount || 0); // Use zoneCount for residential
                let indCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0);
                let comCount = Math.min(3, Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0);
                let roadCount = Math.min(5, Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0);
                let hasWaterCrisis = (Game.wellCount === 0 && Game.pop > 5) ? 1 : 0;
                let hasFoodCrisis = (Game.food < Game.pop * 2) ? 1 : 0;
                let expansion = this.getCityExpansionStats();
                let expansionBucket = Math.min(9, Math.floor(expansion.radius / 5));
                let roadFrontBucket = Math.min(9, Math.floor(expansion.roadFrontier / 5));
                let quadrantBucket = Math.min(4, expansion.quadrants || 0);

                return `S${stage}LV${highestUnlock}CV${Math.min(9, Math.floor(civLevel))}P${popBucket}F${foodBucket}W${woodBucket}WL${wellCount}R${resCount}I${indCount}C${comCount}RD${roadCount}WC${hasWaterCrisis}FC${hasFoodCrisis}EX${expansionBucket}RF${roadFrontBucket}Q${quadrantBucket}`;
            },

            // Count explored tiles around player (small radius for cheap signal)
            localExploredCount: function(radius = 3) {
                if(!Game || !Game.player || !Game.tiles) return 0;
                let cx = Game.player.x, cy = Game.player.y;
                let count = 0;
                for(let x = cx - radius; x <= cx + radius; x++) {
                    for(let y = cy - radius; y <= cy + radius; y++) {
                        if(x>=0 && y>=0 && x < Game.tiles.length && y < Game.tiles[0].length) {
                            let t = Game.tiles[x][y];
                            if(t && t.explored) count++;
                        }
                    }
                }
                return count;
            },

            getCityExpansionStats: function() {
                if(!Game || !Game.blds || Game.blds.length === 0) {
                    return { radius: 0, roadFrontier: 0, quadrants: 0 };
                }

                let origin = Game.settlementPos || this.aiSettlementPos;
                if(!origin) {
                    if(Game.player) origin = { x: Game.player.x, y: Game.player.y };
                    else {
                        let first = Game.blds[0];
                        origin = { x: (first && first.x) || 0, y: (first && first.y) || 0 };
                    }
                }

                let maxDist = 0;
                let roadFrontier = 0;
                let quadrants = new Set();

                for(let b of Game.blds) {
                    if(b.x === undefined || b.y === undefined) continue;
                    let dx = b.x - origin.x;
                    let dy = b.y - origin.y;
                    let manhattan = Math.abs(dx) + Math.abs(dy);
                    if(manhattan > maxDist) maxDist = manhattan;
                    if(b.t === 'ROAD' && manhattan > roadFrontier) roadFrontier = manhattan;
                    if(manhattan > 0) {
                        let quad;
                        if(dx >= 0 && dy >= 0) quad = 'SE';
                        else if(dx >= 0 && dy < 0) quad = 'NE';
                        else if(dx < 0 && dy >= 0) quad = 'SW';
                        else quad = 'NW';
                        quadrants.add(quad);
                    }
                }

                return { radius: maxDist, roadFrontier, quadrants: quadrants.size };
            },
            
            // Check if player is near water (for settlement)
            checkNearWater: function() {
                if(!Game || !Game.player || !Game.tiles) return false;
                const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                let px = Game.player.x, py = Game.player.y;
                for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                    for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                        let x = px + dx, y = py + dy;
                        if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                            let tile = Game.tiles[x][y];
                            if(tile && (tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP')) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            },
            
            // Find nearest water source for WANDER mode seeking
            findNearestWater: function() {
                if(!Game || !Game.player || !Game.tiles) return null;
                let px = Game.player.x, py = Game.player.y;
                let bestDist = Infinity, bestPos = null;
                for(let radius = 1; radius <= 20; radius++) {
                    for(let dx = -radius; dx <= radius; dx++) {
                        for(let dy = -radius; dy <= radius; dy++) {
                            if(Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
                            let x = px + dx, y = py + dy;
                            if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                let tile = Game.tiles[x][y];
                                if(tile && tile.explored && (tile.type === 'WATER' || tile.type === 'RIVER')) {
                                    let dist = Math.abs(dx) + Math.abs(dy);
                                    if(dist < bestDist) {
                                        bestDist = dist;
                                        bestPos = {x, y};
                                    }
                                }
                            }
                        }
                    }
                    if(bestPos) break;
                }
                return bestPos;
            },
            
            // Track death cause for learning
            recordDeath: function(cause) {
                this.lastDeathCause = cause;
                this.consecutiveDeaths = (this.consecutiveDeaths || 0) + 1;
                this.deathCauses = this.deathCauses || {};
                this.deathCauses[cause] = (this.deathCauses[cause] || 0) + 1;
                
                // Track tactic failure
                if(this.activeMacroTactic && this.tacticStats) {
                    // Don't count as success
                    this.log(`âŒ Tactic ${this.activeMacroTactic.name} failed: ${cause}`);
                }
            },
            
            // Track successful episode for tactic learning
            recordSuccess: function(pop, year) {
                if(this.activeMacroTactic && this.tacticStats) {
                    let stats = this.tacticStats[this.activeMacroTactic.id];
                    if(stats) {
                        if(year >= 5 && pop >= 10) { // Count as success if survived 5 years with 10+ pop
                            stats.successes++;
                        }
                        stats.totalYears += year;
                        stats.maxPop = Math.max(stats.maxPop, pop);
                        stats.avgScore = stats.attempts > 0 ? 
                            Math.round((stats.totalYears / stats.attempts) * 10 + stats.maxPop) : 0;
                    }
                }
                this.consecutiveDeaths = 0; // Reset streak on good run
            },
            
            // Get population-tier based strategy advice
            getPopTierStrategy: function(pop) {
                // Returns strategic guidance based on city population tier
                if(pop < 10) {
                    return {
                        tier: 'startup',
                        priority: 'survival',
                        waterRatio: 0.15, // water wells per pop
                        comRatio: 0.2,    // commercial per residential
                        indThreshold: 999, // don't build industrial yet
                        roadsPer: 3,      // roads per total buildings
                        expandRate: 0,    // don't expand yet
                        hint: 'Focus on first residential and well'
                    };
                } else if(pop < 25) {
                    return {
                        tier: 'growth',
                        priority: 'population',
                        waterRatio: 0.12,
                        comRatio: 0.25,
                        indThreshold: 200, // can consider industrial
                        roadsPer: 2.5,
                        expandRate: 1,    // expand slowly
                        hint: 'Build residential, add commercial for production'
                    };
                } else if(pop < 50) {
                    return {
                        tier: 'expansion',
                        priority: 'diversity',
                        waterRatio: 0.1,
                        comRatio: 0.33,
                        indThreshold: 100, // should have industrial
                        roadsPer: 2,
                        expandRate: 2,    // expand moderately
                        hint: 'Balance RCI, push road frontier'
                    };
                } else if(pop < 100) {
                    return {
                        tier: 'city',
                        priority: 'efficiency',
                        waterRatio: 0.08,
                        comRatio: 0.4,
                        indThreshold: 50,
                        roadsPer: 1.5,
                        expandRate: 3,    // expand aggressively
                        hint: 'Maximize industrial, expand into new quadrants'
                    };
                } else {
                    return {
                        tier: 'metropolis',
                        priority: 'dominance',
                        waterRatio: 0.06,
                        comRatio: 0.5,
                        indThreshold: 25,
                        roadsPer: 1,
                        expandRate: 5,    // expand very aggressively
                        hint: 'Fill all quadrants, reach Level 3+'
                    };
                }
            },
            
            // Analyze what's blocking progress and suggest fixes
            diagnoseBlocker: function() {
                if(!Game || Game.gameState !== 'CITY') return null;
                
                let pop = Game.pop || 0;
                let food = Game.food || 0;
                let wood = Game.wood || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.blds ? Game.blds.filter(b => b.t === 'RES').length : 0;
                let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                let waterCap = wellCount * 100;
                let housingCap = resCount * 10;
                
                let blockers = [];
                
                // Check water
                if(pop > waterCap * 0.8) {
                    blockers.push({ issue: 'water', severity: pop > waterCap ? 'critical' : 'warning', fix: 'BUILD_WELL' });
                }
                
                // Check housing
                if(pop >= housingCap - 2) {
                    blockers.push({ issue: 'housing', severity: pop >= housingCap ? 'critical' : 'warning', fix: 'BUILD_RES' });
                }
                
                // Check food production
                if(food < pop * 5) {
                    blockers.push({ issue: 'food', severity: food < pop * 2 ? 'critical' : 'warning', fix: 'BUILD_COM' });
                }
                
                // Check wood production
                if(wood < 50 && comCount > 0) {
                    blockers.push({ issue: 'wood', severity: 'warning', fix: 'BUILD_COM' });
                }
                
                // Check industrial readiness
                if(indCount === 0 && pop >= 25 && resCount >= 4 && comCount >= 1) {
                    blockers.push({ issue: 'no-industrial', severity: 'opportunity', fix: 'BUILD_IND' });
                }
                
                // Check expansion
                let expansion = this.getCityExpansionStats();
                if(expansion.quadrants < 2 && pop >= 30) {
                    blockers.push({ issue: 'cramped', severity: 'opportunity', fix: 'BUILD_ROAD' });
                }
                
                return blockers.length > 0 ? blockers : null;
            },
            
            // Get Q-value for state-action pair
            getQ: function(state, action) {
                if(!this.qTable[state]) this.qTable[state] = {};
                if(this.qTable[state][action] === undefined) this.qTable[state][action] = 0;
                return this.qTable[state][action];
            },
            
            // Update Q-value
            updateQ: function(state, action, reward, nextState) {
                let currentQ = this.getQ(state, action);
                let maxNextQ = Math.max(...this.actions.map(a => this.getQ(nextState, a)));
                let newQ = currentQ + this.learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
                
                // Limit Q-table size to prevent memory explosion
                let stateCount = Object.keys(this.qTable).length;
                if(stateCount >= this.maxQTableSize) {
                    // Remove oldest/lowest-value states
                    this.pruneQTable();
                }
                
                if(!this.qTable[state]) this.qTable[state] = {};
                this.qTable[state][action] = newQ;
            },
            
            // Prune Q-table to prevent memory explosion
            pruneQTable: function() {
                let states = Object.keys(this.qTable);
                if(states.length < this.maxQTableSize * 0.9) return;
                
                // Calculate average Q-value per state
                let stateScores = states.map(s => {
                    let actions = this.qTable[s];
                    let values = Object.values(actions);
                    let maxQ = values.length > 0 ? Math.max(...values) : 0;
                    return { state: s, score: maxQ };
                });
                
                // Sort by score (lowest first) and remove bottom 20%
                stateScores.sort((a, b) => a.score - b.score);
                let removeCount = Math.floor(states.length * 0.2);
                for(let i = 0; i < removeCount; i++) {
                    delete this.qTable[stateScores[i].state];
                }
                console.log(`[AI] Pruned Q-table: removed ${removeCount} low-value states`);
            },
            
            // Choose action using epsilon-greedy policy - POPULATION MAXIMIZER
            // NOW PRIORITIZES PLAYBOOKS FROM WATCHING PLAYER!
            chooseAction: function(state) {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRIORITY 0: Replay mode - follow best run exactly
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(this.useReplayMode) {
                    let replayAction = this.getReplayAction();
                    if(replayAction) {
                        this.log(`ğŸ”„ Replay: ${replayAction}`);
                        return replayAction;
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRIORITY 0.5: Check for known failure state - take evasive action
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let failureCheck = this.isKnownFailureState();
                if(failureCheck && Game.gameState === 'CITY') {
                    this.log(`âš ï¸ Known failure pattern ${failureCheck.pattern} - taking evasive action`);
                    // If water-related, build well
                    if(failureCheck.pattern.includes('water') || failureCheck.pattern.includes('thirst')) {
                        if(Game.food >= 20) return 'BUILD_WELL';
                    }
                    // If famine, build commercial
                    if(failureCheck.pattern.includes('famine')) {
                        if(Game.food >= 200 && Game.wood >= 200) return 'BUILD_COM';
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRIORITY 1: If we have a playbook from watching player, USE IT!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(this.savedPlaybooks && this.savedPlaybooks.length > 0 && this.usePlaybook !== false) {
                    // Initialize playbook tracking
                    if(this.playbookStep === undefined) this.playbookStep = 0;
                    
                    let playbook = this.savedPlaybooks[0].playbook;
                    
                    if(this.playbookStep < playbook.length) {
                        let step = playbook[this.playbookStep];
                        let currentYear = Game.year || 0;
                        
                        // Wait if timing doesn't match yet
                        if(step.yearsSinceLastBuild > 1 && this.lastAIBuildYear !== undefined) {
                            let yearsWaited = currentYear - this.lastAIBuildYear;
                            if(yearsWaited < step.yearsSinceLastBuild - 1) {
                                return 'PASS_YEAR'; // Wait like player did
                            }
                        }
                        
                        // Execute the recorded action
                        return step.action;
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FALLBACK: Original AI behavior
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // 1. WANDER MODE - Gather resources and nomads, then settle near water
                if (Game && Game.gameState === 'WANDER') {
                    const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                    let pop = Game.pop || 0;
                    let food = Game.inventory ? Game.inventory.food : 0;
                    let wood = Game.inventory ? Game.inventory.wood : 0;
                    let thirst = Game.thirst || 100;
                    let thirstCounter = Game.thirstCounter || 0;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CRITICAL: THIRST SURVIVAL - Check every step if we need water!
                    // Game rule: Must drink every 100 steps or die
                    // AI rule: Start seeking water at 70 steps (thirst=30), URGENT at 85 steps
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Check if near drinkable water right now
                    let nearWater = this.checkNearWater();
                    
                    // URGENT WATER MODE: If thirst is critical (<30), drop everything and find water!
                    if(thirst < 30 || thirstCounter > 70) {
                        this.log(`ğŸš¨ THIRST CRITICAL! thirst=${thirst} counter=${thirstCounter} - MUST find water!`);
                        
                        // If already near water, just keep wandering (will auto-drink)
                        if(nearWater) {
                            this.log('ğŸ’§ Near water - drinking!');
                            return 'WANDER'; // Will walk to water and drink
                        }
                        
                        // Force water-seeking mode
                        this.waterSeekMode = true;
                        return 'WANDER'; // executeAction will prioritize water
                    }
                    
                    // PRE-EMPTIVE WATER SEEKING: At 50 thirst, start looking for water proactively
                    if(thirst < 50 || thirstCounter > 50) {
                        if(!nearWater) {
                            this.waterSeekMode = true;
                            this.log(`ğŸ’§ Thirst at ${thirst} (step ${thirstCounter}) - seeking water proactively`);
                        }
                    }
                    
                    // === ADAPTIVE SETTLING BASED ON DEATH HISTORY ===
                    // If we keep dying from water/food issues, settle sooner
                    let settleEarly = this.consecutiveDeaths > 3 || 
                                     (this.lastDeathCause === 'thirst' && this.consecutiveDeaths > 1);
                    
                    // Settlement thresholds - adapt based on past failures
                    const MIN_NOMADS_IDEAL = settleEarly ? 5 : 10;
                    const MIN_FOOD_THRESHOLD = settleEarly ? REQ.MIN_FOOD : 150;
                    const MIN_WOOD_THRESHOLD = settleEarly ? REQ.MIN_WOOD : 40;
                    
                    // Check if we have enough resources
                    let hasEnoughFood = food >= MIN_FOOD_THRESHOLD;
                    let hasEnoughWood = wood >= MIN_WOOD_THRESHOLD;
                    let hasBasicResources = hasEnoughFood && hasEnoughWood;
                    
                    // nearWater already checked above
                    
                    // Urgent settle if thirst is low and we found water
                    if (thirst < 40 && nearWater && food >= REQ.MIN_FOOD && wood >= REQ.MIN_WOOD && pop >= REQ.MIN_POP) {
                        this.log('ğŸ†˜ URGENT: Low thirst, settling near water!');
                        return 'SETTLE';
                    }
                    
                    // Settle if: have resources AND near water AND enough nomads
                    let shouldSettle = hasBasicResources && nearWater &&
                                      (pop >= MIN_NOMADS_IDEAL || 
                                       (pop >= 5 && food >= 200 && wood >= 50));
                    
                    // Also settle if we've been wandering too long (>50 steps) with minimum requirements
                    if (!shouldSettle && this.stepCount > 50 && nearWater && 
                        food >= REQ.MIN_FOOD && wood >= REQ.MIN_WOOD && pop >= REQ.MIN_POP) {
                        this.log('â° Long wander - settling with minimum requirements');
                        shouldSettle = true;
                    }
                    
                    if (shouldSettle) {
                        this.consecutiveDeaths = 0; // Reset on successful settle attempt
                        return 'SETTLE';
                    }
                    
                    // If we have resources but not near water, actively seek water
                    if (hasBasicResources && pop >= REQ.MIN_POP && !nearWater) {
                        this.waterSeekMode = true;
                        this.log('ğŸ” Seeking water for settlement...');
                    }
                    
                    // Keep wandering to gather nomads, food, and wood
                    return 'WANDER';
                }
                
                // 2. CITY MODE - TUTORIAL-BASED BUILDING (Step by step guide)
                if (Game && Game.gameState === 'CITY') {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // AI GAME STATE READER - Read ENTIRE UI like a human would
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // === BUILDING COUNTS (from game state) ===
                    let resCount = Game.zoneCount || 0;  // Residential zones
                    let wellCount = Game.blds ? Game.blds.filter(b => b.t === 'WELL').length : 0;
                    let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    let roadCount = Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0;
                    
                    // === RESOURCE VALUES (same as dashboard shows) ===
                    let pop = Game.pop || 0;
                    let wood = Game.wood || 0;
                    let food = Game.food || 0;
                    let housingCap = Game.housingCap || 0;
                    let year = Game.year || 0;
                    
                    // Get costs from config EARLY
                    let resCost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1] ? CFG.BUILDING_LEVELS[1] : { food: 100, wood: 100 };
                    let wellCost = CFG.COST && CFG.COST.WELL ? CFG.COST.WELL : 20;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // STARTUP STRATEGY: First thing in CITY mode = RES + WELL + PASS_YEAR!
                    // This is the MOST IMPORTANT rule - get income flowing first!
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if(year === 0 && resCount === 0 && wellCount === 0) {
                        // YEAR 0 STARTUP: Build first residential
                        if(food >= resCost.food && wood >= resCost.wood) {
                            this.log('ğŸ¯ STARTUP: Year 0 - Building first Residential!');
                            return 'BUILD_RES';
                        }
                    }
                    
                    if(year === 0 && resCount >= 1 && wellCount === 0) {
                        // YEAR 0 STARTUP: Build first well (critical for water!)
                        if(food >= wellCost) {
                            this.log('ğŸ¯ STARTUP: Year 0 - Building first Well!');
                            return 'BUILD_WELL';
                        }
                    }
                    
                    if(year === 0 && resCount >= 1 && wellCount >= 1) {
                        // YEAR 0 STARTUP COMPLETE: Pass year to get income!
                        this.log('ğŸ¯ STARTUP COMPLETE: Passing year to start income flow!');
                        return 'PASS_YEAR';
                    }
                    let gold = Game.gold || 0;
                    let metal = Game.metal || 0;
                    let stone = Game.stone || 0;
                    
                    // === WATER STATUS (exact same calc as UI shows) ===
                    let waterCapacity = wellCount * 100;
                    let waterPercent = waterCapacity > 0 ? Math.round((pop / waterCapacity) * 100) : 0;
                    let wellsNeeded = Math.ceil(pop / 100);
                    let wellsWithBuffer = wellsNeeded;
                    if (pop > 50) {
                        wellsWithBuffer += 2; // Only add 2-buffer once past 50 pop
                    }
                    let needMoreWells = wellCount < wellsWithBuffer;
                    let baseWellDeficit = wellCount < wellsNeeded;
                    let bufferWellNeeded = !baseWellDeficit && needMoreWells;
                    let waterCrisis = pop > waterCapacity;
                    
                    // === RCI DEMAND (same as the R/C/I bars in UI) ===
                    let rci = Game.calculateRCIDemand ? Game.calculateRCIDemand() : { r: 50, c: 50, i: 50 };
                    let rDemand = rci.r; // Residential demand %
                    let cDemand = rci.c; // Commercial demand %
                    let iDemand = rci.i; // Industrial demand %
                    let highestDemand = rDemand >= cDemand && rDemand >= iDemand ? 'R' : (cDemand >= iDemand ? 'C' : 'I');
                    
                    // === WORKFORCE STATUS (same as workforce display) ===
                    let workforce = Game.workforce || { gatherers: 0, shortage: 0 };
                    let workerShortage = workforce.shortage > 0;
                    
                    // === HOUSING STATUS ===
                    let housingFull = pop >= housingCap;
                    let housingNearFull = pop >= housingCap - 2;
                    let homeless = Math.max(0, pop - housingCap);
                    
                    // === SATISFACTION/NEEDS (from needs warning panel) ===
                    let satisfaction = Game.satisfaction || 100;
                    let needsWater = waterPercent > 80 || waterCrisis;
                    let needsFood = food < pop * 5; // Less than 5 food per person
                    let needsHousing = housingFull || homeless > 0;
                    let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                    let highestUnlock = 1;
                    if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                        highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                    }
                    let civLevel = Game.civLevel || Game.level || 1;
                    let expansionStats = this.getCityExpansionStats();
                    
                    // Get additional costs from config (resCost/wellCost already declared above)
                    let comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                    let indCost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[1] ? CFG.INDUSTRIAL_LEVELS[1] : { food: 1000, wood: 1000 };
                    let roadCost = CFG.COST && CFG.COST.ROAD ? CFG.COST.ROAD : 5;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // AI "SEES" THE UI - Log what AI understands from the display
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let tierStrategy = this.getPopTierStrategy(pop);
                    let blockers = this.diagnoseBlocker();
                    
                    this.log(`ğŸ‘ï¸ AI READS UI:`);
                    this.log(`   ğŸ—ºï¸ Stage ${stage} | Civ L${civLevel} | Unlock L${highestUnlock}`);
                    this.log(`   ğŸ“Š Pop: ${pop}/${housingCap} | Food: ${Math.floor(food)} | Wood: ${Math.floor(wood)} | Year: ${year}`);
                    this.log(`   ğŸ’§ Water: ${waterPercent}% (${wellCount} wells, need ${wellsWithBuffer}) ${waterCrisis ? 'ğŸš¨CRISIS!' : needMoreWells ? 'âš ï¸LOW' : 'âœ…OK'}`);
                    this.log(`   ğŸ“ˆ RCI Demand: R:${rDemand}% C:${cDemand}% I:${iDemand}% â†’ Build ${highestDemand}`);
                    this.log(`   ğŸ—ï¸ Buildings: Res:${resCount} Com:${comCount} Ind:${indCount} Well:${wellCount} Road:${roadCount}`);
                    this.log(`   ğŸŒ Expansion: radius ${expansionStats.radius} | road push ${expansionStats.roadFrontier} | quadrants ${expansionStats.quadrants}`);
                    this.log(`   ğŸ“Š Tier: ${tierStrategy.tier} | Priority: ${tierStrategy.priority} | ${tierStrategy.hint}`);
                    if(blockers && blockers.length > 0) {
                        let blockerStr = blockers.map(b => `${b.issue}(${b.severity})`).join(', ');
                        this.log(`   ğŸš§ Blockers: ${blockerStr}`);
                    }
                    this.log(`   âš ï¸ Needs: ${needsWater ? 'WATER! ' : ''}${needsFood ? 'FOOD! ' : ''}${needsHousing ? 'HOUSING! ' : homeless > 0 ? homeless + ' HOMELESS! ' : ''}${workerShortage ? 'WORKERS!' : ''}`);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CRITICAL BLOCKER FIX - Handle critical issues immediately
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if(blockers) {
                        let critical = blockers.find(b => b.severity === 'critical');
                        if(critical) {
                            let fix = critical.fix;
                            // Check if we can afford the fix
                            if(fix === 'BUILD_WELL' && food >= wellCost) {
                                this.log(`ğŸš¨ CRITICAL FIX: ${critical.issue} â†’ ${fix}`);
                                return fix;
                            }
                            if(fix === 'BUILD_RES' && food >= resCost.food && wood >= resCost.wood) {
                                this.log(`ğŸš¨ CRITICAL FIX: ${critical.issue} â†’ ${fix}`);
                                return fix;
                            }
                            if(fix === 'BUILD_COM' && food >= comCost.food && wood >= comCost.wood) {
                                this.log(`ğŸš¨ CRITICAL FIX: ${critical.issue} â†’ ${fix}`);
                                return fix;
                            }
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // WISDOM-BASED DECISIONS - Use learned rules
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if(this.wisdom && this.wisdom.survivalRules) {
                        // Build context for wisdom evaluation
                        let ctx = {
                            pop: pop,
                            wellCount: wellCount,
                            housingCap: housingCap,
                            food: food,
                            wood: wood,
                            roadCount: roadCount,
                            resCount: resCount,
                            comCount: comCount,
                            indCount: indCount,
                            wellCost: wellCost,
                            resCost: resCost,
                            comCost: comCost,
                            indCost: indCost,
                            roadCost: roadCost
                        };
                        
                        // Try wisdom-based action (70% chance to use wisdom)
                        if(Math.random() < 0.7) {
                            let wisdomAction = this.getWisdomAction(ctx);
                            if(wisdomAction) {
                                this.log(`ğŸ§  Wisdom suggests: ${wisdomAction}`);
                                return wisdomAction;
                            }
                        }
                        
                        // Try flow-based action (for early game)
                        let buildCount = (Game.blds ? Game.blds.length : 0);
                        if(buildCount < 10) {
                            let flowAction = this.getFlowAction(buildCount);
                            if(flowAction && this.canAffordAction(flowAction, ctx)) {
                                this.log(`ğŸ”„ Flow suggests: ${flowAction}`);
                                return flowAction;
                            }
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TUTORIAL MODE (1 in 5 episodes) - Strict scripted build order
                    // This teaches the AI a good baseline strategy
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Initialize tutorial tracking
                    if (this.tutorialMode === undefined) {
                        // 20% chance to follow tutorial (1 in 5)
                        this.tutorialMode = (this.episode % 5 === 0);
                        this.tutorialStep = 0;
                        this.tutorialCycle = 0; // 0-3, repeat 4 times before industrial
                        this.tutorialWaitUntilYear = 0;
                        this.log(`ğŸ“š Tutorial mode: ${this.tutorialMode ? 'ACTIVE' : 'OFF'} (Episode ${this.episode})`);
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // SUCCESS TEMPLATE GUIDANCE (20% chance to follow proven patterns)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let ctx = { pop, food, wood, year, highestDemand, needsWater, needsFood, needsHousing, 
                               workerShortage, homeless, housingNearFull, resCost, wellCost, comCost, indCost, roadCost };
                    let templateAction = this.getTemplateGuidedAction(ctx);
                    if(templateAction) {
                        return templateAction;
                    }

                    if(!this.tutorialMode) {
                        let macroAction = this.getMacroAction({
                            pop,
                            food,
                            wood,
                            year,
                            highestDemand,
                            needsWater,
                            needsFood,
                            needsHousing,
                            workerShortage,
                            homeless,
                            housingNearFull,
                            resCost,
                            wellCost,
                            comCost,
                            indCost,
                            roadCost
                        });
                        if(macroAction) {
                            return macroAction;
                        }
                    }
                    
                    // Log current state for debugging
                    this.log(`ğŸ“Š AI State: Res=${resCount} Well=${wellCount}/${wellsWithBuffer} Road=${roadCount} Com=${comCount} Ind=${indCount} Pop=${pop}/${housingCap} Water=${waterPercent}% Year=${year}`);
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // EMERGENCY: Water crisis takes priority!
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (waterCrisis && food >= wellCost) {
                        this.log('ğŸš¨ EMERGENCY: Water crisis! Building well immediately!');
                        return 'BUILD_WELL';
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // TUTORIAL MODE - Strict scripted build order
                    // Cycle: RES â†’ ROAD(2) â†’ WELL â†’ wait 7yrs â†’ RES + COM + extend road
                    // Repeat 4 times, then build first Industrial
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (this.tutorialMode) {
                        // Tutorial Step Logic
                        // Steps per cycle:
                        // 0: Build RES
                        // 1: Build ROAD
                        // 2: Build ROAD (2nd)
                        // 3: Build WELL
                        // 4: Wait 7 years
                        // 5: Build RES
                        // 6: Build COM
                        // 7: Build ROAD (extend)
                        // 8: Cycle complete â†’ next cycle or Industrial
                        
                        let cycleStep = this.tutorialStep % 8;
                        
                        this.log(`ğŸ“š Tutorial: Cycle ${this.tutorialCycle+1}/4, Step ${cycleStep}, WaitUntil=${this.tutorialWaitUntilYear}`);
                        
                        // After 4 cycles, build Industrial
                        if (this.tutorialCycle >= 4) {
                            if (indCount === 0) {
                                if (food >= indCost.food && wood >= indCost.wood) {
                                    this.log('ğŸ­ Tutorial COMPLETE: Building first Industrial!');
                                    this.tutorialMode = false; // Exit tutorial after this
                                    return 'BUILD_IND';
                                } else {
                                    this.log('â³ Saving for Industrial...');
                                    return 'PASS_YEAR';
                                }
                            }
                            // Tutorial complete, switch to normal mode
                            this.tutorialMode = false;
                        }
                        
                        switch(cycleStep) {
                            case 0: // Build RES
                                if (food >= resCost.food && wood >= resCost.wood) {
                                    this.log('ğŸ  Tutorial: Building Residential');
                                    this.tutorialStep++;
                                    return 'BUILD_RES';
                                }
                                return 'PASS_YEAR';
                                
                            case 1: // Build ROAD 1
                            case 2: // Build ROAD 2
                                if (food >= roadCost) {
                                    this.log('ğŸ›¤ï¸ Tutorial: Building Road ' + (cycleStep));
                                    this.tutorialStep++;
                                    return 'BUILD_ROAD';
                                }
                                return 'PASS_YEAR';
                                
                            case 3: // Build WELL
                                if (food >= wellCost) {
                                    this.log('ğŸ’§ Tutorial: Building Well');
                                    this.tutorialStep++;
                                    this.tutorialWaitUntilYear = year + 7; // Wait 7 years
                                    return 'BUILD_WELL';
                                }
                                return 'PASS_YEAR';
                                
                            case 4: // Wait 7 years
                                if (year >= this.tutorialWaitUntilYear) {
                                    this.log('â° Tutorial: Wait complete, continuing...');
                                    this.tutorialStep++;
                                    // Fall through to step 5
                                } else {
                                    // While waiting, ensure we have buffer wells
                                    if (needMoreWells && food >= wellCost) {
                                        this.log('ğŸ’§ Tutorial: Building buffer well while waiting');
                                        return 'BUILD_WELL';
                                    }
                                    return 'PASS_YEAR';
                                }
                                // Fall through intentionally
                                
                            case 5: // Build RES after wait
                                if (food >= resCost.food && wood >= resCost.wood) {
                                    this.log('ğŸ  Tutorial: Building Residential (post-wait)');
                                    this.tutorialStep++;
                                    return 'BUILD_RES';
                                }
                                return 'PASS_YEAR';
                                
                            case 6: // Build COM
                                if (food >= comCost.food && wood >= comCost.wood) {
                                    this.log('ğŸ”¥ Tutorial: Building Commercial');
                                    this.tutorialStep++;
                                    return 'BUILD_COM';
                                }
                                return 'PASS_YEAR';
                                
                            case 7: // Extend ROAD
                                if (food >= roadCost) {
                                    this.log('ğŸ›¤ï¸ Tutorial: Extending Road');
                                    this.tutorialStep++;
                                    this.tutorialCycle++; // Complete cycle
                                    return 'BUILD_ROAD';
                                }
                                return 'PASS_YEAR';
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // NORMAL MODE (4 out of 5 episodes) - Smart reactive building
                    // Priority: Emergency Wells > Housing > Buffer Wells > Roads > Commercial > Industrial
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // PRIORITY 1: First residential if none exist
                    if (resCount === 0) {
                        if (food >= resCost.food && wood >= resCost.wood) {
                            this.log('ğŸ  Building first residential!');
                            return 'BUILD_RES';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 2: First well if none exist
                    if (wellCount === 0) {
                        if (food >= wellCost) {
                            this.log('ğŸ’§ Building first well!');
                            return 'BUILD_WELL';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 3: First road
                    if (roadCount === 0) {
                        if (food >= roadCost) {
                            this.log('ğŸ›¤ï¸ Building first road!');
                            return 'BUILD_ROAD';
                        }
                        return 'PASS_YEAR';
                    }
                    
                    // PRIORITY 4: Maintain wells (urgent first, then buffer)
                    if (baseWellDeficit && food >= wellCost) {
                        this.log(`ğŸ’§ Building required well (have ${wellCount}, need ${wellsNeeded})`);
                        return 'BUILD_WELL';
                    }
                    if (bufferWellNeeded && food >= wellCost && (needsWater || waterPercent > 85 || food > resCost.food * 2)) {
                        this.log(`ğŸ’§ Building buffer well (have ${wellCount}, want ${wellsWithBuffer})`);
                        return 'BUILD_WELL';
                    }
                    
                    // PRIORITY 5: Housing when near capacity
                    if (pop >= housingCap - 2) {
                        if (food >= resCost.food && wood >= resCost.wood) {
                            this.log('ğŸ  Building residential - population near capacity!');
                            return 'BUILD_RES';
                        }
                    }
                    
                    // PRIORITY 6: Roads (1 per 2 buildings minimum)
                    let totalBuildings = resCount + indCount + comCount + wellCount;
                    let roadsNeeded = Math.max(1, Math.ceil(totalBuildings / 2));
                    if (roadCount < roadsNeeded && food >= roadCost) {
                        this.log('ğŸ›¤ï¸ Building road - need more infrastructure!');
                        return 'BUILD_ROAD';
                    }
                    
                    // PRIORITY 7: Commercial (1 per 3 residential)
                    let comNeeded = Math.max(1, Math.ceil(resCount / 3));
                    if (comCount < comNeeded && food >= comCost.food && wood >= comCost.wood) {
                        this.log('ğŸ”¥ Building commercial for production bonus!');
                        return 'BUILD_COM';
                    }
                    
                    // PRIORITY 8: First Industrial after 4 residential + 1 commercial
                    if (indCount === 0 && resCount >= 4 && comCount >= 1) {
                        if (food >= indCost.food && wood >= indCost.wood) {
                            this.log('ğŸ­ Building first Industrial!');
                            return 'BUILD_IND';
                        }
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // LEVEL 2/3 BUILDING LOGIC - When unlocked and affordable!
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Check for Level 2+ unlocks
                    if(highestUnlock >= 2) {
                        let resL2Cost = CFG.BUILDING_LEVELS[2] || { food: 300, wood: 300 };
                        let indL2Cost = CFG.INDUSTRIAL_LEVELS[2] || { food: 2000, wood: 2000 };
                        let comL2Cost = CFG.LEVEL_2_COSTS && CFG.LEVEL_2_COSTS.COMMERCIAL ? CFG.LEVEL_2_COSTS.COMMERCIAL : { food: 10000, wood: 10000 };
                        
                        // Build L2 Residential if we have good resources and housing is tight
                        if(pop >= housingCap - 5 && food >= resL2Cost.food && wood >= resL2Cost.wood) {
                            this.log('ğŸ  Building Level 2 Residential for more capacity!');
                            return 'BUILD_RES_L2';
                        }
                        
                        // Build L2 Industrial if we have L1 already and good resources
                        if(indCount >= 1 && food >= indL2Cost.food && wood >= indL2Cost.wood && food >= 5000) {
                            this.log('ğŸ­ Upgrading to Level 2 Industrial!');
                            return 'BUILD_IND_L2';
                        }
                        
                        // Build L2 Commercial if we have plenty of resources
                        if(comCount >= 2 && food >= comL2Cost.food && wood >= comL2Cost.wood) {
                            this.log('ğŸª Upgrading to Level 2 Commercial!');
                            return 'BUILD_COM_L2';
                        }
                    }
                    
                    // Check for Level 3 unlocks
                    if(highestUnlock >= 3) {
                        let resL3Cost = CFG.BUILDING_LEVELS[3] || { food: 900, wood: 900 };
                        let indL3Cost = CFG.INDUSTRIAL_LEVELS[3] || { food: 3000, wood: 3000 };
                        
                        // Build L3 Residential if we have good resources
                        if(pop >= housingCap - 3 && food >= resL3Cost.food && wood >= resL3Cost.wood && food >= 2000) {
                            this.log('ğŸ¡ Building Level 3 Residential!');
                            return 'BUILD_RES_L3';
                        }
                        
                        // Build L3 Industrial if we have L2 and good resources
                        if(indCount >= 2 && food >= indL3Cost.food && wood >= indL3Cost.wood && food >= 8000) {
                            this.log('ğŸ­ Building Level 3 Industrial!');
                            return 'BUILD_IND_L3';
                        }
                    }
                    
                    // PRIORITY 9: Expand housing if resources plentiful
                    if (food >= resCost.food * 2 && wood >= resCost.wood * 2) {
                        this.log('ğŸ  Building residential - expanding capacity!');
                        return 'BUILD_RES';
                    }
                    
                    // Default: Pass year
                    this.log('â³ Passing year - waiting for resources/growth');
                    return 'PASS_YEAR';
                }
                
                // Exploration: try random things to find exploits
                if(Math.random() < this.explorationRate) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }
                // Exploitation: best known action
                let bestAction = this.actions[0];
                let bestValue = this.getQ(state, bestAction);
                for(let action of this.actions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                return bestAction;
            },
            
            // Execute an action in the game
            executeAction: function(action) {
                if(Game.gameState === 'WANDER') {
                    if(!Game.player) return false;
                    
                    // === EXPLORATION TEST MODE: Block settling, always explore ===
                    if(this.explorationTestMode && action === 'SETTLE') {
                        // Force WANDER instead - we want to explore, not settle!
                        action = 'WANDER';
                    }
                    
                    // If action is SETTLE, try to settle near water
                    if(action === 'SETTLE') {
                        // First check if we're near water, if not move toward water
                        const REQ = CFG.SETTLEMENT_REQUIREMENTS;
                        let nearWater = false;
                        for(let dx = -REQ.WATER_DISTANCE; dx <= REQ.WATER_DISTANCE; dx++) {
                            for(let dy = -REQ.WATER_DISTANCE; dy <= REQ.WATER_DISTANCE; dy++) {
                                let x = Game.player.x + dx;
                                let y = Game.player.y + dy;
                                if(x >= 0 && x < CFG.W && y >= 0 && y < CFG.H) {
                                    let tile = Game.tiles[x][y];
                                    if(tile && (tile.type === 'WATER' || tile.type === 'RIVER' || tile.type === 'DEEP')) {
                                        nearWater = true;
                                        break;
                                    }
                                }
                            }
                            if(nearWater) break;
                        }
                        
                        if(nearWater) {
                            // We're near water - settle!
                            Game.settleHere();
                            if(Game && Game.player) {
                                this.aiSettlementPos = { x: Game.player.x, y: Game.player.y };
                            }
                            return true;
                        }
                        // If not near water, fall through to WANDER behavior below
                    }
                    
                    // WANDER action: hunt nomads, grab resources, explore, find water
                    const radius = 8;
                    let nomadTarget = null;
                    let berryTarget = null;
                    let woodTarget = null;
                    let waterTarget = null;
                    let animalTarget = null;
                    
                    // Check thirst level - prioritize water if low
                    let thirst = Game.thirst || 100;
                    let thirstCounter = Game.thirstCounter || 0;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // CRITICAL THIRST SURVIVAL: Water is ABSOLUTE priority when low!
                    // - At 70+ steps (thirst<30): MUST find water NOW
                    // - At 50+ steps (thirst<50): Start seeking water proactively
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    let needsWaterUrgent = thirst < 30 || thirstCounter > 70; // CRITICAL - will die soon!
                    let needsWater = thirst < 50 || thirstCounter > 50;       // Should seek water
                    
                    // Debug: log that we're in WANDER executeAction
                    console.log('ğŸš¶ WANDER execute: action=', action, 'pos=', Game.player.x, Game.player.y, 'food=', Game.inventory.food, 'thirst=', thirst, 'counter=', thirstCounter);
                    
                    // URGENT WATER SEARCH: Use wider radius when thirsty!
                    let waterSearchRadius = needsWaterUrgent ? 15 : (needsWater ? 12 : radius);
                    
                    // Water-seeking mode for settlement
                    let seekingWaterForSettlement = this.waterSeekMode && !this.checkNearWater();
                    if(seekingWaterForSettlement) {
                        let waterPos = this.findNearestWater();
                        if(waterPos) {
                            waterTarget = waterPos;
                            this.log('ğŸ’§ Moving toward water for settlement');
                        }
                    }
                    
                    if(Game.tiles) {
                        // Use wider radius for water search when thirsty!
                        let searchRadius = needsWaterUrgent ? waterSearchRadius : radius;
                        
                        for(let r = 1; r <= searchRadius; r++) {
                            for(let dx = -r; dx <= r; dx++) {
                                for(let dy = -r; dy <= r; dy++) {
                                    const tx = Game.player.x + dx;
                                    const ty = Game.player.y + dy;
                                    if(tx<0 || ty<0 || tx>=Game.tiles.length || ty>=Game.tiles[0].length) continue;
                                    const tile = Game.tiles[tx][ty];
                                    if(!tile) continue;
                                    
                                    // Look for water FIRST when thirsty (scan entire radius)
                                    if(!waterTarget && (tile.type === 'WATER' || tile.type === 'RIVER')) {
                                        waterTarget = {x: tx, y: ty};
                                        // If urgent, don't look for anything else - just water!
                                        if(needsWaterUrgent) continue;
                                    }
                                    
                                    // Only look for other targets if not in urgent water mode
                                    if(!needsWaterUrgent) {
                                        // Hunt friendly nomads for population - PRIORITY 1
                                        if(!nomadTarget && tile.entity && tile.entity.type === 'NOMAD' && tile.entity.is_hostile === false) {
                                            nomadTarget = {x: tx, y: ty};
                                        }
                                        // Grab berries for food
                                        if(!berryTarget && tile.entity && tile.entity.type === 'BERRY' && tile.entity.amount > 0) {
                                            berryTarget = {x: tx, y: ty};
                                        }
                                        // Look for animals near settlement spots (for Industrial placement)
                                        if(!animalTarget && tile.animal) {
                                            animalTarget = {x: tx, y: ty};
                                        }
                                        // Chop trees for wood (needed to settle)
                                        if(!woodTarget && tile.tree && Game.inventory && Game.inventory.wood < 50) {
                                            woodTarget = {x: tx, y: ty};
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Priority depends on thirst level:
                    // URGENT thirst: water ONLY, nothing else matters!
                    // Normal thirst: water FIRST, then nomads > berries > wood
                    // Not thirsty: nomads > berries > wood > water (for settling)
                    let target;
                    if(needsWaterUrgent && waterTarget) {
                        target = waterTarget; // CRITICAL: find water or die!
                        console.log('ğŸš¨ URGENT THIRST! Seeking water at', waterTarget.x, waterTarget.y, 'thirst=', thirst);
                    } else if(needsWater && waterTarget) {
                        target = waterTarget; // Prioritize water
                        console.log('ğŸ’§ THIRSTY! Seeking water at', waterTarget.x, waterTarget.y);
                    } else {
                        target = nomadTarget || berryTarget || animalTarget || woodTarget || waterTarget;
                    }
                    if(target) {
                        const stepX = Math.sign(target.x - Game.player.x);
                        const stepY = Math.sign(target.y - Game.player.y);
                        console.log('ğŸ¯ Moving toward target at', target.x, target.y, '| step:', stepX, stepY);
                        let moved = false;
                        if(Math.abs(target.x - Game.player.x) >= Math.abs(target.y - Game.player.y)) {
                            moved = Game.movePlayer(stepX, 0);
                            // If blocked, try perpendicular direction
                            if(!moved && stepY !== 0) moved = Game.movePlayer(0, stepY);
                        } else {
                            moved = Game.movePlayer(0, stepY);
                            // If blocked, try perpendicular direction
                            if(!moved && stepX !== 0) moved = Game.movePlayer(stepX, 0);
                        }
                        if(moved) return true;
                        // Fall through to try other directions if blocked
                    }
                    
                    // Explore unexplored tiles (or just try to move if all explored)
                    const dirs = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                    
                    // Shuffle directions for variety
                    for(let i = dirs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                    }
                    
                    const unexplored = [];
                    const walkable = [];
                    for(const d of dirs) {
                        const nx = Game.player.x + d.dx;
                        const ny = Game.player.y + d.dy;
                        if(nx<0 || ny<0 || nx>=Game.tiles.length || ny>=Game.tiles[0].length) continue;
                        const t = Game.tiles[nx][ny];
                        if(!t) continue;
                        if(t.type !== 'WATER' && t.type !== 'DEEP' && t.type !== 'RIVER' && t.type !== 'STONE') {
                            walkable.push(d);
                            if(!t.explored) {
                                unexplored.push(d);
                            }
                        }
                    }
                    
                    // Prefer unexplored, but try any walkable if none
                    let moveTargets = unexplored.length > 0 ? unexplored : walkable;
                    
                    for(const pick of moveTargets) {
                        console.log('ğŸ” Trying move:', pick.dx, pick.dy);
                        if(Game.movePlayer(pick.dx, pick.dy)) {
                            return true;
                        }
                    }
                    
                    // Truly stuck - log it
                    console.log('âš ï¸ AI stuck! No valid moves. Food:', Game.inventory?.food, 'Pos:', Game.player.x, Game.player.y);
                    return false;
                }
                
                // Find a valid position to build - NOW USES PLAYBOOK IF AVAILABLE
                var self = this;
                
                // Smart road placement for expansion
                var findFrontierRoadSpot = function() {
                    if(!Game.settlementPos || !Game.blds || Game.blds.length === 0) return null;
                    
                    let origin = Game.settlementPos;
                    let expansionStats = self.getCityExpansionStats();
                    let tierStrategy = self.getPopTierStrategy(Game.pop || 0);
                    
                    // Find which quadrants are under-developed
                    let quadrantBuildings = { NE: 0, NW: 0, SE: 0, SW: 0 };
                    for(let b of Game.blds) {
                        if(b.x === undefined || b.y === undefined) continue;
                        let dx = b.x - origin.x;
                        let dy = b.y - origin.y;
                        if(dx >= 0 && dy < 0) quadrantBuildings.NE++;
                        else if(dx < 0 && dy < 0) quadrantBuildings.NW++;
                        else if(dx >= 0 && dy >= 0) quadrantBuildings.SE++;
                        else quadrantBuildings.SW++;
                    }
                    
                    // Find least-developed quadrant
                    let minQuad = 'NE', minCount = quadrantBuildings.NE;
                    for(let q in quadrantBuildings) {
                        if(quadrantBuildings[q] < minCount) {
                            minCount = quadrantBuildings[q];
                            minQuad = q;
                        }
                    }
                    
                    // Get direction toward least-developed quadrant
                    let targetDX = (minQuad === 'NE' || minQuad === 'SE') ? 1 : -1;
                    let targetDY = (minQuad === 'NE' || minQuad === 'NW') ? -1 : 1;
                    
                    // Find existing roads and look for frontier extension
                    let roads = Game.blds.filter(b => b.t === 'ROAD');
                    if(roads.length > 0) {
                        // Sort roads by distance from origin, farthest first in target direction
                        roads.sort((a, b) => {
                            let scoreA = (a.x - origin.x) * targetDX + (a.y - origin.y) * targetDY;
                            let scoreB = (b.x - origin.x) * targetDX + (b.y - origin.y) * targetDY;
                            return scoreB - scoreA; // Higher score = more in target direction
                        });
                        
                        // Try to extend from frontier roads
                        for(let road of roads) {
                            // Try directions, prioritizing target direction
                            let dirs = [
                                {dx: targetDX, dy: 0, priority: 2},
                                {dx: 0, dy: targetDY, priority: 2},
                                {dx: targetDX, dy: targetDY, priority: 1}, // Diagonal is lower priority
                                {dx: -targetDX, dy: 0, priority: 0},
                                {dx: 0, dy: -targetDY, priority: 0}
                            ];
                            dirs.sort((a, b) => b.priority - a.priority);
                            
                            for(let dir of dirs) {
                                let tx = road.x + dir.dx;
                                let ty = road.y + dir.dy;
                                if(self.isValidBuildSpot(tx, ty, 'ROAD')) {
                                    self.log(`ğŸ›¤ï¸ Expanding road frontier toward ${minQuad} quadrant`);
                                    return { x: tx, y: ty };
                                }
                            }
                        }
                    }
                    
                    return null; // Fall through to regular buildspot
                };
                
                var findBuildSpot = function(zoneType) {
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // PRIORITY: Build CLUSTERED near settlement origin!
                    // Start from settlement, spiral outward, prefer adjacent to existing buildings
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // Helper: Check if tile is valid for building
                    var isGoodSpot = function(x, y) {
                        if(x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) return false;
                        let tile = Game.tiles[x][y];
                        if(!tile) return false;
                        if(!tile.explored) return false; // MUST be explored!
                        if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                        if(tile.stoneDeposit) return false;
                        if(tile.zone || tile.building || tile.road) return false;
                        // Check blds array for overlap
                        for(let b of (Game.blds || [])) {
                            let bz = (b.t === 'WELL' || b.t === 'COM' || b.t === 'IND' || b.t === 'FOOD_PIT' || b.t === 'WOOD_PIT' || b.t === 'STONE_PIT' || b.t === 'METAL_PIT') ? 1 : 2;
                            if(x < b.x + bz && x + 1 > b.x && y < b.y + bz && y + 1 > b.y) return false;
                        }
                        return true;
                    };
                    
                    // Helper: Count adjacent buildings (higher = more clustered)
                    var countAdjacentBuildings = function(x, y) {
                        let count = 0;
                        for(let dx = -1; dx <= 1; dx++) {
                            for(let dy = -1; dy <= 1; dy++) {
                                if(dx === 0 && dy === 0) continue;
                                let nx = x + dx, ny = y + dy;
                                if(nx < 0 || ny < 0 || nx >= CFG.W || ny >= CFG.H) continue;
                                let t = Game.tiles[nx][ny];
                                if(t && (t.zone || t.building || t.road)) count++;
                                // Also check blds array
                                for(let b of (Game.blds || [])) {
                                    if(b.x === nx && b.y === ny) count++;
                                }
                            }
                        }
                        return count;
                    };
                    
                    // Get origin point (settlement position or player position)
                    let origin = Game.settlementPos || (Game.player ? { x: Game.player.x, y: Game.player.y } : { x: Math.floor(CFG.W/2), y: Math.floor(CFG.H/2) });
                    
                    // Collect all valid spots within range, sorted by clustering score
                    let candidates = [];
                    const maxRange = 8; // Don't build too far away
                    
                    for(let r = 1; r <= maxRange; r++) {
                        for(let dx = -r; dx <= r; dx++) {
                            for(let dy = -r; dy <= r; dy++) {
                                let x = origin.x + dx;
                                let y = origin.y + dy;
                                
                                if(isGoodSpot(x, y)) {
                                    let adjacentScore = countAdjacentBuildings(x, y);
                                    let distFromOrigin = Math.abs(dx) + Math.abs(dy);
                                    // Score: prefer adjacent buildings (cluster), penalize distance
                                    let score = adjacentScore * 10 - distFromOrigin;
                                    candidates.push({ x, y, score, adjacent: adjacentScore, dist: distFromOrigin });
                                }
                            }
                        }
                    }
                    
                    // Sort by score (highest first) - prefers clustered spots
                    candidates.sort((a, b) => b.score - a.score);
                    
                    // Return best spot (most clustered, closest to origin)
                    if(candidates.length > 0) {
                        let best = candidates[0];
                        console.log('ğŸ—ï¸ AI build spot: (' + best.x + ',' + best.y + ') adjacent=' + best.adjacent + ' dist=' + best.dist);
                        return { x: best.x, y: best.y };
                    }
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Fallback: If no clustered spot found, try any valid explored tile nearby
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    for(let r = 1; r <= 15; r++) {
                        for(let dx = -r; dx <= r; dx++) {
                            for(let dy = -r; dy <= r; dy++) {
                                let x = origin.x + dx;
                                let y = origin.y + dy;
                                if(isGoodSpot(x, y)) {
                                    return { x, y };
                                }
                            }
                        }
                    }
                    
                    console.log('âš ï¸ AI: No valid build spot found!');
                    return null;
                };
                
                var spot;
                var unlockedLevels = PROGRESSION && PROGRESSION.unlockedLevels ? PROGRESSION.unlockedLevels : [1];
                var highestUnlock = Math.max(...unlockedLevels);
                
                switch(action) {
                    case 'BUILD_RES':
                        spot = findBuildSpot();
                        // Get residential cost from config (Level 1 = 100 food, 100 wood)
                        var resCost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[1] ? CFG.BUILDING_LEVELS[1] : { food: 100, wood: 100 };
                        if(spot && Game.food >= resCost.food && Game.wood >= resCost.wood) {
                            Controller.selectedBuildingLevel = 1; // Set level before building
                            Game.build('RES', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_RES_L2':
                        // Only if Level 2 is unlocked
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var resL2Cost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[2] ? CFG.BUILDING_LEVELS[2] : { food: 300, wood: 300 };
                            if(spot && Game.food >= resL2Cost.food && Game.wood >= resL2Cost.wood) {
                                Controller.selectedBuildingLevel = 2;
                                Game.build('RES', spot.x, spot.y);
                                this.log('ğŸ  Built Level 2 Residential!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L3':
                        // Only if Level 3 is unlocked
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            var resL3Cost = CFG.BUILDING_LEVELS && CFG.BUILDING_LEVELS[3] ? CFG.BUILDING_LEVELS[3] : { food: 900, wood: 900 };
                            if(spot && Game.food >= resL3Cost.food && Game.wood >= resL3Cost.wood) {
                                Controller.selectedBuildingLevel = 3;
                                Game.build('RES', spot.x, spot.y);
                                this.log('ğŸ¡ Built Level 3 Residential!');
                                return true;
                            }
                        }
                        break;
                        
                    case 'BUILD_IND':
                        spot = findBuildSpot();
                        // Industrial Level 1 costs 1000 food + 1000 wood
                        var indCost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[1] ? CFG.INDUSTRIAL_LEVELS[1] : { food: 1000, wood: 1000 };
                        if(spot && Game.food >= indCost.food && Game.wood >= indCost.wood) {
                            Controller.selectedIndustrialLevel = 1; // Set level before building
                            Game.build('IND', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_IND_L2':
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var indL2Cost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[2] ? CFG.INDUSTRIAL_LEVELS[2] : { food: 2000, wood: 2000 };
                            if(spot && Game.food >= indL2Cost.food && Game.wood >= indL2Cost.wood) {
                                Controller.selectedIndustrialLevel = 2;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ğŸ­ Built Level 2 Industrial!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L3':
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            var indL3Cost = CFG.INDUSTRIAL_LEVELS && CFG.INDUSTRIAL_LEVELS[3] ? CFG.INDUSTRIAL_LEVELS[3] : { food: 3000, wood: 3000 };
                            if(spot && Game.food >= indL3Cost.food && Game.wood >= indL3Cost.wood) {
                                Controller.selectedIndustrialLevel = 3;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ğŸ­ Built Level 3 Industrial!');
                                return true;
                            }
                        }
                        break;
                        
                    case 'BUILD_COM':
                        spot = findBuildSpot();
                        // Commercial Level 1 = Campfire (200 food, 200 wood per LEVEL_1_COSTS)
                        var comCost = CFG.LEVEL_1_COSTS && CFG.LEVEL_1_COSTS.COMMERCIAL ? CFG.LEVEL_1_COSTS.COMMERCIAL : { food: 200, wood: 200 };
                        if(spot && Game.food >= comCost.food && Game.wood >= comCost.wood) {
                            Controller.selectedCommercialLevel = 1; // Set level before building
                            Game.build('COM', spot.x, spot.y);
                            return true;
                        }
                        break;
                    
                    case 'BUILD_COM_L2':
                        if(highestUnlock >= 2) {
                            spot = findBuildSpot();
                            var comL2Cost = CFG.LEVEL_2_COSTS && CFG.LEVEL_2_COSTS.COMMERCIAL ? CFG.LEVEL_2_COSTS.COMMERCIAL : { food: 10000, wood: 10000 };
                            if(spot && Game.food >= comL2Cost.food && Game.wood >= comL2Cost.wood) {
                                Controller.selectedCommercialLevel = 2;
                                Game.build('COM', spot.x, spot.y);
                                this.log('ğŸª Built Level 2 Commercial!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L3':
                        if(highestUnlock >= 3) {
                            spot = findBuildSpot();
                            // Level 3 commercial - extrapolate cost
                            var comL3Cost = { food: 50000, wood: 50000 };
                            if(spot && Game.food >= comL3Cost.food && Game.wood >= comL3Cost.wood) {
                                Controller.selectedCommercialLevel = 3;
                                Game.build('COM', spot.x, spot.y);
                                this.log('ğŸ¬ Built Level 3 Commercial!');
                                return true;
                            }
                        }
                        break;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEVEL 4-6 BUILDINGS (Requires Clan Chief) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    case 'BUILD_RES_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var resL4Cost = CFG.BUILDING_DB['RES_4'] ? CFG.BUILDING_DB['RES_4'].cost : { food: 2000, wood: 2000, stone: 40 };
                            if(spot && Game.food >= resL4Cost.food && Game.wood >= resL4Cost.wood && (Game.stone || 0) >= (resL4Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 4;
                                Game.build('RES', spot.x, spot.y);
                                this.log('â›º Built Level 4 Tipi Village!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var resL5Cost = CFG.BUILDING_DB['RES_5'] ? CFG.BUILDING_DB['RES_5'].cost : { food: 8000, wood: 8000, stone: 80 };
                            if(spot && Game.food >= resL5Cost.food && Game.wood >= resL5Cost.wood && (Game.stone || 0) >= (resL5Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 5;
                                Game.build('RES', spot.x, spot.y);
                                this.log('ğŸ  Built Level 5 Log Longhouse!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_RES_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var resL6Cost = CFG.BUILDING_DB['RES_6'] ? CFG.BUILDING_DB['RES_6'].cost : { food: 20000, wood: 20000, stone: 100 };
                            if(spot && Game.food >= resL6Cost.food && Game.wood >= resL6Cost.wood && (Game.stone || 0) >= (resL6Cost.stone || 0)) {
                                Controller.selectedBuildingLevel = 6;
                                Game.build('RES', spot.x, spot.y);
                                this.log('ğŸ° Built Level 6 Old Growth Compound!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var indL4Cost = CFG.BUILDING_DB['IND_4'] ? CFG.BUILDING_DB['IND_4'].cost : { food: 2400, wood: 2400, stone: 48 };
                            if(spot && Game.food >= indL4Cost.food && Game.wood >= indL4Cost.wood && (Game.stone || 0) >= (indL4Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 4;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ğŸ¢ Built Level 4 Turtle Hunting Ground!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var indL5Cost = CFG.BUILDING_DB['IND_5'] ? CFG.BUILDING_DB['IND_5'].cost : { food: 9600, wood: 9600, stone: 96 };
                            if(spot && Game.food >= indL5Cost.food && Game.wood >= indL5Cost.wood && (Game.stone || 0) >= (indL5Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 5;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ğŸ» Built Level 5 Bear Pit!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_IND_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var indL6Cost = CFG.BUILDING_DB['IND_6'] ? CFG.BUILDING_DB['IND_6'].cost : { food: 24000, wood: 24000, stone: 120 };
                            if(spot && Game.food >= indL6Cost.food && Game.wood >= indL6Cost.wood && (Game.stone || 0) >= (indL6Cost.stone || 0)) {
                                Controller.selectedIndustrialLevel = 6;
                                Game.build('IND', spot.x, spot.y);
                                this.log('ğŸ¦¬ Built Level 6 Buffalo Grounds!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L4':
                        if(Game.hasClanChief && highestUnlock >= 4) {
                            spot = findBuildSpot();
                            var comL4Cost = CFG.BUILDING_DB['COM_4'] ? CFG.BUILDING_DB['COM_4'].cost : { food: 1600, wood: 1600, stone: 32 };
                            if(spot && Game.food >= comL4Cost.food && Game.wood >= comL4Cost.wood && (Game.stone || 0) >= (comL4Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 4;
                                Game.build('COM', spot.x, spot.y);
                                this.log('ğŸ›¢ï¸ Built Level 4 Barter Barrel!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L5':
                        if(Game.hasClanChief && highestUnlock >= 5) {
                            spot = findBuildSpot();
                            var comL5Cost = CFG.BUILDING_DB['COM_5'] ? CFG.BUILDING_DB['COM_5'].cost : { food: 6400, wood: 6400, stone: 64 };
                            if(spot && Game.food >= comL5Cost.food && Game.wood >= comL5Cost.wood && (Game.stone || 0) >= (comL5Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 5;
                                Game.build('COM', spot.x, spot.y);
                                this.log('ğŸ›ï¸ Built Level 5 Blanket Market!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_COM_L6':
                        if(Game.hasClanChief && highestUnlock >= 6) {
                            spot = findBuildSpot();
                            var comL6Cost = CFG.BUILDING_DB['COM_6'] ? CFG.BUILDING_DB['COM_6'].cost : { food: 16000, wood: 16000, stone: 80 };
                            if(spot && Game.food >= comL6Cost.food && Game.wood >= comL6Cost.wood && (Game.stone || 0) >= (comL6Cost.stone || 0)) {
                                Controller.selectedCommercialLevel = 6;
                                Game.build('COM', spot.x, spot.y);
                                this.log('ğŸ›ï¸ Built Level 6 Bear Market!');
                                return true;
                            }
                        }
                        break;
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MILESTONE BUILDINGS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    case 'BUILD_CLAN_CHIEF':
                        // Requires 100k food, 100k wood, and 1 gold
                        if(!Game.hasClanChief && Game.food >= 100000 && Game.wood >= 100000 && (Game.gold || 0) >= 1) {
                            spot = findBuildSpot();
                            if(spot) {
                                Game.food -= 100000;
                                Game.wood -= 100000;
                                Game.gold = (Game.gold || 0) - 1;
                                Game.hasClanChief = true;
                                // Add the building to the game
                                Game.blds.push({ t: 'CLAN_CHIEF', x: spot.x, y: spot.y, level: 1 });
                                this.log('ğŸ›ï¸ Built Clan Chief\'s Hut! Levels 4-6 unlocked!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'BUILD_DOCK':
                        // Requires 500k food, 500k wood, and 5 gold, plus Clan Chief
                        if(Game.hasClanChief && !Game.hasDock && Game.food >= 500000 && Game.wood >= 500000 && (Game.gold || 0) >= 5) {
                            spot = findBuildSpot();
                            if(spot) {
                                Game.food -= 500000;
                                Game.wood -= 500000;
                                Game.gold = (Game.gold || 0) - 5;
                                Game.hasDock = true;
                                Game.blds.push({ t: 'DOCK', x: spot.x, y: spot.y, level: 2 });
                                this.log('âš“ Built Trading Dock! Level 7+ unlocked!');
                                return true;
                            }
                        }
                        break;
                    
                    case 'EXCHANGE_GOLD':
                        // Exchange 5000 metal for 1 gold
                        var metalNeeded = CFG.GOLD_EXCHANGE_RATE || 5000;
                        var totalMetal = (Game.metal || 0) + (Game.pocket && Game.pocket.metal || 0);
                        if(totalMetal >= metalNeeded) {
                            // Deduct from pocket first, then main inventory
                            var remaining = metalNeeded;
                            if(Game.pocket && Game.pocket.metal > 0) {
                                var fromPocket = Math.min(Game.pocket.metal, remaining);
                                Game.pocket.metal -= fromPocket;
                                remaining -= fromPocket;
                            }
                            if(remaining > 0) {
                                Game.metal = (Game.metal || 0) - remaining;
                            }
                            Game.gold = (Game.gold || 0) + 1;
                            this.log('ğŸ’° Exchanged ' + metalNeeded + ' metal for 1 gold! Total gold: ' + Game.gold);
                            return true;
                        }
                        break;
                        
                    case 'BUILD_WELL':
                        spot = findBuildSpot();
                        // Well cost from config
                        var wellCost = CFG.COST && CFG.COST.WELL ? CFG.COST.WELL : 20;
                        if(spot && Game.food >= wellCost) {
                            Game.build('WELL', spot.x, spot.y);
                            return true;
                        }
                        break;
                        
                    case 'BUILD_ROAD':
                        // Try frontier expansion first, then regular spot
                        spot = findFrontierRoadSpot() || findBuildSpot();
                        // Road cost from config
                        var roadCost = CFG.COST && CFG.COST.ROAD ? CFG.COST.ROAD : 5;
                        if(spot && Game.food >= roadCost) {
                            Game.build('ROAD', spot.x, spot.y);
                            return true;
                        }
                        break;
                        
                    case 'PASS_YEAR':
                        Game.endTurn();
                        return true;
                        
                    case 'WAIT':
                        // Do nothing this step
                        return true;
                }
                
                return false;
            },
            
            // Calculate reward based on game state change - CURRICULUM LEARNING
            calculateReward: function(prevState, currentState, action) {
                let reward = 0;
                let phase = this.learningPhase || 1;
                let actualPop = Game.pop || 0;
                let year = Game.year || 0;
                if(!this.episodeStartSnapshotTaken) {
                    this.episodeStartSnapshotTaken = true;
                    this.episodeStartPop = actualPop;
                    this.episodeStartRes = Game.zoneCount || 0;
                    this.episodeStartStage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                    this.episodeStartYear = year;
                }
                let stage = PROGRESSION ? (PROGRESSION.stage || 0) : 0;
                let highestUnlock = 1;
                if(PROGRESSION && Array.isArray(PROGRESSION.unlockedLevels) && PROGRESSION.unlockedLevels.length > 0) {
                    highestUnlock = Math.max(...PROGRESSION.unlockedLevels);
                }
                let expansionStats = this.getCityExpansionStats();

                // Game over penalty (scales with phase - dying matters more as we advance)
                var gameOverPanel = document.getElementById('gameover-screen');
                if(gameOverPanel && gameOverPanel.style.display === 'flex') {
                    return -100 * phase; // -100 in phase 1, -200 in phase 2, -300 in phase 3
                }

                if(stage > (this.lastStageAwarded || 0)) {
                    let stageReward = stage === 1 ? 200 : stage === 2 ? 500 : 150;
                    reward += stageReward;
                    this.lastStageAwarded = stage;
                    this.progressMade = true;
                    this.log(`ğŸš€ Advanced to Stage ${stage}! +${stageReward}`);
                }

                if(highestUnlock > (this.lastLevelUnlockAward || 1)) {
                    let levelDelta = highestUnlock - (this.lastLevelUnlockAward || 1);
                    let levelReward = levelDelta * 150;
                    reward += levelReward;
                    this.lastLevelUnlockAward = highestUnlock;
                    this.progressMade = true;
                    this.log(`ğŸ… Housing Level ${highestUnlock} unlocked! +${levelReward}`);
                }

                if(expansionStats.radius > (this.lastExpansionRadius || 0)) {
                    let radiusGain = expansionStats.radius - (this.lastExpansionRadius || 0);
                    reward += radiusGain * 5;
                    this.lastExpansionRadius = expansionStats.radius;
                    if(radiusGain > 0) this.progressMade = true;
                }

                if(expansionStats.quadrants > (this.lastQuadrantCount || 0)) {
                    let quadGain = expansionStats.quadrants - (this.lastQuadrantCount || 0);
                    let quadReward = quadGain * 200;
                    reward += quadReward;
                    this.lastQuadrantCount = expansionStats.quadrants;
                    this.progressMade = true;
                    this.log(`ğŸŒ Expanded into ${expansionStats.quadrants} map quadrants! +${quadReward}`);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // MEGA MILESTONE REWARDS - Exponential scaling for population survival
                // The REAL goal: Keep many people alive for many years!
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if(Game.gameState === 'CITY') {
                    // Population-Year Score: pop * years (base milestone tracking)
                    let popYearScore = actualPop * year;
                    
                    // Milestone bonuses (exponentially increasing)
                    // 10 pop Ã— 10 years = 100 pop-years â†’ +100 reward
                    // 50 pop Ã— 20 years = 1000 pop-years â†’ +500 reward
                    // 100 pop Ã— 100 years = 10000 pop-years â†’ +5000 reward!
                    if(popYearScore >= 100 && !this.milestone100) { this.milestone100 = true; reward += 100; this.log('ğŸ† Milestone: 100 pop-years!'); }
                    if(popYearScore >= 500 && !this.milestone500) { this.milestone500 = true; reward += 300; this.log('ğŸ† Milestone: 500 pop-years!'); }
                    if(popYearScore >= 1000 && !this.milestone1k) { this.milestone1k = true; reward += 500; this.log('ğŸ† Milestone: 1,000 pop-years!'); }
                    if(popYearScore >= 5000 && !this.milestone5k) { this.milestone5k = true; reward += 2000; this.log('ğŸ†ğŸ† Milestone: 5,000 pop-years!'); }
                    if(popYearScore >= 10000 && !this.milestone10k) { this.milestone10k = true; reward += 5000; this.log('ğŸ†ğŸ†ğŸ† LEGENDARY: 10,000 pop-years!'); }
                    if(popYearScore >= 50000 && !this.milestone50k) { this.milestone50k = true; reward += 25000; this.log('ğŸ‘‘ GODLIKE: 50,000 pop-years!'); }
                    
                    // Continuous reward: Every step in CITY mode with living population
                    // More people = exponentially more reward per step
                    // Formula: pop^1.2 * 0.01 per step (100 pop = 2.5 pts/step, 1000 pop = 39 pts/step)
                    reward += Math.pow(actualPop, 1.2) * 0.01;
                    
                    // Year survival bonus (living another year is valuable!)
                    let prevYear = this.lastKnownYear || 0;
                    if(year > prevYear) {
                        // Bonus = population * years survived this step * 5
                        reward += actualPop * (year - prevYear) * 5;
                        this.lastKnownYear = year;
                    }
                }

                // === PHASE 1: SURVIVAL FOCUS ===
                // Big rewards for staying alive, drinking water, gathering food
                if(phase === 1) {
                    // Reward for being alive
                    reward += 2;
                    
                    // Thirst management is critical
                    let thirst = Game.thirst || 100;
                    if(thirst > 80) reward += 5;      // Well hydrated
                    else if(thirst < 30) reward -= 15; // Dangerously thirsty
                    
                    // Food gathering
                    let food = Game.inventory ? Game.inventory.food : 0;
                    if(food > 150) reward += 3;
                    
                    // Settling is the goal of phase 1
                    if(action === 'SETTLE' && Game.gameState === 'CITY') {
                        reward += 100; // HUGE reward for successfully settling
                    }
                }

                // === PHASE 2: CITY BUILDING FOCUS ===
                // Rewards for building any zones, roads, survival
                if(phase >= 2) {
                    // --- POPULATION GROWTH ---
                    let prevPopBucket = parseInt(prevState.match(/P(\d+)/)?.[1] || 0);
                    let currPopBucket = parseInt(currentState.match(/P(\d+)/)?.[1] || 0);
                    if(currPopBucket > prevPopBucket) reward += (currPopBucket - prevPopBucket) * 50; // Doubled!

                    // --- BUILDING COUNTS ---
                    let wellCount = parseInt(currentState.match(/WL(\d+)/)?.[1] || 0);
                    let resCount = parseInt(currentState.match(/R(\d+)/)?.[1] || 0);
                    let indCount = parseInt(currentState.match(/I(\d+)/)?.[1] || 0);
                    let comCount = parseInt(currentState.match(/C(\d+)/)?.[1] || 0);
                    let roadCount = Game.blds ? Game.blds.filter(b => b.t === 'ROAD').length : 0;
                    let totalBuildings = resCount + indCount + comCount + wellCount;

                    // Reward for each building type (scaled to building's impact)
                    reward += resCount * 15;  // Residential = population capacity
                    reward += indCount * 20;  // Industrial = resource production  
                    reward += comCount * 20;  // Commercial = trade/money
                    reward += wellCount * 10; // Wells = survival infrastructure
                    reward += roadCount * 5;  // Roads = efficiency
                    
                    // Big bonus for building actions
                    if(action === 'BUILD_RES') reward += 25;
                    if(action === 'BUILD_IND') reward += 35;
                    if(action === 'BUILD_COM') reward += 35;
                    if(action === 'BUILD_ROAD') reward += 15;
                    if(action === 'BUILD_WELL') reward += 20;
                }

                // === PHASE 3: BALANCED CITY FOCUS ===
                if(phase >= 3) {
                    let resCount = parseInt(currentState.match(/R(\d+)/)?.[1] || 0);
                    let indCount = parseInt(currentState.match(/I(\d+)/)?.[1] || 0);
                    let comCount = parseInt(currentState.match(/C(\d+)/)?.[1] || 0);
                    
                    // --- RCI DEMAND BALANCE ---
                    let rci = Game.calculateRCIDemand ? Game.calculateRCIDemand() : {r:0,c:0,i:0};
                    let allZonesPresent = (resCount > 0 && comCount > 0 && indCount > 0);
                    let balancedRCI = (rci.r < 40 && rci.c < 40 && rci.i < 40);
                    if(allZonesPresent) {
                        reward += 100; // Big bonus for having all 3 zones
                        if(balancedRCI) reward += 150; // Huge bonus for balanced city
                    }
                }

                // === ALWAYS ACTIVE REWARDS ===
                
                // --- EXPLORATION (WANDER) - Reduced! Building is more important ---
                if(Game.gameState === 'WANDER') {
                    const nowExplored = this.localExploredCount(3);
                    const deltaExplored = Math.max(0, nowExplored - (this.lastExploredCount || 0));
                    reward += deltaExplored * 0.5; // REDUCED from 2 to 0.5 - exploring is cheap
                    this.lastExploredCount = nowExplored;
                }

                // --- SETTLEMENT LOCATION BONUS ---
                // If just settled, check for nearby animals/berries
                if(action === 'SETTLE' && Game.player) {
                    let foundAnimal = false, foundBerry = false;
                    for(let dx=-3;dx<=3;dx++) for(let dy=-3;dy<=3;dy++) {
                        let tx = Game.player.x+dx, ty = Game.player.y+dy;
                        if(tx<0||ty<0||tx>=Game.tiles.length||ty>=Game.tiles[0].length) continue;
                        let tile = Game.tiles[tx][ty];
                        if(tile && tile.entity) {
                            if(tile.entity.type==='ANIMAL') foundAnimal = true;
                            if(tile.entity.type==='BERRY') foundBerry = true;
                        }
                        // Also check for animals on tile
                        if(tile && tile.animal) foundAnimal = true;
                    }
                    if(foundAnimal) {
                        reward += 15;
                        this.smartSettlements++; // Track smart settlement
                    }
                    if(foundBerry) {
                        reward += 10;
                        if(!foundAnimal) this.smartSettlements++; // Count if not already counted
                    }
                }

                // --- CRISIS PENALTIES ---
                if(currentState.includes('WC1')) reward -= 10;
                if(currentState.includes('FC1')) reward -= 10;

                // --- FOOD REWARD ---
                let prevFoodBucket = parseInt(prevState.match(/F(\d+)/)?.[1] || 0);
                let currFoodBucket = parseInt(currentState.match(/F(\d+)/)?.[1] || 0);
                if(currFoodBucket > prevFoodBucket) reward += (currFoodBucket - prevFoodBucket) * 3;

                // --- SURVIVAL BONUS ---
                reward += 1;

                // --- ACTION PENALTIES/BONUSES ---
                if(action === 'WAIT') reward -= 5;
                if(action === 'PASS_YEAR' && resCount > 0) reward += 5;

                if(actualPop > this.episodeStartPop || (Game.zoneCount || 0) > this.episodeStartRes || stage > this.episodeStartStage) {
                    this.progressMade = true;
                }

                if(!this.progressMade && Game.gameState === 'CITY' && year < 2) {
                    reward = Math.min(reward, 0);
                }

                return reward;
            },
            
            // Run one step of training
            step: function() {
                try {
                    if(!this.isTraining || this.isResetting) return; // Skip if resetting
                    
                    // Track steps per episode for timeout
                    if(!this.stepCount) this.stepCount = 0;
                    this.stepCount++;
                    
                    // === EXPLORATION TEST MODE TRACKING ===
                    if(this.explorationTestMode) {
                        this.trackExploration();
                    }
                    
                    // Track player position to detect stuck AI (only in WANDER mode)
                    let playerPos = Game.player ? `${Game.player.x},${Game.player.y}` : 'none';
                    if(Game.gameState === 'WANDER') {
                        if(playerPos === this.lastPlayerPos) {
                            this.stuckCounter = (this.stuckCounter || 0) + 1;
                            
                            // Log why we might be stuck every 20 stuck steps
                            if(this.stuckCounter % 20 === 0) {
                                let food = Game.inventory ? Game.inventory.food : 0;
                                let thirst = Game.thirst || 100;
                                console.log('âš ï¸ AI stuck! Count:', this.stuckCounter, 'Food:', food, 'Thirst:', thirst, 'Pos:', playerPos);
                                
                                // If stuck due to no food, end immediately
                                if(food <= 0) {
                                    this.log('ğŸ– Stuck with no food - ending episode');
                                }
                            }
                        } else {
                            this.stuckCounter = 0;
                            this.lastPlayerPos = playerPos;
                        }
                    } else {
                        // In CITY mode, track if we're making progress (building, passing years)
                        // Reset stuck counter only if year changed or we built something
                        let currentYear = Game.year || 0;
                        let currentBuildCount = Game.blds ? Game.blds.length : 0;
                        
                        if(currentYear !== this.lastCityYear || currentBuildCount !== this.lastCityBuildCount) {
                            this.stuckCounter = 0;
                            this.lastCityYear = currentYear;
                            this.lastCityBuildCount = currentBuildCount;
                        } else {
                            // Not making progress in CITY mode
                            this.stuckCounter = (this.stuckCounter || 0) + 1;
                            
                            // Log periodically
                            if(this.stuckCounter % 100 === 0) {
                                console.log('âš ï¸ CITY mode idle! Steps without progress:', this.stuckCounter, 'Year:', currentYear, 'Buildings:', currentBuildCount);
                            }
                            
                            // Force PASS_YEAR if stuck too long (500 steps without progress)
                            if(this.stuckCounter > 500 && this.stuckCounter % 100 === 0) {
                                console.log('â© Forcing PASS_YEAR due to idle');
                                Game.endTurn();
                                this.stuckCounter = 0;
                            }
                        }
                    }
                    
                    var prevState = this.getState();
                    var action = this.chooseAction(prevState);
                    
                    // Debug log every 100 steps (reduced from 50 for performance)
                    if(this.stepCount % 100 === 1) {
                        console.log('ğŸ¤– Step', this.stepCount, '| State:', prevState, '| Action:', action, '| Pop:', Game.pop, '| Food:', Game.inventory ? Game.inventory.food : Game.food);
                    }
                    
                    // Execute action
                    var success = this.executeAction(action);
                    
                    // Track build order for experience replay
                    if(success && action.startsWith('BUILD_')) {
                        if(!this.episodeBuildOrder) this.episodeBuildOrder = [];
                        this.episodeBuildOrder.push(action);
                    }
                    
                    // Get new state and reward
                    var currentState = this.getState();
                    var reward = this.calculateReward(prevState, currentState, action);
                    
                    // Update Q-table
                    this.updateQ(prevState, action, reward, currentState);
                    
                    this.totalReward += reward;
                    
                    // === PLAYTESTING: Detect bugs and track balance (less frequent for performance) ===
                    if(this.stepCount % 50 === 0) {
                        this.detectBugs();
                        this.trackBalanceMetrics();
                        this.detectExploits();
                    }
                    this.trackCoverage(action);
                    
                    // Update live stats every 25 steps (reduced from 10 for performance)
                    if(this.stepCount % 25 === 0) {
                        this.updateLiveStats(currentState, action);
                    }
                    
                    // Check for game over (multiple conditions)
                    var gameOverPanel = document.getElementById('gameover-screen');
                    var panelVisible = gameOverPanel && (gameOverPanel.style.display === 'flex' || gameOverPanel.style.display === 'block');
                    var noPop = (Game.pop !== undefined && Game.pop <= 0);
                    var tooManyYears = (Game.year > 100);
                    var tooManySteps = (this.stepCount > 3000); // Safety timeout (reduced from 5000)
                    var isStuck = (this.stuckCounter > 100); // Stuck for 100+ steps in WANDER
                    var isCityIdle = (Game.gameState === 'CITY' && this.stuckCounter > 1000); // 1000 steps without progress in CITY
                    var noFood = (Game.gameState === 'WANDER' && Game.inventory && Game.inventory.food <= 0);
                    
                    var isGameOver = panelVisible || noPop || tooManyYears || tooManySteps || isStuck || isCityIdle || noFood;
                    
                    if(isGameOver && !this.isResetting) {
                        let reason = panelVisible ? 'gameover' : noPop ? 'no-pop' : tooManyYears ? 'too-many-years' : tooManySteps ? 'timeout' : isStuck ? 'stuck' : isCityIdle ? 'city-idle' : noFood ? 'starved' : 'unknown';
                        
                        // Detailed death cause analysis
                        let deathCause = reason;
                        if(Game.gameState === 'WANDER') {
                            let thirst = Game.thirst || 0;
                            if(thirst <= 0) deathCause = 'thirst';
                            else if(noFood) deathCause = 'starved-wander';
                        } else if(Game.gameState === 'CITY') {
                            let waterCap = (Game.wellCount || 0) * 100;
                            if(Game.pop > waterCap) deathCause = 'water-crisis';
                            else if(Game.food <= 0) deathCause = 'famine';
                            else if(noPop) deathCause = 'population-collapse';
                        }
                        
                        this.recordDeath(deathCause);
                        this.recordSuccess(Game.pop || 0, Game.year || 0);
                        
                        // === EXPLORATION TEST MODE: Record death for analysis ===
                        if(this.explorationTestMode) {
                            this.recordExploreDeath(deathCause);
                        }
                        
                        this.log('ğŸ›‘ DEATH (' + deathCause + '): pop=' + Game.pop + ', yr=' + Game.year + ', steps=' + this.stepCount);
                        this.stepCount = 0;
                        this.stuckCounter = 0;
                        this.lastPlayerPos = null;
                        this.endEpisode();
                    }
                } catch(err) {
                    console.error('AI step error:', err);
                    // Don't let errors kill training
                }
            },
            
            // Log to the AI panel
            log: function(msg) {
                var logEl = document.getElementById('ai-log');
                if(logEl) {
                    var time = new Date().toLocaleTimeString();
                    logEl.innerHTML = '[' + time + '] ' + msg + '<br>' + logEl.innerHTML;
                    // Keep only last 50 lines
                    var lines = logEl.innerHTML.split('<br>');
                    if(lines.length > 50) {
                        logEl.innerHTML = lines.slice(0, 50).join('<br>');
                    }
                }
                console.log('ğŸ¤– ' + msg);
            },
            
            // Update live stats display
            updateLiveStats: function(state, action) {
                var stateEl = document.getElementById('ai-current-state');
                var actionEl = document.getElementById('ai-current-action');
                var stepEl = document.getElementById('ai-step-count');
                var popEl = document.getElementById('ai-current-pop');
                
                if(stateEl) stateEl.textContent = 'State: ' + (state || '--');
                if(actionEl) actionEl.textContent = 'Action: ' + (action || '--');
                if(stepEl) stepEl.textContent = 'Steps: ' + (this.stepCount || 0);
                if(popEl) popEl.textContent = 'Pop: ' + (Game.pop || 0) + ' | Food: ' + Math.floor(Game.food || 0) + ' | Yr: ' + (Game.year || 0);
            },
            
            // End current episode and start new one
            endEpisode: function() {
                if(this.isResetting) {
                    return; // Already resetting, skip
                }
                this.isResetting = true;
                this.stepCount = 0;

                this.episode++;
                this.gamesPlayed++;
                this.episodeRewards.push(this.totalReward);

                if(this.totalReward > this.bestScore) {
                    this.bestScore = this.totalReward;
                }
                
                // === EXPERIENCE REPLAY - Record this episode ===
                this.recordExperience();
                this.recordFailurePattern();

                // === TRACK LEARNING ANALYTICS ===
                // Track if AI built a city
                if(Game.gameState === 'CITY') {
                    this.citiesBuilt++;
                    
                    // Track best population
                    if(Game.pop > this.bestPopulation) {
                        this.bestPopulation = Game.pop;
                    }
                    
                    // Track best survival years
                    if(Game.year > this.bestSurvivalYears) {
                        this.bestSurvivalYears = Game.year;
                    }
                    
                    // Track balanced cities (all 3 zone types)
                    let resCount = Game.zoneCount || 0;
                    let comCount = Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0;
                    let indCount = Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0;
                    if(resCount > 0 && comCount > 0 && indCount > 0) {
                        this.balancedCities++;
                    }
                }
                
                // === RESET MILESTONE TRACKERS FOR NEW EPISODE ===
                this.milestone100 = false;
                this.milestone500 = false;
                this.milestone1k = false;
                this.milestone5k = false;
                this.milestone10k = false;
                this.milestone50k = false;
                this.lastKnownYear = 0;
                
                // === RESET TUTORIAL STATE FOR NEW EPISODE ===
                this.tutorialMode = undefined; // Will be randomly set in chooseAction
                this.tutorialStep = 0;
                this.tutorialCycle = 0;
                this.tutorialWaitUntilYear = 0;
                
                // === RESET MACRO TACTIC FOR NEW EPISODE ===
                this.activeMacroTactic = null;
                this.currentMacroStep = 0;
                this.macroStepStartYear = 0;
                this.lastDeathCause = null; // Reset death cause (consecutiveDeaths stays)
                this.waterSeekMode = false;
                
                // === RESET PROGRESSION TRACKERS ===
                this.progressMade = false;
                this.lastExpansionRadius = 0;
                this.lastQuadrantCount = 0;
                this.lastStageAwarded = 0;
                this.lastLevelUnlockAward = 1;
                this.episodeStartSnapshotTaken = false;
                this.episodeBuildOrder = []; // Track build sequence for experience replay
                this.useReplayMode = false;  // Reset replay mode
                
                // === CURRICULUM PHASE ADVANCEMENT ===
                let oldPhase = this.learningPhase;
                if(this.learningPhase === 1 && this.citiesBuilt >= this.phase1Threshold) {
                    this.learningPhase = 2;
                    this.log('ğŸ“ PHASE 2: Learning city building!');
                }
                if(this.learningPhase === 2 && this.balancedCities >= this.phase2Threshold) {
                    this.learningPhase = 3;
                    this.log('ğŸ“ PHASE 3: Mastering balanced cities!');
                }
                
                // Track reward history for graph (keep last 20)
                this.rewardHistory.push(this.totalReward);
                if(this.rewardHistory.length > 20) {
                    this.rewardHistory.shift();
                }
                
                // Draw reward graph
                this.drawRewardGraph();

                // === ADAPTIVE EXPLORATION RATE ===
                // If we're failing a lot, explore more. If succeeding, exploit more.
                let baseDecay = this.explorationDecay;
                if(this.consecutiveDeaths >= 5) {
                    // Stuck - increase exploration
                    this.explorationRate = Math.min(0.5, this.explorationRate * 1.2);
                    this.log('ğŸ”„ Stuck! Increasing exploration to ' + (this.explorationRate * 100).toFixed(1) + '%');
                } else if(this.totalReward > 100 && Game.pop >= 20) {
                    // Good run - faster decay to exploit knowledge
                    this.explorationRate = Math.max(this.minExploration, this.explorationRate * baseDecay * 0.9);
                } else {
                    // Normal decay
                    this.explorationRate = Math.max(this.minExploration, this.explorationRate * baseDecay);
                }
                
                // === EPISODE SUMMARY ===
                let tierStrategy = this.getPopTierStrategy(Game.pop || 0);
                let expansionStats = this.getCityExpansionStats();
                this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                this.log(`ğŸ“Š EPISODE ${this.episode} SUMMARY:`);
                this.log(`   ğŸ¯ Reward: ${this.totalReward.toFixed(0)} | Best: ${this.bestScore.toFixed(0)}`);
                this.log(`   ğŸ‘¥ Pop: ${Game.pop || 0} (${tierStrategy.tier}) | Year: ${Game.year || 0}`);
                this.log(`   ğŸ—ï¸ Buildings: Res=${Game.zoneCount||0} Well=${Game.wellCount||0} Com=${Game.blds ? Game.blds.filter(b=>b.t==='COM').length : 0} Ind=${Game.blds ? Game.blds.filter(b=>b.t==='IND').length : 0}`);
                this.log(`   ğŸŒ Expansion: radius=${expansionStats.radius} quadrants=${expansionStats.quadrants}`);
                if(this.activeMacroTactic) {
                    this.log(`   ğŸ“‹ Tactic: ${this.activeMacroTactic.name} (step ${this.currentMacroStep || 0})`);
                }
                if(this.lastDeathCause) {
                    this.log(`   ğŸ’€ Death cause: ${this.lastDeathCause} (${this.consecutiveDeaths} in a row)`);
                }
                this.log(`   ğŸ² Exploration: ${(this.explorationRate * 100).toFixed(1)}%`);
                this.log(`   ğŸ’¾ Buffer: ${(this.experienceBuffer||[]).length}/${this.maxBufferSize} | Templates: ${(this.successTemplates||[]).length}`);
                if(this.bestRunEver) {
                    this.log(`   ğŸ† Best Ever: Pop ${this.bestRunEver.pop}, Year ${this.bestRunEver.year}`);
                }
                this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // Log progress
                this.log('ğŸ® Ep ' + this.episode + ': R=' + this.totalReward.toFixed(0) + ', Best=' + this.bestScore.toFixed(0));

                // --- Persistent logging ---
                try {
                    let sessionId = localStorage.getItem('citgame_ai_session_id');
                    if(!sessionId) {
                        sessionId = 'sess_' + Date.now() + '_' + Math.floor(Math.random()*1000000);
                        localStorage.setItem('citgame_ai_session_id', sessionId);
                    }
                    let log = JSON.parse(localStorage.getItem('citgame_ai_log') || '[]');
                    log.push({
                        session: sessionId,
                        episode: this.episode,
                        reward: this.totalReward,
                        bestScore: this.bestScore,
                        explorationRate: this.explorationRate,
                        statesLearned: Object.keys(this.qTable).length,
                        timestamp: new Date().toISOString()
                    });
                    localStorage.setItem('citgame_ai_log', JSON.stringify(log));
                } catch(e) { console.warn('AI log error', e); }

                // Update UI
                this.updateTrainingUI();

                // Reset for next episode
                this.totalReward = 0;

                // Delay before reset so user can see death screen (4 seconds at slow speeds)
                let deathScreenDelay = this.trainingSpeed <= 1 ? 4000 : (this.trainingSpeed <= 5 ? 2000 : 500);
                let self = this;
                setTimeout(function() {
                    self.forceResetGame();
                    self.isResetting = false;
                }, deathScreenDelay);
            },
            
            // Force reset game without any dialogs or page reloads
            forceResetGame: function() {
                try {
                    console.log('ğŸ”„ forceResetGame starting...');
                    
                    // Hide game over screen
                    var gameOverPanel = document.getElementById('gameover-screen');
                    if(gameOverPanel) gameOverPanel.style.display = 'none';
                    
                    // Direct game state reset
                    if(typeof Game !== 'undefined') {
                        // Re-init with new seed - this will reset everything including player
                        Game.init(Math.floor(Math.random() * 999999));
                        
                        console.log('ğŸ”„ Game.init complete. Player:', Game.player ? 'OK at ' + Game.player.x + ',' + Game.player.y : 'NULL');
                        console.log('ğŸ”„ Tiles:', Game.tiles ? Game.tiles.length + 'x' + (Game.tiles[0] ? Game.tiles[0].length : 0) : 'NULL');
                        
                        // Force camera to player position (Game.init sets this, but ensure it)
                        if(typeof Controller !== 'undefined' && Game.player) {
                            Controller.cam.x = Game.player.x * CFG.TILE;
                            Controller.cam.y = Game.player.y * CFG.TILE;
                            Controller.cam.z = CFG.CAMERA.START_ZOOM || 1;
                            console.log('ğŸ”„ Camera set to:', Controller.cam.x, Controller.cam.y);
                        }
                        
                        // Force explore starting area (in case spawnPlayer missed it)
                        if(Game.player && Game.exploreArea) {
                            Game.exploreArea(Game.player.x, Game.player.y, 5);
                        }

                        this.episodeStartSnapshotTaken = false;
                        this.progressMade = false;
                        this.lastExpansionRadius = 0;
                        this.lastQuadrantCount = 0;
                        this.lastStageAwarded = 0;
                        this.lastLevelUnlockAward = 1;
                        this.assignMacroTactic(true);
                    }
                    
                    // Reset progression
                    if(typeof PROGRESSION !== 'undefined' && PROGRESSION.reset) {
                        PROGRESSION.reset();
                    }
                    
                    // Update UI
                    if(typeof Controller !== 'undefined' && Controller.updateUI) {
                        Controller.updateUI();
                    }
                    
                    // Force a render refresh
                    if(typeof Renderer !== 'undefined' && Renderer.resize) {
                        Renderer.resize();
                    }
                    
                    console.log('ğŸ”„ forceResetGame complete!');
                    
                } catch(err) {
                    console.error('Force reset error:', err);
                    // DO NOT reload page - just continue
                }
            },
            
            // Start training
            startTraining: function() {
                var self = this;
                this.isTraining = true;
                this.isResetting = false;
                this.stepCount = 0;
                this.loopCounter = 0;
                this.errorCount = 0;
                
                // Initialize wisdom system if not already done
                if(!this.wisdom || !this.wisdom.survivalRules || this.wisdom.survivalRules.length === 0) {
                    this.initWisdom();
                    this.log('ğŸ§  Wisdom system initialized');
                }
                
                // Load any saved playbooks from watching player
                this.loadPlaybooks();
                this.playbookStep = 0;
                this.lastAIBuildPos = null;
                this.lastAIBuildYear = 0;
                this.aiSettlementPos = null;
                this.episodeStartSnapshotTaken = false;
                this.progressMade = false;
                this.lastExpansionRadius = 0;
                this.lastQuadrantCount = 0;
                this.lastStageAwarded = 0;
                this.lastLevelUnlockAward = 1;
                this.activeMacroTactic = null;
                this.macroStepIndex = 0;
                this.macroWaitUntilYear = 0;
                this.macroRotationIndex = this.macroPlaybooks ? Math.floor(Math.random() * this.macroPlaybooks.length) : 0;
                this.assignMacroTactic(false);
                
                if(this.savedPlaybooks && this.savedPlaybooks.length > 0) {
                    this.log('ğŸ“š Using learned playbook with ' + this.savedPlaybooks[0].playbook.length + ' steps!');
                    this.log('ğŸ¯ Target: Pop=' + this.savedPlaybooks[0].finalPop + ', Year=' + this.savedPlaybooks[0].finalYear);
                } else {
                    this.log('ğŸ“ No playbook - Watch player to learn their strategy!');
                }
                
                this.log('â–¶ï¸ Training STARTED at speed ' + this.trainingSpeed + 'x');
                
                // Show floating hard stop button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'block';
                
                // Clear any existing intervals
                if(this.trainingIntervalId) clearInterval(this.trainingIntervalId);
                
                // The main training interval - NEVER stops unless user clicks stop
                this.trainingIntervalId = setInterval(function() {
                    try {
                        if(!self.isTraining) {
                            return; // Don't clear interval, just skip
                        }
                        
                        self.loopCounter++;
                        
                        // Skip steps while resetting
                        if(self.isResetting) {
                            return; // Let reset complete
                        }
                        
                        // Run steps with error protection
                        // Handle fractional speeds (< 1) by skipping frames
                        if(self.trainingSpeed < 1) {
                            // For 0.25x speed: only run every 4th frame (0.25 = 1/4)
                            // For 0.1x speed: only run every 10th frame
                            // For 0.05x speed: only run every 20th frame (super slow!)
                            self.frameSkipCounter = (self.frameSkipCounter || 0) + self.trainingSpeed;
                            if(self.frameSkipCounter >= 1) {
                                self.frameSkipCounter -= 1;
                                try {
                                    self.step();
                                } catch(stepErr) {
                                    self.errorCount++;
                                    if(self.errorCount < 10) {
                                        console.error('Step error:', stepErr);
                                    }
                                }
                            }
                        } else {
                            // Normal speed: run multiple steps per frame
                            for(var i = 0; i < self.trainingSpeed; i++) {
                                try {
                                    self.step();
                                } catch(stepErr) {
                                    self.errorCount++;
                                    if(self.errorCount < 10) {
                                        console.error('Step error:', stepErr);
                                    }
                                }
                            }
                        }
                        
                        // Periodic status log
                        if(self.loopCounter % 600 === 0) { // Every ~10 seconds
                            self.log('ğŸ’“ Running: Ep=' + self.episode + ', Loop=' + self.loopCounter + ', Errors=' + self.errorCount);
                        }
                        
                    } catch(loopErr) {
                        console.error('Loop error:', loopErr);
                        self.errorCount++;
                    }
                }, 16);
                
                this.updateTrainingUI();
            },
            
            // Stop training
            stopTraining: function() {
                this.isTraining = false;
                if(this.trainingIntervalId) {
                    clearInterval(this.trainingIntervalId);
                    this.trainingIntervalId = null;
                }
                
                // Hide floating hard stop button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'none';
                
                this.log('â¹ï¸ STOPPED - ' + this.episode + ' episodes, ' + this.errorCount + ' errors');
                this.updateTrainingUI();
            },
            
            // HARD STOP - Emergency stop all AI activity
            hardStop: function() {
                // Stop training
                this.isTraining = false;
                if(this.trainingIntervalId) {
                    clearInterval(this.trainingIntervalId);
                    this.trainingIntervalId = null;
                }
                
                // Stop watching
                this.isWatching = false;
                
                // Stop exploration test
                if(this.explorationTestMode) {
                    this.explorationTestMode = false;
                    var exploreBtn = document.getElementById('ai-explore-btn');
                    var exploreStatus = document.getElementById('ai-explore-status');
                    if(exploreBtn) {
                        exploreBtn.style.background = '#E91E63';
                        exploreBtn.textContent = 'ğŸ—ºï¸ Explore Test';
                    }
                    if(exploreStatus) exploreStatus.style.display = 'none';
                }
                
                // Hide floating button
                var hardStopBtn = document.getElementById('ai-hard-stop');
                if(hardStopBtn) hardStopBtn.style.display = 'none';
                
                // Update all UI
                this.updateTrainingUI();
                
                this.log('ğŸš¨ HARD STOP - All AI activity halted!');
                Controller.toast('ğŸš¨ AI HARD STOPPED');
            },
            
            // Get memory usage stats
            getMemoryStats: function() {
                let qTableSize = Object.keys(this.qTable).length;
                let bufferSize = (this.experienceBuffer || []).length;
                let templateSize = (this.successTemplates || []).length;
                let playbookSize = (this.savedPlaybooks || []).length;
                
                // Estimate memory usage (rough)
                let estimatedMB = (JSON.stringify(this.qTable).length / 1024 / 1024).toFixed(2);
                
                return {
                    qTableStates: qTableSize,
                    experienceBuffer: bufferSize,
                    templates: templateSize,
                    playbooks: playbookSize,
                    estimatedMB: estimatedMB
                };
            },
            
            // Clear memory to reduce usage
            clearMemory: function(keepBest = true) {
                let oldStats = this.getMemoryStats();
                
                // Clear Q-table
                this.qTable = {};
                
                // Clear experience buffer but keep best if requested
                if(keepBest && this.bestRunEver) {
                    this.experienceBuffer = [this.bestRunEver];
                } else {
                    this.experienceBuffer = [];
                }
                
                // Keep only top 3 templates
                if(this.successTemplates && this.successTemplates.length > 3) {
                    this.successTemplates = this.successTemplates.slice(0, 3);
                }
                
                // Clear playbooks except best
                if(this.savedPlaybooks && this.savedPlaybooks.length > 1) {
                    this.savedPlaybooks = this.savedPlaybooks.slice(0, 1);
                }
                
                // Clear movement history
                if(this.movementHistory) this.movementHistory = [];
                
                // Clear death locations
                if(this.exploreStats && this.exploreStats.deathLocations) {
                    this.exploreStats.deathLocations = this.exploreStats.deathLocations.slice(-100);
                }
                
                let newStats = this.getMemoryStats();
                this.log(`ğŸ§¹ Memory cleared: ${oldStats.qTableStates} â†’ ${newStats.qTableStates} states, ${oldStats.estimatedMB}MB â†’ ${newStats.estimatedMB}MB`);
                Controller.toast(`ğŸ§¹ Memory cleared! Was ${oldStats.estimatedMB}MB`);
                
                this.updateTrainingUI();
            },
            
            // Export stats to file
            exportStats: function() {
                var stats = {
                    totalEpisodes: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    statesLearned: Object.keys(this.qTable).length,
                    recentRewards: this.episodeRewards.slice(-100),
                    avgReward: this.episodeRewards.length > 0 ? 
                        (this.episodeRewards.reduce(function(a,b){return a+b;}, 0) / this.episodeRewards.length).toFixed(2) : 0,
                    exportDate: new Date().toISOString()
                };
                
                var blob = new Blob([JSON.stringify(stats, null, 2)], {type: 'application/json'});
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.download = 'ai_training_stats_' + this.episode + '_episodes.json';
                a.click();
                URL.revokeObjectURL(url);
                this.log('ğŸ“Š Stats exported!');
            },
            
            // ===== FILE-BASED Q-TABLE SAVE/LOAD =====
            // Save Q-table to a downloadable JSON file
            saveBrainToFile: function() {
                var data = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    qTable: this.qTable,
                    episode: this.episode,
                    bestScore: this.bestScore,
                    explorationRate: this.explorationRate,
                    episodeRewards: this.episodeRewards.slice(-100),
                    bestRunEver: this.bestRunEver,
                    successTemplates: this.successTemplates || [],
                    experienceBuffer: this.experienceBuffer || []
                };
                
                var blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                var filename = 'civilzones_ai_ep' + this.episode + '_' + new Date().toISOString().slice(0,10) + '.json';
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                Controller.toast('ğŸ“¥ AI saved to file: ' + filename);
                this.log('ğŸ“¥ AI brain saved: ' + Object.keys(this.qTable).length + ' states');
            },
            
            // Load Q-table from a JSON file
            loadBrainFromFile: function(file) {
                if(!file) return;
                
                var reader = new FileReader();
                var self = this;
                reader.onload = function(e) {
                    try {
                        var data = JSON.parse(e.target.result);
                        
                        // Validate the file has Q-table data
                        if(!data.qTable) {
                            Controller.toast('âŒ Invalid AI file: missing qTable data', true);
                            return;
                        }
                        
                        // Load all data
                        self.qTable = data.qTable;
                        self.episode = data.episode || 0;
                        self.bestScore = data.bestScore || 0;
                        self.explorationRate = data.explorationRate || 0.1;
                        self.episodeRewards = data.episodeRewards || [];
                        
                        // Load experience data if present
                        if(data.bestRunEver) self.bestRunEver = data.bestRunEver;
                        if(data.successTemplates) self.successTemplates = data.successTemplates;
                        if(data.experienceBuffer) self.experienceBuffer = data.experienceBuffer;
                        
                        self.updateTrainingUI();
                        
                        var statesCount = Object.keys(self.qTable).length;
                        Controller.toast('ğŸ“¤ Loaded AI from file! ' + statesCount + ' states, Episode ' + self.episode);
                        self.log('ğŸ“¤ AI brain loaded: ' + statesCount + ' states, Episode ' + self.episode);
                        
                    } catch(err) {
                        Controller.toast('âŒ Error loading AI file: ' + err.message, true);
                        console.error('Error loading AI file:', err);
                    }
                };
                reader.readAsText(file);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EXPLORATION TEST MODE - Test map collection in WANDER mode
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            toggleExplorationTest: function() {
                this.explorationTestMode = !this.explorationTestMode;
                
                let btn = document.getElementById('ai-explore-btn');
                let status = document.getElementById('ai-explore-status');
                
                if(this.explorationTestMode) {
                    // Start exploration test
                    this.resetExploreStats();
                    this.exploreStats.startTime = Date.now();
                    
                    // Count total explorable tiles
                    this.countExplorableTiles();
                    
                    if(btn) btn.style.background = '#C2185B';
                    if(btn) btn.textContent = 'ğŸ—ºï¸ Stop Test';
                    if(status) status.style.display = 'block';
                    
                    // Make sure we're in WANDER mode
                    if(Game.gameState !== 'WANDER') {
                        Controller.toast('âš ï¸ Exploration test works best in WANDER mode. Starting new game...');
                        this.forceResetGame();
                    }
                    
                    // Start training if not already
                    if(!this.isTraining) {
                        this.startTraining();
                    }
                    
                    this.log('ğŸ—ºï¸ EXPLORATION TEST STARTED - Goal: Visit all tiles, collect everything!');
                    Controller.toast('ğŸ—ºï¸ Exploration Test Mode: ON');
                } else {
                    // Stop exploration test
                    if(btn) btn.style.background = '#E91E63';
                    if(btn) btn.textContent = 'ğŸ—ºï¸ Explore Test';
                    if(status) status.style.display = 'none';
                    
                    // Show final report before resetting
                    this.showExplorationReport();
                    
                    // Reset stats so next run starts fresh
                    this.resetExploreStats();
                    this.updateExploreUI();
                    
                    this.log('ğŸ—ºï¸ EXPLORATION TEST STOPPED & RESET');
                    Controller.toast('ğŸ—ºï¸ Exploration Test Mode: OFF (Stats Reset)');
                }
            },
            
            resetExploreStats: function() {
                this.exploreStats = {
                    tilesVisited: new Set(),
                    totalTiles: 0,
                    resourcesCollected: 0,
                    berriesCollected: 0,
                    woodCollected: 0,
                    nomadsRecruited: 0,
                    animalsHunted: 0,
                    deaths: 0,
                    totalSteps: 0,
                    stepsThisRun: 0,
                    runsCompleted: 0,
                    deathLocations: [],
                    dangerZones: {},
                    startTime: Date.now()
                };
            },
            
            countExplorableTiles: function() {
                if(!Game.tiles) return;
                let count = 0;
                for(let x = 0; x < Game.tiles.length; x++) {
                    for(let y = 0; y < Game.tiles[x].length; y++) {
                        let tile = Game.tiles[x][y];
                        if(tile && tile.type !== 'WATER' && tile.type !== 'DEEP' && tile.type !== 'RIVER' && tile.type !== 'STONE') {
                            count++;
                        }
                    }
                }
                this.exploreStats.totalTiles = count;
                this.log(`ğŸ—ºï¸ Total explorable tiles: ${count}`);
            },
            
            // Called during step() when in exploration test mode
            trackExploration: function() {
                if(!this.explorationTestMode || Game.gameState !== 'WANDER') return;
                
                this.exploreStats.stepsThisRun++;
                this.exploreStats.totalSteps++;
                
                // Track current tile
                if(Game.player) {
                    let tileKey = `${Game.player.x},${Game.player.y}`;
                    this.exploreStats.tilesVisited.add(tileKey);
                    
                    // Check for resources on this tile
                    let tile = Game.tiles[Game.player.x][Game.player.y];
                    if(tile) {
                        // Track resource collection (the game auto-collects when walking over)
                        if(tile.entity) {
                            if(tile.entity.type === 'BERRY' && tile.entity.amount > 0) {
                                this.exploreStats.berriesCollected++;
                                this.exploreStats.resourcesCollected++;
                            } else if(tile.entity.type === 'NOMAD') {
                                this.exploreStats.nomadsRecruited++;
                                this.exploreStats.resourcesCollected++;
                            }
                        }
                        if(tile.tree) {
                            this.exploreStats.woodCollected++;
                            this.exploreStats.resourcesCollected++;
                        }
                        if(tile.animal) {
                            this.exploreStats.animalsHunted++;
                            this.exploreStats.resourcesCollected++;
                        }
                    }
                }
                
                // Update UI every 10 steps
                if(this.exploreStats.totalSteps % 10 === 0) {
                    this.updateExploreUI();
                }
            },
            
            // Called when AI dies in exploration test mode
            recordExploreDeath: function(cause) {
                if(!this.explorationTestMode) return;
                
                this.exploreStats.deaths++;
                this.exploreStats.runsCompleted++;
                
                // Record death location
                if(Game.player) {
                    let loc = {
                        x: Game.player.x,
                        y: Game.player.y,
                        cause: cause,
                        steps: this.exploreStats.stepsThisRun
                    };
                    this.exploreStats.deathLocations.push(loc);
                    
                    // Track danger zones
                    let key = `${Game.player.x},${Game.player.y}`;
                    this.exploreStats.dangerZones[key] = (this.exploreStats.dangerZones[key] || 0) + 1;
                }
                
                this.exploreStats.stepsThisRun = 0;
                this.updateExploreUI();
                
                this.log(`ğŸ’€ Explore death #${this.exploreStats.deaths}: ${cause} at (${Game.player?.x},${Game.player?.y})`);
            },
            
            updateExploreUI: function() {
                let tilesEl = document.getElementById('ai-explore-tiles');
                let resEl = document.getElementById('ai-explore-resources');
                let deathsEl = document.getElementById('ai-explore-deaths');
                let dangerEl = document.getElementById('ai-explore-danger');
                
                let visited = this.exploreStats.tilesVisited.size;
                let total = this.exploreStats.totalTiles || 1;
                let pct = ((visited / total) * 100).toFixed(1);
                
                let avgSteps = this.exploreStats.deaths > 0 
                    ? (this.exploreStats.totalSteps / this.exploreStats.deaths).toFixed(0) 
                    : '--';
                
                // Calculate danger per tile (deaths per 100 tiles visited)
                let dangerPer100 = visited > 0 
                    ? ((this.exploreStats.deaths / visited) * 100).toFixed(2)
                    : '--';
                
                if(tilesEl) tilesEl.textContent = `Tiles: ${visited}/${total} (${pct}%)`;
                if(resEl) resEl.textContent = `Resources: ${this.exploreStats.resourcesCollected} (ğŸ«${this.exploreStats.berriesCollected} ğŸªµ${this.exploreStats.woodCollected} ğŸ‘¥${this.exploreStats.nomadsRecruited})`;
                if(deathsEl) deathsEl.textContent = `Deaths: ${this.exploreStats.deaths} | Avg Steps/Death: ${avgSteps}`;
                if(dangerEl) dangerEl.textContent = `Danger/100 tiles: ${dangerPer100}% death chance`;
            },
            
            showExplorationReport: function() {
                let stats = this.exploreStats;
                let visited = stats.tilesVisited.size;
                let total = stats.totalTiles || 1;
                let pct = ((visited / total) * 100).toFixed(1);
                let avgSteps = stats.deaths > 0 ? (stats.totalSteps / stats.deaths).toFixed(0) : 'N/A';
                let dangerPer100 = visited > 0 ? ((stats.deaths / visited) * 100).toFixed(3) : 'N/A';
                let duration = stats.startTime ? ((Date.now() - stats.startTime) / 1000 / 60).toFixed(1) : '0';
                
                // Find most dangerous zones
                let dangerList = Object.entries(stats.dangerZones)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([loc, count]) => `  ${loc}: ${count} deaths`)
                    .join('\n') || '  None recorded';
                
                // Death cause breakdown
                let causes = {};
                stats.deathLocations.forEach(d => {
                    causes[d.cause] = (causes[d.cause] || 0) + 1;
                });
                let causeList = Object.entries(causes)
                    .sort((a, b) => b[1] - a[1])
                    .map(([cause, count]) => `  ${cause}: ${count}`)
                    .join('\n') || '  None recorded';
                
                let report = `
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ—ºï¸ EXPLORATION TEST REPORT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š COVERAGE:
  Tiles Visited: ${visited} / ${total} (${pct}%)
  Test Duration: ${duration} minutes
  Total Steps: ${stats.totalSteps}
  Runs Completed: ${stats.runsCompleted}

ğŸ“¦ RESOURCES COLLECTED:
  Berries: ${stats.berriesCollected}
  Wood: ${stats.woodCollected}
  Nomads Recruited: ${stats.nomadsRecruited}
  Animals Hunted: ${stats.animalsHunted}
  Total: ${stats.resourcesCollected}

ğŸ’€ SURVIVAL ANALYSIS:
  Total Deaths: ${stats.deaths}
  Avg Steps Before Death: ${avgSteps}
  Danger Rating: ${dangerPer100}% per 100 tiles

â˜ ï¸ DEATH CAUSES:
${causeList}

âš ï¸ MOST DANGEROUS LOCATIONS:
${dangerList}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${visited >= total ? 'ğŸ† MAP 100% EXPLORED!' : `Progress: ${pct}% - Keep exploring!`}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
                
                console.log(report);
                alert(report);
                this.log('ğŸ“ˆ Exploration report generated - check console for details');
            },
            
            // Modified chooseAction for exploration test mode
            getExplorationAction: function() {
                // In exploration mode, never settle - just explore!
                if(Game.gameState !== 'WANDER') return null;
                
                // Always WANDER to explore
                return 'WANDER';
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WISDOM SYSTEM - Summarized knowledge instead of raw data
            // Complex ideas = simple working tasks put together logically
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Learned rules (wisdom extracted from experience)
            wisdom: {
                // Survival rules: condition â†’ required action
                survivalRules: [],
                // Build order patterns that work
                successFlows: [],
                // Ratios that work well
                optimalRatios: { wellsPerPop: 0.01, resPerWell: 4, comPerRes: 0.25, indPerRes: 0.15 },
                // Timing rules
                timingRules: [],
                // Statistics for rule confidence
                ruleStats: {}
            },
            
            // Initialize wisdom with basic rules
            initWisdom: function() {
                // Core survival rules (condition â†’ action â†’ priority)
                this.wisdom.survivalRules = [
                    { id: 'thirst', condition: 'pop > wells * 100', action: 'BUILD_WELL', priority: 10, confidence: 1.0 },
                    { id: 'housing', condition: 'pop >= housingCap - 5', action: 'BUILD_RES', priority: 8, confidence: 1.0 },
                    { id: 'food_low', condition: 'food < pop * 5', action: 'BUILD_COM', priority: 7, confidence: 0.8 },
                    { id: 'expand', condition: 'pop > 20 && roads < pop/5', action: 'BUILD_ROAD', priority: 5, confidence: 0.7 }
                ];
                
                // Basic success flow (what order to build)
                this.wisdom.successFlows = [
                    { name: 'Basic Start', steps: ['SETTLE', 'BUILD_WELL', 'BUILD_RES', 'BUILD_RES', 'BUILD_WELL', 'BUILD_COM'], avgPop: 0, uses: 0, successes: 0 }
                ];
                
                // Timing rules (when to do things)
                this.wisdom.timingRules = [
                    { id: 'early_wells', rule: 'Build well before pop > 50', yearRange: [0, 5], triggered: 0, helped: 0 },
                    { id: 'expand_y10', rule: 'Build roads after year 10', yearRange: [10, 20], triggered: 0, helped: 0 }
                ];
            },
            
            // Learn from a completed episode - extract patterns
            learnFromEpisode: function(result) {
                let dominated = result.pop < 10 && result.year < 5; // Quick death, not useful
                
                // Update rule confidence based on what happened
                if(result.deathCause) {
                    this.updateRuleFromFailure(result);
                }
                
                if(result.pop >= 20 || result.year >= 10) {
                    this.updateRuleFromSuccess(result);
                }
                
                // Update optimal ratios from successful runs
                if(result.pop >= 30 && result.year >= 15) {
                    this.updateOptimalRatios(result);
                }
                
                // Extract successful build flows
                if(result.buildOrder && result.buildOrder.length >= 5 && result.pop >= 25) {
                    this.extractSuccessFlow(result);
                }
                
                // Prune low-confidence rules
                this.pruneWisdom();
            },
            
            // Update rules based on failure
            updateRuleFromFailure: function(result) {
                let cause = result.deathCause || 'unknown';
                let stats = this.wisdom.ruleStats;
                
                // Track failure patterns (summarized, not individual)
                let patternKey = `${cause}_pop${Math.floor(result.pop/20)*20}_yr${Math.floor(result.year/10)*10}`;
                stats[patternKey] = stats[patternKey] || { count: 0, lastSeen: 0 };
                stats[patternKey].count++;
                stats[patternKey].lastSeen = Date.now();
                
                // If same failure happens 3+ times, create/strengthen a rule
                if(stats[patternKey].count >= 3) {
                    let existingRule = this.wisdom.survivalRules.find(r => r.id === 'learned_' + patternKey);
                    if(!existingRule) {
                        // Create new rule based on failure pattern
                        let newRule = this.createRuleFromFailure(cause, result);
                        if(newRule) {
                            this.wisdom.survivalRules.push(newRule);
                            console.log(`[WISDOM] New rule learned: ${newRule.id} â†’ ${newRule.action}`);
                        }
                    } else {
                        existingRule.confidence = Math.min(1.0, existingRule.confidence + 0.1);
                    }
                }
            },
            
            // Create a rule from repeated failures
            createRuleFromFailure: function(cause, result) {
                let pop = result.pop || 0;
                let wells = result.wells || 0;
                let res = result.resCount || 0;
                
                switch(cause) {
                    case 'thirst':
                    case 'water-crisis':
                    case 'dehydration':
                        return {
                            id: 'learned_water_' + Math.floor(pop/20)*20,
                            condition: `pop > ${Math.max(10, pop - 20)} && wells < ${wells + 1}`,
                            action: 'BUILD_WELL',
                            priority: 10,
                            confidence: 0.6,
                            learned: true
                        };
                    case 'famine':
                    case 'starvation':
                        return {
                            id: 'learned_food_' + Math.floor(pop/20)*20,
                            condition: `pop > ${Math.max(10, pop - 10)} && food < pop * 3`,
                            action: 'BUILD_COM',
                            priority: 8,
                            confidence: 0.6,
                            learned: true
                        };
                    case 'overcrowding':
                        return {
                            id: 'learned_housing_' + Math.floor(pop/20)*20,
                            condition: `pop >= housingCap - 10`,
                            action: 'BUILD_RES',
                            priority: 7,
                            confidence: 0.6,
                            learned: true
                        };
                    default:
                        return null;
                }
            },
            
            // Update rules from successful runs
            updateRuleFromSuccess: function(result) {
                // Boost confidence of rules that match successful state
                let wells = result.wells || 0;
                let pop = result.pop || 0;
                
                // If we had enough wells and survived, that ratio works
                if(pop > 50 && wells > 0) {
                    let ratio = pop / wells;
                    // Update optimal ratio (weighted average)
                    this.wisdom.optimalRatios.wellsPerPop = 
                        (this.wisdom.optimalRatios.wellsPerPop * 0.9) + ((1/ratio) * 0.1);
                }
            },
            
            // Update optimal ratios from very successful runs
            updateOptimalRatios: function(result) {
                if(!result.buildings) return;
                
                let res = result.buildings.filter(b => b.t === 'RES' || b.t === 'R').length;
                let com = result.buildings.filter(b => b.t === 'COM' || b.t === 'C').length;
                let ind = result.buildings.filter(b => b.t === 'IND' || b.t === 'I').length;
                let wells = result.wells || 0;
                
                if(res > 0) {
                    // Weighted update of ratios
                    let w = 0.1; // Learning weight
                    if(com > 0) this.wisdom.optimalRatios.comPerRes = this.wisdom.optimalRatios.comPerRes * (1-w) + (com/res) * w;
                    if(ind > 0) this.wisdom.optimalRatios.indPerRes = this.wisdom.optimalRatios.indPerRes * (1-w) + (ind/res) * w;
                    if(wells > 0) this.wisdom.optimalRatios.resPerWell = this.wisdom.optimalRatios.resPerWell * (1-w) + (res/wells) * w;
                }
            },
            
            // Extract a successful build flow
            extractSuccessFlow: function(result) {
                // Simplify build order (remove duplicates in sequence)
                let simplified = [];
                let lastAction = null;
                for(let action of result.buildOrder.slice(0, 15)) {
                    if(action !== lastAction || action === 'BUILD_RES') {
                        simplified.push(action);
                        lastAction = action;
                    }
                }
                
                // Check if similar flow exists
                let similar = this.wisdom.successFlows.find(f => {
                    if(f.steps.length !== simplified.length) return false;
                    let matches = 0;
                    for(let i = 0; i < f.steps.length; i++) {
                        if(f.steps[i] === simplified[i]) matches++;
                    }
                    return matches / f.steps.length > 0.7; // 70% similar
                });
                
                if(similar) {
                    // Update existing flow
                    similar.uses++;
                    similar.avgPop = (similar.avgPop * (similar.uses - 1) + result.pop) / similar.uses;
                    if(result.pop >= 30) similar.successes++;
                } else if(this.wisdom.successFlows.length < 10) {
                    // Add new flow
                    this.wisdom.successFlows.push({
                        name: `Flow_${Date.now()}`,
                        steps: simplified,
                        avgPop: result.pop,
                        uses: 1,
                        successes: result.pop >= 30 ? 1 : 0
                    });
                }
                
                // Sort by success rate and prune to top 5
                this.wisdom.successFlows.sort((a, b) => {
                    let rateA = a.uses > 0 ? a.successes / a.uses : 0;
                    let rateB = b.uses > 0 ? b.successes / b.uses : 0;
                    return rateB - rateA;
                });
                this.wisdom.successFlows = this.wisdom.successFlows.slice(0, 5);
            },
            
            // Prune low-value wisdom to save memory
            pruneWisdom: function() {
                // Remove low-confidence learned rules
                this.wisdom.survivalRules = this.wisdom.survivalRules.filter(r => 
                    !r.learned || r.confidence >= 0.3
                );
                
                // Remove old failure stats (older than 1 hour)
                let cutoff = Date.now() - 3600000;
                for(let key in this.wisdom.ruleStats) {
                    if(this.wisdom.ruleStats[key].lastSeen < cutoff && this.wisdom.ruleStats[key].count < 5) {
                        delete this.wisdom.ruleStats[key];
                    }
                }
                
                // Keep rule stats under 100 entries
                let statsKeys = Object.keys(this.wisdom.ruleStats);
                if(statsKeys.length > 100) {
                    statsKeys.sort((a, b) => this.wisdom.ruleStats[b].count - this.wisdom.ruleStats[a].count);
                    for(let i = 100; i < statsKeys.length; i++) {
                        delete this.wisdom.ruleStats[statsKeys[i]];
                    }
                }
            },
            
            // Get best action from wisdom (rule-based)
            getWisdomAction: function(ctx) {
                if(!ctx) return null;
                
                // Evaluate all survival rules
                let applicableRules = [];
                for(let rule of this.wisdom.survivalRules) {
                    if(this.evaluateCondition(rule.condition, ctx)) {
                        applicableRules.push(rule);
                    }
                }
                
                if(applicableRules.length === 0) return null;
                
                // Sort by priority * confidence
                applicableRules.sort((a, b) => (b.priority * b.confidence) - (a.priority * a.confidence));
                
                // Return highest priority action we can afford
                for(let rule of applicableRules) {
                    if(this.canAffordAction(rule.action, ctx)) {
                        return rule.action;
                    }
                }
                
                return null;
            },
            
            // Simple condition evaluator
            evaluateCondition: function(condition, ctx) {
                try {
                    // Replace variables with context values
                    let expr = condition
                        .replace(/pop/g, ctx.pop || 0)
                        .replace(/wells/g, ctx.wellCount || 0)
                        .replace(/housingCap/g, ctx.housingCap || 0)
                        .replace(/food/g, ctx.food || 0)
                        .replace(/roads/g, ctx.roadCount || 0)
                        .replace(/res/g, ctx.resCount || 0)
                        .replace(/com/g, ctx.comCount || 0)
                        .replace(/ind/g, ctx.indCount || 0);
                    
                    // Safely evaluate (basic math only)
                    return Function('"use strict"; return (' + expr + ')')();
                } catch(e) {
                    return false;
                }
            },
            
            // Get suggested flow step
            getFlowAction: function(buildCount) {
                if(this.wisdom.successFlows.length === 0) return null;
                
                // Use best flow (highest success rate)
                let bestFlow = this.wisdom.successFlows[0];
                if(buildCount < bestFlow.steps.length) {
                    return bestFlow.steps[buildCount];
                }
                return null;
            },
            
            // Show wisdom summary
            showWisdom: function() {
                let w = this.wisdom;
                let msg = 'ğŸ§  AI WISDOM SUMMARY\n\n';
                
                msg += 'ğŸ“‹ SURVIVAL RULES:\n';
                w.survivalRules.slice(0, 8).forEach(r => {
                    msg += `  ${r.learned ? 'ğŸ†•' : 'ğŸ“Œ'} ${r.action} (priority:${r.priority}, conf:${(r.confidence*100).toFixed(0)}%)\n`;
                });
                
                msg += '\nğŸ“Š OPTIMAL RATIOS:\n';
                msg += `  Wells: 1 per ${Math.round(1/w.optimalRatios.wellsPerPop)} pop\n`;
                msg += `  RES per Well: ${w.optimalRatios.resPerWell.toFixed(1)}\n`;
                msg += `  COM per RES: ${(w.optimalRatios.comPerRes*100).toFixed(0)}%\n`;
                msg += `  IND per RES: ${(w.optimalRatios.indPerRes*100).toFixed(0)}%\n`;
                
                msg += '\nğŸ”„ SUCCESS FLOWS:\n';
                w.successFlows.slice(0, 3).forEach((f, i) => {
                    let rate = f.uses > 0 ? ((f.successes/f.uses)*100).toFixed(0) : 0;
                    msg += `  ${i+1}. ${f.steps.slice(0,5).join('â†’')}...\n`;
                    msg += `     AvgPop:${f.avgPop.toFixed(0)} Success:${rate}% (${f.uses} uses)\n`;
                });
                
                msg += `\nğŸ’¾ Stats tracked: ${Object.keys(w.ruleStats).length} patterns`;
                
                alert(msg);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EXPERIENCE REPLAY BUFFER - Simplified, wisdom-based
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            experienceBuffer: [],
            maxBufferSize: 10, // Reduced from 50 - we learn rules, not store data
            successTemplates: [],  // Proven build sequences
            bestRunEver: null,     // Single best run for replay
            
            // Record experience at end of episode - now uses wisdom system
            recordExperience: function() {
                let exp = {
                    episode: this.episode,
                    reward: this.totalReward,
                    pop: Game.pop || 0,
                    year: Game.year || 0,
                    wells: Game.wellCount || 0,
                    resCount: Game.zoneCount || 0,
                    buildings: Game.blds ? Game.blds.map(b => ({t: b.t})) : [], // Just type, not position
                    buildOrder: (this.episodeBuildOrder || []).slice(0, 20), // Max 20 actions
                    deathCause: this.lastDeathCause
                };
                
                // LEARN FROM THIS EPISODE - extract wisdom instead of storing raw data
                this.learnFromEpisode(exp);
                
                // Only keep top 10 experiences (not 50)
                this.experienceBuffer.push(exp);
                this.experienceBuffer.sort((a, b) => b.reward - a.reward);
                if(this.experienceBuffer.length > this.maxBufferSize) {
                    this.experienceBuffer.pop();
                }
                
                // Track best run ever (single reference)
                if(!this.bestRunEver || exp.reward > this.bestRunEver.reward) {
                    this.bestRunEver = exp;
                    this.log(`ğŸ† NEW BEST! Pop:${exp.pop} Year:${exp.year}`);
                }
            },
            
            // Create a success template from a good run
            createSuccessTemplate: function(exp) {
                // Check if we already have a similar template
                let dominated = this.successTemplates.some(t => 
                    t.pop >= exp.pop && t.year >= exp.year
                );
                if(dominated) return;
                
                let template = {
                    id: 'auto_' + Date.now(),
                    name: `Pop${exp.pop}_Yr${exp.year}`,
                    pop: exp.pop,
                    year: exp.year,
                    reward: exp.reward,
                    buildOrder: exp.buildOrder.slice(0, 20), // First 20 actions
                    stage: exp.stage,
                    created: new Date().toISOString()
                };
                
                // Remove templates this one dominates
                this.successTemplates = this.successTemplates.filter(t => 
                    t.pop > template.pop || t.year > template.year
                );
                
                this.successTemplates.push(template);
                this.successTemplates.sort((a, b) => b.pop - a.pop);
                
                // Keep only top 10 templates
                if(this.successTemplates.length > 10) {
                    this.successTemplates = this.successTemplates.slice(0, 10);
                }
                
                this.log(`ğŸ“‹ Created success template: ${template.name}`);
            },
            
            // Replay the best run (use its build order)
            replayBestRun: function() {
                if(!this.bestRunEver || !this.bestRunEver.buildOrder.length) {
                    Controller.toast('No best run recorded yet! Train more first.');
                    return;
                }
                
                // Convert best run to a playbook format
                this.replayPlaybook = this.bestRunEver.buildOrder.slice();
                this.replayStep = 0;
                this.useReplayMode = true;
                
                Controller.toast(`ğŸ”„ Replaying best run (Pop:${this.bestRunEver.pop}, Yr:${this.bestRunEver.year})`);
                this.log(`ğŸ”„ Replay mode: ${this.replayPlaybook.length} actions from best run`);
            },
            
            // Get next action from replay if active
            getReplayAction: function() {
                if(!this.useReplayMode || !this.replayPlaybook) return null;
                
                if(this.replayStep >= this.replayPlaybook.length) {
                    this.useReplayMode = false;
                    this.log('ğŸ”„ Replay complete, resuming normal AI');
                    return null;
                }
                
                let action = this.replayPlaybook[this.replayStep];
                this.replayStep++;
                return action;
            },
            
            // Show success templates in a popup
            showSuccessTemplates: function() {
                if(this.successTemplates.length === 0) {
                    Controller.toast('No success templates yet! Get pop 30+ for 10+ years.');
                    return;
                }
                
                let msg = 'ğŸ“‹ SUCCESS TEMPLATES:\n\n';
                this.successTemplates.forEach((t, i) => {
                    msg += `${i+1}. ${t.name}\n`;
                    msg += `   Pop:${t.pop} Year:${t.year} Stage:${t.stage}\n`;
                    msg += `   Build: ${t.buildOrder.slice(0,5).join('â†’')}...\n\n`;
                });
                msg += '\nAI will automatically use these patterns!';
                
                alert(msg);
            },
            
            // Soft reset - keep best patterns but reset Q-table
            softReset: function() {
                // Keep these
                let keepTemplates = this.successTemplates.slice();
                let keepBest = this.bestRunEver;
                let keepBuffer = this.experienceBuffer.slice(0, 10); // Top 10
                let keepTacticStats = this.tacticStats ? {...this.tacticStats} : {};
                
                // Reset Q-table but boost exploration
                this.qTable = {};
                this.episode = 0;
                this.totalReward = 0;
                this.episodeRewards = [];
                this.explorationRate = 0.8; // High but not 1.0
                
                // Restore keepers
                this.successTemplates = keepTemplates;
                this.bestRunEver = keepBest;
                this.experienceBuffer = keepBuffer;
                this.tacticStats = keepTacticStats;
                
                this.log('â™»ï¸ Soft reset: Q-table cleared, patterns preserved');
                Controller.toast('â™»ï¸ Soft Reset! Patterns kept, fresh start.');
                this.updateTrainingUI();
            },
            
            // Use success template to guide early actions
            getTemplateGuidedAction: function(ctx) {
                if(this.successTemplates.length === 0) return null;
                if(Game.year > 15) return null; // Only guide early game
                
                // Find best matching template for current situation
                let bestTemplate = null;
                for(let t of this.successTemplates) {
                    if(t.buildOrder && t.buildOrder.length > 0) {
                        bestTemplate = t;
                        break;
                    }
                }
                
                if(!bestTemplate) return null;
                
                // Count how many builds we've done
                let buildCount = (Game.blds ? Game.blds.length : 0);
                if(buildCount < bestTemplate.buildOrder.length) {
                    // 30% chance to follow template (not deterministic)
                    if(Math.random() < 0.3) {
                        let suggestedAction = bestTemplate.buildOrder[buildCount];
                        if(this.canAffordAction(suggestedAction, ctx)) {
                            this.log(`ğŸ“‹ Template suggests: ${suggestedAction}`);
                            return suggestedAction;
                        }
                    }
                }
                
                return null;
            },
            
            // Check if AI can afford an action
            canAffordAction: function(action, ctx) {
                if(!ctx) return true;
                switch(action) {
                    case 'BUILD_RES': return ctx.food >= ctx.resCost.food && ctx.wood >= ctx.resCost.wood;
                    case 'BUILD_WELL': return ctx.food >= ctx.wellCost;
                    case 'BUILD_ROAD': return ctx.food >= ctx.roadCost;
                    case 'BUILD_COM': return ctx.food >= ctx.comCost.food && ctx.wood >= ctx.comCost.wood;
                    case 'BUILD_IND': return ctx.food >= ctx.indCost.food && ctx.wood >= ctx.indCost.wood;
                    default: return true;
                }
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FAILURE PATTERN DETECTION - Learn what NOT to do
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            failurePatterns: {},
            
            recordFailurePattern: function() {
                if(!this.lastDeathCause) return;
                
                // Create pattern key from recent state
                let pop = Game.pop || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.zoneCount || 0;
                let year = Game.year || 0;
                
                let pattern = `${this.lastDeathCause}_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`;
                
                this.failurePatterns[pattern] = (this.failurePatterns[pattern] || 0) + 1;
                
                // If we've hit this pattern 3+ times, it's a known failure
                if(this.failurePatterns[pattern] >= 3) {
                    this.log(`âš ï¸ Known failure pattern: ${pattern} (${this.failurePatterns[pattern]}x)`);
                }
            },
            
            // Check if current state matches a known failure pattern
            isKnownFailureState: function() {
                let pop = Game.pop || 0;
                let wellCount = Game.wellCount || 0;
                let resCount = Game.zoneCount || 0;
                let year = Game.year || 0;
                
                // Check common failure causes
                let patterns = [
                    `thirst_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`,
                    `water-crisis_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`,
                    `famine_p${Math.floor(pop/10)*10}_w${wellCount}_r${resCount}_y${Math.floor(year/5)*5}`
                ];
                
                for(let p of patterns) {
                    if(this.failurePatterns[p] >= 3) {
                        return { pattern: p, count: this.failurePatterns[p] };
                    }
                }
                return null;
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ADVANCED PLAYTESTING FEATURES - Bug Detection & Balance Testing
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            playtestMetrics: {
                bugsFound: [],
                balanceIssues: [],
                exploitsDetected: [],
                coverageMap: {},
                milestoneTimings: []
            },
            
            // Detect potential bugs/anomalies in game state
            detectBugs: function() {
                let bugs = [];
                
                // Check for negative values
                if(Game.pop < 0) bugs.push({type: 'NEGATIVE_POP', value: Game.pop, severity: 'critical'});
                if(Game.food < 0) bugs.push({type: 'NEGATIVE_FOOD', value: Game.food, severity: 'warning'});
                if(Game.wood < 0) bugs.push({type: 'NEGATIVE_WOOD', value: Game.wood, severity: 'warning'});
                
                // Check for impossible states
                if(Game.pop > 0 && Game.zoneCount === 0) {
                    bugs.push({type: 'POP_WITHOUT_HOUSING', pop: Game.pop, severity: 'warning'});
                }
                
                // Check for water without wells
                if(Game.gameState === 'CITY' && Game.wellCount === 0 && Game.year > 3) {
                    bugs.push({type: 'NO_WATER_SOURCE', year: Game.year, severity: 'balance'});
                }
                
                // Check for NaN values
                if(isNaN(Game.pop)) bugs.push({type: 'NAN_POP', severity: 'critical'});
                if(isNaN(Game.food)) bugs.push({type: 'NAN_FOOD', severity: 'critical'});
                
                // Record any new bugs
                for(let bug of bugs) {
                    let bugKey = `${bug.type}_${bug.severity}`;
                    if(!this.playtestMetrics.bugsFound.some(b => `${b.type}_${b.severity}` === bugKey)) {
                        this.playtestMetrics.bugsFound.push({...bug, episode: this.episode, timestamp: Date.now()});
                        this.log(`ğŸ› BUG DETECTED: ${bug.type} (${bug.severity})`);
                    }
                }
                
                return bugs;
            },
            
            // Track game balance metrics
            trackBalanceMetrics: function() {
                let year = Game.year || 0;
                let pop = Game.pop || 0;
                
                // Track milestone timings
                let milestones = [
                    { name: 'first_building', condition: () => Game.blds && Game.blds.length >= 1 },
                    { name: 'pop_10', condition: () => pop >= 10 },
                    { name: 'pop_25', condition: () => pop >= 25 },
                    { name: 'pop_50', condition: () => pop >= 50 },
                    { name: 'pop_100', condition: () => pop >= 100 },
                    { name: 'first_industrial', condition: () => Game.blds && Game.blds.some(b => b.t === 'IND') },
                    { name: 'level_2_unlock', condition: () => PROGRESSION && PROGRESSION.unlockedLevels && PROGRESSION.unlockedLevels.includes(2) },
                    { name: 'level_3_unlock', condition: () => PROGRESSION && PROGRESSION.unlockedLevels && PROGRESSION.unlockedLevels.includes(3) },
                ];
                
                for(let m of milestones) {
                    if(!this['_milestone_' + m.name] && m.condition()) {
                        this['_milestone_' + m.name] = true;
                        this.playtestMetrics.milestoneTimings.push({
                            milestone: m.name,
                            year: year,
                            episode: this.episode,
                            timestamp: Date.now()
                        });
                        this.log(`ğŸ Milestone: ${m.name} at Year ${year}`);
                    }
                }
            },
            
            // Detect potential exploits
            detectExploits: function() {
                let exploits = [];
                let year = Game.year || 0;
                let pop = Game.pop || 0;
                
                // Fast population growth (might be exploit)
                if(year > 0 && pop / year > 10) {
                    exploits.push({type: 'FAST_POP_GROWTH', ratio: pop/year, severity: 'investigate'});
                }
                
                // Resource hoarding without using them
                if(Game.food > 10000 && Game.blds && Game.blds.length < 5) {
                    exploits.push({type: 'RESOURCE_HOARD', food: Game.food, buildings: Game.blds.length, severity: 'investigate'});
                }
                
                // Dying with lots of resources (might indicate unclear mechanics)
                if(this.lastDeathCause && Game.food > 500 && Game.wood > 200) {
                    exploits.push({type: 'DEATH_WITH_RESOURCES', cause: this.lastDeathCause, food: Game.food, severity: 'balance'});
                }
                
                for(let e of exploits) {
                    let key = `${e.type}_${this.episode}`;
                    if(!this.playtestMetrics.exploitsDetected.some(x => x.key === key)) {
                        e.key = key;
                        this.playtestMetrics.exploitsDetected.push(e);
                        this.log(`âš¡ EXPLOIT?: ${e.type}`);
                    }
                }
            },
            
            // Track which game mechanics have been tested
            trackCoverage: function(action) {
                this.playtestMetrics.coverageMap[action] = (this.playtestMetrics.coverageMap[action] || 0) + 1;
            },
            
            // Generate playtest report
            generatePlaytestReport: function() {
                let report = {
                    summary: {
                        totalEpisodes: this.episode,
                        bestPopulation: this.bestPopulation,
                        bestSurvivalYears: this.bestSurvivalYears,
                        citiesBuilt: this.citiesBuilt,
                        balancedCities: this.balancedCities
                    },
                    bugs: this.playtestMetrics.bugsFound,
                    exploits: this.playtestMetrics.exploitsDetected,
                    milestones: this.playtestMetrics.milestoneTimings,
                    coverage: this.playtestMetrics.coverageMap,
                    deathCauses: this.deathCauses || {},
                    failurePatterns: Object.entries(this.failurePatterns || {})
                        .filter(([k, v]) => v >= 2)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                };
                
                // Log summary
                this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                this.log('ğŸ“Š PLAYTEST REPORT');
                this.log(`   Episodes: ${report.summary.totalEpisodes}`);
                this.log(`   Best Pop: ${report.summary.bestPopulation}`);
                this.log(`   Bugs Found: ${report.bugs.length}`);
                this.log(`   Exploits: ${report.exploits.length}`);
                this.log(`   Actions Tested: ${Object.keys(report.coverage).length}`);
                this.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                return report;
            },
            
            // Show playtest report in alert
            showPlaytestReport: function() {
                let report = this.generatePlaytestReport();
                
                let msg = 'ğŸ® AI PLAYTEST REPORT\\n\\n';
                msg += `ğŸ“Š ${report.summary.totalEpisodes} episodes played\\n`;
                msg += `ğŸ‘¥ Best population: ${report.summary.bestPopulation}\\n`;
                msg += `ğŸ“… Longest survival: ${report.summary.bestSurvivalYears} years\\n`;
                msg += `ğŸ™ï¸ Cities built: ${report.summary.citiesBuilt}\\n\\n`;
                
                if(report.bugs.length > 0) {
                    msg += `ğŸ› BUGS FOUND (${report.bugs.length}):\\n`;
                    report.bugs.slice(0, 5).forEach(b => {
                        msg += `   - ${b.type} (${b.severity})\\n`;
                    });
                    msg += '\\n';
                }
                
                if(report.exploits.length > 0) {
                    msg += `âš¡ POTENTIAL EXPLOITS (${report.exploits.length}):\\n`;
                    report.exploits.slice(0, 5).forEach(e => {
                        msg += `   - ${e.type}\\n`;
                    });
                    msg += '\\n';
                }
                
                msg += 'ğŸ’€ TOP DEATH CAUSES:\\n';
                Object.entries(report.deathCauses)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .forEach(([cause, count]) => {
                        msg += `   - ${cause}: ${count}x\\n`;
                    });
                
                alert(msg);
            },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // IMITATION LEARNING V2 - AI learns EXACT patterns from player
            // Records: what you built, where relative to other buildings,
            // timing (years between builds), and terrain context
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Start watching player - records detailed playbook
            startWatching: function() {
                this.isWatching = true;
                this.watchStartState = this.getState();
                this.watchStartYear = Game.year || 0;
                this.watchStartPop = Game.pop || 0;
                
                // The playbook - a sequence of actions with context
                this.playerPlaybook = [];
                this.lastBuildPos = null;      // Last building position
                this.lastBuildYear = 0;        // Year of last build
                this.settlementPos = null;     // Where player settled
                
                this.log('ğŸ‘ï¸ AI is now WATCHING you play!');
                this.log('ğŸ“ Recording your exact build order, timing, and positions...');
                Controller.toast('ğŸ‘ï¸ AI is watching! Build your city and I\'ll learn your strategy!');
                this.updateWatchUI();
            },
            
            // Stop watching and compile the learned playbook
            stopWatching: function() {
                if(!this.isWatching) return;
                
                this.isWatching = false;
                let actions = this.playerPlaybook.length;
                
                if(actions > 0) {
                    // Save playbook to localStorage for future runs
                    this.savedPlaybooks = this.savedPlaybooks || [];
                    this.savedPlaybooks.push({
                        playbook: this.playerPlaybook,
                        finalPop: Game.pop,
                        finalYear: Game.year,
                        finalScore: Game.pop * 100 + Game.food,
                        timestamp: Date.now()
                    });
                    
                    // Keep only best 5 playbooks
                    this.savedPlaybooks.sort((a,b) => b.finalScore - a.finalScore);
                    this.savedPlaybooks = this.savedPlaybooks.slice(0, 5);
                    
                    localStorage.setItem('ai_playbooks', JSON.stringify(this.savedPlaybooks));
                    
                    this.log('ğŸ“š Learned playbook with ' + actions + ' steps!');
                    this.log('ğŸ“Š Final: Pop=' + Game.pop + ', Year=' + Game.year);
                    this.log('ğŸ’¾ Saved to memory. AI will try to copy this!');
                    Controller.toast('ğŸ“ AI learned ' + actions + ' steps from you! Score: ' + (Game.pop * 100 + Game.food));
                } else {
                    this.log('ğŸ‘ï¸ Stopped watching (no actions recorded)');
                }
                
                this.updateWatchUI();
            },
            
            // Record a player action with FULL context
            recordPlayerAction: function(action, x, y) {
                if(!this.isWatching) return;
                
                let currentYear = Game.year || 0;
                let yearsSinceLastBuild = currentYear - (this.lastBuildYear || 0);
                let currentPop = Game.pop || 0;
                let currentFood = Game.food || 0;
                let currentWood = Game.wood || 0;
                
                // Get position (from params or from click position)
                let buildX = x !== undefined ? x : (Controller.mx || 0);
                let buildY = y !== undefined ? y : (Controller.my || 0);
                
                // Calculate relative position from settlement or last build
                let relativePos = {x: 0, y: 0};
                if(this.settlementPos) {
                    relativePos.x = buildX - this.settlementPos.x;
                    relativePos.y = buildY - this.settlementPos.y;
                }
                
                // Check terrain context around build position
                let terrainContext = this.getTerrainContext(buildX, buildY);
                
                // Record the action with full context
                let record = {
                    action: action,
                    step: this.playerPlaybook.length + 1,
                    
                    // Position info
                    absolutePos: {x: buildX, y: buildY},
                    relativeToSettlement: relativePos,
                    distanceFromLast: this.lastBuildPos ? 
                        Math.sqrt(Math.pow(buildX - this.lastBuildPos.x, 2) + Math.pow(buildY - this.lastBuildPos.y, 2)) : 0,
                    
                    // Timing info
                    year: currentYear,
                    yearsSinceLastBuild: yearsSinceLastBuild,
                    
                    // Resource context
                    popWhenBuilt: currentPop,
                    foodWhenBuilt: currentFood,
                    woodWhenBuilt: currentWood,
                    
                    // Terrain context
                    nearWater: terrainContext.nearWater,
                    nearTrees: terrainContext.nearTrees,
                    nearRoad: terrainContext.nearRoad,
                    nearResidential: terrainContext.nearResidential,
                    
                    // Building counts at this moment
                    resCount: Game.zoneCount || 0,
                    wellCount: Game.wellCount || 0,
                    indCount: Game.blds ? Game.blds.filter(b => b.t === 'IND').length : 0,
                    comCount: Game.blds ? Game.blds.filter(b => b.t === 'COM').length : 0,
                    roadCount: Game.roadTileCount || 0
                };
                
                this.playerPlaybook.push(record);
                
                // Track settlement position
                if(action === 'SETTLE') {
                    this.settlementPos = {x: Game.player.x, y: Game.player.y};
                }
                
                // Update last build position
                if(action.startsWith('BUILD_')) {
                    this.lastBuildPos = {x: buildX, y: buildY};
                    this.lastBuildYear = currentYear;
                }
                
                console.log('ğŸ“ Recorded step', record.step, ':', action, 'at', buildX, ',', buildY);
                this.log('ğŸ“ Step ' + record.step + ': ' + action + ' (Pop:' + currentPop + ', Yr:' + currentYear + ')');
            },
            
            // Get terrain context around a position
            getTerrainContext: function(x, y) {
                let context = {
                    nearWater: false,
                    nearTrees: false,
                    nearRoad: false,
                    nearResidential: false
                };
                
                if(!Game.tiles) return context;
                
                for(let dx = -3; dx <= 3; dx++) {
                    for(let dy = -3; dy <= 3; dy++) {
                        let tx = x + dx, ty = y + dy;
                        if(tx < 0 || ty < 0 || tx >= CFG.W || ty >= CFG.H) continue;
                        let tile = Game.tiles[tx][ty];
                        if(!tile) continue;
                        
                        if(tile.type === 'WATER' || tile.type === 'RIVER') context.nearWater = true;
                        if(tile.tree || tile.type === 'FOREST') context.nearTrees = true;
                        if(tile.road) context.nearRoad = true;
                        if(tile.zone === 'R') context.nearResidential = true;
                    }
                }
                
                return context;
            },
            
            // AI tries to execute the learned playbook
            executePlaybook: function() {
                if(!this.savedPlaybooks || this.savedPlaybooks.length === 0) {
                    this.log('âŒ No playbook learned! Watch player first.');
                    return false;
                }
                
                // Use the best playbook
                let playbook = this.savedPlaybooks[0].playbook;
                let currentStep = this.playbookStep || 0;
                
                if(currentStep >= playbook.length) {
                    this.log('âœ… Playbook completed!');
                    this.playbookStep = 0;
                    return false;
                }
                
                let step = playbook[currentStep];
                
                // Check if conditions match (similar year, pop level)
                let currentYear = Game.year || 0;
                let currentPop = Game.pop || 0;
                
                // Wait if not enough time has passed
                if(step.year > 0 && currentYear < step.year - 2) {
                    // Pass year to catch up
                    Game.endTurn();
                    return true;
                }
                
                // Find a similar spot to build
                let buildPos = this.findSimilarBuildSpot(step);
                
                if(buildPos) {
                    // Execute the action at the found position
                    this.log('ğŸ¯ Step ' + (currentStep + 1) + ': ' + step.action);
                    
                    if(step.action === 'SETTLE') {
                        Game.settleHere();
                    } else if(step.action === 'PASS_YEAR') {
                        Game.endTurn();
                    } else if(step.action.startsWith('BUILD_')) {
                        let tool = step.action.replace('BUILD_', '');
                        if(tool === 'RES') Controller.selectedBuildingLevel = 1;
                        if(tool === 'IND') Controller.selectedIndustrialLevel = 1;
                        if(tool === 'COM') Controller.selectedCommercialLevel = 1;
                        Game.build(tool, buildPos.x, buildPos.y);
                    }
                    
                    this.playbookStep++;
                    return true;
                }
                
                // Couldn't find suitable spot, skip this step
                this.log('âš ï¸ Skipping step ' + (currentStep + 1) + ' - no suitable spot');
                this.playbookStep++;
                return true;
            },
            
            // Find a similar spot to what player used
            findSimilarBuildSpot: function(step) {
                if(!Game.tiles) return null;
                
                let bestSpot = null;
                let bestScore = -Infinity;
                
                // Search around settlement if we have one
                let centerX = Game.player ? Game.player.x : CFG.W / 2;
                let centerY = Game.player ? Game.player.y : CFG.H / 2;
                
                // If step has relative position, try that offset first
                if(step.relativeToSettlement && this.aiSettlementPos) {
                    let idealX = this.aiSettlementPos.x + step.relativeToSettlement.x;
                    let idealY = this.aiSettlementPos.y + step.relativeToSettlement.y;
                    
                    // Check if ideal spot is valid
                    if(idealX >= 0 && idealX < CFG.W && idealY >= 0 && idealY < CFG.H) {
                        let tile = Game.tiles[idealX][idealY];
                        if(tile && this.isValidBuildSpot(idealX, idealY, step.action)) {
                            return {x: idealX, y: idealY};
                        }
                    }
                }
                
                // Search for best matching spot
                for(let r = 0; r <= 20; r++) {
                    for(let dx = -r; dx <= r; dx++) {
                        for(let dy = -r; dy <= r; dy++) {
                            if(Math.abs(dx) !== r && Math.abs(dy) !== r) continue; // Only ring
                            
                            let x = centerX + dx;
                            let y = centerY + dy;
                            
                            if(x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) continue;
                            if(!this.isValidBuildSpot(x, y, step.action)) continue;
                            
                            // Score this spot based on similarity to player's choice
                            let score = this.scoreBuildSpot(x, y, step);
                            
                            if(score > bestScore) {
                                bestScore = score;
                                bestSpot = {x: x, y: y};
                            }
                        }
                    }
                    
                    // Stop if we found a decent spot
                    if(bestSpot && bestScore > 50) break;
                }
                
                return bestSpot;
            },
            
            // Check if spot is valid for building
            isValidBuildSpot: function(x, y, action) {
                if(!Game.tiles || x < 0 || y < 0 || x >= CFG.W || y >= CFG.H) return false;
                let tile = Game.tiles[x][y];
                if(!tile) return false;
                
                // Can't build on water, stone, or existing structures
                if(tile.type === 'WATER' || tile.type === 'DEEP' || tile.type === 'RIVER' || tile.type === 'STONE') return false;
                if(tile.zone || tile.road) return false;
                if(tile.stoneDeposit) return false;
                
                return true;
            },
            
            // Score a spot based on similarity to player's recorded context
            scoreBuildSpot: function(x, y, step) {
                let score = 100; // Base score
                let context = this.getTerrainContext(x, y);
                
                // Match terrain preferences from player's build
                if(step.nearWater && context.nearWater) score += 30;
                if(step.nearTrees && context.nearTrees) score += 20;
                if(step.nearRoad && context.nearRoad) score += 25;
                if(step.nearResidential && context.nearResidential) score += 25;
                
                // Penalize if player wanted something that's missing
                if(step.nearWater && !context.nearWater) score -= 20;
                if(step.nearRoad && !context.nearRoad) score -= 15;
                
                // Bonus for matching distance from last build
                if(this.lastAIBuildPos) {
                    let dist = Math.sqrt(Math.pow(x - this.lastAIBuildPos.x, 2) + Math.pow(y - this.lastAIBuildPos.y, 2));
                    let targetDist = step.distanceFromLast || 2;
                    let distDiff = Math.abs(dist - targetDist);
                    score -= distDiff * 5; // Penalize distance mismatch
                }
                
                return score;
            },
            
            // Load saved playbooks from localStorage
            loadPlaybooks: function() {
                try {
                    let saved = localStorage.getItem('ai_playbooks');
                    if(saved) {
                        this.savedPlaybooks = JSON.parse(saved);
                        this.log('ğŸ“‚ Loaded ' + this.savedPlaybooks.length + ' playbooks');
                    }
                } catch(e) {
                    console.error('Failed to load playbooks:', e);
                }
            },
            
            // Update watch UI
            updateWatchUI: function() {
                let btn = document.getElementById('ai-watch-btn');
                if(btn) {
                    btn.textContent = this.isWatching ? 'â¹ï¸ Stop Watching' : 'ğŸ‘ï¸ Watch Me';
                    btn.style.background = this.isWatching ? '#e74c3c' : '#9b59b6';
                }
                let countEl = document.getElementById('ai-demo-count');
                if(countEl) countEl.textContent = (this.playerPlaybook || []).length;
                
                // Show playbook count
                let playbookCountEl = document.getElementById('ai-playbook-count');
                if(playbookCountEl) playbookCountEl.textContent = (this.savedPlaybooks || []).length + ' playbooks saved';
            },
            
            // Update training UI panel
            updateTrainingUI: function() {
                let panel = document.getElementById('ai-training-panel');
                if(!panel) return;
                
                let avgReward = this.episodeRewards.length > 0 
                    ? (this.episodeRewards.slice(-20).reduce((a,b) => a+b, 0) / Math.min(20, this.episodeRewards.length)).toFixed(1)
                    : 0;
                
                document.getElementById('ai-episode').textContent = this.episode;
                document.getElementById('ai-best-score').textContent = this.bestScore.toFixed(1);
                document.getElementById('ai-avg-reward').textContent = avgReward;
                document.getElementById('ai-exploration').textContent = (this.explorationRate * 100).toFixed(1) + '%';
                document.getElementById('ai-states').textContent = Object.keys(this.qTable).length;
                
                // Update learning analytics
                let citiesEl = document.getElementById('ai-cities-built');
                let bestPopEl = document.getElementById('ai-best-pop');
                let bestYearEl = document.getElementById('ai-best-year');
                let rciEl = document.getElementById('ai-rci-balance');
                let smartEl = document.getElementById('ai-settled-near-res');
                
                if(citiesEl) citiesEl.textContent = 'Cities Built: ' + this.citiesBuilt;
                if(bestPopEl) bestPopEl.textContent = 'Best Population: ' + this.bestPopulation;
                if(bestYearEl) bestYearEl.textContent = 'Best Survival: ' + this.bestSurvivalYears + ' years';
                if(rciEl) rciEl.textContent = 'Balanced Cities: ' + this.balancedCities;
                if(smartEl) smartEl.textContent = 'Smart Settlements: ' + this.smartSettlements;
                
                // Update curriculum phase banner
                let phaseBanner = document.getElementById('ai-phase-banner');
                if(phaseBanner) {
                    let phase = this.learningPhase || 1;
                    if(phase === 1) {
                        phaseBanner.style.background = '#2e7d32';
                        phaseBanner.innerHTML = 'ğŸ“ Phase 1: Learning Survival (' + this.citiesBuilt + '/' + this.phase1Threshold + ' cities)';
                    } else if(phase === 2) {
                        phaseBanner.style.background = '#1565c0';
                        phaseBanner.innerHTML = 'ğŸ—ï¸ Phase 2: Building Cities (' + this.balancedCities + '/' + this.phase2Threshold + ' balanced)';
                    } else {
                        phaseBanner.style.background = '#6a1b9a';
                        phaseBanner.innerHTML = 'ğŸ‘‘ Phase 3: Mastering Balance!';
                    }
                }
                
                // Update memory stats
                let memStats = this.getMemoryStats();
                let memStatesEl = document.getElementById('ai-mem-states');
                let memMbEl = document.getElementById('ai-mem-mb');
                if(memStatesEl) memStatesEl.textContent = memStats.qTableStates + ' states';
                if(memMbEl) {
                    memMbEl.textContent = memStats.estimatedMB + 'MB';
                    // Color code based on memory usage
                    if(parseFloat(memStats.estimatedMB) > 100) memMbEl.style.color = '#f44336'; // Red > 100MB
                    else if(parseFloat(memStats.estimatedMB) > 50) memMbEl.style.color = '#FF9800'; // Orange > 50MB
                    else memMbEl.style.color = '#4CAF50'; // Green
                }
                
                let btn = document.getElementById('ai-train-btn');
                if(btn) btn.textContent = this.isTraining ? 'â¹ï¸ Stop' : 'â–¶ï¸ Train';
            },
            
            // Draw reward trend graph
            drawRewardGraph: function() {
                let canvas = document.getElementById('ai-reward-graph');
                if(!canvas || !canvas.getContext) return;
                let ctx = canvas.getContext('2d');
                let w = canvas.width;
                let h = canvas.height;
                
                // Clear
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);
                
                if(this.rewardHistory.length < 2) return;
                
                // Find min/max
                let minR = Math.min(...this.rewardHistory, 0);
                let maxR = Math.max(...this.rewardHistory, 100);
                let range = maxR - minR || 1;
                
                // Draw zero line
                let zeroY = h - ((0 - minR) / range) * h;
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(0, zeroY);
                ctx.lineTo(w, zeroY);
                ctx.stroke();
                
                // Draw line graph
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#4CAF50';
                for(let i = 0; i < this.rewardHistory.length; i++) {
                    let x = (i / (this.rewardHistory.length - 1)) * w;
                    let y = h - ((this.rewardHistory[i] - minR) / range) * h;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            
            // Get best action for current state (for display)
            getBestAction: function() {
                let state = this.getState();
                let bestAction = this.actions[0];
                let bestValue = this.getQ(state, bestAction);
                
                for(let action of this.actions) {
                    let value = this.getQ(state, action);
                    if(value > bestValue) {
                        bestValue = value;
                        bestAction = action;
                    }
                }
                
                return {action: bestAction, value: bestValue.toFixed(2)};
            }
        };
        
        // Try to load saved brain on startup
        setTimeout(() => QLearningAI.loadBrain(), 1000);

        window.onload=()=>{
            try {
                Controller.init();
            } catch(err) {
                console.error('Failed to initialize:', err);
                document.getElementById('toast').innerText = 'Initialization Error! Check console (F12)';
                document.getElementById('toast').style.opacity = '1';
            }
        };
    </script>

</body></html>